/*************************************************************************
 * Copyright(c) 1998-2008, ALICE Experiment at CERN, All rights reserved. *
 *                                                                        *
 * Author: The ALICE Off-line Project.                                    *
 * Contributors are mentioned in the code where appropriate.              *
 *                                                                        *
 * Permission to use, copy, modify and distribute this software and its   *
 * documentation strictly for non-commercial purposes is hereby granted   *
 * without fee, provided that the above copyright notice appears in all   *
 * copies and that both the copyright notice and this permission notice   *
 * appear in the supporting documentation. The authors make no claims     *
 * about the suitability of this software for any purpose. It is          *
 * provided "as is" without express or implied warranty.                  *
 **************************************************************************/

/*************************************************
 * Charge-rapidity correlations with Q-cumulants *
 *                                               *
 * author: Jacopo Margutti                       *
 *         (margutti@nikhef.nl)                  *
 *************************************************/

#define AliFlowAnalysisCRC_cxx

#include "Riostream.h"
#include "AliFlowCommonConstants.h"
#include "AliFlowCommonHist.h"
#include "AliFlowCommonHistResults.h"
#include "TChain.h"

#include "TFile.h"
#include "TList.h"
#include "TGraph.h"
#include "TParticle.h"
#include "TRandom3.h"
#include "TStyle.h"
#include "TProfile.h"
#include "TProfile2D.h"
#include "TProfile3D.h"
#include "TMath.h"
#include "TArrow.h"
#include "TPaveLabel.h"
#include "TCanvas.h"
#include "AliFlowEventSimple.h"
#include "AliFlowVector.h"
#include "AliFlowTrackSimple.h"
#include "AliFlowAnalysisCRC.h"
#include "AliLog.h"
#include "TRandom.h"
#include "TF1.h"
#include "TNtuple.h"
#include "THnSparse.h"
#include <complex>
#include <cmath>

class TH1;
class TH2;
class TGraph;
class TPave;
class TLatex;
class TMarker;
class TRandom3;
class TObjArray;
class TList;
class TCanvas;
class TSystem;
class TROOT;
class AliFlowVector;
class TVector;

//==============================================================================================================

using std::endl;
using std::cout;
using std::flush;
ClassImp(AliFlowAnalysisCRC)

AliFlowAnalysisCRC::AliFlowAnalysisCRC(const char* name,
                                           Int_t nCen,
                                           Double_t CenWidth):
TNamed(name,name),
// 0.) base:
fHistList(NULL),
// 1.) common:
fBookOnlyBasicCCH(kTRUE),
fCommonHists(NULL),
fCommonHists2nd(NULL),
fCommonHists4th(NULL),
fCommonHists6th(NULL),
fCommonHists8th(NULL),
fCommonHistsResults2nd(NULL),
fCommonHistsResults4th(NULL),
fCommonHistsResults6th(NULL),
fCommonHistsResults8th(NULL),
fnBinsPhi(0),
fPhiMin(0),
fPhiMax(0),
fPhiBinWidth(0),
fnBinsPt(0),
fPtMin(0),
fPtMax(0),
fPtBinWidth(0),
fnBinsEta(0),
fEtaMin(0),
fEtaMax(0),
fEtaBinWidth(0),
fCommonConstants(NULL),
fFillMultipleControlHistograms(kFALSE),
fHarmonic(1),
fAnalysisLabel(NULL),
// 2a.) particle weights:
fUsePhiWeights(kFALSE),
fUsePtWeights(kFALSE),
fUseEtaWeights(kFALSE),
fUseTrackWeights(kFALSE),
fUsePhiEtaWeights(kFALSE),
fUsePhiEtaWeightsChDep(kFALSE),
fUsePhiEtaWeightsVtxDep(kFALSE),
fUsePhiEtaWeightsChPtDep(kFALSE),
fUseZDCESEMulWeights(kFALSE),
fUseZDCESESpecWeights(kFALSE),
fCutMultiplicityOutliers(kFALSE),
fUseParticleWeights(NULL),
// 2b.) event weights:
fMultiplicityWeight(NULL),
fMultiplicityIs(AliFlowCommonConstants::kRP),
// 3.) integrated flow:
fIntFlowList(NULL),
fIntFlowProfiles(NULL),
fIntFlowResults(NULL),
fIntFlowAllCorrelationsVsM(NULL),
fIntFlowFlags(NULL),
fApplyCorrectionForNUA(kFALSE),
fApplyCorrectionForNUAVsM(kFALSE),
fnBinsMult(10000),
fMinMult(0.),
fMaxMult(10000.),
fPropagateErrorAlsoFromNIT(kFALSE),
fCalculateCumulantsVsM(kFALSE),
fCalculateAllCorrelationsVsM(kFALSE),
fMinimumBiasReferenceFlow(kTRUE),
fForgetAboutCovariances(kFALSE),
fStoreVarious(kFALSE),
fExactNoRPs(0),
fUse2DHistograms(kFALSE),
fFillProfilesVsMUsingWeights(kTRUE),
fUseQvectorTerms(kFALSE),
fReQ(NULL),
fImQ(NULL),
fSpk(NULL),
fReQGF(NULL),
fImQGF(NULL),
fIntFlowCorrelationsEBE(NULL),
fIntFlowEventWeightsForCorrelationsEBE(NULL),
fIntFlowCorrelationsAllEBE(NULL),
fNumberOfRPsEBE(0.),
fNumberOfPOIsEBE(0.),
fReferenceMultiplicityEBE(0.),
fReferenceMultiplicityRecEBE(0.),
fCentralityEBE(0.),
fNewCentralityEBE(0.),
fZDCESEclEbE(0),
fNewMetricLEBE(0.),
fNewMetricDEBE(0.),
fNewMetricL2EBE(0.),
fNewMetricD2EBE(0.),
fCentralityCL1EBE(0.),
fNITSCL1EBE(0.),
fCentralityTRKEBE(0.),
fZNCQ0(0.),
fZNAQ0(0.),
fZNCen(0.),
fZNAen(0.),
fZPCen(0.),
fZPAen(0.),
fEnNucl(1.),
fAvMultiplicity(NULL),
fIntFlowCorrelationsPro(NULL),
fIntFlowSquaredCorrelationsPro(NULL),
fIntFlowCorrelationsAllPro(NULL),
fIntFlowExtraCorrelationsPro(NULL),
fIntFlowProductOfCorrelationsPro(NULL),
fIntFlowProductOfCorrectionTermsForNUAPro(NULL),
fIntFlowCorrelationsHist(NULL),
fIntFlowCorrelationsAllHist(NULL),
fIntFlowCovariances(NULL),
fIntFlowSumOfProductOfEventWeights(NULL),
fIntFlowCovariancesNUA(NULL),
fIntFlowSumOfProductOfEventWeightsNUA(NULL),
fIntFlowQcumulants(NULL),
fIntFlowQcumulantsRebinnedInM(NULL),
fIntFlowQcumulantsErrorSquaredRatio(NULL),
fIntFlow(NULL),
fIntFlowRebinnedInM(NULL),
fIntFlowDetectorBias(NULL),
// 4.) differential flow:
fDiffFlowList(NULL),
fDiffFlowProfiles(NULL),
fDiffFlowResults(NULL),
fDiffFlow2D(NULL),
fDiffFlowFlags(NULL),
fCalculateDiffFlow(kTRUE),
fCalculate2DDiffFlow(kFALSE),
fCalculateDiffFlowVsEta(kTRUE),
// 5.) other differential correlators:
fOtherDiffCorrelatorsList(NULL),
// 6.) distributions:
fDistributionsList(NULL),
fDistributionsFlags(NULL),
fStoreDistributions(kFALSE),
fnBinsForCorrelations(10000),
// 8.) debugging and cross-checking:
fNestedLoopsList(NULL),
fEvaluateIntFlowNestedLoops(kFALSE),
fEvaluateDiffFlowNestedLoops(kFALSE),
fMaxAllowedMultiplicity(10),
fEvaluateNestedLoops(NULL),
fIntFlowDirectCorrelations(NULL),
fIntFlowExtraDirectCorrelations(NULL),
fCrossCheckInPtBinNo(10),
fCrossCheckInEtaBinNo(20),
fNoOfParticlesInBin(NULL),
fMixedHarmonicsNestedLoops(NULL),
// 9.) mixed harmonics:
fMixedHarmonicsList(NULL),
fMixedHarmonicsProfiles(NULL),
fMixedHarmonicsResults(NULL),
fMixedHarmonicsErrorPropagation(NULL),
fMixedHarmonicsFlags(NULL),
fCalculateMixedHarmonics(kFALSE),
fCalculateMixedHarmonicsVsM(kFALSE),
f2pCorrelations(NULL),
f3pCorrelations(NULL),
f4pCorrelations(NULL),
f5pCorrelations(NULL),
f6pCorrelations(NULL),
f7pCorrelations(NULL),
f8pCorrelations(NULL),
f2pCumulants(NULL),
f3pCumulants(NULL),
f4pCumulants(NULL),
f5pCumulants(NULL),
f6pCumulants(NULL),
f7pCumulants(NULL),
f8pCumulants(NULL),
fMixedHarmonicProductOfEventWeights(NULL),
fMixedHarmonicProductOfCorrelations(NULL),
// 10.) Control histograms:
fControlHistogramsList(NULL),
fControlHistogramsFlags(NULL),
fStoreControlHistograms(kFALSE),
fCorrelationNoRPsVsRefMult(NULL),
fCorrelationNoPOIsVsRefMult(NULL),
fCorrelationNoRPsVsNoPOIs(NULL),
// 11.) Bootstrap:
fBootstrapList(NULL),
fBootstrapProfilesList(NULL),
fBootstrapResultsList(NULL),
fBootstrapFlags(NULL),
fUseBootstrap(kFALSE),
fUseBootstrapVsM(kFALSE),
fnSubsamples(10),
fRandom(NULL),
fBootstrapCorrelations(NULL),
fBootstrapCumulants(NULL),
// 12.) Charge-Eta Asymmetry:
fCRCList(NULL),
fTempList(NULL),
fCRCFlags(NULL),
fCalculateCRC(kTRUE),
fCalculateCRCPt(kFALSE),
fCalculateCME(kFALSE),
fCalculateCRCInt(kFALSE),
fCalculateCRC2(kFALSE),
fCalculateCRCVZ(kFALSE),
fCalculateCRCZDC(kFALSE),
fCalculateFlowQC(kFALSE),
fCalculateFlowZDC(kFALSE),
fCalculateFlowVZ(kFALSE),
fCalculateEbEFlow(kFALSE),
fStoreZDCQVecVtxPos(kFALSE),
fUsePhiEtaCuts(kFALSE),
fUseVZERO(kFALSE),
fUseZDC(kFALSE),
fRecenterZDC(kFALSE),
fNUAforCRC(kFALSE),
fUseCRCRecenter(kFALSE),
fDivSigma(kTRUE),
fInvertZDC(kFALSE),
fCRCTestSin(kFALSE),
fVtxRbR(kFALSE),
fCRCEtaMin(0.),
fCRCEtaMax(0.),
fRunNum(0),
fCachedRunNum(0),
fRunBin(0),
fCenBin(0),
fCorrWeightTPC(kUnit),
fCorrWeightVZ(kUnit),
fCorrWeightZDC(kUnit),
fCRCIntList(NULL),
fCRCnCen(nCen),
fCRCCenBinWidth(CenWidth),
fCRCIntRbRList(NULL),
fCRCnRun(211),
fDataSet(kAny),
fInteractionRate(kAll),
fSelectCharge(kAllCh),
fPOIExtraWeights(kNone),
fCRCQVecList(NULL),
fCRCQVecListTPC(NULL),
fCRCQVecWeightsList(NULL),
fCRCZDCCalibList(NULL),
fCRCZDC2DCutList(NULL),
fCRCVZEROCalibList(NULL),
fCRCZDCResList(NULL),
fZDCESEList(NULL),
fCRCVZList(NULL),
fCRCZDCList(NULL),
fCRCZDCRbRList(NULL),
fCRCPtList(NULL),
fCMEList(NULL),
fCMETPCList(NULL),
fCMEZDCList(NULL),
fCRC2List(NULL),
fCRC2nEtaBins(6),
fFlowSPZDCList(NULL),
fFlowQCList(NULL),
fFlowQCCorrZDCList(NULL),
//fFlowQCOrdMagList(NULL),
fFlowGFList(NULL),
fFlowQCCenBin(100),
fFlowQCDeltaEta(0.4),
fFlowSPVZList(NULL),
fVariousList(NULL),
fEbEFlowList(NULL),
fCenWeightEbE(0.),
fQAZDCCuts(kFALSE),
fQAZDCCutsFlag(kTRUE),
fUseTracklets(kFALSE),
fMinMulZN(0),
fMaxDevZN(5.),
fZDCGainAlpha(0.395),
fbFlagIsPosMagField(kFALSE),
fbFlagIsBadRunForC34(kFALSE),
fStoreExtraHistoForSubSampling(kFALSE)
{
  // constructor

  // base list to hold all output objects:
  fHistList = new TList();
  fHistList->SetName("cobjQC");
  fHistList->SetOwner(kTRUE);

  // base list to hold all temp objects:
  fTempList = new TList();
  fTempList->SetName("temp");
  fTempList->SetOwner(kTRUE);

  // multiplicity weight:
  fMultiplicityWeight = new TString("combinations");

  // analysis label;
  fAnalysisLabel = new TString();

  // initialize all arrays:
  this->InitializeArraysForIntFlow();
  this->InitializeArraysForDiffFlow();
  this->InitializeArraysForDistributions();
  this->InitializeArraysForVarious();
  this->InitializeArraysForNestedLoops();
  this->InitializeArraysForMixedHarmonics();
  this->InitializeArraysForControlHistograms();
  this->InitializeArraysForBootstrap();

  fRunList = TArrayI();
  fAvVtxPosX = TArrayD();
  fAvVtxPosY = TArrayD();
  fAvVtxPosZ = TArrayD();
  fnEvRbR = TArrayI();

  // CRC
  this->InitializeCostantsForCRC();
  this->InitializeArraysForParticleWeights();
  this->InitializeArraysForCRC();
  this->InitializeArraysForCRCVZ();
  this->InitializeArraysForCRCZDC();
  this->InitializeArraysForCRC2();
  this->InitializeArraysForQVec();
  this->InitializeArraysForCRCPt();
  this->InitializeArraysForCME();
  this->InitializeArraysForFlowEbE();
  this->InitializeArraysForFlowQC();
  this->InitializeArraysForFlowGF();
  this->InitializeArraysForFlowSPZDC();
  this->InitializeArraysForFlowSPVZ();
  this->InitializeArraysForEbEFlow();

  // printf("Arrays initialized \n");

  for(Int_t i=0; i<fkGFPtB; i++) {
    fReQGFPt[i] = NULL;
    fImQGFPt[i] = NULL;
  }

} // end of constructor

//================================================================================================================

AliFlowAnalysisCRC::~AliFlowAnalysisCRC()
{
  // destructor
  delete fHistList;
  delete fTempList;
  if(fCRCQVecWeightsList) delete fCRCQVecWeightsList;
  if(fCRCZDCCalibList)    delete fCRCZDCCalibList;
  if(fCRCZDC2DCutList)    delete fCRCZDC2DCutList;
  if(fCRCVZEROCalibList)  delete fCRCVZEROCalibList;
  if(fCRCZDCResList)      delete fCRCZDCResList;
  if(fZDCESEList)         delete fZDCESEList;
  delete[] fCRCPtvarPtBins;
  delete[] fCRCPtBins;
  delete[] fZDCEPweightEbE;
  delete[] fCorrMap;
  delete[] fchisqVA;
  delete[] fchisqVC;
  if(fPhiExclZoneHist) delete fPhiExclZoneHist;
} // end of AliFlowAnalysisCRC::~AliFlowAnalysisCRC()

//================================================================================================================

void AliFlowAnalysisCRC::Init()
{
  // a) Cross check if the settings make sense before starting the QC adventure;
  // b) Access all common constants;
  // c) Book all objects;
  // d) Store flags for integrated and differential flow;
  // e) Store flags for distributions of corelations;
  // f) Store harmonic which will be estimated;
  // g) Store flags for mixed harmonics;
  // h) Store flags for control histograms;
  // i) Store bootstrap flags.

  //save old value and prevent histograms from being added to directory
  //to avoid name clashes in case multiple analaysis objects are used
  //in an analysis
  Bool_t oldHistAddStatus = TH1::AddDirectoryStatus();
  TH1::AddDirectory(kFALSE);
  fRandom = new TRandom3(0); // if uiSeed is 0, the seed is determined uniquely in space and time via TUUID

  // a) Cross check if the settings make sense before starting the QC adventure;
  this->CrossCheckSettings();
  // b) Access all common constants and book a profile to hold them:
  this->CommonConstants("Init");
  // c) Book all objects:
  this->BookAndFillWeightsHistograms();
  this->BookAndNestAllLists();
  this->BookCommonHistograms();
  this->BookEverythingForIntegratedFlow();
  this->BookEverythingForDifferentialFlow();
  this->BookEverythingFor2DDifferentialFlow();
  this->BookEverythingForDistributions();
  this->BookEverythingForNestedLoops();
  this->BookEverythingForMixedHarmonics();
  this->BookEverythingForControlHistograms();
  this->BookEverythingForBootstrap();
  this->SetRunList();
  if(fCalculateCRC) {
    this->BookEverythingForCRC();
    this->BookEverythingForCRCVZ();
    this->BookEverythingForCRCZDC();
    this->BookEverythingForCRCPt();
    this->BookEverythingForCRC2();
    this->BookEverythingForQVec();
    this->BookEverythingForCME();
    this->BookEverythingForFlowEbE();
    this->BookEverythingForFlowQC();
    this->BookEverythingForFlowGF();
    this->BookEverythingForFlowSPZDC();
    this->BookEverythingForFlowSPVZ();
    this->BookEverythingForEbEFlow();
  }
  this->BookEverythingForVarious();

  this->SetCentralityWeights();

  // d) Store flags for integrated and differential flow:
  this->StoreIntFlowFlags();
  this->StoreDiffFlowFlags();
  // e) Store flags for distributions of corelations:
  this->StoreFlagsForDistributions();
  // f) Store harmonic which will be estimated:
  this->StoreHarmonic();
  // g) Store flags for mixed harmonics:
  this->StoreMixedHarmonicsFlags();
  // h) Store flags for control histograms:
  this->StoreControlHistogramsFlags();
  // i) Store bootstrap flags:
  this->StoreBootstrapFlags();
  if(fCalculateCRC) {
    // j) Store CRC flags:
    this->StoreCRCFlags();
  }

  TH1::AddDirectory(oldHistAddStatus);

  // printf("Stuff booked \n");

} // end of void AliFlowAnalysisCRC::Init()

//================================================================================================================

void AliFlowAnalysisCRC::Make(AliFlowEventSimple* anEvent)
{
  // Running over data only in this method.
  // a) Check all pointers used in this method;
  // b) Define local variables;
  // c) Fill the common control histograms and call the method to fill fAvMultiplicity;
  // d) Loop over data and calculate e-b-e quantities Q_{n,k}, S_{p,k} and s_{p,k};
  // d.1) initialize particle weights
  // e) Calculate the final expressions for S_{p,k} and s_{p,k} (important !!!!);
  // f) Call the methods which calculate correlations for reference flow;
  // g) Call the methods which calculate correlations for differential flow;
  // h) Call the methods which calculate correlations for 2D differential flow;
  // i) Call the methods which calculate other differential correlators;
  // j) Distributions of correlations;
  // k) Store various;
  // l) Cross-check with nested loops correlators for reference flow;
  // m) Cross-check with nested loops correlators for differential flow;
  // n) Reset all event-by-event quantities (very important !!!!).

  // a) Check all pointers used in this method:
  this->CheckPointersUsedInMake();

  // b) Define local variables:
  Double_t dPhi = 0.; // azimuthal angle in the laboratory frame
  Double_t dPt  = 0.; // transverse momentum
  Double_t dEta = 0.; // pseudorapidity
  Double_t wPhi = 1.; // phi weight
  Double_t wPt  = 1.; // pt weight
  Double_t wEta = 1.; // eta weight
  Double_t wTrack = 1.; // track weight
  Double_t wPhiEta = 1.;
  Double_t wt = 1.;
  Int_t nCounterNoRPs = 0; // needed only for shuffling
  fNumberOfRPsEBE = anEvent->GetNumberOfRPs(); // number of RPs (i.e. number of reference particles)
  fNumberOfPOIsEBE = anEvent->GetNumberOfPOIs(); // number of POIs (i.e. number of particles of interest)
  fReferenceMultiplicityEBE = anEvent->GetReferenceMultiplicity(); // reference multiplicity for current event
  fCentralityEBE = anEvent->GetCentrality(); // centrality percentile for current event
  fCentralityCL1EBE = anEvent->GetCentralityCL1(); // centrality percentile for current event (alternative estimation)
  fCentralityTRKEBE = anEvent->GetCentralityTRK(); // centrality percentile for current event (alternative estimation)
  fNITSCL1EBE = anEvent->GetNITSCL1();

//  printf("begin AliFlowAnalysisCRC::Make \n");

  if(fExactNoRPs > 0 && fNumberOfRPsEBE<fExactNoRPs){return;}
  if(!fCentralityEBE){return;}
  if(!fNumberOfRPsEBE || !fNumberOfPOIsEBE){return;}
  fhCenvsMul[0]->Fill(fCentralityEBE,fReferenceMultiplicityEBE);
  if(fCutMultiplicityOutliers) {
    if((fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) && !MultCut2015o()){return;}
  }

  if(!fRefMultRbRPro) {
    fReferenceMultiplicityRecEBE = fReferenceMultiplicityEBE-fMultCutAv->GetBinContent(fMultCutAv->FindBin(fCentralityEBE));
  } else {
    Int_t runbin = fRefMultRbRPro->GetXaxis()->FindBin(Form("%d",fRunNum));
    Int_t cenbin = fRefMultRbRPro->GetYaxis()->FindBin(fCentralityEBE);
    fReferenceMultiplicityRecEBE = fReferenceMultiplicityEBE-fRefMultRbRPro->GetBinContent(runbin,cenbin);
  }

  // centrality flattening with weights
  fCenWeightEbE = 1.;
  if(fCenWeigCalHist) fCenWeightEbE = fCenWeigCalHist->GetBinContent(fCenWeigCalHist->FindBin(fCentralityEBE));

  // primary vertex position (x,y,z)
  anEvent->GetVertexPosition(fVtxPos);
  // re-centered around zer (implemented only for run2)
  if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
    if(fAvVtxPosX[fRunBin]) fVtxPosCor[0] = fVtxPos[0]-fAvVtxPosX[fRunBin];
    if(fAvVtxPosY[fRunBin]) fVtxPosCor[1] = fVtxPos[1]-fAvVtxPosY[fRunBin];
    if(fAvVtxPosZ[fRunBin]) fVtxPosCor[2] = fVtxPos[2]-fAvVtxPosZ[fRunBin];
  } else {
    fVtxPosCor[0] = fVtxPos[0];
    fVtxPosCor[1] = fVtxPos[1];
    fVtxPosCor[2] = fVtxPos[2];
  }

  Double_t ptEta[2] = {0.,0.}; // 0 = dPt, 1 = dEta
  Int_t dCharge = 0; // charge

  // d) Loop over data and calculate e-b-e quantities Q_{n,k}, S_{p,k} and s_{p,k}:
  Int_t nPrim = anEvent->NumberOfTracks();  // nPrim = total number of primary tracks
  AliFlowTrackSimple *aftsTrack = NULL;
  Int_t n = fHarmonic; // shortcut for the harmonic

  // d.1) Initialize particle weights
  Int_t cw = 0;

  if (fDataSet==kAny) {fRunBin = 0;}
  else {fRunBin = GetCRCRunBin(fRunNum);}
  if(fRunBin<0 || fRunBin>=fCRCnRun) {return;}
  fCenBin = GetCRCCenBin(fCentralityEBE);
  if(fCenBin<0 || fCenBin>=fCRCnCen) {return;}

  fhCenvsMul[2]->Fill(fNumberOfRPsEBE,fNumberOfPOIsEBE);
  fhCenvsMul[3]->Fill(fReferenceMultiplicityEBE,fNumberOfRPsEBE);
  fhCenvsMul[4]->Fill(fReferenceMultiplicityEBE,fNumberOfPOIsEBE);
  if(fhAvAbsOrbit) {
    UInt_t TimeStamp = (UInt_t)anEvent->GetAbsOrbit();
    fhAvAbsOrbit->Fill(fRunBin+0.5,(Double_t)TimeStamp);
  }

  if(fDataSet==k2015 || fDataSet==k2015v6) {
    if(fRunNum!=fCachedRunNum) {
      fbFlagIsPosMagField = kFALSE;
      Int_t dRun15hPos[] = {246390, 246391, 246392, 246994, 246991, 246989, 246984, 246982, 246980, 246948, 246945, 246928, 246851, 246847, 246846, 246845, 246844, 246810, 246809, 246808, 246807, 246805, 246804, 246766, 246765, 246763, 246760, 246759, 246758, 246757, 246751, 246750, 246495, 246493, 246488, 246487, 246434, 246431, 246428, 246424};
      for (Int_t i=0; i<40; i++) {
        if(fRunNum==dRun15hPos[i]) fbFlagIsPosMagField = kTRUE;
      }
      fbFlagIsBadRunForC34 = kFALSE;
      Int_t BadRunList[] = {245705, 246042, 246049, 246087, 246151, 246181, 246217, 246222, 246272, 246275};
      for (Int_t i=0; i<10; i++) {
        if(fRunNum==BadRunList[i]) fbFlagIsBadRunForC34 = kTRUE;
      }
    }
  }

  // VZERO *********************************************************************************************************

  if(fUseVZERO) {

    for(Int_t h=0; h<fCRCnHar; h++) {
      // Get Q vectors for the subevents
      AliFlowVector vQarray[2];
      anEvent->GetV02Qsub(vQarray,h+1);
      fVZFlowVect[0][h] = vQarray[0];
      fVZFlowVect[1][h] = vQarray[1];
      // re-center VZERO Q-vectors
      if(fCRCVZEROCalibList) this->RecenterCRCQVecVZERO();

      // fill Q-vector RbR
//      if(fCRCVZEROQVec[fRunBin][h]) {
//        fCRCVZEROQVec[fRunBin][h]->Fill(0.5,fCentralityEBE,fVZFlowVect[0][h].X());
//        fCRCVZEROQVec[fRunBin][h]->Fill(1.5,fCentralityEBE,fVZFlowVect[0][h].Y());
//        fCRCVZEROQVec[fRunBin][h]->Fill(2.5,fCentralityEBE,fVZFlowVect[1][h].X());
//        fCRCVZEROQVec[fRunBin][h]->Fill(3.5,fCentralityEBE,fVZFlowVect[1][h].Y());
//        fCRCVZEROQVec[fRunBin][h]->Fill(4.5,fCentralityEBE,fVZFlowVect[0][h].X()*fVZFlowVect[1][h].X());
//        fCRCVZEROQVec[fRunBin][h]->Fill(5.5,fCentralityEBE,fVZFlowVect[0][h].Y()*fVZFlowVect[1][h].Y());
//        fCRCVZEROQVec[fRunBin][h]->Fill(6.5,fCentralityEBE,fVZFlowVect[0][h].X()*fVZFlowVect[1][h].Y());
//        fCRCVZEROQVec[fRunBin][h]->Fill(7.5,fCentralityEBE,fVZFlowVect[0][h].Y()*fVZFlowVect[1][h].X());
//      }
    } // end of for(Int_t h=0; h<fCRCnHar; h++)
  } // end of if(fUseVZERO)

  // ZDC *********************************************************************************************************

  if(fUseZDC) {
    // Get Q vectors for the subevents
    AliFlowVector vQarray[2];
    anEvent->GetZDC2Qsub(vQarray);
    fZDCFlowVect[0] = vQarray[0];
    fZDCFlowVect[1] = vQarray[1];
    fZNCQ0 = anEvent->GetZNCQ0()/fEnNucl;
    fZNAQ0 = anEvent->GetZNAQ0()/fEnNucl;
    fZNCen = anEvent->GetZNCEnergy()/fEnNucl;
    fZNAen = anEvent->GetZNAEnergy()/fEnNucl;
    fZPCen = anEvent->GetZPCEnergy()/fEnNucl;
    fZPAen = anEvent->GetZPAEnergy()/fEnNucl;
  } // end of if(fUseZDC)

  this->CalculateCRCQVec();

  if(fUseZDC) {
    this->PassQAZDCCuts();
    if(fRecenterZDC) {
      this->RecenterCRCQVecZDC();
    }
  }
  // ZDC-C (eta < -8.8)
  Double_t ZCRe = fZDCFlowVect[0].X();
  Double_t ZCIm = fZDCFlowVect[0].Y();
  Double_t ZCM  = fZDCFlowVect[0].GetMult();
  // ZDC-A (eta > 8.8)
  Double_t ZARe = fZDCFlowVect[1].X();
  Double_t ZAIm = fZDCFlowVect[1].Y();
  Double_t ZAM  = fZDCFlowVect[1].GetMult();
  if( fInvertZDC ) ZARe = -ZARe;

  // ZDC QA cuts
  Bool_t bPassZDCcuts = kTRUE;
  if( ZCM<=0. || ZAM<=0. || sqrt(ZCRe*ZCRe+ZCIm*ZCIm)<1.E-6 || sqrt(ZARe*ZARe+ZAIm*ZAIm)<1.E-6 ) bPassZDCcuts=kFALSE;
  if( !std::isfinite(fZDCFlowVect[0].Mod()) || !std::isfinite(fZDCFlowVect[1].Mod())) bPassZDCcuts=kFALSE;
  if(fQAZDCCuts && !fQAZDCCutsFlag) bPassZDCcuts=kFALSE;
  if(bPassZDCcuts) fEventCounter->Fill(1.5);

  // EbE flow *********************************************************************************************************

  if(fCalculateEbEFlow) {
    if(fNumberOfPOIsEBE>0 && fNumberOfPOIsEBE<=2500) {
      fEBEFlowMulBin = (Int_t)(fNumberOfPOIsEBE/100);
    } else {
      fEBEFlowMulBin = -1;
    }
  }

  // run-by-run corrections ********************************************************************************************

  if(fRunNum!=fCachedRunNum) {
    for (Int_t cb=0; cb<fCRCnCen; cb++) {
      if(fPtWeightsHist[cb]){
        for (Int_t bx=1; bx<=fPtWeightsHist[cb]->GetNbinsX(); bx++) {
          fPtWeightsCent->SetBinContent(bx,cb+1,fPtWeightsHist[cb]->GetBinContent(bx));
        }
      }
    }

    if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiRbR) {
      if(fWeightsList->FindObject(Form("fCRCQVecPhiHistRbR[%d]",fRunNum))) {
        fPhiEtaRbRWeights = (TH3D*)(fWeightsList->FindObject(Form("fCRCQVecPhiRbRHist[%d]",fRunNum)));
      } else {
        AliWarning("WARNING: POIExtraWeights (kEtaPhiRbR) not found ! \n");
      }
    }
    if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiChRbR) {
      for (Int_t i=0; i<2; i++) {
        if(fWeightsList->FindObject(Form("fCRCQVecPhiRbRHistCh[%d][%d]",fRunNum,i))) {
          fPhiEtaRbRWeightsCh[i] = (TH3D*)(fWeightsList->FindObject(Form("fCRCQVecPhiRbRHistCh[%d][%d]",fRunNum,i)));
        } else {
          AliWarning("WARNING: POIExtraWeights (kEtaPhiChRbR) not found ! \n");
        }
      }
    }
    if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiVtxRbR) {
      for (Int_t cb=0; cb<fCRCnCen; cb++) {
        if(fWeightsList->FindObject(Form("CRCQVecPhiHistVtx[%d][%d]",cb,fRunNum))) {
          fPhiEtaWeightsVtx[cb] = (TH3D*)(fWeightsList->FindObject(Form("CRCQVecPhiHistVtx[%d][%d]",cb,fRunNum)));
        } else {
          AliWarning("WARNING: POIExtraWeights (kEtaPhiVtxRbR) not found ! \n");
        }
      }
    }
  }

  // loop over particles **********************************************************************************************

  for(Int_t i=0;i<nPrim;i++) {
    if(fExactNoRPs > 0 && nCounterNoRPs>fExactNoRPs){continue;}
    aftsTrack=anEvent->GetTrack(i);
    if(aftsTrack) {

      if(!(aftsTrack->InRPSelection() || aftsTrack->InPOISelection() || aftsTrack->InPOISelection(2))){continue;} // safety measure: consider only tracks which are RPs or POIs

      // RPs *********************************************************************************************************

      if(aftsTrack->InRPSelection()) {
        nCounterNoRPs++;
        dPhi = aftsTrack->Phi();
        dPt  = aftsTrack->Pt();
        dEta = aftsTrack->Eta();
        dCharge = aftsTrack->Charge();

        if(fSelectCharge==kPosCh && dCharge<0.) continue;
        if(fSelectCharge==kNegCh && dCharge>0.) continue;

        cw = (dCharge > 0. ? 0 : 1);
        wPhi = 1.;
        wPt  = 1.;
        wEta = 1.;
        wTrack = 1.;
        wPhiEta = 1.;

        // pT weights
        if(fUsePtWeights && fPtWeightsHist[fCenBin]) {
          if(dPt>fPtWeightsCent->GetXaxis()->GetXmin() && dPt<fPtWeightsCent->GetXaxis()->GetXmax()) wt = fPtWeightsCent->Interpolate(dPt,fCentralityEBE);
          else if(dPt<fPtWeightsCent->GetXaxis()->GetXmin())  wt = fPtWeightsCent->Interpolate(fPtWeightsCent->GetXaxis()->GetXmin(),fCentralityEBE);
          else if(dPt>fPtWeightsCent->GetXaxis()->GetXmax())  wt = fPtWeightsCent->Interpolate(fPtWeightsCent->GetXaxis()->GetXmax(),fCentralityEBE);
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }

        // extra weights: eta, phi, ch, vtx
        if(fPOIExtraWeights==kEtaPhi && fPhiEtaWeights) // determine phieta weight for POI:
        {
          wt = fPhiEtaWeights->GetBinContent(fPhiEtaWeights->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if(fPOIExtraWeights==kEtaPhiCh && fPhiEtaWeightsCh[cw]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaWeightsCh[cw]->GetBinContent(fPhiEtaWeightsCh[cw]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if((fPOIExtraWeights==kEtaPhiVtx || fPOIExtraWeights==kEtaPhiVtxRbR) && fPhiEtaWeightsVtx[fCenBin]) // determine phieta weight for POI:
        {
          wt = fPhiEtaWeightsVtx[fCenBin]->GetBinContent(fPhiEtaWeightsVtx[fCenBin]->FindBin(fVtxPosCor[2],dPhi,dEta));
          if(wt==0.) continue;
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        Int_t ptbebe = (dPt>1.? 2 : (dPt>0.5 ? 1 : 0)); // hardcoded
        if(fPOIExtraWeights==kEtaPhiChPt && fPhiEtaWeightsChPt[cw][ptbebe]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaWeightsChPt[cw][ptbebe]->GetBinContent(fPhiEtaWeightsChPt[cw][ptbebe]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        // run-by-run
        if(fPOIExtraWeights==kEtaPhiRbR && fPhiEtaRbRWeights) // determine phieta weight for POI:
        {
          wt = fPhiEtaRbRWeights->GetBinContent(fPhiEtaRbRWeights->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if(fPOIExtraWeights==kEtaPhiChRbR && fPhiEtaRbRWeightsCh[cw]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaRbRWeightsCh[cw]->GetBinContent(fPhiEtaRbRWeightsCh[cw]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }

        if(fPhiExclZoneHist) {
          if(fPhiExclZoneHist->GetBinContent(fPhiExclZoneHist->FindBin(dEta,dPhi))<0.5) continue;
        }

        // Calculate Re[Q_{m*n,k}] and Im[Q_{m*n,k}] for this event (m = 1,2,...,12, k = 0,1,...,8):
        for(Int_t m=0;m<12;m++) // to be improved - hardwired 6
        {
          for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
          {
            (*fReQ)(m,k)+=pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1)*n*dPhi);
            (*fImQ)(m,k)+=pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1)*n*dPhi);
          }
        }
        // Calculate S_{p,k} for this event (Remark: final calculation of S_{p,k} follows after the loop over data bellow):
        for(Int_t p=0;p<8;p++)
        {
          for(Int_t k=0;k<9;k++)
          {
            (*fSpk)(p,k)+=pow(wPhiEta*wPhi*wPt*wEta*wTrack,k);
          }
        }
        // Differential flow:
        if(fCalculateDiffFlow || fCalculate2DDiffFlow)
        {
          ptEta[0] = dPt;
          ptEta[1] = dEta;
          // Calculate r_{m*n,k} and s_{p,k} (r_{m,k} is 'p-vector' for RPs):
          for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
          {
            for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
            {
              if(fCalculateDiffFlow)
              {
                for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
                {
                  fReRPQ1dEBE[0][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
                  fImRPQ1dEBE[0][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
                  if(m==0) // s_{p,k} does not depend on index m
                  {
                    fs1dEBE[0][pe][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k),1.);
                  } // end of if(m==0) // s_{p,k} does not depend on index m
                } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
              } // end of if(fCalculateDiffFlow)
              if(fCalculate2DDiffFlow)
              {
                fReRPQ2dEBE[0][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
                fImRPQ2dEBE[0][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
                if(m==0) // s_{p,k} does not depend on index m
                {
                  fs2dEBE[0][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k),1.);
                } // end of if(m==0) // s_{p,k} does not depend on index m
              } // end of if(fCalculate2DDiffFlow)
            } // end of for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
          } // end of for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
          // Checking if RP particle is also POI particle:
          if(aftsTrack->InPOISelection())
          {
            // Calculate q_{m*n,k} and s_{p,k} ('q-vector' and 's' for RPs && POIs):
            for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
            {
              for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
              {
                if(fCalculateDiffFlow)
                {
                  for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
                  {
                    fReRPQ1dEBE[2][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
                    fImRPQ1dEBE[2][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
                    if(m==0) // s_{p,k} does not depend on index m
                    {
                      fs1dEBE[2][pe][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k),1.);
                    } // end of if(m==0) // s_{p,k} does not depend on index m
                  } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
                } // end of if(fCalculateDiffFlow)
                if(fCalculate2DDiffFlow)
                {
                  fReRPQ2dEBE[2][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
                  fImRPQ2dEBE[2][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
                  if(m==0) // s_{p,k} does not depend on index m
                  {
                    fs2dEBE[2][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k),1.);
                  } // end of if(m==0) // s_{p,k} does not depend on index m
                } // end of if(fCalculate2DDiffFlow)
              } // end of for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
            } // end of for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
          } // end of if(aftsTrack->InPOISelection())
        } // end of if(fCalculateDiffFlow || fCalculate2DDiffFlow)

      } // end of if(pTrack->InRPSelection())

      // POIs ********************************************************************************************************

      if(aftsTrack->InPOISelection() || aftsTrack->InPOISelection(2)) {

        if(!fUseTracklets && aftsTrack->InPOISelection(2)) continue;
        if(fUseTracklets && !aftsTrack->InPOISelection(2)) continue;

        dPhi = aftsTrack->Phi();
        dPt  = aftsTrack->Pt();
        dEta = aftsTrack->Eta();
        dCharge = aftsTrack->Charge();
        // Int_t ITStype = aftsTrack->ITStype();

        if(fSelectCharge==kPosCh && dCharge<0.) continue;
        if(fSelectCharge==kNegCh && dCharge>0.) continue;

        Bool_t IsSplitMergedTracks = kFALSE;
        if(fRemoveSplitMergedTracks) {
          IsSplitMergedTracks = EvaulateIfSplitMergedTracks(anEvent,aftsTrack,i);
        }
        if(IsSplitMergedTracks) continue;

        if(fCRCTestSin) {
          if(dCharge > 0.) dPt += 1.E-2;
          else dPt -= 1.E-2;
        }

        cw = (dCharge > 0. ? 0 : 1);
        wPhi = 1.;
        wPt  = 1.;
        wEta = 1.;
        wTrack = 1.;
        wPhiEta = 1.;

        if(fMinMulZN==0 && dPhi>3.141593e-01 && dPhi<1.256637e+00) {
          if(dEta>0.) continue;
          if(dEta<0.) wPhiEta *= 2.;
        }

        // pT weights
        if(fUsePtWeights && fPtWeightsHist[fCenBin]) {
          if(dPt>fPtWeightsCent->GetXaxis()->GetXmin() && dPt<fPtWeightsCent->GetXaxis()->GetXmax()) wt = fPtWeightsCent->Interpolate(dPt,fCentralityEBE);
          else if(dPt<fPtWeightsCent->GetXaxis()->GetXmin())  wt = fPtWeightsCent->Interpolate(fPtWeightsCent->GetXaxis()->GetXmin(),fCentralityEBE);
          else if(dPt>fPtWeightsCent->GetXaxis()->GetXmax())  wt = fPtWeightsCent->Interpolate(fPtWeightsCent->GetXaxis()->GetXmax(),fCentralityEBE);
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }

        // extra weights: eta, phi, ch, vtx
        if(fPOIExtraWeights==kEtaPhi && fPhiEtaWeights) // determine phieta weight for POI:
        {
          wt = fPhiEtaWeights->GetBinContent(fPhiEtaWeights->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if(fPOIExtraWeights==kEtaPhiCh && fPhiEtaWeightsCh[cw]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaWeightsCh[cw]->GetBinContent(fPhiEtaWeightsCh[cw]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if((fPOIExtraWeights==kEtaPhiVtx || fPOIExtraWeights==kEtaPhiVtxRbR) && fPhiEtaWeightsVtx[fCenBin]) // determine phieta weight for POI:
        {
          wt = fPhiEtaWeightsVtx[fCenBin]->GetBinContent(fPhiEtaWeightsVtx[fCenBin]->FindBin(fVtxPosCor[2],dPhi,dEta));
          if(wt==0.) continue;
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        Int_t ptbebe = (dPt>1.? 2 : (dPt>0.5 ? 1 : 0)); // hardcoded
        if(fPOIExtraWeights==kEtaPhiChPt && fPhiEtaWeightsChPt[cw][ptbebe]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaWeightsChPt[cw][ptbebe]->GetBinContent(fPhiEtaWeightsChPt[cw][ptbebe]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        // run-by-run
        if(fPOIExtraWeights==kEtaPhiRbR && fPhiEtaRbRWeights) // determine phieta weight for POI:
        {
          wt = fPhiEtaRbRWeights->GetBinContent(fPhiEtaRbRWeights->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }
        if(fPOIExtraWeights==kEtaPhiChRbR && fPhiEtaRbRWeightsCh[cw]) // determine phieta weight for POI, ch dep:
        {
          wt = fPhiEtaRbRWeightsCh[cw]->GetBinContent(fPhiEtaRbRWeightsCh[cw]->FindBin(fCentralityEBE,dPhi,dEta));
          if(std::isfinite(1./wt)) wPhiEta *= 1./wt;
        }

        if(fUsePhiEtaCuts)
        {
          // test: remove region with low SPD efficiency
          if(dPhi>2.136283 && dPhi<2.324779) continue;
        }

        // Generic Framework: Calculate Re[Q_{m*n,k}] and Im[Q_{m*n,k}] for this event (m = 1,2,...,12, k = 0,1,...,8):
        Double_t MaxPtCut = 3.;
        if(fMinMulZN==99) MaxPtCut = 1.;
        if(dPt<MaxPtCut) {
          for(Int_t m=0;m<21;m++) // to be improved - hardwired 6
          {
            for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
            {
              (*fReQGF)(m,k) += pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos(m*dPhi);
              (*fImQGF)(m,k) += pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin(m*dPhi);
            }
          }
        }

        for(Int_t ptb=0; ptb<fkGFPtB; ptb++) {
          if(ptb==0 && dPt>0.5) continue;
          if(ptb==1 && (dPt<0.5 || dPt>1.)) continue;
          if(ptb==2 && (dPt<1. || dPt>2.)) continue;
          if(ptb==3 && dPt<2.) continue;
          if(ptb==4 && (dPt<1. || dPt>2.5)) continue;
          if(ptb==5 && dPt<2.5) continue;
          if(ptb==6 && (dPt<1. || dPt>3.)) continue;
          if(ptb==7 && dPt<3.) continue;
          for(Int_t m=0;m<21;m++) // to be improved - hardwired 6
          {
            for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
            {
              (*fReQGFPt[ptb])(m,k) += pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos(m*dPhi);
              (*fImQGFPt[ptb])(m,k) += pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin(m*dPhi);
            }
          }
        }

        ptEta[0] = dPt;
        ptEta[1] = dEta;
        // Calculate p_{m*n,k} ('p-vector' for POIs):
        for(Int_t k=0;k<9;k++) // to be improved - hardwired 9
        {
          for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
          {
            if(fCalculateDiffFlow)
            {
              for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
              {
                fReRPQ1dEBE[1][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
                fImRPQ1dEBE[1][pe][m][k]->Fill(ptEta[pe],pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
              } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
            } // end of if(fCalculateDiffFlow)
            if(fCalculate2DDiffFlow)
            {
              fReRPQ2dEBE[1][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Cos((m+1.)*n*dPhi),1.);
              fImRPQ2dEBE[1][m][k]->Fill(dPt,dEta,pow(wPhiEta*wPhi*wPt*wEta*wTrack,k)*TMath::Sin((m+1.)*n*dPhi),1.);
            } // end of if(fCalculate2DDiffFlow)
          } // end of for(Int_t m=0;m<4;m++) // to be improved - hardwired 4
        } // end of for(Int_t k=0;k<9;k++) // to be improved - hardwired 9

        // Charge-Rapidity Correlations
        for (Int_t h=0;h<fCRCnHar;h++) {

          fCRCQRe[cw][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
          fCRCQIm[cw][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
          fCRCMult[cw][h]->Fill(dEta,wPhiEta);

          fCRC2QRe[cw][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
          fCRC2QIm[cw][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
          fCRC2Mul[cw][h]->Fill(dEta,pow(wPhiEta,h));

          fCRCZDCQRe[cw][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
          fCRCZDCQIm[cw][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
          fCRCZDCMult[cw][h]->Fill(dEta,wPhiEta);

          if(fRandom->Integer(2)>0.5) {
            fCRC2QRe[2][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
            fCRC2QIm[2][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
            fCRC2Mul[2][h]->Fill(dEta,pow(wPhiEta,h));
          }

          if(fRandom->Integer(2)>0.5) {
            fCRCZDCQRe[2][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
            fCRCZDCQIm[2][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
            fCRCZDCMult[2][h]->Fill(dEta,wPhiEta);
          } else {
            fCRCZDCQRe[3][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
            fCRCZDCQIm[3][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
            fCRCZDCMult[3][h]->Fill(dEta,wPhiEta);
          }

          if(fCalculateCME) {
            Double_t SpecWeig = 1.;
            if(fUseZDCESESpecWeights && fZDCESESpecWeightsHist[fZDCESEclEbE] && dPt>0.2 && dPt<20.2) {
              Double_t weraw = fZDCESESpecWeightsHist[fZDCESEclEbE]->GetBinContent(fZDCESESpecWeightsHist[fZDCESEclEbE]->FindBin(fCentralityEBE,dPt));
              if(weraw > 0.) SpecWeig = 1./weraw;
            }
            fCMEQRe[cw][h]->Fill(dEta,SpecWeig*wPhiEta*TMath::Cos((h+1.)*dPhi));
            fCMEQIm[cw][h]->Fill(dEta,SpecWeig*wPhiEta*TMath::Sin((h+1.)*dPhi));
            fCMEMult[cw][h]->Fill(dEta,SpecWeig*wPhiEta);
            fCMEQRe[2+cw][h]->Fill(dEta,pow(SpecWeig*wPhiEta,2.)*TMath::Cos((h+1.)*dPhi));
            fCMEQIm[2+cw][h]->Fill(dEta,pow(SpecWeig*wPhiEta,2.)*TMath::Sin((h+1.)*dPhi));
            fCMEMult[2+cw][h]->Fill(dEta,pow(SpecWeig*wPhiEta,2.));

            // spectra
            fhCenvsSpec[fZDCESEclEbE]->Fill(fCentralityEBE,dPt,SpecWeig*wPhiEta);
            fhCenvsSpec[fZDCESEnCl]->Fill(fCentralityEBE,dPt,SpecWeig*wPhiEta);
          }

        } // end of for (Int_t h=0;h<fCRCnHar;h++)

        // Flow SP ZDC
        Bool_t bFillDis=kTRUE;
        for (Int_t k=0; k<fQVecPower; k++) {
          for (Int_t h=0;h<fFlowNHarmMax;h++) {

            if(fFlowQCDeltaEta>0.) {

              fPOIPtDiffQRe[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
              fPOIPtDiffQIm[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
              fPOIPtDiffMul[k][h]->Fill(dPt,pow(wPhiEta,k));

              fPOIPtDiffQReCh[cw][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
              fPOIPtDiffQImCh[cw][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
              fPOIPtDiffMulCh[cw][k][h]->Fill(dPt,pow(wPhiEta,k));

              fPOIPhiDiffQRe[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
              fPOIPhiDiffQIm[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
              fPOIPhiDiffMul[k][h]->Fill(dPhi,pow(wPhiEta,k));

              fPOIPhiEtaDiffQRe[k][h]->Fill(dPhi,dEta,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
              fPOIPhiEtaDiffQIm[k][h]->Fill(dPhi,dEta,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
              fPOIPhiEtaDiffMul[k][h]->Fill(dPhi,dEta,pow(wPhiEta,k));

              if(fabs(dEta)>fFlowQCDeltaEta/2.) {
                Int_t keta = (dEta<0.?0:1);
                fPOIPtDiffQReEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPtDiffQImEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPtDiffMulEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k));
                fPOIPhiDiffQReEG[keta][k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPhiDiffQImEG[keta][k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPhiDiffMulEG[keta][k][h]->Fill(dPhi,pow(wPhiEta,k));
              }

            } else if(fFlowQCDeltaEta<0. && fFlowQCDeltaEta>-1.) {

              if(dEta>0.) {
                fPOIPtDiffQRe[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPtDiffQIm[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPtDiffMul[k][h]->Fill(dPt,pow(wPhiEta,k));

                fPOIPhiDiffQRe[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPhiDiffQIm[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPhiDiffMul[k][h]->Fill(dPhi,pow(wPhiEta,k));

                Double_t boundetagap = fabs(fFlowQCDeltaEta);

                if((dEta>0. && dEta<0.4-boundetagap/2.) || (dEta>0.4+boundetagap/2. && dEta<0.8)) {
                  Int_t keta;
                  if(dEta>0. && dEta<0.4-boundetagap/2.) keta = 0;
                  else keta = 1;
                  fPOIPtDiffQReEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                  fPOIPtDiffQImEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                  fPOIPtDiffMulEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k));
                }
              } else {
                bFillDis = kFALSE;
                continue;
              }

            } else if(fFlowQCDeltaEta<-1. && fFlowQCDeltaEta>-2.) {

              if(dEta<0.) {
                fPOIPtDiffQRe[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPtDiffQIm[k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPtDiffMul[k][h]->Fill(dPt,pow(wPhiEta,k));

                fPOIPhiDiffQRe[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                fPOIPhiDiffQIm[k][h]->Fill(dPhi,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                fPOIPhiDiffMul[k][h]->Fill(dPhi,pow(wPhiEta,k));

                Double_t boundetagap = fabs(fFlowQCDeltaEta)-1.;

                if((dEta<0. && dEta>-0.4+boundetagap/2.) || (dEta<-0.4-boundetagap/2. && dEta>-0.8)) {
                  Int_t keta;
                  if(dEta<0. && dEta>-0.4+boundetagap/2.) keta = 0;
                  else keta = 1;
                  fPOIPtDiffQReEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Cos((h+1.)*dPhi));
                  fPOIPtDiffQImEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k)*TMath::Sin((h+1.)*dPhi));
                  fPOIPtDiffMulEG[keta][k][h]->Fill(dPt,pow(wPhiEta,k));
                }
              } else {
                bFillDis = kFALSE;
                continue;
              }

            }
          }
        }

        for (Int_t h=0;h<fFlowNHarmMax;h++) {
          fEtaDiffQRe[cw][h]->Fill(dEta,wPhiEta*TMath::Cos((h+1.)*dPhi));
          fEtaDiffQIm[cw][h]->Fill(dEta,wPhiEta*TMath::Sin((h+1.)*dPhi));
          fEtaDiffMul[cw][h]->Fill(dEta,pow(wPhiEta,h+1));
          fPOIEtaPtQRe[cw][h]->Fill(dEta,dPt,wPhiEta*TMath::Cos((h+1.)*dPhi));
          fPOIEtaPtQIm[cw][h]->Fill(dEta,dPt,wPhiEta*TMath::Sin((h+1.)*dPhi));
          fPOIEtaPtMul[cw][h]->Fill(dEta,dPt,wPhiEta);
        }

        if(fCalculateEbEFlow) {
          if(fEBEFlowMulBin>=0) fEbEFlowAzimDis[fEBEFlowMulBin]->Fill(dPhi,wPhiEta);
        }

        // WARNING: do not invert order of SPZDC and QC, used in SC
        if(bPassZDCcuts && fCalculateFlowZDC && fUseZDC) this->CalculateFlowSPZDC(ZCRe,ZCIm,ZARe,ZAIm,dPhi,dEta,dPt,wPhiEta,dCharge,i);

        if(bFillDis && bPassZDCcuts && fCalculateFlowZDC && fUseZDC) {

          fFlowSPZDCv1etaPro[fCenBin][0][7]->Fill(dEta,TMath::Cos(dPhi)*ZARe+TMath::Sin(dPhi)*ZAIm,wPhiEta);
          fFlowSPZDCv1etaPro[fCenBin][0][8]->Fill(dEta,TMath::Cos(dPhi)*ZCRe+TMath::Sin(dPhi)*ZCIm,wPhiEta);
          if(cw==0) {
            fFlowSPZDCv1etaPro[fCenBin][0][9]->Fill(dEta,TMath::Cos(dPhi)*ZARe+TMath::Sin(dPhi)*ZAIm,wPhiEta);
            fFlowSPZDCv1etaPro[fCenBin][0][10]->Fill(dEta,TMath::Cos(dPhi)*ZCRe+TMath::Sin(dPhi)*ZCIm,wPhiEta);
          } else {
            fFlowSPZDCv1etaPro[fCenBin][0][11]->Fill(dEta,TMath::Cos(dPhi)*ZARe+TMath::Sin(dPhi)*ZAIm,wPhiEta);
            fFlowSPZDCv1etaPro[fCenBin][0][12]->Fill(dEta,TMath::Cos(dPhi)*ZCRe+TMath::Sin(dPhi)*ZCIm,wPhiEta);
          }

        }

        // all runs
        fCRCQVecPhiHist->Fill(fCentralityEBE,dPhi,dEta,wPhiEta);
        fCRCQVecPhiHistCh[cw]->Fill(fCentralityEBE,dPhi,dEta,wPhiEta);
        fCRCQVecPhiRbRHist[fRunBin]->Fill(fCentralityEBE,dPhi,dEta,wPhiEta);
        fCRCQVecPhiRbRHistCh[cw][fRunBin]->Fill(fCentralityEBE,dPhi,dEta,wPhiEta);
        for (Int_t h=0;h<6;h++) {
          fCRCQVecHarCosProCh[cw]->Fill(fCentralityEBE,(Double_t)h+0.5,dEta,TMath::Cos((h+1.)*dPhi),wPhiEta);
          fCRCQVecHarSinProCh[cw]->Fill(fCentralityEBE,(Double_t)h+0.5,dEta,TMath::Sin((h+1.)*dPhi),wPhiEta);
        }
        Double_t FillCw = (fbFlagIsPosMagField==kTRUE?(cw==0?0.5:1.5):(cw==0?2.5:3.5));
        if(fCentralityEBE>5. && fCentralityEBE<40.) {
          fCRCQVecPtHistMagField->Fill(dPt,FillCw,wPhiEta);
        }
        if(fVtxRbR) fCRCQVecPhiHistVtx[fCenBin][fRunBin]->Fill(fVtxPosCor[2],dPhi,dEta,wPhiEta);

        if(fCRCQVecPhiHistRefMul[fCenBin]) {
          fCRCQVecPhiHistRefMul[fCenBin]->Fill(fReferenceMultiplicityRecEBE,dPhi,dEta,wPhiEta);
        }
        if(fCRCQVecPhiHistVtxAll[fCenBin]) {
          fCRCQVecPhiHistVtxAll[fCenBin]->Fill(fVtxPosCor[2],dPhi,dEta,wPhiEta);
        }

        fFlowQCSpectraPubBin->Fill(fCentralityEBE,dPt,wPhiEta*fCenWeightEbE);
        fFlowQCSpectraCharge[cw]->Fill(fCentralityEBE,dPt,wPhiEta*fCenWeightEbE);

      } // end of if(pTrack->InPOISelection())
    } else // to if(aftsTrack)
    {
      printf("\n WARNING (QC): No particle (i.e. aftsTrack is a NULL pointer in AFAWQC::Make())!!!!\n\n");
    }
  } // end of for(Int_t i=0;i<nPrim;i++)

  // ************************************************************************************************************

  // e) Calculate the final expressions for S_{p,k} and s_{p,k} (important !!!!):
  for(Int_t p=0;p<8;p++)
  {
    for(Int_t k=0;k<9;k++)
    {
      (*fSpk)(p,k)=pow((*fSpk)(p,k),p+1);
    }
  }

  // f) Call the methods which calculate correlations for reference flow:
  if(!fEvaluateIntFlowNestedLoops)
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      if(fNumberOfRPsEBE>1){this->CalculateIntFlowCorrelations();} // without using particle weights
    } else // to if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      if(fNumberOfRPsEBE>1){this->CalculateIntFlowCorrelationsUsingParticleWeights();} // with using particle weights
    }
    // Whether or not using particle weights the following is calculated in the same way:
    if(fNumberOfRPsEBE>3){this->CalculateIntFlowProductOfCorrelations();}
    if(fNumberOfRPsEBE>1){this->CalculateIntFlowSumOfEventWeights();}
    if(fNumberOfRPsEBE>1){this->CalculateIntFlowSumOfProductOfEventWeights();}
    // Non-isotropic terms:
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      if(fNumberOfRPsEBE>0){this->CalculateIntFlowCorrectionsForNUASinTerms();}
      if(fNumberOfRPsEBE>0){this->CalculateIntFlowCorrectionsForNUACosTerms();}
    } else // to if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      if(fNumberOfRPsEBE>0){this->CalculateIntFlowCorrectionsForNUASinTermsUsingParticleWeights();}
      if(fNumberOfRPsEBE>0){this->CalculateIntFlowCorrectionsForNUACosTermsUsingParticleWeights();}
    }
    // Whether or not using particle weights the following is calculated in the same way:
    if(fNumberOfRPsEBE>0){this->CalculateIntFlowProductOfCorrectionTermsForNUA();}
    if(fNumberOfRPsEBE>0){this->CalculateIntFlowSumOfEventWeightsNUA();}
    if(fNumberOfRPsEBE>0){this->CalculateIntFlowSumOfProductOfEventWeightsNUA();}
    // Mixed harmonics:
    if(fCalculateMixedHarmonics){this->CalculateMixedHarmonics();}
  } // end of if(!fEvaluateIntFlowNestedLoops)

  // g) Call the methods which calculate correlations for differential flow:
  if(!fEvaluateDiffFlowNestedLoops && fCalculateDiffFlow)
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // Without using particle weights:
      this->CalculateDiffFlowCorrelations("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrelations("RP","Eta");}
      this->CalculateDiffFlowCorrelations("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrelations("POI","Eta");}
      // Non-isotropic terms:
      this->CalculateDiffFlowCorrectionsForNUASinTerms("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUASinTerms("RP","Eta");}
      this->CalculateDiffFlowCorrectionsForNUASinTerms("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUASinTerms("POI","Eta");}
      this->CalculateDiffFlowCorrectionsForNUACosTerms("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUACosTerms("RP","Eta");}
      this->CalculateDiffFlowCorrectionsForNUACosTerms("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUACosTerms("POI","Eta");}
    } else // to if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // With using particle weights:
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrelationsUsingParticleWeights("RP","Eta");}
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrelationsUsingParticleWeights("POI","Eta");}
      // Non-isotropic terms:
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("RP","Eta");}
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("POI","Eta");}
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("RP","Eta");}
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("POI","Eta");}
    }
    // Whether or not using particle weights the following is calculated in the same way:
    this->CalculateDiffFlowProductOfCorrelations("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowProductOfCorrelations("RP","Eta");}
    this->CalculateDiffFlowProductOfCorrelations("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowProductOfCorrelations("POI","Eta");}
    this->CalculateDiffFlowSumOfEventWeights("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowSumOfEventWeights("RP","Eta");}
    this->CalculateDiffFlowSumOfEventWeights("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowSumOfEventWeights("POI","Eta");}
    this->CalculateDiffFlowSumOfProductOfEventWeights("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowSumOfProductOfEventWeights("RP","Eta");}
    this->CalculateDiffFlowSumOfProductOfEventWeights("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowSumOfProductOfEventWeights("POI","Eta");}
  } // end of if(!fEvaluateDiffFlowNestedLoops && fCalculateDiffFlow)

  // h) Call the methods which calculate correlations for 2D differential flow:
  if(!fEvaluateDiffFlowNestedLoops && fCalculate2DDiffFlow)
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // Without using particle weights:
      this->Calculate2DDiffFlowCorrelations("RP");
      this->Calculate2DDiffFlowCorrelations("POI");
      // Non-isotropic terms:
      // ... to be ctd ...
    } else // to if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // With using particle weights:
      // ... to be ctd ...
      // Non-isotropic terms:
      // ... to be ctd ...
    }
    // Whether or not using particle weights the following is calculated in the same way:
    // ... to be ctd ...
  } // end of if(!fEvaluateDiffFlowNestedLoops && fCalculate2DDiffFlow)

  // i) Call the methods which calculate other differential correlators:
  if(!fEvaluateDiffFlowNestedLoops && fCalculateDiffFlow)
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // Without using particle weights:
      this->CalculateOtherDiffCorrelators("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateOtherDiffCorrelators("RP","Eta");}
      this->CalculateOtherDiffCorrelators("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateOtherDiffCorrelators("POI","Eta");}
    } else // to if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // With using particle weights:
      // ... to be ctd ...
    }
    // Whether or not using particle weights the following is calculated in the same way:
    // ... to be ctd ...
  } // end of if(!fEvaluateDiffFlowNestedLoops)

  // i.2) Calculate CRC quantities:
  if(fCalculateCRC) {
    if(fCalculateCRCInt) this->CalculateCRCCorr();
    if(fCalculateCRC2) this->CalculateCRC2Cor();
    if(fCalculateCRCVZ && fUseVZERO) this->CalculateCRCVZERO();
    if(fCalculateCRCZDC && fUseZDC) this->CalculateCRCZDC();
    if(fCalculateCRCPt) this->CalculateCRCPtCorr();
    //    if(fUseVZERO && fUseZDC) this->CalculateVZvsZDC();
    if(fCalculateCME && fUseZDC) {
      this->CalculateCMETPC();
      this->CalculateCMEZDC();
    }
  }
  if(fCalculateFlowQC) {
    this->CalculateFlowSCZDC();
    this->CalculateFlowQC();
    this->CalculateFlowGF();
  }
  if(fCalculateFlowVZ && fUseVZERO) this->CalculateFlowSPVZ();
  if(fCalculateEbEFlow) this->FitEbEFlow();

  // j) Distributions of correlations:
  if(fStoreDistributions){this->StoreDistributionsOfCorrelations();}

  // l) Cross-check with nested loops correlators for reference flow:
  if(fEvaluateIntFlowNestedLoops){this->EvaluateIntFlowNestedLoops(anEvent);}

  // m) Cross-check with nested loops correlators for differential flow:
  if(fEvaluateDiffFlowNestedLoops){this->EvaluateDiffFlowNestedLoops(anEvent);}

  // n) Store multiplicity in various:
  if(fStoreVarious) this->FillVarious();

  // o) Reset all event-by-event quantities (very important !!!!):
  this->ResetEventByEventQuantities();

  // p) cache run number
  fCachedRunNum = fRunNum;

  fQAZDCCutsFlag = kTRUE;

//  printf("end AliFlowAnalysisCRC::Make \n");

} // end of AliFlowAnalysisCRC::Make(AliFlowEventSimple* anEvent)

//=======================================================================================================================

void AliFlowAnalysisCRC::Finish()
{
  // Calculate the final results.

  // a) Check all pointers used in this method;
  // b) Access the constants;
  // c) Access the flags;
  // d) Calculate reference cumulants (not corrected for detector effects);
  // e) Correct reference cumulants for detector effects;
  // f) Calculate reference flow;
  // g) Store results for reference flow in AliFlowCommonHistResults and print them on the screen;
  // h) Calculate the final results for differential flow (without/with weights);
  // i) Correct the results for differential flow (without/with weights) for effects of non-uniform acceptance (NUA);
  // j) Calculate the final results for integrated flow (RP/POI) and store in AliFlowCommonHistResults;
  // k) Store results for differential flow in AliFlowCommonHistResults;
  // l) Print the final results for integrated flow (RP/POI) on the screen;
  // m) Cross-checking: Results from Q-vectors vs results from nested loops;
  // n) Calculate cumulants for mixed harmonics;
  // o) Calculate charge-rapidity correlations;
  // p) Calculate cumulants for bootstrap;
  // q) Finalize various;

  // a) Check all pointers used in this method:
  this->CheckPointersUsedInFinish();

  // b) Access the constants:
  this->CommonConstants("Finish");

  if(fCommonHists && fCommonHists->GetHarmonic()) {
    fHarmonic = (Int_t)(fCommonHists->GetHarmonic())->GetBinContent(1);
  }

  // c) Access the flags: // tbi (implement a method for this? should I store again the flags because they can get modified with redoFinish?)
  fUsePhiWeights = (Bool_t)fUseParticleWeights->GetBinContent(1);
  fUsePtWeights = (Bool_t)fUseParticleWeights->GetBinContent(2);
  fUseEtaWeights = (Bool_t)fUseParticleWeights->GetBinContent(3);
  fUseTrackWeights = (Bool_t)fUseParticleWeights->GetBinContent(4);
  fUsePhiEtaWeights = (Bool_t)fUseParticleWeights->GetBinContent(5);
  fUsePhiEtaWeightsChDep = (Bool_t)fUseParticleWeights->GetBinContent(6);
  fUsePhiEtaWeightsVtxDep = (Bool_t)fUseParticleWeights->GetBinContent(7);
  fUsePhiEtaWeightsChPtDep = (Bool_t)fUseParticleWeights->GetBinContent(8);
  fApplyCorrectionForNUA = (Bool_t)fIntFlowFlags->GetBinContent(3);
  fPrintFinalResults[0] = (Bool_t)fIntFlowFlags->GetBinContent(4);
  fPrintFinalResults[1] = (Bool_t)fIntFlowFlags->GetBinContent(5);
  fPrintFinalResults[2] = (Bool_t)fIntFlowFlags->GetBinContent(6);
  fPrintFinalResults[3] = (Bool_t)fIntFlowFlags->GetBinContent(7);
  fApplyCorrectionForNUAVsM = (Bool_t)fIntFlowFlags->GetBinContent(8);
  fPropagateErrorAlsoFromNIT = (Bool_t)fIntFlowFlags->GetBinContent(9);
  fCalculateCumulantsVsM = (Bool_t)fIntFlowFlags->GetBinContent(10);
  fMinimumBiasReferenceFlow = (Bool_t)fIntFlowFlags->GetBinContent(11);
  fForgetAboutCovariances = (Bool_t)fIntFlowFlags->GetBinContent(12);
  fStoreVarious = (Bool_t)fIntFlowFlags->GetBinContent(13);
  fFillMultipleControlHistograms = (Bool_t)fIntFlowFlags->GetBinContent(14);
  fCalculateAllCorrelationsVsM = (Bool_t)fIntFlowFlags->GetBinContent(15);
  fUse2DHistograms = (Bool_t)fIntFlowFlags->GetBinContent(18);
  fFillProfilesVsMUsingWeights = (Bool_t)fIntFlowFlags->GetBinContent(19);
  fUseQvectorTerms = (Bool_t)fIntFlowFlags->GetBinContent(20);
  fEvaluateIntFlowNestedLoops = (Bool_t)fEvaluateNestedLoops->GetBinContent(1);
  fEvaluateDiffFlowNestedLoops = (Bool_t)fEvaluateNestedLoops->GetBinContent(2);
  fCrossCheckInPtBinNo = (Int_t)fEvaluateNestedLoops->GetBinContent(3);
  fCrossCheckInEtaBinNo = (Int_t)fEvaluateNestedLoops->GetBinContent(4);
  fCalculateMixedHarmonics = (Bool_t)fMixedHarmonicsFlags->GetBinContent(1);
  //fHarmonic = (Int_t)fMixedHarmonicsFlags->GetBinContent(2); // TBI should I add inpdependent generic harmonic here?
  fCalculateMixedHarmonicsVsM = (Bool_t)fMixedHarmonicsFlags->GetBinContent(3);
  fUseBootstrap = (Bool_t)fBootstrapFlags->GetBinContent(1);
  fUseBootstrapVsM = (Bool_t)fBootstrapFlags->GetBinContent(2);
  fnSubsamples = (Int_t)fBootstrapFlags->GetBinContent(3);

  // d) Calculate reference cumulants (not corrected for detector effects):
  this->FinalizeCorrelationsIntFlow();
  this->CalculateCovariancesIntFlow();
  this->CalculateCumulantsIntFlow();

  // e) Correct reference cumulants for detector effects:
  this->FinalizeCorrectionTermsForNUAIntFlow();
  this->CalculateCovariancesNUAIntFlow();
  this->CalculateQcumulantsCorrectedForNUAIntFlow();

  // f) Calculate reference flow:
  this->CalculateReferenceFlow();

  // g) Store results for reference flow in AliFlowCommonHistResults and print them on the screen:
  this->FillCommonHistResultsIntFlow();
  if(fPrintFinalResults[0]){this->PrintFinalResultsForIntegratedFlow("RF");}
  if(fPrintFinalResults[3] && fCalculateCumulantsVsM){this->PrintFinalResultsForIntegratedFlow("RF, rebinned in M");}

  // h) Calculate the final results for differential flow (without/with weights):
  if(fCalculateDiffFlow)
  {
    this->FinalizeReducedCorrelations("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->FinalizeReducedCorrelations("RP","Eta");}
    this->FinalizeReducedCorrelations("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->FinalizeReducedCorrelations("POI","Eta");}
    this->CalculateDiffFlowCovariances("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCovariances("RP","Eta");}
    this->CalculateDiffFlowCovariances("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCovariances("POI","Eta");}
    this->CalculateDiffFlowCumulants("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCumulants("RP","Eta");}
    this->CalculateDiffFlowCumulants("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCumulants("POI","Eta");}
    this->CalculateDiffFlow("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlow("RP","Eta");}
    this->CalculateDiffFlow("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlow("POI","Eta");}
  } // if(fCalculateDiffFlow)

  // i) Correct the results for differential flow (without/with weights) for effects of non-uniform acceptance (NUA):
  if(fCalculateDiffFlow)
  {
    this->FinalizeCorrectionTermsForNUADiffFlow("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->FinalizeCorrectionTermsForNUADiffFlow("RP","Eta");}
    this->FinalizeCorrectionTermsForNUADiffFlow("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->FinalizeCorrectionTermsForNUADiffFlow("POI","Eta");}
    this->CalculateDiffFlowCumulantsCorrectedForNUA("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCumulantsCorrectedForNUA("RP","Eta");}
    this->CalculateDiffFlowCumulantsCorrectedForNUA("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCumulantsCorrectedForNUA("POI","Eta");}
    if(fApplyCorrectionForNUA)
    {
      this->CalculateDiffFlowCorrectedForNUA("RP","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectedForNUA("RP","Eta");}
      this->CalculateDiffFlowCorrectedForNUA("POI","Pt");
      if(fCalculateDiffFlowVsEta){this->CalculateDiffFlowCorrectedForNUA("POI","Eta");}
    }
  } // end of if(fCalculateDiffFlow && fApplyCorrectionForNUA)

  // i) Calcualate final results for 2D differential flow:
  if(fCalculate2DDiffFlow)
  {
    this->Calculate2DDiffFlowCumulants("RP");
    this->Calculate2DDiffFlowCumulants("POI");
    this->Calculate2DDiffFlow("RP");
    this->Calculate2DDiffFlow("POI");
  } // end of if(fCalculate2DDiffFlow)

  // j) Calculate the final results for integrated flow (RP/POI) and store in AliFlowCommonHistResults:
  if(fCalculateDiffFlow)
  {
    this->CalculateFinalResultsForRPandPOIIntegratedFlow("RP");
    this->CalculateFinalResultsForRPandPOIIntegratedFlow("POI");
  }

  // k) Store results for differential flow in AliFlowCommonHistResults:
  if(fCalculateDiffFlow)
  {
    this->FillCommonHistResultsDiffFlow("RP");
    this->FillCommonHistResultsDiffFlow("POI");
  }

  // l) Print the final results for integrated flow (RP/POI) on the screen:
  if(fPrintFinalResults[1] && fCalculateDiffFlow){this->PrintFinalResultsForIntegratedFlow("RP");}
  if(fPrintFinalResults[2] && fCalculateDiffFlow){this->PrintFinalResultsForIntegratedFlow("POI");}

  // m) Cross-checking: Results from Q-vectors vs results from nested loops:
  //  m1) Reference flow:
  if(fEvaluateIntFlowNestedLoops)
  {
    this->CrossCheckIntFlowCorrelations();
    this->CrossCheckIntFlowCorrectionTermsForNUA();
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights){this->CrossCheckIntFlowExtraCorrelations();}
    if(fCalculateMixedHarmonics){this->CrossCheckIntFlowCorrelations();}
  } // end of if(fEvaluateIntFlowNestedLoops)
  //  m2) Differential flow:
  if(fEvaluateDiffFlowNestedLoops && fCalculateDiffFlow)
  {
    // Correlations:
    this->PrintNumberOfParticlesInSelectedBin();
    this->CrossCheckDiffFlowCorrelations("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckDiffFlowCorrelations("RP","Eta");}
    this->CrossCheckDiffFlowCorrelations("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckDiffFlowCorrelations("POI","Eta");}
    // Correction terms for non-uniform acceptance:
    this->CrossCheckDiffFlowCorrectionTermsForNUA("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckDiffFlowCorrectionTermsForNUA("RP","Eta");}
    this->CrossCheckDiffFlowCorrectionTermsForNUA("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckDiffFlowCorrectionTermsForNUA("POI","Eta");}
    // Other differential correlators:
    this->CrossCheckOtherDiffCorrelators("RP","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckOtherDiffCorrelators("RP","Eta");}
    this->CrossCheckOtherDiffCorrelators("POI","Pt");
    if(fCalculateDiffFlowVsEta){this->CrossCheckOtherDiffCorrelators("POI","Eta");}
  } // end of if(fEvaluateDiffFlowNestedLoops)

  // n) Calculate cumulants for mixed harmonics:
  if(fCalculateMixedHarmonics){this->CalculateCumulantsMixedHarmonics();}

  // o) Calculate charge-rapidity correlations:
  if(fCalculateCRC) {
    if(fCalculateCRCInt) this->FinalizeCRCCorr();
    if(fCalculateCRC2) this->FinalizeCRC2Cor();
    if(fCalculateCRCVZ && fUseVZERO) this->FinalizeCRCVZERO();
    if(fCalculateCRCZDC && fUseZDC) this->FinalizeCRCZDC();
    if(fCalculateCRCPt) this->FinalizeCRCPtCorr();
    if(fCalculateCME && fUseZDC) {
      this->FinalizeCMETPC();
      this->FinalizeCMEZDC();
    }
  }
  // WARNING: do not invert order of SPZDC and QC, used in SC
  if(fCalculateFlowZDC && fUseZDC) this->FinalizeFlowSPZDC();
  if(fCalculateFlowQC) {
    this->FinalizeFlowQC();
    this->FinalizeFlowGF();
  }
  if(fCalculateFlowVZ && fUseVZERO) this->FinalizeFlowSPVZ();

  // p) Calculate cumulants for bootstrap:
  if(fUseBootstrap||fUseBootstrapVsM){this->CalculateCumulantsForBootstrap();}

  // q) Finalize various:
  if(fStoreVarious) this->FinalizeVarious();

} // end of AliFlowAnalysisCRC::Finish()

//=======================================================================================================================

Bool_t AliFlowAnalysisCRC::EvaulateIfSplitMergedTracks(AliFlowEventSimple* anEvent, AliFlowTrackSimple* aftsTrack, Int_t it1)
{
  const Float_t kLimit1 = 0.02 * 3;
  Float_t bSign = (fbFlagIsPosMagField? -1 : 1);

  Int_t nTracks = anEvent->NumberOfTracks();  // nPrim = total number of primary tracks

  Bool_t isNoSplit = kFALSE;

  //your cuts
  if (it1 < nTracks - 1) {
    for (Int_t itll2 = it1 + 1; itll2 < nTracks; itll2++) {

      AliFlowTrackSimple* aftsTrack2 = (AliFlowTrackSimple*)anEvent->GetTrack(itll2);
      if (!aftsTrack2) {
        delete aftsTrack2;
        continue;
      }

      if(!aftsTrack2->InPOISelection()) continue;

      Double_t deta1 = aftsTrack->Eta() - aftsTrack2->Eta();
      // phi in rad
      Float_t phi1rad1 = aftsTrack->Phi();
      Float_t phi2rad1 = aftsTrack2->Phi();
      Double_t dphi1 = TMath::ASin(TMath::Sin(phi1rad1-phi2rad1));
      Float_t dphistarminabs1 = 1e5;
      Bool_t IsNoSpliTrack = kFALSE;

      if (TMath::Abs(deta1) < 0.1 && aftsTrack->Charge()==aftsTrack2->Charge()) {

        // check first boundaries to see if is worth to loop and find the minimum
        Float_t dphistar11 = GetDPhiStar(phi1rad1, aftsTrack->Pt(), aftsTrack->Charge(), phi2rad1, aftsTrack2->Pt(), aftsTrack2->Charge(), 0.8, bSign);
        Float_t dphistar21 = GetDPhiStar(phi1rad1, aftsTrack->Pt(), aftsTrack->Charge(), phi2rad1, aftsTrack2->Pt(), aftsTrack2->Charge(), 2.5, bSign);

        if (TMath::Abs(dphistar11) < kLimit1 || TMath::Abs(dphistar21) < kLimit1 || dphistar11 * dphistar21 < 0 ) {

          for (Double_t rad1 = 0.8; rad1 < 2.51; rad1 += 0.01) {
            Float_t dphistar1 = GetDPhiStar(phi1rad1, aftsTrack->Pt(), aftsTrack->Charge(), phi2rad1, aftsTrack2->Pt(), aftsTrack2->Charge(), rad1, bSign);
            Float_t dphistarabs1 = TMath::Abs(dphistar1);
            if (dphistarabs1 < dphistarminabs1) {
              dphistarminabs1 = dphistarabs1;
            }
          }

          if (dphistarminabs1 < 0.017 && TMath::Abs(deta1) < 0.012) {
            // printf("HBT: Removed track pair %d %d with [[%f %f]] %f | %f %f %d %f %f %d %f \n", it1, itll2, TMath::Abs(deta1), TMath::Abs(phi1rad1-phi2rad1), dphistarminabs1, phi1rad1, aftsTrack->Pt(), aftsTrack->Charge(), phi2rad1, aftsTrack2->Pt(), aftsTrack2->Charge(), bSign);
            // isNoSplit = kTRUE;
            // IsNoSpliTrack = kTRUE;
          }

        }

        if (TMath::Abs(dphi1) < TMath::TwoPi()/100. && TMath::Abs(deta1) < 0.006) {
          isNoSplit = kTRUE;
          IsNoSpliTrack = kTRUE;
        }

        fTwoTrackDistanceLS[0]->Fill(deta1, dphi1, 0.5*TMath::Abs(aftsTrack->Pt()+aftsTrack2->Pt()));
        if(!IsNoSpliTrack) fTwoTrackDistanceLS[1]->Fill(deta1, dphi1, 0.5*TMath::Abs(aftsTrack->Pt()+aftsTrack2->Pt()));
      }

      IsNoSpliTrack = kFALSE;
      if (TMath::Abs(deta1) < 0.1 && aftsTrack->Charge()!=aftsTrack2->Charge()) {

        Double_t dphi1 = TMath::ASin(TMath::Sin(phi1rad1-phi2rad1));
        if (TMath::Abs(dphi1) < TMath::TwoPi()/100. && TMath::Abs(deta1) < 0.006) {
          IsNoSpliTrack = kTRUE;
        }

        fTwoTrackDistanceUS[0]->Fill(deta1, dphi1, 0.5*TMath::Abs(aftsTrack->Pt()+aftsTrack2->Pt()));
        if(!IsNoSpliTrack) fTwoTrackDistanceUS[1]->Fill(deta1, dphi1, 0.5*TMath::Abs(aftsTrack->Pt()+aftsTrack2->Pt()));
      }

    }
  }

  return isNoSplit;
}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateIntFlowNestedLoops(AliFlowEventSimple* anEvent)
{
  // Evaluate all correlators for reference flow with nested loops.

  Int_t nPrim = anEvent->NumberOfTracks(); // number of primaries
  if(nPrim>0 && nPrim<=fMaxAllowedMultiplicity) // by default fMaxAllowedMultiplicity = 10
  {
    // Without using particle weights:
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // Correlations:
      this->CalculateIntFlowCorrelations(); // from Q-vectors
      this->EvaluateIntFlowCorrelationsWithNestedLoops(anEvent); // from nested loops (TBI: do I have to pass here anEvent or not?)
      // Correction for non-uniform acceptance:
      this->CalculateIntFlowCorrectionsForNUASinTerms(); // from Q-vectors (sin terms)
      this->CalculateIntFlowCorrectionsForNUACosTerms(); // from Q-vectors (cos terms)
      this->EvaluateIntFlowCorrectionsForNUAWithNestedLoops(anEvent); // from nested loops (both sin and cos terms)
      // Mixed harmonics:
      if(fCalculateMixedHarmonics)
      {
        this->CalculateMixedHarmonics(); // from Q-vectors
        this->EvaluateMixedHarmonicsWithNestedLoops(anEvent); // from nested loops (TBI: do I have to pass here anEvent or not?)
      } // end of if(fCalculateMixedHarmonics)
    }
    // Using particle weights:
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    {
      // Correlations
      this->CalculateIntFlowCorrelationsUsingParticleWeights(); // from Q-vectors
      this->EvaluateIntFlowCorrelationsWithNestedLoopsUsingParticleWeights(anEvent); // from nested loops (to be improved: do I have to pass here anEvent or not?)
      // Correction for non-uniform acceptance:
      this->CalculateIntFlowCorrectionsForNUASinTermsUsingParticleWeights(); // from Q-vectors (sin terms)
      this->CalculateIntFlowCorrectionsForNUACosTermsUsingParticleWeights(); // from Q-vectors (cos terms)
      this->EvaluateIntFlowCorrectionsForNUAWithNestedLoopsUsingParticleWeights(anEvent); // from nested loops (both sin and cos terms)
    }
  } else if(nPrim>fMaxAllowedMultiplicity) // to if(nPrim>0 && nPrim<=fMaxAllowedMultiplicity)
  {
    cout<<endl;
    cout<<"Skipping the event because multiplicity is "<<nPrim<<". Too high to evaluate nested loops!"<<endl;
  } else
  {
    cout<<endl;
    cout<<"Skipping the event because multiplicity is "<<nPrim<<"."<<endl;
  }

} // end of void AliFlowAnalysisCRC::EvaluateIntFlowNestedLoops(AliFlowEventSimple* anEvent)

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateDiffFlowNestedLoops(AliFlowEventSimple* anEvent)
{
  // Evalauted all correlators for differential flow with nested loops.

  if(!fCalculateDiffFlow){return;}

  Int_t nPrim = anEvent->NumberOfTracks(); // number of primaries
  if(nPrim>0 && nPrim<=fMaxAllowedMultiplicity) // by default fMaxAllowedMultiplicity = 10
  {
    // Without using particle weights:
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      // 1.) Reduced correlations:
      //  Q-vectors:
      this->CalculateDiffFlowCorrelations("RP","Pt");
      this->CalculateDiffFlowCorrelations("RP","Eta");
      this->CalculateDiffFlowCorrelations("POI","Pt");
      this->CalculateDiffFlowCorrelations("POI","Eta");
      //  Nested loops:
      this->EvaluateDiffFlowCorrelationsWithNestedLoops(anEvent,"RP","Pt");
      this->EvaluateDiffFlowCorrelationsWithNestedLoops(anEvent,"RP","Eta");
      this->EvaluateDiffFlowCorrelationsWithNestedLoops(anEvent,"POI","Pt");
      this->EvaluateDiffFlowCorrelationsWithNestedLoops(anEvent,"POI","Eta");
      // 2.) Reduced corrections for non-uniform acceptance:
      //  Q-vectors:
      this->CalculateDiffFlowCorrectionsForNUASinTerms("RP","Pt");
      this->CalculateDiffFlowCorrectionsForNUASinTerms("RP","Eta");
      this->CalculateDiffFlowCorrectionsForNUASinTerms("POI","Pt");
      this->CalculateDiffFlowCorrectionsForNUASinTerms("POI","Eta");
      this->CalculateDiffFlowCorrectionsForNUACosTerms("RP","Pt");
      this->CalculateDiffFlowCorrectionsForNUACosTerms("RP","Eta");
      this->CalculateDiffFlowCorrectionsForNUACosTerms("POI","Pt");
      this->CalculateDiffFlowCorrectionsForNUACosTerms("POI","Eta");
      //  Nested loops:
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoops(anEvent,"RP","Pt");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoops(anEvent,"RP","Eta");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoops(anEvent,"POI","Pt");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoops(anEvent,"POI","Eta");
      // 3.) Other differential correlators:
      //  Q-vectors:
      this->CalculateOtherDiffCorrelators("RP","Pt");
      this->CalculateOtherDiffCorrelators("RP","Eta");
      this->CalculateOtherDiffCorrelators("POI","Pt");
      this->CalculateOtherDiffCorrelators("POI","Eta");
      //  Nested loops:
      this->EvaluateOtherDiffCorrelatorsWithNestedLoops(anEvent,"RP","Pt");
      this->EvaluateOtherDiffCorrelatorsWithNestedLoops(anEvent,"RP","Eta");
      this->EvaluateOtherDiffCorrelatorsWithNestedLoops(anEvent,"POI","Pt");
      this->EvaluateOtherDiffCorrelatorsWithNestedLoops(anEvent,"POI","Eta");
    } // end of if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    // Using particle weights:
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    {
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("RP","Pt");
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("RP","Eta");
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("POI","Pt");
      this->CalculateDiffFlowCorrelationsUsingParticleWeights("POI","Eta");
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("RP","Pt");
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("RP","Eta");
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("POI","Pt");
      this->CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights("POI","Eta");
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("RP","Pt");
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("RP","Eta");
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("POI","Pt");
      this->CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights("POI","Eta");
      this->EvaluateDiffFlowCorrelationsWithNestedLoopsUsingParticleWeights(anEvent,"RP","Pt");
      this->EvaluateDiffFlowCorrelationsWithNestedLoopsUsingParticleWeights(anEvent,"RP","Eta");
      this->EvaluateDiffFlowCorrelationsWithNestedLoopsUsingParticleWeights(anEvent,"POI","Pt");
      this->EvaluateDiffFlowCorrelationsWithNestedLoopsUsingParticleWeights(anEvent,"POI","Eta");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoopsUsingParticleWeights(anEvent,"RP","Pt");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoopsUsingParticleWeights(anEvent,"RP","Eta");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoopsUsingParticleWeights(anEvent,"POI","Pt");
      this->EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoopsUsingParticleWeights(anEvent,"POI","Eta");
    } // end of if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
  } // end of if(nPrim>0 && nPrim<=fMaxAllowedMultiplicity) // by default fMaxAllowedMultiplicity = 10

} // end of void AliFlowAnalysisCRC::EvaluateDiffFlowNestedLoops(AliFlowEventSimple* anEvent)

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrectionsForNUACosTerms()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrectionsForNUASinTerms()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::GetOutputHistograms(TList *outputListHistos)
{
  // a) Get pointers for common control and common result histograms;
  // b) Get pointers for histograms holding particle weights;
  // c) Get pointers for reference flow histograms;
  // d) Get pointers for differential flow histograms;
  // e) Get pointers for 2D differential flow histograms;
  // f) Get pointers for other differential correlators;
  // g) Get pointers for mixed harmonics histograms;
  // h) Get pointers for nested loops' histograms;
  // i) Get pointers for control histograms;
  // j) Get pointers for bootstrap.
  // k) Get pointers for CRC histograms;

  if(outputListHistos)
  {
    this->SetHistList(outputListHistos);
    if(!fHistList)
    {
      printf("\n WARNING (QC): fHistList is NULL in AFAWQC::GOH() !!!!\n\n");
      exit(0);
    }
    this->GetPointersForCommonHistograms();
    this->GetPointersForParticleWeightsHistograms();
    this->GetPointersForIntFlowHistograms();
    this->GetPointersForDiffFlowHistograms();
    this->GetPointersFor2DDiffFlowHistograms();
    this->GetPointersForOtherDiffCorrelators();
    this->GetPointersForMixedHarmonicsHistograms();
    this->GetPointersForNestedLoopsHistograms();
    this->GetPointersForControlHistograms();
    this->GetPointersForBootstrap();
    this->GetPointersForCRC();
    this->GetPointersForCRCVZ();
    this->GetPointersForCRCZDC();
    this->GetPointersForCRCPt();
    this->GetPointersForCRC2();
    this->GetPointersForQVec();
    this->GetPointersForCME();
    this->GetPointersForFlowQC();
    this->GetPointersForFlowGF();
    this->GetPointersForFlowSPZDC();
    this->GetPointersForFlowSPVZ();
    this->GetPointersForEbEFlow();
    this->GetPointersForVarious();
  } else
  {
    printf("\n WARNING (QC): outputListHistos is NULL in AFAWQC::GOH() !!!!\n\n");
    exit(0);
  }

} // end of void AliFlowAnalysisCRC::GetOutputHistograms(TList *outputListHistos)

//=======================================================================================================================

TProfile* AliFlowAnalysisCRC::MakePtProjection(TProfile2D *profilePtEta) const
{
  // project 2D profile onto pt axis to get 1D profile

  Int_t nBinsPt   = profilePtEta->GetNbinsX();
  Double_t dPtMin = (profilePtEta->GetXaxis())->GetXmin();
  Double_t dPtMax = (profilePtEta->GetXaxis())->GetXmax();

  Int_t nBinsEta   = profilePtEta->GetNbinsY();

  TProfile *profilePt = new TProfile("","",nBinsPt,dPtMin,dPtMax);

  for(Int_t p=1;p<=nBinsPt;p++)
  {
    Double_t contentPt = 0.;
    Double_t entryPt = 0.;
    Double_t spreadPt = 0.;
    Double_t sum1 = 0.;
    Double_t sum2 = 0.;
    Double_t sum3 = 0.;
    for(Int_t e=1;e<=nBinsEta;e++)
    {
      contentPt += (profilePtEta->GetBinContent(profilePtEta->GetBin(p,e)))
      * (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)));
      entryPt   += (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)));

      sum1 += (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)))
      * (pow(profilePtEta->GetBinError(profilePtEta->GetBin(p,e)),2.)
         + pow(profilePtEta->GetBinContent(profilePtEta->GetBin(p,e)),2.));
      sum2 += (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)));
      sum3 += (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)))
      * (profilePtEta->GetBinContent(profilePtEta->GetBin(p,e)));
    }
    if(sum2>0. && sum1/sum2-pow(sum3/sum2,2.) > 0.)
    {
      spreadPt = pow(sum1/sum2-pow(sum3/sum2,2.),0.5);
    }
    profilePt->SetBinContent(p,contentPt);
    profilePt->SetBinEntries(p,entryPt);
    {
      profilePt->SetBinError(p,spreadPt);
    }

  }

  return profilePt;

} // end of TProfile* AliFlowAnalysisCRC::MakePtProjection(TProfile2D *profilePtEta)


//=======================================================================================================================


TProfile* AliFlowAnalysisCRC::MakeEtaProjection(TProfile2D *profilePtEta) const
{
  // project 2D profile onto eta axis to get 1D profile

  Int_t nBinsEta   = profilePtEta->GetNbinsY();
  Double_t dEtaMin = (profilePtEta->GetYaxis())->GetXmin();
  Double_t dEtaMax = (profilePtEta->GetYaxis())->GetXmax();

  Int_t nBinsPt = profilePtEta->GetNbinsX();

  TProfile *profileEta = new TProfile("","",nBinsEta,dEtaMin,dEtaMax);

  for(Int_t e=1;e<=nBinsEta;e++)
  {
    Double_t contentEta = 0.;
    Double_t entryEta = 0.;
    for(Int_t p=1;p<=nBinsPt;p++)
    {
      contentEta += (profilePtEta->GetBinContent(profilePtEta->GetBin(p,e)))
      * (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)));
      entryEta   += (profilePtEta->GetBinEntries(profilePtEta->GetBin(p,e)));
    }
    profileEta->SetBinContent(e,contentEta);
    profileEta->SetBinEntries(e,entryEta);
  }

  return profileEta;

} // end of TProfile* AliFlowAnalysisCRC::MakeEtaProjection(TProfile2D *profilePtEta)

//=======================================================================================================================

void AliFlowAnalysisCRC::PrintFinalResultsForIntegratedFlow(TString type)
{
  // Printing on the screen the final results for integrated flow (RF, POI and RP).

  Int_t n = fHarmonic;

  Double_t dVn[4] = {0.}; // array to hold Vn{2}, Vn{4}, Vn{6} and Vn{8}
  Double_t dVnErr[4] = {0.}; // array to hold errors of Vn{2}, Vn{4}, Vn{6} and Vn{8}

  if(type == "RF")
  {
    for(Int_t b=0;b<4;b++)
    {
      dVn[0] = (fCommonHistsResults2nd->GetHistIntFlow())->GetBinContent(1);
      dVnErr[0] = (fCommonHistsResults2nd->GetHistIntFlow())->GetBinError(1);
      dVn[1] = (fCommonHistsResults4th->GetHistIntFlow())->GetBinContent(1);
      dVnErr[1] = (fCommonHistsResults4th->GetHistIntFlow())->GetBinError(1);
      dVn[2] = (fCommonHistsResults6th->GetHistIntFlow())->GetBinContent(1);
      dVnErr[2] = (fCommonHistsResults6th->GetHistIntFlow())->GetBinError(1);
      dVn[3] = (fCommonHistsResults8th->GetHistIntFlow())->GetBinContent(1);
      dVnErr[3] = (fCommonHistsResults8th->GetHistIntFlow())->GetBinError(1);
    }
  } else if(type == "RP")
  {
    dVn[0] = (fCommonHistsResults2nd->GetHistIntFlowRP())->GetBinContent(1);
    dVnErr[0] = (fCommonHistsResults2nd->GetHistIntFlowRP())->GetBinError(1);
    dVn[1] = (fCommonHistsResults4th->GetHistIntFlowRP())->GetBinContent(1);
    dVnErr[1] = (fCommonHistsResults4th->GetHistIntFlowRP())->GetBinError(1);
    dVn[2] = (fCommonHistsResults6th->GetHistIntFlowRP())->GetBinContent(1);
    dVnErr[2] = (fCommonHistsResults6th->GetHistIntFlowRP())->GetBinError(1);
    dVn[3] = (fCommonHistsResults8th->GetHistIntFlowRP())->GetBinContent(1);
    dVnErr[3] = (fCommonHistsResults8th->GetHistIntFlowRP())->GetBinError(1);
  } else if(type == "POI")
  {
    dVn[0] = (fCommonHistsResults2nd->GetHistIntFlowPOI())->GetBinContent(1);
    dVnErr[0] = (fCommonHistsResults2nd->GetHistIntFlowPOI())->GetBinError(1);
    dVn[1] = (fCommonHistsResults4th->GetHistIntFlowPOI())->GetBinContent(1);
    dVnErr[1] = (fCommonHistsResults4th->GetHistIntFlowPOI())->GetBinError(1);
    dVn[2] = (fCommonHistsResults6th->GetHistIntFlowPOI())->GetBinContent(1);
    dVnErr[2] = (fCommonHistsResults6th->GetHistIntFlowPOI())->GetBinError(1);
    dVn[3] = (fCommonHistsResults8th->GetHistIntFlowPOI())->GetBinContent(1);
    dVnErr[3] = (fCommonHistsResults8th->GetHistIntFlowPOI())->GetBinError(1);
  } else if(type == "RF, rebinned in M" && fCalculateCumulantsVsM)
  {
    for(Int_t b=0;b<4;b++)
    {
      dVn[b] = fIntFlowRebinnedInM->GetBinContent(b+1);
      dVnErr[b] = fIntFlowRebinnedInM->GetBinError(b+1);
    }
  }

  TString title = " flow estimates from Q-cumulants";
  TString subtitle = "    (";
  TString subtitle2 = "       (rebinned in M)";

  if(type != "RF, rebinned in M")
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      subtitle.Append(type);
      subtitle.Append(", without weights)");
    } else
    {
      subtitle.Append(type);
      subtitle.Append(", with weights)");
    }
  } else
  {
    if(!(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights))
    {
      subtitle.Append("RF");
      subtitle.Append(", without weights)");
    } else
    {
      subtitle.Append("RF");
      subtitle.Append(", with weights)");
    }
  }

  cout<<endl;
  cout<<"*************************************"<<endl;
  cout<<"*************************************"<<endl;
  cout<<title.Data()<<endl;
  cout<<subtitle.Data()<<endl;
  if(type == "RF, rebinned in M"){cout<<subtitle2.Data()<<endl;}
  cout<<endl;

  for(Int_t i=0;i<4;i++)
  {
    cout<<"  v_"<<n<<"{"<<2*(i+1)<<"} = "<<dVn[i]<<" +/- "<<dVnErr[i]<<endl;
  }

  cout<<endl;
  if(type == "RF")
  {
    if(fApplyCorrectionForNUA)
    {
      cout<<" detector bias (corrected for): "<<endl;
    } else
    {
      cout<<" detector bias (not corrected for):"<<endl;
    }
    cout<<"  to QC{2}: "<<fIntFlowDetectorBias->GetBinContent(1)<<" +/- "<<fIntFlowDetectorBias->GetBinError(1)<<endl;
    cout<<"  to QC{4}: "<<fIntFlowDetectorBias->GetBinContent(2)<<" +/- "<<fIntFlowDetectorBias->GetBinError(2)<<endl;
    cout<<endl;
  }
  if(type == "RF" || type == "RF, rebinned in M")
  {
    cout<<"     nEvts = "<<(Int_t)fCommonHists->GetHistMultRP()->GetEntries()<<", <M> = "<<(Double_t)fCommonHists->GetHistMultRP()->GetMean()<<endl;
  }
  else if (type == "RP")
  {
    cout<<"     nEvts = "<<(Int_t)fCommonHists->GetHistMultRP()->GetEntries()<<", <M> = "<<(Double_t)fCommonHists->GetHistMultRP()->GetMean()<<endl;
  }
  else if (type == "POI")
  {
    cout<<"     nEvts = "<<(Int_t)fCommonHists->GetHistMultPOI()->GetEntries()<<", <M> = "<<(Double_t)fCommonHists->GetHistMultPOI()->GetMean()<<endl;
  }

  cout<<"*************************************"<<endl;
  cout<<"*************************************"<<endl;
  cout<<endl;

}// end of AliFlowAnalysisCRC::PrintFinalResultsForIntegratedFlow(TString type="RF");

//=======================================================================================================================

void AliFlowAnalysisCRC::WriteHistograms(TString outputFileName)
{
  //store the final results in output .root file
  TFile *output = new TFile(outputFileName.Data(),"RECREATE");
  //output->WriteObject(fHistList, "cobjQC","SingleKey");
  fHistList->Write(fHistList->GetName(), TObject::kSingleKey);
  delete output;
}


//=======================================================================================================================


void AliFlowAnalysisCRC::WriteHistograms(TDirectoryFile *outputFileName)
{
  //store the final results in output .root file
  fHistList->SetName("cobjQC");
  fHistList->SetOwner(kTRUE);
  outputFileName->Add(fHistList);
  outputFileName->Write(outputFileName->GetName(), TObject::kSingleKey);
}

//=======================================================================================================================

void AliFlowAnalysisCRC::BookCommonHistograms()
{
  // Book common control histograms and common histograms for final results.
  //  a) Book common control histograms;
  //  b) Book common result histograms.

  // a) Book common control histograms:
  //  Common control histograms (all events):
  TString commonHistsName = "AliFlowCommonHistQC";
  commonHistsName += fAnalysisLabel->Data();
  fCommonHists = new AliFlowCommonHist(commonHistsName.Data(),commonHistsName.Data(),fBookOnlyBasicCCH);
  fHistList->Add(fCommonHists);
  //  Common control histograms (selected events):
  if(fFillMultipleControlHistograms)
  {
    // Common control histogram filled for events with 2 and more reference particles:
    TString commonHists2ndOrderName = "AliFlowCommonHist2ndOrderQC";
    commonHists2ndOrderName += fAnalysisLabel->Data();
    fCommonHists2nd = new AliFlowCommonHist(commonHists2ndOrderName.Data(),commonHists2ndOrderName.Data(),fBookOnlyBasicCCH);
    fHistList->Add(fCommonHists2nd);
    // Common control histogram filled for events with 2 and more reference particles:
    TString commonHists4thOrderName = "AliFlowCommonHist4thOrderQC";
    commonHists4thOrderName += fAnalysisLabel->Data();
    fCommonHists4th = new AliFlowCommonHist(commonHists4thOrderName.Data(),commonHists4thOrderName.Data(),fBookOnlyBasicCCH);
    fHistList->Add(fCommonHists4th);
    // Common control histogram filled for events with 6 and more reference particles:
    TString commonHists6thOrderName = "AliFlowCommonHist6thOrderQC";
    commonHists6thOrderName += fAnalysisLabel->Data();
    fCommonHists6th = new AliFlowCommonHist(commonHists6thOrderName.Data(),commonHists6thOrderName.Data(),fBookOnlyBasicCCH);
    fHistList->Add(fCommonHists6th);
    // Common control histogram filled for events with 8 and more reference particles:
    TString commonHists8thOrderName = "AliFlowCommonHist8thOrderQC";
    commonHists8thOrderName += fAnalysisLabel->Data();
    fCommonHists8th = new AliFlowCommonHist(commonHists8thOrderName.Data(),commonHists8thOrderName.Data(),fBookOnlyBasicCCH);
    fHistList->Add(fCommonHists8th);
  } // end of if(fFillMultipleControlHistograms)

  // b) Book common result histograms:
  //  Common result histograms for QC{2}:
  TString commonHistResults2ndOrderName = "AliFlowCommonHistResults2ndOrderQC";
  commonHistResults2ndOrderName += fAnalysisLabel->Data();
  fCommonHistsResults2nd = new AliFlowCommonHistResults(commonHistResults2ndOrderName.Data(),"",fHarmonic);
  fHistList->Add(fCommonHistsResults2nd);
  //  Common result histograms for QC{4}:
  TString commonHistResults4thOrderName = "AliFlowCommonHistResults4thOrderQC";
  commonHistResults4thOrderName += fAnalysisLabel->Data();
  fCommonHistsResults4th = new AliFlowCommonHistResults(commonHistResults4thOrderName.Data(),"",fHarmonic);
  fHistList->Add(fCommonHistsResults4th);
  //  Common result histograms for QC{6}:
  TString commonHistResults6thOrderName = "AliFlowCommonHistResults6thOrderQC";
  commonHistResults6thOrderName += fAnalysisLabel->Data();
  fCommonHistsResults6th = new AliFlowCommonHistResults(commonHistResults6thOrderName.Data(),"",fHarmonic);
  fHistList->Add(fCommonHistsResults6th);
  //  Common result histograms for QC{8}:
  TString commonHistResults8thOrderName = "AliFlowCommonHistResults8thOrderQC";
  commonHistResults8thOrderName += fAnalysisLabel->Data();
  fCommonHistsResults8th = new AliFlowCommonHistResults(commonHistResults8thOrderName.Data(),"",fHarmonic);
  fHistList->Add(fCommonHistsResults8th);

} // end of void AliFlowAnalysisCRC::BookCommonHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookAndFillWeightsHistograms()
{
  // Book and fill histograms which hold phi, pt and eta weights.

  if(!fWeightsList)
  {
    printf("\n WARNING (QC): fWeightsList is NULL in AFAWQC::BAFWH() !!!! \n\n");
    exit(0);
  }

  Double_t ptbinsforweights[200001] = {0.};
  for (Int_t phib=0; phib<200001; phib++) {
    ptbinsforweights[phib] = 0.2 + phib*(50.-0.2)/200000.;
  }
  Double_t cenbinsforweights[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
  if(fPtWeightsHist[0]) {
    fPtWeightsCent = new TH2F("fPtWeightsCent","fPtWeightsCent",200000,ptbinsforweights,10,cenbinsforweights);
    fTempList->Add(fPtWeightsCent);
  }

  // // POIs
  // for(Int_t c=0; c<2; c++)
  // {
  //  fPhiWeightsPOIs[c] = new TH1F(Form("fPhiWeightsPOIs[%d][%d]",c,h),Form("fPhiWeightsPOIs[%d][%d]",c,h),fnBinsPhi,fPhiMin,fPhiMax);
  //  fPhiWeightsPOIs[c]->Sumw2();
  //  fEtaWeightsPOIs[c] = new TH1D(Form("fEtaWeightsPOIs[%d][%d]",c,h),Form("fEtaWeightsPOIs[%d][%d]",c,h),fnBinsEta,fEtaMin,fEtaMax);
  //  fEtaWeightsPOIs[c]->Sumw2();
  //  fPhiEtaWeightsPOIs[c] = new TH2D(Form("fPhiEtaWeightsPOIs[%d][%d]",c,h),Form("fPhiEtaWeightsPOIs[%d][%d]",c,h),fnBinsPhi,fPhiMin,fPhiMax,fnBinsEta,fEtaMin,fEtaMax);
  //  fPhiEtaWeightsPOIs[c]->Sumw2();
  //
  //  if(fUsePhiWeights)
  //  {
  //   if(fWeightsList->FindObject(Form("fPhiHist[%d][%d]",c,h)))
  //   {
  //    fPhiDistrRefPOIs[c] = dynamic_cast<TH1F*>(fWeightsList->FindObject(Form("fPhiHist[%d][%d]",c,h)));
  //    if(!fPhiDistrRefPOIs[c])
  //    {
  //     printf("\n WARNING (QC): fPhiDistrRefPOIs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //     exit(0);
  //    }
  //    if(TMath::Abs(fPhiDistrRefPOIs[c]->GetBinWidth(1)-fPhiBinWidth)>pow(10.,-6.))
  //    {
  //     cout<<endl;
  //     cout<<"WARNING (QC): Inconsistent binning in histograms for phi-weights throughout the code."<<endl;
  //     cout<<endl;
  //     //exit(0);
  //    }
  //   } else
  //   {
  //    cout<<"WARNING: fWeightsList->FindObject(\"fPhiHist\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //    exit(0);
  //   }
  //  } // end of if(fUsePhiWeights)
  //
  //  if(fUsePtWeights)
  //  {
  //   if(fWeightsList->FindObject(Form("fPtHist[%d][%d]",c,h)))
  //   {
  //    fPtDistrRefPOIs[c] = dynamic_cast<TH1D*>(fWeightsList->FindObject(Form("fPtHist[%d][%d]",c,h)));
  //    if(!fPtDistrRefPOIs[c])
  //    {
  //     printf("\n WARNING (QC): fPtDistrRefPOIs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //     exit(0);
  //    }
  //    if(TMath::Abs(fPtDistrRefPOIs[c]->GetBinWidth(1)-fPtBinWidth)>pow(10.,-6.))
  //    {
  //     cout<<endl;
  //     cout<<"WARNING (QC): Inconsistent binning in histograms for pt-weights throughout the code."<<endl;
  //     cout<<endl;
  //     //exit(0);
  //    }
  //   } else
  //   {
  //    cout<<"WARNING: fWeightsList->FindObject(\"fPtHist\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //    exit(0);
  //   }
  //  } // end of if(fUsePtWeights)
  //
  //  if(fUseEtaWeights)
  //  {
  //   if(fWeightsList->FindObject(Form("fEtaHist[%d][%d]",c,h)))
  //   {
  //    fEtaDistrRefPOIs[c] = dynamic_cast<TH1D*>(fWeightsList->FindObject(Form("fEtaHist[%d][%d]",c,h)));
  //    if(!fEtaDistrRefPOIs[c])
  //    {
  //     printf("\n WARNING (QC): fEtaDistrRefPOIs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //     exit(0);
  //    }
  //    if(TMath::Abs(fEtaDistrRefPOIs[c]->GetBinWidth(1)-fEtaBinWidth)>pow(10.,-6.))
  //    {
  //     cout<<endl;
  //     cout<<"WARNING (QC): Inconsistent binning in histograms for eta-weights throughout the code."<<endl;
  //     cout<<endl;
  //     //exit(0);
  //    }
  //   } else
  //   {
  //    cout<<"WARNING: fWeightsList->FindObject(\"fEtaHist\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //    exit(0);
  //   }
  //  } // end of if(fUseEtaWeights)
  //
  //
  // } // end of for(Int_t c=0; c<2; c++)

  //**********************************************************************************************************

  // RPs

  // fPhiWeightsRPs = new TH1F("fPhiWeightsRPs","fPhiWeightsRPs",fnBinsPhi,fPhiMin,fPhiMax);
  // fEtaWeightsRPs = new TH1D("fEtaWeightsRPs","fEtaWeightsRPs",fnBinsEta,fEtaMin,fEtaMax);
  //
  // if(fUsePhiWeights)
  // {
  //  if(fWeightsList->FindObject("fPhiDistrRPs"))
  //  {
  //   fPhiDistrRefRPs = dynamic_cast<TH1F*>(fWeightsList->FindObject("fPhiDistrRPs"));
  //   if(!fPhiDistrRefRPs)
  //   {
  //    printf("\n WARNING (QC): fPhiDistrRefRPs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //    exit(0);
  //   }
  //   if(TMath::Abs(fPhiDistrRefRPs->GetBinWidth(1)-fPhiBinWidth)>pow(10.,-6.))
  //   {
  //    cout<<endl;
  //    cout<<"WARNING (QC): Inconsistent binning in histograms for phi-weights throughout the code."<<endl;
  //    cout<<endl;
  //    //exit(0);
  //   }
  //  } else
  //  {
  //   cout<<"WARNING: fWeightsList->FindObject(\"fPhiDistrRPs\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //   exit(0);
  //  }
  // } // end of if(fUsePhiWeights)
  //
  // if(fUsePtWeights)
  // {
  //  if(fWeightsList->FindObject("fPtDistrRPs"))
  //  {
  //   fPtDistrRefRPs = dynamic_cast<TH1D*>(fWeightsList->FindObject("fPtDistrRPs"));
  //   if(!fPtDistrRefRPs)
  //   {
  //    printf("\n WARNING (QC): fPtDistrRefRPs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //    exit(0);
  //   }
  //   if(TMath::Abs(fPtDistrRefRPs->GetBinWidth(1)-fPtBinWidth)>pow(10.,-6.))
  //   {
  //    cout<<endl;
  //    cout<<"WARNING (QC): Inconsistent binning in histograms for phi-weights throughout the code."<<endl;
  //    cout<<endl;
  //    //exit(0);
  //   }
  //  } else
  //  {
  //   cout<<"WARNING: fWeightsList->FindObject(\"fPtDistrRPs\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //   exit(0);
  //  }
  // } // end of if(fUsePtWeights)
  //
  // if(fUseEtaWeights)
  // {
  //  if(fWeightsList->FindObject("fEtaDistrRPs"))
  //  {
  //   fEtaDistrRefRPs = dynamic_cast<TH1D*>(fWeightsList->FindObject("fEtaDistrRPs"));
  //   if(!fEtaDistrRefRPs)
  //   {
  //    printf("\n WARNING (QC): fEtaDistrRefRPs is NULL in AFAWQC::BAFWH() !!!!\n\n");
  //    exit(0);
  //   }
  //   if(TMath::Abs(fEtaDistrRefRPs->GetBinWidth(1)-fEtaBinWidth)>pow(10.,-6.))
  //   {
  //    cout<<endl;
  //    cout<<"WARNING (QC): Inconsistent binning in histograms for eta-weights throughout the code."<<endl;
  //    cout<<endl;
  //    //exit(0);
  //   }
  //  } else
  //  {
  //   cout<<"WARNING: fWeightsList->FindObject(\"fEtaDistrRPs\") is NULL in AFAWQC::BAFWH() !!!!"<<endl;
  //   exit(0);
  //  }
  // } // end of if(fUseEtaWeights)
  //

} // end of AliFlowAnalysisCRC::BookAndFillWeightsHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::SetCentralityWeights()
{
  if(!fCenWeightsHist) return;
  fCenWeigCalHist = (TH1D*)(fCenWeightsHist->Clone("fCenWeigCalHist"));
  TF1 *CenFit = new TF1("CenFit","pol0", 0., 100.);
  if(fDataSet!=AliFlowAnalysisCRC::k2011) {
    fCenWeigCalHist->Fit("CenFit","QNR","",0.,50.);
    Double_t CenAv = CenFit->GetParameter(0);
    for(Int_t b=1; b<=fCenWeigCalHist->GetNbinsX(); b++) {
      Double_t newbin = fCenWeigCalHist->GetBinContent(b);
      if(newbin) {
        fCenWeigCalHist->SetBinContent(b,CenAv/newbin);
      } else {
        fCenWeigCalHist->SetBinContent(b,1.);
      }
    }
  }
  else {
    fCenWeigCalHist->Fit("CenFit","QNR","",0.,8.);
    Double_t CenAv = CenFit->GetParameter(0);
    fCenWeigCalHist->Fit("CenFit","QNR","",12.,50.);
    Double_t SemiCenAv = CenFit->GetParameter(0);
    for(Int_t b=1; b<=fCenWeigCalHist->GetNbinsX(); b++) {
      Double_t newbin = fCenWeigCalHist->GetBinContent(b);
      if(newbin) {
        if(b<=10) fCenWeigCalHist->SetBinContent(b,CenAv/newbin);
        if(b>10 && b<=50) fCenWeigCalHist->SetBinContent(b,SemiCenAv/newbin);
        if(b>50) fCenWeigCalHist->SetBinContent(b,1.);
      } else {
        fCenWeigCalHist->SetBinContent(b,1.);
      }
    }
  }
  fCenWeigCalHist->SetName("CenWeights");
  fVariousList->Add(fCenWeigCalHist);
} // end of AliFlowAnalysisCRC::SetCentralityWeights()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForIntegratedFlow()
{
  // Book all objects for integrated flow:
  //  a) Book profile to hold all flags for integrated flow;
  //  b) Book event-by-event quantities;
  //  c) Book profiles; // to be improved (comment)
  //  d) Book histograms holding the final results.

  TString sinCosFlag[2] = {"sin","cos"}; // to be improved (should I promote this to data members?)
  TString powerFlag[2] = {"linear","quadratic"}; // to be improved (should I promote this to data members?)

  // a) Book profile to hold all flags for integrated flow:
  TString intFlowFlagsName = "fIntFlowFlags";
  intFlowFlagsName += fAnalysisLabel->Data();
  fIntFlowFlags = new TProfile(intFlowFlagsName.Data(),"Flags for Integrated Flow",20,0.,20.);
  fIntFlowFlags->SetTickLength(-0.01,"Y");
  fIntFlowFlags->SetMarkerStyle(25);
  fIntFlowFlags->SetLabelSize(0.04);
  fIntFlowFlags->SetLabelOffset(0.02,"Y");
  fIntFlowFlags->SetStats(kFALSE);
  fIntFlowFlags->GetXaxis()->SetBinLabel(1,"Particle Weights");
  fIntFlowFlags->GetXaxis()->SetBinLabel(2,"Event Weights");
  fIntFlowFlags->GetXaxis()->SetBinLabel(3,"Corrected for NUA?");
  fIntFlowFlags->GetXaxis()->SetBinLabel(4,"Print RF results");
  fIntFlowFlags->GetXaxis()->SetBinLabel(5,"Print RP results");
  fIntFlowFlags->GetXaxis()->SetBinLabel(6,"Print POI results");
  fIntFlowFlags->GetXaxis()->SetBinLabel(7,"Print RF (rebinned in M) results");
  fIntFlowFlags->GetXaxis()->SetBinLabel(8,"Corrected for NUA vs M?");
  fIntFlowFlags->GetXaxis()->SetBinLabel(9,"Propagate errors to v_{n} from correlations?");
  fIntFlowFlags->GetXaxis()->SetBinLabel(10,"Calculate cumulants vs M");
  fIntFlowFlags->GetXaxis()->SetBinLabel(11,"fMinimumBiasReferenceFlow");
  fIntFlowFlags->GetXaxis()->SetBinLabel(12,"fForgetAboutCovariances");
  fIntFlowFlags->GetXaxis()->SetBinLabel(13,"fStoreVarious");
  fIntFlowFlags->GetXaxis()->SetBinLabel(14,"fFillMultipleControlHistograms");
  fIntFlowFlags->GetXaxis()->SetBinLabel(15,"Calculate all correlations vs M");
  fIntFlowFlags->GetXaxis()->SetBinLabel(16,"fMultiplicityIs");
  fIntFlowFlags->GetXaxis()->SetBinLabel(17,"fExactNoRPs");
  fIntFlowFlags->GetXaxis()->SetBinLabel(18,"fUse2DHistograms");
  fIntFlowFlags->GetXaxis()->SetBinLabel(19,"fFillProfilesVsMUsingWeights");
  fIntFlowFlags->GetXaxis()->SetBinLabel(20,"fUseQvectorTerms");
  fIntFlowList->Add(fIntFlowFlags);

  // b) Book event-by-event quantities:
  // Re[Q_{m*n,k}], Im[Q_{m*n,k}] and S_{p,k}^M:
  fReQ = new TMatrixD(12,9);
  fImQ = new TMatrixD(12,9);
  fSpk = new TMatrixD(8,9);
  fReQGF = new TMatrixD(21,9);
  fImQGF = new TMatrixD(21,9);
  for(Int_t i=0; i<fkGFPtB; i++) {
    fReQGFPt[i] = new TMatrixD(21,9);
    fImQGFPt[i] = new TMatrixD(21,9);
  }
  // average correlations <2>, <4>, <6> and <8> for single event (bining is the same as in fIntFlowCorrelationsPro and fIntFlowCorrelationsHist):
  TString intFlowCorrelationsEBEName = "fIntFlowCorrelationsEBE";
  intFlowCorrelationsEBEName += fAnalysisLabel->Data();
  fIntFlowCorrelationsEBE = new TH1D(intFlowCorrelationsEBEName.Data(),intFlowCorrelationsEBEName.Data(),4,0,4);
  // weights for average correlations <2>, <4>, <6> and <8> for single event:
  TString intFlowEventWeightsForCorrelationsEBEName = "fIntFlowEventWeightsForCorrelationsEBE";
  intFlowEventWeightsForCorrelationsEBEName += fAnalysisLabel->Data();
  fIntFlowEventWeightsForCorrelationsEBE = new TH1D(intFlowEventWeightsForCorrelationsEBEName.Data(),intFlowEventWeightsForCorrelationsEBEName.Data(),4,0,4);
  // average all correlations for single event (bining is the same as in fIntFlowCorrelationsAllPro and fIntFlowCorrelationsAllHist):
  TString intFlowCorrelationsAllEBEName = "fIntFlowCorrelationsAllEBE";
  intFlowCorrelationsAllEBEName += fAnalysisLabel->Data();
  fIntFlowCorrelationsAllEBE = new TH1D(intFlowCorrelationsAllEBEName.Data(),intFlowCorrelationsAllEBEName.Data(),64,0,64);
  // average correction terms for non-uniform acceptance for single event
  // (binning is the same as in fIntFlowCorrectionTermsForNUAPro[2] and fIntFlowCorrectionTermsForNUAHist[2]):
  TString fIntFlowCorrectionTermsForNUAEBEName = "fIntFlowCorrectionTermsForNUAEBE";
  fIntFlowCorrectionTermsForNUAEBEName += fAnalysisLabel->Data();
  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    fIntFlowCorrectionTermsForNUAEBE[sc] = new TH1D(Form("%s: %s terms",fIntFlowCorrectionTermsForNUAEBEName.Data(),sinCosFlag[sc].Data()),Form("Correction terms for non-uniform acceptance (%s terms)",sinCosFlag[sc].Data()),4,0,4);
  }
  // event weights for terms for non-uniform acceptance:
  TString fIntFlowEventWeightForCorrectionTermsForNUAEBEName = "fIntFlowEventWeightForCorrectionTermsForNUAEBE";
  fIntFlowEventWeightForCorrectionTermsForNUAEBEName += fAnalysisLabel->Data();
  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    fIntFlowEventWeightForCorrectionTermsForNUAEBE[sc] = new TH1D(Form("%s: %s terms",fIntFlowEventWeightForCorrectionTermsForNUAEBEName.Data(),sinCosFlag[sc].Data()),Form("Event weights for terms for non-uniform acceptance (%s terms)",sinCosFlag[sc].Data()),4,0,4); // to be improved - 4
  }
  // c) Book profiles: // to be improved (comment)
  // profile to hold average multiplicities and number of events for events with nRP>=0, nRP>=1, ... , and nRP>=8:
  TString avMultiplicityName = "fAvMultiplicity";
  avMultiplicityName += fAnalysisLabel->Data();
  fAvMultiplicity = new TProfile(avMultiplicityName.Data(),"Average multiplicities of reference particles (RPs)",9,0,9);
  fAvMultiplicity->SetTickLength(-0.01,"Y");
  fAvMultiplicity->SetMarkerStyle(25);
  fAvMultiplicity->SetLabelSize(0.05);
  fAvMultiplicity->SetLabelOffset(0.02,"Y");
  fAvMultiplicity->SetYTitle("Average multiplicity");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(1,"all evts");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(2,"n_{RP} #geq 1");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(3,"n_{RP} #geq 2");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(4,"n_{RP} #geq 3");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(5,"n_{RP} #geq 4");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(6,"n_{RP} #geq 5");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(7,"n_{RP} #geq 6");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(8,"n_{RP} #geq 7");
  (fAvMultiplicity->GetXaxis())->SetBinLabel(9,"n_{RP} #geq 8");
  fIntFlowProfiles->Add(fAvMultiplicity);
  // Average correlations <<2>>, <<4>>, <<6>> and <<8>> for all events (with wrong errors!):
  TString correlationFlag[4] = {"#LT#LT2#GT#GT","#LT#LT4#GT#GT","#LT#LT6#GT#GT","#LT#LT8#GT#GT"};
  TString intFlowCorrelationsProName = "fIntFlowCorrelationsPro";
  intFlowCorrelationsProName += fAnalysisLabel->Data();
  fIntFlowCorrelationsPro = new TProfile(intFlowCorrelationsProName.Data(),"Average correlations for all events",4,0,4,"s");
  fIntFlowCorrelationsPro->Sumw2();
  fIntFlowCorrelationsPro->SetTickLength(-0.01,"Y");
  fIntFlowCorrelationsPro->SetMarkerStyle(25);
  fIntFlowCorrelationsPro->SetLabelSize(0.06);
  fIntFlowCorrelationsPro->SetLabelOffset(0.01,"Y");
  for(Int_t b=0;b<4;b++)
  {
    (fIntFlowCorrelationsPro->GetXaxis())->SetBinLabel(b+1,correlationFlag[b].Data());
  }
  fIntFlowProfiles->Add(fIntFlowCorrelationsPro);
  // Average correlations squared <<2>^2>, <<4>^2>, <<6>^2> and <<8>^2> for all events:
  TString squaredCorrelationFlag[4] = {"#LT#LT2#GT^{2}#GT","#LT#LT4#GT^{2}#GT","#LT#LT6#GT^{2}#GT","#LT#LT8#GT^{2}#GT"};
  TString intFlowSquaredCorrelationsProName = "fIntFlowSquaredCorrelationsPro";
  intFlowSquaredCorrelationsProName += fAnalysisLabel->Data();
  fIntFlowSquaredCorrelationsPro = new TProfile(intFlowSquaredCorrelationsProName.Data(),"Average squared correlations for all events",4,0,4,"s");
  fIntFlowSquaredCorrelationsPro->Sumw2();
  fIntFlowSquaredCorrelationsPro->SetTickLength(-0.01,"Y");
  fIntFlowSquaredCorrelationsPro->SetMarkerStyle(25);
  fIntFlowSquaredCorrelationsPro->SetLabelSize(0.06);
  fIntFlowSquaredCorrelationsPro->SetLabelOffset(0.01,"Y");
  for(Int_t b=0;b<4;b++)
  {
    (fIntFlowSquaredCorrelationsPro->GetXaxis())->SetBinLabel(b+1,squaredCorrelationFlag[b].Data());
  }
  fIntFlowProfiles->Add(fIntFlowSquaredCorrelationsPro);
  if(fCalculateCumulantsVsM)
  {
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      // average correlations <<2>>, <<4>>, <<6>> and <<8>> versus multiplicity for all events (with wrong errors):
      TString intFlowCorrelationsVsMProName = "fIntFlowCorrelationsVsMPro";
      intFlowCorrelationsVsMProName += fAnalysisLabel->Data();
      fIntFlowCorrelationsVsMPro[ci] = new TProfile(Form("%s, %s",intFlowCorrelationsVsMProName.Data(),correlationFlag[ci].Data()),
                                                    Form("%s vs multiplicity",correlationFlag[ci].Data()),
                                                    fnBinsMult,fMinMult,fMaxMult,"s");
      fIntFlowCorrelationsVsMPro[ci]->Sumw2();
      fIntFlowCorrelationsVsMPro[ci]->GetYaxis()->SetTitle(correlationFlag[ci].Data());
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowProfiles->Add(fIntFlowCorrelationsVsMPro[ci]);
      // average squared correlations <<2>^2>, <<4>^2>, <<6>^2> and <<8>^2> versus multiplicity for all events:
      TString intFlowSquaredCorrelationsVsMProName = "fIntFlowSquaredCorrelationsVsMPro";
      intFlowSquaredCorrelationsVsMProName += fAnalysisLabel->Data();
      fIntFlowSquaredCorrelationsVsMPro[ci] = new TProfile(Form("%s, %s",intFlowSquaredCorrelationsVsMProName.Data(),squaredCorrelationFlag[ci].Data()),
                                                           Form("%s vs multiplicity",squaredCorrelationFlag[ci].Data()),
                                                           fnBinsMult,fMinMult,fMaxMult,"s");
      fIntFlowSquaredCorrelationsVsMPro[ci]->Sumw2();
      fIntFlowSquaredCorrelationsVsMPro[ci]->GetYaxis()->SetTitle(squaredCorrelationFlag[ci].Data());
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowSquaredCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowSquaredCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowSquaredCorrelationsVsMPro[ci]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowProfiles->Add(fIntFlowSquaredCorrelationsVsMPro[ci]);
    } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
  } // end of if(fCalculateCumulantsVsM)
  // averaged all correlations for all events (with wrong errors!):
  TString intFlowCorrelationsAllProName = "fIntFlowCorrelationsAllPro";
  intFlowCorrelationsAllProName += fAnalysisLabel->Data();
  fIntFlowCorrelationsAllPro = new TProfile(intFlowCorrelationsAllProName.Data(),"Average all correlations for all events",64,0,64);
  fIntFlowCorrelationsAllPro->Sumw2();
  fIntFlowCorrelationsAllPro->SetTickLength(-0.01,"Y");
  fIntFlowCorrelationsAllPro->SetMarkerStyle(25);
  fIntFlowCorrelationsAllPro->SetLabelSize(0.03);
  fIntFlowCorrelationsAllPro->SetLabelOffset(0.01,"Y");
  // 2-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(1,"#LT#LT2#GT#GT_{n|n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(2,"#LT#LT2#GT#GT_{2n|2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(3,"#LT#LT2#GT#GT_{3n|3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(4,"#LT#LT2#GT#GT_{4n|4n}");
  // 3-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(6,"#LT#LT3#GT#GT_{2n|n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(7,"#LT#LT3#GT#GT_{3n|2n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(8,"#LT#LT3#GT#GT_{4n|2n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(9,"#LT#LT3#GT#GT_{4n|3n,n}");
  // 4-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(11,"#LT#LT4#GT#GT_{n,n|n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(12,"#LT#LT4#GT#GT_{2n,n|2n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(13,"#LT#LT4#GT#GT_{2n,2n|2n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(14,"#LT#LT4#GT#GT_{3n|n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(15,"#LT#LT4#GT#GT_{3n,n|3n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(16,"#LT#LT4#GT#GT_{3n,n|2n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(17,"#LT#LT4#GT#GT_{4n|2n,n,n}");
  // 5-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(19,"#LT#LT5#GT#GT_{2n,n|n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(20,"#LT#LT5#GT#GT_{2n,2n|2n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(21,"#LT#LT5#GT#GT_{3n,n|2n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(22,"#LT#LT5#GT#GT_{4n|n,n,n,n}");
  // 6-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(24,"#LT#LT6#GT#GT_{n,n,n|n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(25,"#LT#LT6#GT#GT_{2n,n,n|2n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(26,"#LT#LT6#GT#GT_{2n,2n|n,n,n,n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(27,"#LT#LT6#GT#GT_{3n,n|n,n,n,n}");
  // 7-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(29,"#LT#LT7#GT#GT_{2n,n,n|n,n,n,n}");
  // 8-p correlations:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(31,"#LT#LT8#GT#GT_{n,n,n,n|n,n,n,n}");
  //  EXTRA correlations for v3{5} study:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(33,"#LT#LT4#GT#GT_{4n,2n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(34,"#LT#LT5#GT#GT_{3n,3n|2n,2n,2n}");
  //  EXTRA correlations for Teaney-Yan study:
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(35,"#LT#LT2#GT#GT_{5n|5n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(36,"#LT#LT2#GT#GT_{6n|6n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(37,"#LT#LT3#GT#GT_{5n|3n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(38,"#LT#LT3#GT#GT_{5n|4n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(39,"#LT#LT3#GT#GT_{6n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(40,"#LT#LT3#GT#GT_{6n|4n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(41,"#LT#LT3#GT#GT_{6n|5n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(42,"#LT#LT4#GT#GT_{6n|3n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(43,"#LT#LT4#GT#GT_{3n,2n|3n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(44,"#LT#LT4#GT#GT_{4n,1n|3n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(45,"#LT#LT4#GT#GT_{3n,3n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(46,"#LT#LT4#GT#GT_{4n,2n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(47,"#LT#LT4#GT#GT_{5n,1n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(48,"#LT#LT4#GT#GT_{4n,2n|4n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(49,"#LT#LT4#GT#GT_{5n,1n|4n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(50,"#LT#LT4#GT#GT_{5n|3n,1n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(51,"#LT#LT4#GT#GT_{5n|2n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(52,"#LT#LT4#GT#GT_{5n,1n|5n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(53,"#LT#LT5#GT#GT_{3n,3n|3n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(54,"#LT#LT5#GT#GT_{4n,2n|3n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(55,"#LT#LT5#GT#GT_{3n,2n|3n,1n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(56,"#LT#LT5#GT#GT_{3n,2n|2n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(57,"#LT#LT5#GT#GT_{5n,1n|3n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(58,"#LT#LT6#GT#GT_{3n,2n,1n|3n,2n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(59,"#LT#LT4#GT#GT_{6n|4n,1n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(60,"#LT#LT4#GT#GT_{6n|2n,2n,2n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(61,"#LT#LT5#GT#GT_{6n|2n,2n,1n,1n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(62,"#LT#LT5#GT#GT_{4n,1n,1n|3n,3n}");
  (fIntFlowCorrelationsAllPro->GetXaxis())->SetBinLabel(63,"#LT#LT6#GT#GT_{3n,3n|2n,2n,1n,1n}");
  fIntFlowProfiles->Add(fIntFlowCorrelationsAllPro);
  // average all correlations versus multiplicity (errors via Sumw2 - to be improved):
  if(fCalculateAllCorrelationsVsM)
  {
    // 2-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[0] = new TProfile("two1n1n","#LT#LT2#GT#GT_{n|n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[1] = new TProfile("two2n2n","#LT#LT2#GT#GT_{2n|2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[2] = new TProfile("two3n3n","#LT#LT2#GT#GT_{3n|3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[3] = new TProfile("two4n4n","#LT#LT2#GT#GT_{4n|4n}",fnBinsMult,fMinMult,fMaxMult);
    // 3-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[5] = new TProfile("three2n1n1n","#LT#LT3#GT#GT_{2n|n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[6] = new TProfile("three3n2n1n","#LT#LT3#GT#GT_{3n|2n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[7] = new TProfile("three4n2n2n","#LT#LT3#GT#GT_{4n|2n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[8] = new TProfile("three4n3n1n","#LT#LT3#GT#GT_{4n|3n,n}",fnBinsMult,fMinMult,fMaxMult);
    // 4-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[10] = new TProfile("four1n1n1n1n","#LT#LT4#GT#GT_{n,n|n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[11] = new TProfile("four2n1n2n1n","#LT#LT4#GT#GT_{2n,n|2n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[12] = new TProfile("four2n2n2n2n","#LT#LT4#GT#GT_{2n,2n|2n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[13] = new TProfile("four3n1n1n1n","#LT#LT4#GT#GT_{3n|n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[14] = new TProfile("four3n1n3n1n","#LT#LT4#GT#GT_{3n,n|3n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[15] = new TProfile("four3n1n2n2n","#LT#LT4#GT#GT_{3n,n|2n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[16] = new TProfile("four4n2n1n1n","#LT#LT4#GT#GT_{4n|2n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    // 5-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[18] = new TProfile("five2n1n1n1n1n","#LT#LT5#GT#GT_{2n,n|n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[19] = new TProfile("five2n2n2n1n1n","#LT#LT5#GT#GT_{2n,2n|2n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[20] = new TProfile("five3n1n2n1n1n","#LT#LT5#GT#GT_{3n,n|2n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[21] = new TProfile("five4n1n1n1n1n","#LT#LT5#GT#GT_{4n|n,n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    // 6-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[23] = new TProfile("six1n1n1n1n1n1n","#LT#LT6#GT#GT_{n,n,n|n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[24] = new TProfile("six2n1n1n2n1n1n","#LT#LT6#GT#GT_{2n,n,n|2n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[25] = new TProfile("six2n2n1n1n1n1n","#LT#LT6#GT#GT_{2n,2n|n,n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[26] = new TProfile("six3n1n1n1n1n1n","#LT#LT6#GT#GT_{3n,n|n,n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    // 7-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[28] = new TProfile("seven2n1n1n1n1n1n1n","#LT#LT7#GT#GT_{2n,n,n|n,n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    // 8-p correlations vs M:
    fIntFlowCorrelationsAllVsMPro[30] = new TProfile("eight1n1n1n1n1n1n1n1n","#LT#LT8#GT#GT_{n,n,n,n|n,n,n,n}",fnBinsMult,fMinMult,fMaxMult);
    // EXTRA correlations vs M for v3{5} study (to be improved - put them in a right order somewhere):
    fIntFlowCorrelationsAllVsMPro[32] = new TProfile("four4n2n3n3n","#LT#LT4#GT#GT_{4n,2n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[33] = new TProfile("five3n3n2n2n2n","#LT#LT5#GT#GT_{3n,3n|2n,2n,2n}",fnBinsMult,fMinMult,fMaxMult);
    // EXTRA correlations vs M for Teaney-Yan study (to be improved - put them in a right order somewhere):
    fIntFlowCorrelationsAllVsMPro[34] = new TProfile("two5n5n","#LT#LT2#GT#GT_{5n|5n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[35] = new TProfile("two6n6n","#LT#LT2#GT#GT_{6n|6n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[36] = new TProfile("three5n3n2n","#LT#LT3#GT#GT_{5n|3n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[37] = new TProfile("three5n4n1n","#LT#LT3#GT#GT_{5n|4n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[38] = new TProfile("three6n3n3n","#LT#LT3#GT#GT_{6n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[39] = new TProfile("three6n4n2n","#LT#LT3#GT#GT_{6n|4n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[40] = new TProfile("three6n5n1n","#LT#LT3#GT#GT_{6n|5n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[41] = new TProfile("four6n3n2n1n","#LT#LT4#GT#GT_{6n|3n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[42] = new TProfile("four3n2n3n2n","#LT#LT4#GT#GT_{3n,2n|3n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[43] = new TProfile("four4n1n3n2n","#LT#LT4#GT#GT_{4n,1n|3n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[44] = new TProfile("four3n3n3n3n","#LT#LT4#GT#GT_{3n,3n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[45] = new TProfile("four4n2n3n3n","#LT#LT4#GT#GT_{4n,2n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[46] = new TProfile("four5n1n3n3n","#LT#LT4#GT#GT_{5n,1n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[47] = new TProfile("four4n2n4n2n","#LT#LT4#GT#GT_{4n,2n|4n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[48] = new TProfile("four5n1n4n2n","#LT#LT4#GT#GT_{5n,1n|4n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[49] = new TProfile("four5n3n1n1n","#LT#LT4#GT#GT_{5n|3n,1n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[50] = new TProfile("four5n2n2n1n","#LT#LT4#GT#GT_{5n|2n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[51] = new TProfile("four5n1n5n1n","#LT#LT4#GT#GT_{5n,1n|5n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[52] = new TProfile("five3n3n3n2n1n","#LT#LT5#GT#GT_{3n,3n|3n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[53] = new TProfile("five4n2n3n2n1n","#LT#LT5#GT#GT_{4n,2n|3n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[54] = new TProfile("five3n2n3n1n1n","#LT#LT5#GT#GT_{3n,2n|3n,1n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[55] = new TProfile("five3n2n2n2n1n","#LT#LT5#GT#GT_{3n,2n|2n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[56] = new TProfile("five5n1n3n2n1n","#LT#LT5#GT#GT_{5n,1n|3n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[57] = new TProfile("six3n2n1n3n2n1n","#LT#LT6#GT#GT_{3n,2n,1n|3n,2n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[58] = new TProfile("four6n4n1n1n","#LT#LT4#GT#GT_{6n|4n,1n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[59] = new TProfile("four6n2n2n2n","#LT#LT4#GT#GT_{6n|2n,2n,2n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[60] = new TProfile("five6n2n2n1n1n","#LT#LT5#GT#GT_{6n|2n,2n,1n,1n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[61] = new TProfile("five4n1n1n3n3n","#LT#LT5#GT#GT_{4n,1n,1n|3n,3n}",fnBinsMult,fMinMult,fMaxMult);
    fIntFlowCorrelationsAllVsMPro[62] = new TProfile("six3n3n2n2n1n1n","#LT#LT6#GT#GT_{3n,3n|2n,2n,1n,1n}",fnBinsMult,fMinMult,fMaxMult);
    for(Int_t n=0;n<63;n++)
    {
      if(fIntFlowCorrelationsAllVsMPro[n])
      {
        fIntFlowCorrelationsAllVsMPro[n]->Sumw2();
        if(fMultiplicityIs==AliFlowCommonConstants::kRP)
        {
          fIntFlowCorrelationsAllVsMPro[n]->GetXaxis()->SetTitle("# RPs");
        } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
        {
          fIntFlowCorrelationsAllVsMPro[n]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
        } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
        {
          fIntFlowCorrelationsAllVsMPro[n]->GetXaxis()->SetTitle("# POIs");
        }
        fIntFlowAllCorrelationsVsM->Add(fIntFlowCorrelationsAllVsMPro[n]);
      } // end of if(fIntFlowCorrelationsAllVsMPro[n])
    } // end of for(Int_t n=0;n<63;n++)
  } // end of if(fCalculateAllCorrelationsVsM)
  // when particle weights are used some extra correlations appear:
  if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
  {
    TString intFlowExtraCorrelationsProName = "fIntFlowExtraCorrelationsPro";
    intFlowExtraCorrelationsProName += fAnalysisLabel->Data();
    fIntFlowExtraCorrelationsPro = new TProfile(intFlowExtraCorrelationsProName.Data(),"Average extra correlations for all events",100,0,100,"s");
    fIntFlowExtraCorrelationsPro->SetTickLength(-0.01,"Y");
    fIntFlowExtraCorrelationsPro->SetMarkerStyle(25);
    fIntFlowExtraCorrelationsPro->SetLabelSize(0.03);
    fIntFlowExtraCorrelationsPro->SetLabelOffset(0.01,"Y");
    // extra 2-p correlations:
    (fIntFlowExtraCorrelationsPro->GetXaxis())->SetBinLabel(1,"<<w1^3 w2 cos(n*(phi1-phi2))>>");
    (fIntFlowExtraCorrelationsPro->GetXaxis())->SetBinLabel(2,"<<w1 w2 w3^2 cos(n*(phi1-phi2))>>");
    fIntFlowProfiles->Add(fIntFlowExtraCorrelationsPro);
  } // end of if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
  // average product of correlations <2>, <4>, <6> and <8>:
  TString productFlag[6] = {"#LT#LT2#GT#LT4#GT#GT","#LT#LT2#GT#LT6#GT#GT","#LT#LT2#GT#LT8#GT#GT",
    "#LT#LT4#GT#LT6#GT#GT","#LT#LT4#GT#LT8#GT#GT","#LT#LT6#GT#LT8#GT#GT"};
  TString intFlowProductOfCorrelationsProName = "fIntFlowProductOfCorrelationsPro";
  intFlowProductOfCorrelationsProName += fAnalysisLabel->Data();
  fIntFlowProductOfCorrelationsPro = new TProfile(intFlowProductOfCorrelationsProName.Data(),"Average products of correlations",6,0,6);
  fIntFlowProductOfCorrelationsPro->SetTickLength(-0.01,"Y");
  fIntFlowProductOfCorrelationsPro->SetMarkerStyle(25);
  fIntFlowProductOfCorrelationsPro->SetLabelSize(0.05);
  fIntFlowProductOfCorrelationsPro->SetLabelOffset(0.01,"Y");
  for(Int_t b=0;b<6;b++)
  {
    (fIntFlowProductOfCorrelationsPro->GetXaxis())->SetBinLabel(b+1,productFlag[b].Data());
  }
  fIntFlowProfiles->Add(fIntFlowProductOfCorrelationsPro);
  // average product of correlations <2>, <4>, <6> and <8> versus multiplicity
  // [0=<<2><4>>,1=<<2><6>>,2=<<2><8>>,3=<<4><6>>,4=<<4><8>>,5=<<6><8>>]
  if(fCalculateCumulantsVsM)
  {
    TString intFlowProductOfCorrelationsVsMProName = "fIntFlowProductOfCorrelationsVsMPro";
    intFlowProductOfCorrelationsVsMProName += fAnalysisLabel->Data();
    for(Int_t pi=0;pi<6;pi++)
    {
      fIntFlowProductOfCorrelationsVsMPro[pi] = new TProfile(Form("%s, %s",intFlowProductOfCorrelationsVsMProName.Data(),productFlag[pi].Data()),
                                                             Form("%s versus multiplicity",productFlag[pi].Data()),
                                                             fnBinsMult,fMinMult,fMaxMult);
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowProductOfCorrelationsVsMPro[pi]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowProductOfCorrelationsVsMPro[pi]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowProductOfCorrelationsVsMPro[pi]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowProfiles->Add(fIntFlowProductOfCorrelationsVsMPro[pi]);
    } // end of for(Int_t pi=0;pi<6;pi++)
  } // end of if(fCalculateCumulantsVsM)
  // average product of correction terms for NUA:
  TString intFlowProductOfCorrectionTermsForNUAProName = "fIntFlowProductOfCorrectionTermsForNUAPro";
  intFlowProductOfCorrectionTermsForNUAProName += fAnalysisLabel->Data();
  fIntFlowProductOfCorrectionTermsForNUAPro = new TProfile(intFlowProductOfCorrectionTermsForNUAProName.Data(),"Average products of correction terms for NUA",27,0,27);
  fIntFlowProductOfCorrectionTermsForNUAPro->SetTickLength(-0.01,"Y");
  fIntFlowProductOfCorrectionTermsForNUAPro->SetMarkerStyle(25);
  fIntFlowProductOfCorrectionTermsForNUAPro->SetLabelSize(0.03);
  fIntFlowProductOfCorrectionTermsForNUAPro->SetLabelOffset(0.01,"Y");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(1,"<<2><cos(#phi)>>");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(2,"<<2><sin(#phi)>>");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(3,"<<cos(#phi)><sin(#phi)>>");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(4,"Cov(<2>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(5,"Cov(<2>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(6,"Cov(<2>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(7,"Cov(<2>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(8,"Cov(<4>,<cos(#phi)>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(9,"Cov(<4>,<sin(#phi)>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(10,"Cov(<4>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(11,"Cov(<4>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(12,"Cov(<4>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(13,"Cov(<4>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(14,"Cov(<cos(#phi)>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(15,"Cov(<cos(#phi)>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(16,"Cov(<cos(#phi)>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(17,"Cov(<cos(#phi)>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(18,"Cov(<sin(#phi)>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(19,"Cov(<sin(#phi)>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(20,"Cov(<sin(#phi)>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(21,"Cov(<sin(#phi)>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(22,"Cov(<cos(#phi_{1}+#phi_{2})>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(23,"Cov(<cos(#phi_{1}+#phi_{2})>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(24,"Cov(<cos(#phi_{1}+#phi_{2})>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(25,"Cov(<sin(#phi_{1}+#phi_{2})>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(26,"Cov(<sin(#phi_{1}+#phi_{2})>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowProductOfCorrectionTermsForNUAPro->GetXaxis())->SetBinLabel(27,"Cov(<cos(#phi_{1}-#phi_{2}-#phi_{3}>,<sin(#phi_{1}-#phi_{2}-#phi_{3}>)");
  fIntFlowProfiles->Add(fIntFlowProductOfCorrectionTermsForNUAPro);
  // average correction terms for non-uniform acceptance (with wrong errors!):
  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    TString intFlowCorrectionTermsForNUAProName = "fIntFlowCorrectionTermsForNUAPro";
    intFlowCorrectionTermsForNUAProName += fAnalysisLabel->Data();
    fIntFlowCorrectionTermsForNUAPro[sc] = new TProfile(Form("%s: %s terms",intFlowCorrectionTermsForNUAProName.Data(),sinCosFlag[sc].Data()),Form("Correction terms for non-uniform acceptance (%s terms)",sinCosFlag[sc].Data()),4,0,4,"s");
    fIntFlowCorrectionTermsForNUAPro[sc]->SetTickLength(-0.01,"Y");
    fIntFlowCorrectionTermsForNUAPro[sc]->SetMarkerStyle(25);
    fIntFlowCorrectionTermsForNUAPro[sc]->SetLabelSize(0.05);
    fIntFlowCorrectionTermsForNUAPro[sc]->SetLabelOffset(0.01,"Y");
    (fIntFlowCorrectionTermsForNUAPro[sc]->GetXaxis())->SetBinLabel(1,Form("#LT#LT%s(n(#phi_{1}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAPro[sc]->GetXaxis())->SetBinLabel(2,Form("#LT#LT%s(n(#phi_{1}+#phi_{2}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAPro[sc]->GetXaxis())->SetBinLabel(3,Form("#LT#LT%s(n(#phi_{1}-#phi_{2}-#phi_{3}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAPro[sc]->GetXaxis())->SetBinLabel(4,Form("#LT#LT%s(n(2#phi_{1}-#phi_{2}))#GT#GT",sinCosFlag[sc].Data()));
    fIntFlowProfiles->Add(fIntFlowCorrectionTermsForNUAPro[sc]);
    // versus multiplicity:
    if(fCalculateCumulantsVsM)
    {
      TString correctionTermFlag[4] = {"(n(phi1))","(n(phi1+phi2))","(n(phi1-phi2-phi3))","(n(2phi1-phi2))"}; // to be improved - hardwired 4
      for(Int_t ci=0;ci<4;ci++) // correction term index (to be improved - hardwired 4)
      {
        TString intFlowCorrectionTermsForNUAVsMProName = "fIntFlowCorrectionTermsForNUAVsMPro";
        intFlowCorrectionTermsForNUAVsMProName += fAnalysisLabel->Data();
        fIntFlowCorrectionTermsForNUAVsMPro[sc][ci] = new TProfile(Form("%s: #LT#LT%s%s#GT#GT",intFlowCorrectionTermsForNUAVsMProName.Data(),sinCosFlag[sc].Data(),correctionTermFlag[ci].Data()),Form("#LT#LT%s%s#GT#GT vs M",sinCosFlag[sc].Data(),correctionTermFlag[ci].Data()),fnBinsMult,fMinMult,fMaxMult,"s");
        fIntFlowProfiles->Add(fIntFlowCorrectionTermsForNUAVsMPro[sc][ci]);
      }
    } // end of if(fCalculateCumulantsVsM)
  } // end of for(Int_t sc=0;sc<2;sc++)

  // d) Book histograms holding the final results:
  // average correlations <<2>>, <<4>>, <<6>> and <<8>> for all events (with correct errors!):
  TString intFlowCorrelationsHistName = "fIntFlowCorrelationsHist";
  intFlowCorrelationsHistName += fAnalysisLabel->Data();
  fIntFlowCorrelationsHist = new TH1D(intFlowCorrelationsHistName.Data(),"Average correlations for all events",4,0,4);
  fIntFlowCorrelationsHist->SetTickLength(-0.01,"Y");
  fIntFlowCorrelationsHist->SetMarkerStyle(25);
  fIntFlowCorrelationsHist->SetLabelSize(0.06);
  fIntFlowCorrelationsHist->SetLabelOffset(0.01,"Y");
  (fIntFlowCorrelationsHist->GetXaxis())->SetBinLabel(1,"#LT#LT2#GT#GT");
  (fIntFlowCorrelationsHist->GetXaxis())->SetBinLabel(2,"#LT#LT4#GT#GT");
  (fIntFlowCorrelationsHist->GetXaxis())->SetBinLabel(3,"#LT#LT6#GT#GT");
  (fIntFlowCorrelationsHist->GetXaxis())->SetBinLabel(4,"#LT#LT8#GT#GT");
  fIntFlowResults->Add(fIntFlowCorrelationsHist);
  // average correlations <<2>>, <<4>>, <<6>> and <<8>> for all events (with correct errors!) vs M:
  if(fCalculateCumulantsVsM)
  {
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      TString intFlowCorrelationsVsMHistName = "fIntFlowCorrelationsVsMHist";
      intFlowCorrelationsVsMHistName += fAnalysisLabel->Data();
      fIntFlowCorrelationsVsMHist[ci] = new TH1D(Form("%s, %s",intFlowCorrelationsVsMHistName.Data(),correlationFlag[ci].Data()),
                                                 Form("%s vs multiplicity",correlationFlag[ci].Data()),
                                                 fnBinsMult,fMinMult,fMaxMult);
      fIntFlowCorrelationsVsMHist[ci]->GetYaxis()->SetTitle(correlationFlag[ci].Data());
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowCorrelationsVsMHist[ci]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowCorrelationsVsMHist[ci]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowCorrelationsVsMHist[ci]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowResults->Add(fIntFlowCorrelationsVsMHist[ci]);
    } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
  } // end of if(fCalculateCumulantsVsM)
  // average all correlations for all events (with correct errors!):
  TString intFlowCorrelationsAllHistName = "fIntFlowCorrelationsAllHist";
  intFlowCorrelationsAllHistName += fAnalysisLabel->Data();
  fIntFlowCorrelationsAllHist = new TH1D(intFlowCorrelationsAllHistName.Data(),"Average correlations for all events",34,0,34);
  fIntFlowCorrelationsAllHist->SetTickLength(-0.01,"Y");
  fIntFlowCorrelationsAllHist->SetMarkerStyle(25);
  fIntFlowCorrelationsAllHist->SetLabelSize(0.03);
  fIntFlowCorrelationsAllHist->SetLabelOffset(0.01,"Y");
  // 2-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(1,"<<2>>_{n|n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(2,"<<2>>_{2n|2n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(3,"<<2>>_{3n|3n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(4,"<<2>>_{4n|4n}");
  // 3-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(6,"<<3>>_{2n|n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(7,"<<3>>_{3n|2n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(8,"<<3>>_{4n|2n,2n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(9,"<<3>>_{4n|3n,n}");
  // 4-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(11,"<<4>>_{n,n|n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(12,"<<4>>_{2n,n|2n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(13,"<<4>>_{2n,2n|2n,2n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(14,"<<4>>_{3n|n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(15,"<<4>>_{3n,n|3n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(16,"<<4>>_{3n,n|2n,2n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(17,"<<4>>_{4n|2n,n,n}");
  // 5-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(19,"<<5>>_{2n|n,n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(20,"<<5>>_{2n,2n|2n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(21,"<<5>>_{3n,n|2n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(22,"<<5>>_{4n|n,n,n,n}");
  // 6-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(24,"<<6>>_{n,n,n|n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(25,"<<6>>_{2n,n,n|2n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(26,"<<6>>_{2n,2n|n,n,n,n}");
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(27,"<<6>>_{3n,n|n,n,n,n}");
  // 7-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(29,"<<7>>_{2n,n,n|n,n,n,n}");
  // 8-p correlations:
  (fIntFlowCorrelationsAllHist->GetXaxis())->SetBinLabel(31,"<<8>>_{n,n,n,n|n,n,n,n}");
  fIntFlowResults->Add(fIntFlowCorrelationsAllHist);
  // average correction terms for non-uniform acceptance (with correct errors!):
  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    TString intFlowCorrectionTermsForNUAHistName = "fIntFlowCorrectionTermsForNUAHist";
    intFlowCorrectionTermsForNUAHistName += fAnalysisLabel->Data();
    fIntFlowCorrectionTermsForNUAHist[sc] = new TH1D(Form("%s: %s terms",intFlowCorrectionTermsForNUAHistName.Data(),sinCosFlag[sc].Data()),Form("Correction terms for non-uniform acceptance (%s terms)",sinCosFlag[sc].Data()),4,0,4);
    fIntFlowCorrectionTermsForNUAHist[sc]->SetTickLength(-0.01,"Y");
    fIntFlowCorrectionTermsForNUAHist[sc]->SetMarkerStyle(25);
    fIntFlowCorrectionTermsForNUAHist[sc]->SetLabelSize(0.05);
    fIntFlowCorrectionTermsForNUAHist[sc]->SetLabelOffset(0.01,"Y");
    (fIntFlowCorrectionTermsForNUAHist[sc]->GetXaxis())->SetBinLabel(1,Form("#LT#LT%s(n(#phi_{1}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAHist[sc]->GetXaxis())->SetBinLabel(2,Form("#LT#LT%s(n(#phi_{1}+#phi_{2}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAHist[sc]->GetXaxis())->SetBinLabel(3,Form("#LT#LT%s(n(#phi_{1}-#phi_{2}-#phi_{3}))#GT#GT",sinCosFlag[sc].Data()));
    (fIntFlowCorrectionTermsForNUAHist[sc]->GetXaxis())->SetBinLabel(4,Form("#LT#LT%s(n(2#phi_{1}-#phi_{2}))#GT#GT",sinCosFlag[sc].Data()));
    fIntFlowResults->Add(fIntFlowCorrectionTermsForNUAHist[sc]);
  } // end of for(Int_t sc=0;sc<2;sc++)
  // covariances (multiplied with weight dependent prefactor):
  TString intFlowCovariancesName = "fIntFlowCovariances";
  intFlowCovariancesName += fAnalysisLabel->Data();
  fIntFlowCovariances = new TH1D(intFlowCovariancesName.Data(),"Covariances (multiplied with weight dependent prefactor)",6,0,6);
  fIntFlowCovariances->SetLabelSize(0.04);
  fIntFlowCovariances->SetMarkerStyle(25);
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(1,"Cov(#LT2#GT,#LT4#GT)");
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(2,"Cov(#LT2#GT,#LT6#GT)");
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(3,"Cov(#LT2#GT,#LT8#GT)");
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(4,"Cov(#LT4#GT,#LT6#GT)");
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(5,"Cov(#LT4#GT,#LT8#GT)");
  (fIntFlowCovariances->GetXaxis())->SetBinLabel(6,"Cov(#LT6#GT,#LT8#GT)");
  fIntFlowResults->Add(fIntFlowCovariances);
  // sum of linear and quadratic event weights for <2>, <4>, <6> and <8>:
  TString intFlowSumOfEventWeightsName = "fIntFlowSumOfEventWeights";
  intFlowSumOfEventWeightsName += fAnalysisLabel->Data();
  for(Int_t power=0;power<2;power++)
  {
    fIntFlowSumOfEventWeights[power] = new TH1D(Form("%s: %s",intFlowSumOfEventWeightsName.Data(),powerFlag[power].Data()),Form("Sum of %s event weights for correlations",powerFlag[power].Data()),4,0,4);
    fIntFlowSumOfEventWeights[power]->SetLabelSize(0.04);
    fIntFlowSumOfEventWeights[power]->SetMarkerStyle(25);
    if(power == 0)
    {
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(1,"#sum_{i=1}^{N} w_{#LT2#GT}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(2,"#sum_{i=1}^{N} w_{#LT4#GT}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(3,"#sum_{i=1}^{N} w_{#LT6#GT}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(4,"#sum_{i=1}^{N} w_{#LT8#GT}");
    } else if (power == 1)
    {
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(1,"#sum_{i=1}^{N} w_{#LT2#GT}^{2}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(2,"#sum_{i=1}^{N} w_{#LT4#GT}^{2}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(3,"#sum_{i=1}^{N} w_{#LT6#GT}^{2}");
      (fIntFlowSumOfEventWeights[power]->GetXaxis())->SetBinLabel(4,"#sum_{i=1}^{N} w_{#LT8#GT}^{2}");
    }
    fIntFlowResults->Add(fIntFlowSumOfEventWeights[power]);
  }
  // sum of products of event weights for correlations <2>, <4>, <6> and <8>:
  TString intFlowSumOfProductOfEventWeightsName = "fIntFlowSumOfProductOfEventWeights";
  intFlowSumOfProductOfEventWeightsName += fAnalysisLabel->Data();
  fIntFlowSumOfProductOfEventWeights = new TH1D(intFlowSumOfProductOfEventWeightsName.Data(),"Sum of product of event weights for correlations",6,0,6);
  fIntFlowSumOfProductOfEventWeights->SetLabelSize(0.04);
  fIntFlowSumOfProductOfEventWeights->SetMarkerStyle(25);
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(1,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LT4#GT}");
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(2,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LT6#GT}");
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(3,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LT8#GT}");
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(4,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LT6#GT}");
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(5,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LT8#GT}");
  (fIntFlowSumOfProductOfEventWeights->GetXaxis())->SetBinLabel(6,"#sum_{i=1}^{N} w_{#LT6#GT} w_{#LT8#GT}");
  fIntFlowResults->Add(fIntFlowSumOfProductOfEventWeights);
  // final result for covariances of correlations (multiplied with weight dependent prefactor) versus M
  // [0=Cov(2,4),1=Cov(2,6),2=Cov(2,8),3=Cov(4,6),4=Cov(4,8),5=Cov(6,8)]:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowCovariancesVsMName = "fIntFlowCovariancesVsM";
    intFlowCovariancesVsMName += fAnalysisLabel->Data();
    TString covarianceFlag[6] = {"Cov(<2>,<4>)","Cov(<2>,<6>)","Cov(<2>,<8>)","Cov(<4>,<6>)","Cov(<4>,<8>)","Cov(<6>,<8>)"};
    for(Int_t ci=0;ci<6;ci++)
    {
      fIntFlowCovariancesVsM[ci] = new TH1D(Form("%s, %s",intFlowCovariancesVsMName.Data(),covarianceFlag[ci].Data()),
                                            Form("%s vs multiplicity",covarianceFlag[ci].Data()),
                                            fnBinsMult,fMinMult,fMaxMult);
      fIntFlowCovariancesVsM[ci]->GetYaxis()->SetTitle(covarianceFlag[ci].Data());
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowCovariancesVsM[ci]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowCovariancesVsM[ci]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowCovariancesVsM[ci]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowResults->Add(fIntFlowCovariancesVsM[ci]);
    }
  } // end of if(fCalculateCumulantsVsM)
  // sum of linear and quadratic event weights for <2>, <4>, <6> and <8> versus multiplicity
  // [0=sum{w_{<2>}},1=sum{w_{<4>}},2=sum{w_{<6>}},3=sum{w_{<8>}}][0=linear 1,1=quadratic]:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowSumOfEventWeightsVsMName = "fIntFlowSumOfEventWeightsVsM";
    intFlowSumOfEventWeightsVsMName += fAnalysisLabel->Data();
    TString sumFlag[2][4] = {{"#sum_{i=1}^{N} w_{<2>}","#sum_{i=1}^{N} w_{<4>}","#sum_{i=1}^{N} w_{<6>}","#sum_{i=1}^{N} w_{<8>}"},
      {"#sum_{i=1}^{N} w_{<2>}^{2}","#sum_{i=1}^{N} w_{<4>}^{2}","#sum_{i=1}^{N} w_{<6>}^{2}","#sum_{i=1}^{N} w_{<8>}^{2}"}};
    for(Int_t si=0;si<4;si++)
    {
      for(Int_t power=0;power<2;power++)
      {
        fIntFlowSumOfEventWeightsVsM[si][power] = new TH1D(Form("%s, %s",intFlowSumOfEventWeightsVsMName.Data(),sumFlag[power][si].Data()),
                                                           Form("%s vs multiplicity",sumFlag[power][si].Data()),
                                                           fnBinsMult,fMinMult,fMaxMult);
        fIntFlowSumOfEventWeightsVsM[si][power]->GetYaxis()->SetTitle(sumFlag[power][si].Data());
        if(fMultiplicityIs==AliFlowCommonConstants::kRP)
        {
          fIntFlowSumOfEventWeightsVsM[si][power]->GetXaxis()->SetTitle("# RPs");
        } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
        {
          fIntFlowSumOfEventWeightsVsM[si][power]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
        } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
        {
          fIntFlowSumOfEventWeightsVsM[si][power]->GetXaxis()->SetTitle("# POIs");
        }
        fIntFlowResults->Add(fIntFlowSumOfEventWeightsVsM[si][power]);
      } // end of for(Int_t power=0;power<2;power++)
    } // end of for(Int_t si=0;si<4;si++)
  } // end of if(fCalculateCumulantsVsM)
  // sum of products of event weights for correlations <2>, <4>, <6> and <8> vs M
  // [0=sum{w_{<2>}w_{<4>}},1=sum{w_{<2>}w_{<6>}},2=sum{w_{<2>}w_{<8>}},
  //  3=sum{w_{<4>}w_{<6>}},4=sum{w_{<4>}w_{<8>}},5=sum{w_{<6>}w_{<8>}}]:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowSumOfProductOfEventWeightsVsMName = "fIntFlowSumOfProductOfEventWeightsVsM";
    intFlowSumOfProductOfEventWeightsVsMName += fAnalysisLabel->Data();
    TString sopowFlag[6] = {"#sum_{i=1}^{N} w_{<2>} w_{<4>}","#sum_{i=1}^{N} w_{<2>} w_{<6>}","#sum_{i=1}^{N} w_{<2>} w_{<8>}",
      "#sum_{i=1}^{N} w_{<4>} w_{<6>}","#sum_{i=1}^{N} w_{<4>} w_{<8>}","#sum_{i=1}^{N} w_{<6>} w_{<8>}"};
    for(Int_t pi=0;pi<6;pi++)
    {
      fIntFlowSumOfProductOfEventWeightsVsM[pi] = new TH1D(Form("%s, %s",intFlowSumOfProductOfEventWeightsVsMName.Data(),sopowFlag[pi].Data()),
                                                           Form("%s versus multiplicity",sopowFlag[pi].Data()),
                                                           fnBinsMult,fMinMult,fMaxMult);
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowSumOfProductOfEventWeightsVsM[pi]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowSumOfProductOfEventWeightsVsM[pi]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowSumOfProductOfEventWeightsVsM[pi]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowSumOfProductOfEventWeightsVsM[pi]->GetYaxis()->SetTitle(sopowFlag[pi].Data());
      fIntFlowResults->Add(fIntFlowSumOfProductOfEventWeightsVsM[pi]);
    } // end of for(Int_t pi=0;pi<6;pi++)
  } // end of if(fCalculateCumulantsVsM)
  // covariances of NUA terms (multiplied with weight dependent prefactor):
  TString intFlowCovariancesNUAName = "fIntFlowCovariancesNUA";
  intFlowCovariancesNUAName += fAnalysisLabel->Data();
  fIntFlowCovariancesNUA = new TH1D(intFlowCovariancesNUAName.Data(),"Covariances for NUA (multiplied with weight dependent prefactor)",27,0,27);
  fIntFlowCovariancesNUA->SetLabelSize(0.04);
  fIntFlowCovariancesNUA->SetMarkerStyle(25);
  fIntFlowCovariancesNUA->GetXaxis()->SetLabelSize(0.02);
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(1,"Cov(<2>,<cos(#phi)>");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(2,"Cov(<2>,<sin(#phi)>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(3,"Cov(<cos(#phi)>,<sin(#phi)>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(4,"Cov(<2>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(5,"Cov(<2>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(6,"Cov(<2>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(7,"Cov(<2>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(8,"Cov(<4>,<cos(#phi)>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(9,"Cov(<4>,<sin(#phi)>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(10,"Cov(<4>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(11,"Cov(<4>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(12,"Cov(<4>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(13,"Cov(<4>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(14,"Cov(<cos(#phi)>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(15,"Cov(<cos(#phi)>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(16,"Cov(<cos(#phi)>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(17,"Cov(<cos(#phi)>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(18,"Cov(<sin(#phi)>,<cos(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(19,"Cov(<sin(#phi)>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(20,"Cov(<sin(#phi)>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(21,"Cov(<sin(#phi)>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(22,"Cov(<cos(#phi_{1}+#phi_{2})>,<sin(#phi_{1}+#phi_{2})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(23,"Cov(<cos(#phi_{1}+#phi_{2})>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(24,"Cov(<cos(#phi_{1}+#phi_{2})>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(25,"Cov(<sin(#phi_{1}+#phi_{2})>,<cos(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(26,"Cov(<sin(#phi_{1}+#phi_{2})>,<sin(#phi_{1}-#phi_{2}-#phi_{3})>)");
  (fIntFlowCovariancesNUA->GetXaxis())->SetBinLabel(27,"Cov(<cos(#phi_{1}-#phi_{2}-#phi_{3}>,<sin(#phi_{1}-#phi_{2}-#phi_{3}>)");
  fIntFlowResults->Add(fIntFlowCovariancesNUA);
  // sum of linear and quadratic event weights for NUA terms:
  TString intFlowSumOfEventWeightsNUAName = "fIntFlowSumOfEventWeightsNUA";
  intFlowSumOfEventWeightsNUAName += fAnalysisLabel->Data();
  for(Int_t sc=0;sc<2;sc++)
  {
    for(Int_t power=0;power<2;power++)
    {
      fIntFlowSumOfEventWeightsNUA[sc][power] = new TH1D(Form("%s: %s, %s",intFlowSumOfEventWeightsNUAName.Data(),powerFlag[power].Data(),sinCosFlag[sc].Data()),Form("Sum of %s event weights for NUA %s terms",powerFlag[power].Data(),sinCosFlag[sc].Data()),4,0,4); // to be improved - 4
      fIntFlowSumOfEventWeightsNUA[sc][power]->SetLabelSize(0.05);
      fIntFlowSumOfEventWeightsNUA[sc][power]->SetMarkerStyle(25);
      if(power == 0)
      {
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(1,Form("#sum_{i=1}^{N} w_{<%s(#phi)>}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(2,Form("#sum_{i=1}^{N} w_{<%s(#phi_{1}+#phi_{2})>}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(3,Form("#sum_{i=1}^{N} w_{<%s(#phi_{1}-#phi_{2}-#phi_{3})>}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(4,Form("#sum_{i=1}^{N} w_{<%s(2#phi_{1}-#phi_{2})>}",sinCosFlag[sc].Data()));
      } else if(power == 1)
      {
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(1,Form("#sum_{i=1}^{N} w_{<%s(#phi)>}^{2}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(2,Form("#sum_{i=1}^{N} w_{<%s(#phi_{1}+#phi_{2})>}^{2}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(3,Form("#sum_{i=1}^{N} w_{<%s(#phi_{1}-#phi_{2}-#phi_{3})>}^{2}",sinCosFlag[sc].Data()));
        (fIntFlowSumOfEventWeightsNUA[sc][power]->GetXaxis())->SetBinLabel(4,Form("#sum_{i=1}^{N} w_{<%s(2#phi_{1}-#phi_{2})>}^{2}",sinCosFlag[sc].Data()));
      }
      fIntFlowResults->Add(fIntFlowSumOfEventWeightsNUA[sc][power]);
    }
  }
  // sum of products of event weights for NUA terms:
  TString intFlowSumOfProductOfEventWeightsNUAName = "fIntFlowSumOfProductOfEventWeightsNUA";
  intFlowSumOfProductOfEventWeightsNUAName += fAnalysisLabel->Data();
  fIntFlowSumOfProductOfEventWeightsNUA = new TH1D(intFlowSumOfProductOfEventWeightsNUAName.Data(),"Sum of product of event weights for NUA terms",27,0,27);
  fIntFlowSumOfProductOfEventWeightsNUA->SetLabelSize(0.02);
  fIntFlowSumOfProductOfEventWeightsNUA->SetMarkerStyle(25);
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(1,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTcos(#phi)#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(2,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTsin(#phi)#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(3,"#sum_{i=1}^{N} w_{#LTcos(#phi)#GT} w_{#LTsin(#phi)#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(4,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTcos(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(5,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTsin(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(6,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(7,"#sum_{i=1}^{N} w_{#LT2#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(8,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTcos(#phi)#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(9,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTsin(#phi)#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(10,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTcos(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(11,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTsin(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(12,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(13,"#sum_{i=1}^{N} w_{#LT4#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(14,"#sum_{i=1}^{N} w_{#LTcos(#phi)#GT} w_{#LTcos(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(15,"#sum_{i=1}^{N} w_{#LTcos(#phi)#GT} w_{#LTsin(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(16,"#sum_{i=1}^{N} w_{#LTcos(#phi)#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(17,"#sum_{i=1}^{N} w_{#LTcos(#phi)#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(18,"#sum_{i=1}^{N} w_{#LTsin(#phi)#GT} w_{#LTcos(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(19,"#sum_{i=1}^{N} w_{#LTsin(#phi)#GT} w_{#LTsin(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(20,"#sum_{i=1}^{N} w_{#LTsin(#phi)#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(21,"#sum_{i=1}^{N} w_{#LTsin(#phi)#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(22,"#sum_{i=1}^{N} w_{#LTcos(#phi_{1}+#phi_{2})#GT} w_{#LTsin(#phi_{1}+#phi_{2})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(23,"#sum_{i=1}^{N} w_{#LTcos(#phi_{1}+#phi_{2})#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(24,"#sum_{i=1}^{N} w_{#LTcos(#phi_{1}+#phi_{2})#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(25,"#sum_{i=1}^{N} w_{#LTsin(#phi_{1}+#phi_{2})#GT} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(26,"#sum_{i=1}^{N} w_{#LTsin(#phi_{1}+#phi_{2})#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  (fIntFlowSumOfProductOfEventWeightsNUA->GetXaxis())->SetBinLabel(27,"#sum_{i=1}^{N} w_{#LTcos(#phi_{1}-#phi_{2}-#phi_{3})#GT} w_{#LTsin(#phi_{1}-#phi_{2}-#phi_{3})#GT}");
  fIntFlowResults->Add(fIntFlowSumOfProductOfEventWeightsNUA);
  // Final results for reference Q-cumulants:
  TString cumulantFlag[4] = {"QC{2}","QC{4}","QC{6}","QC{8}"};
  TString intFlowQcumulantsName = "fIntFlowQcumulants";
  intFlowQcumulantsName += fAnalysisLabel->Data();
  fIntFlowQcumulants = new TH1D(intFlowQcumulantsName.Data(),"Reference Q-cumulants",4,0,4);
  if(fPropagateErrorAlsoFromNIT)
  {
    fIntFlowQcumulants->SetTitle("Reference Q-cumulants (error from non-isotropic terms also propagated)");
  }
  fIntFlowQcumulants->SetLabelSize(0.05);
  fIntFlowQcumulants->SetMarkerStyle(25);
  for(Int_t b=0;b<4;b++)
  {
    (fIntFlowQcumulants->GetXaxis())->SetBinLabel(b+1,cumulantFlag[b].Data());
  }
  fIntFlowResults->Add(fIntFlowQcumulants);
  // Final results for reference Q-cumulants rebinned in M:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowQcumulantsRebinnedInMName = "fIntFlowQcumulantsRebinnedInM";
    intFlowQcumulantsRebinnedInMName += fAnalysisLabel->Data();
    fIntFlowQcumulantsRebinnedInM = new TH1D(intFlowQcumulantsRebinnedInMName.Data(),"Reference Q-cumulants rebinned in M",4,0,4);
    fIntFlowQcumulantsRebinnedInM->SetLabelSize(0.05);
    fIntFlowQcumulantsRebinnedInM->SetMarkerStyle(25);
    for(Int_t b=0;b<4;b++)
    {
      (fIntFlowQcumulantsRebinnedInM->GetXaxis())->SetBinLabel(b+1,cumulantFlag[b].Data());
    }
    fIntFlowResults->Add(fIntFlowQcumulantsRebinnedInM);
  } // end of if(fCalculateCumulantsVsM)
  // Ratio between error squared: with/without non-isotropic terms:
  TString intFlowQcumulantsErrorSquaredRatioName = "fIntFlowQcumulantsErrorSquaredRatio";
  intFlowQcumulantsErrorSquaredRatioName += fAnalysisLabel->Data();
  fIntFlowQcumulantsErrorSquaredRatio = new TH1D(intFlowQcumulantsErrorSquaredRatioName.Data(),"Error squared of reference Q-cumulants: #frac{with NUA terms}{without NUA terms}",4,0,4);
  fIntFlowQcumulantsErrorSquaredRatio->SetLabelSize(0.05);
  fIntFlowQcumulantsErrorSquaredRatio->SetMarkerStyle(25);
  for(Int_t b=0;b<4;b++)
  {
    (fIntFlowQcumulantsErrorSquaredRatio->GetXaxis())->SetBinLabel(b+1,cumulantFlag[b].Data());
  }
  fIntFlowResults->Add(fIntFlowQcumulantsErrorSquaredRatio);
  // final results for integrated Q-cumulants versus multiplicity:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowQcumulantsVsMName = "fIntFlowQcumulantsVsM";
    intFlowQcumulantsVsMName += fAnalysisLabel->Data();
    for(Int_t co=0;co<4;co++) // cumulant order
    {
      fIntFlowQcumulantsVsM[co] = new TH1D(Form("%s, %s",intFlowQcumulantsVsMName.Data(),cumulantFlag[co].Data()),
                                           Form("%s vs multiplicity",cumulantFlag[co].Data()),
                                           fnBinsMult,fMinMult,fMaxMult);
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowQcumulantsVsM[co]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowQcumulantsVsM[co]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowQcumulantsVsM[co]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowQcumulantsVsM[co]->GetYaxis()->SetTitle(cumulantFlag[co].Data());
      fIntFlowResults->Add(fIntFlowQcumulantsVsM[co]);
    } // end of for(Int_t co=0;co<4;co++) // cumulant order
  } // end of if(fCalculateCumulantsVsM)
  // final integrated flow estimates from Q-cumulants:
  TString flowFlag[4] = {Form("v_{%d}{2,QC}",fHarmonic),Form("v_{%d}{4,QC}",fHarmonic),Form("v_{%d}{6,QC}",fHarmonic),Form("v_{%d}{8,QC}",fHarmonic)};
  TString intFlowName = "fIntFlow";
  intFlowName += fAnalysisLabel->Data();
  // integrated flow from Q-cumulants:
  fIntFlow = new TH1D(intFlowName.Data(),"Reference flow estimates from Q-cumulants",4,0,4);
  fIntFlow->SetLabelSize(0.05);
  fIntFlow->SetMarkerStyle(25);
  for(Int_t b=0;b<4;b++)
  {
    (fIntFlow->GetXaxis())->SetBinLabel(b+1,flowFlag[b].Data());
  }
  fIntFlowResults->Add(fIntFlow);
  // Reference flow vs M rebinned in one huge bin:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowRebinnedInMName = "fIntFlowRebinnedInM";
    intFlowRebinnedInMName += fAnalysisLabel->Data();
    fIntFlowRebinnedInM = new TH1D(intFlowRebinnedInMName.Data(),"Reference flow estimates from Q-cumulants (rebinned in M)",4,0,4);
    fIntFlowRebinnedInM->SetLabelSize(0.05);
    fIntFlowRebinnedInM->SetMarkerStyle(25);
    for(Int_t b=0;b<4;b++)
    {
      (fIntFlowRebinnedInM->GetXaxis())->SetBinLabel(b+1,flowFlag[b].Data());
    }
    fIntFlowResults->Add(fIntFlowRebinnedInM);
  }
  // integrated flow from Q-cumulants: versus multiplicity:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowVsMName = "fIntFlowVsM";
    intFlowVsMName += fAnalysisLabel->Data();
    for(Int_t co=0;co<4;co++) // cumulant order
    {
      fIntFlowVsM[co] = new TH1D(Form("%s, %s",intFlowVsMName.Data(),flowFlag[co].Data()),
                                 Form("%s vs multiplicity",flowFlag[co].Data()),
                                 fnBinsMult,fMinMult,fMaxMult);
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowVsM[co]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowVsM[co]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowVsM[co]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowVsM[co]->GetYaxis()->SetTitle(flowFlag[co].Data());
      fIntFlowResults->Add(fIntFlowVsM[co]);
    } // end of for(Int_t co=0;co<4;co++) // cumulant order
  } // end of if(fCalculateCumulantsVsM)
  // quantifying detector effects effects to correlations:
  TString intFlowDetectorBiasName = "fIntFlowDetectorBias";
  intFlowDetectorBiasName += fAnalysisLabel->Data();
  fIntFlowDetectorBias = new TH1D(intFlowDetectorBiasName.Data(),"Quantifying detector bias",4,0,4);
  fIntFlowDetectorBias->SetLabelSize(0.05);
  fIntFlowDetectorBias->SetMarkerStyle(25);
  for(Int_t ci=0;ci<4;ci++)
  {
    (fIntFlowDetectorBias->GetXaxis())->SetBinLabel(ci+1,Form("#frac{corrected}{measured} %s",cumulantFlag[ci].Data()));
  }
  fIntFlowResults->Add(fIntFlowDetectorBias);
  // quantifying detector effects to correlations versus multiplicity:
  if(fCalculateCumulantsVsM)
  {
    TString intFlowDetectorBiasVsMName = "fIntFlowDetectorBiasVsM";
    intFlowDetectorBiasVsMName += fAnalysisLabel->Data();
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      fIntFlowDetectorBiasVsM[ci] = new TH1D(Form("%s for %s",intFlowDetectorBiasVsMName.Data(),cumulantFlag[ci].Data()),
                                             Form("Quantifying detector bias for %s vs multiplicity",cumulantFlag[ci].Data()),
                                             fnBinsMult,fMinMult,fMaxMult);
      if(fMultiplicityIs==AliFlowCommonConstants::kRP)
      {
        fIntFlowDetectorBiasVsM[ci]->GetXaxis()->SetTitle("# RPs");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
      {
        fIntFlowDetectorBiasVsM[ci]->GetXaxis()->SetTitle("Reference multiplicity (from ESD)");
      } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
      {
        fIntFlowDetectorBiasVsM[ci]->GetXaxis()->SetTitle("# POIs");
      }
      fIntFlowDetectorBiasVsM[ci]->GetYaxis()->SetTitle("#frac{corrected}{measured}");
      fIntFlowResults->Add(fIntFlowDetectorBiasVsM[ci]);
    } // end of for(Int_t co=0;co<4;co++) // cumulant order
  } // end of if(fCalculateCumulantsVsM)

} // end of AliFlowAnalysisCRC::BookEverythingForIntegratedFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForControlHistograms()
{
  // Book all objects for control histograms.

  // a) Book profile to hold all flags for control histograms;
  // b) Book all control histograms.

  // a) Book profile to hold all flags for control histograms:
  TString controlHistogramsFlagsName = "fControlHistogramsFlags";
  controlHistogramsFlagsName += fAnalysisLabel->Data();
  fControlHistogramsFlags = new TProfile(controlHistogramsFlagsName.Data(),"Flags for Control Histograms",2,0,2);
  fControlHistogramsFlags->SetTickLength(-0.01,"Y");
  fControlHistogramsFlags->SetMarkerStyle(25);
  fControlHistogramsFlags->SetLabelSize(0.04);
  fControlHistogramsFlags->SetLabelOffset(0.02,"Y");
  fControlHistogramsFlags->SetStats(kFALSE);
  fControlHistogramsFlags->GetXaxis()->SetBinLabel(1,"fStoreControlHistograms");
  fControlHistogramsFlags->GetXaxis()->SetBinLabel(2,"fUseQvectorTerms");
  fControlHistogramsList->Add(fControlHistogramsFlags);

  if(!fStoreControlHistograms){return;}

  // b) Book all control histograms:
  //  b1) Correlation between # RPs and ref. mult. determined centrally:
  TString sCorrelationNoRPsVsRefMultName = "fCorrelationNoRPsVsRefMult";
  sCorrelationNoRPsVsRefMultName += fAnalysisLabel->Data();
  fCorrelationNoRPsVsRefMult = new TH2D(sCorrelationNoRPsVsRefMultName.Data(),"# RPs vs. Reference Multiplicity",fnBinsMult,fMinMult,fMaxMult,fnBinsMult,fMinMult,fMaxMult);
  fCorrelationNoRPsVsRefMult->SetTickLength(-0.01,"Y");
  fCorrelationNoRPsVsRefMult->SetLabelSize(0.04);
  fCorrelationNoRPsVsRefMult->SetLabelOffset(0.02,"Y");
  fCorrelationNoRPsVsRefMult->SetStats(kTRUE);
  fCorrelationNoRPsVsRefMult->GetXaxis()->SetTitle("# RPs");
  fCorrelationNoRPsVsRefMult->GetYaxis()->SetTitle("Reference Multiplicity");
  fControlHistogramsList->Add(fCorrelationNoRPsVsRefMult);
  //  b2) Correlation between # POIs and ref. mult. determined centrally:
  TString sCorrelationNoPOIsVsRefMultName = "fCorrelationNoPOIsVsRefMult";
  sCorrelationNoPOIsVsRefMultName += fAnalysisLabel->Data();
  fCorrelationNoPOIsVsRefMult = new TH2D(sCorrelationNoPOIsVsRefMultName.Data(),"# POIs vs. Reference Multiplicity",fnBinsMult,fMinMult,fMaxMult,fnBinsMult,fMinMult,fMaxMult);
  fCorrelationNoPOIsVsRefMult->SetTickLength(-0.01,"Y");
  fCorrelationNoPOIsVsRefMult->SetLabelSize(0.04);
  fCorrelationNoPOIsVsRefMult->SetLabelOffset(0.02,"Y");
  fCorrelationNoPOIsVsRefMult->SetStats(kTRUE);
  fCorrelationNoPOIsVsRefMult->GetXaxis()->SetTitle("# POIs");
  fCorrelationNoPOIsVsRefMult->GetYaxis()->SetTitle("Reference Multiplicity");
  fControlHistogramsList->Add(fCorrelationNoPOIsVsRefMult);
  //  b3) Correlation between # RPs and # POIs:
  TString sCorrelationNoRPsVsNoPOIsName = "fCorrelationNoRPsVsNoPOIs";
  sCorrelationNoRPsVsNoPOIsName += fAnalysisLabel->Data();
  fCorrelationNoRPsVsNoPOIs = new TH2D(sCorrelationNoRPsVsNoPOIsName.Data(),"# RPs vs. # POIs",fnBinsMult,fMinMult,fMaxMult,fnBinsMult,fMinMult,fMaxMult);
  fCorrelationNoRPsVsNoPOIs->SetTickLength(-0.01,"Y");
  fCorrelationNoRPsVsNoPOIs->SetLabelSize(0.04);
  fCorrelationNoRPsVsNoPOIs->SetLabelOffset(0.02,"Y");
  fCorrelationNoRPsVsNoPOIs->SetStats(kTRUE);
  fCorrelationNoRPsVsNoPOIs->GetXaxis()->SetTitle("# RPs");
  fCorrelationNoRPsVsNoPOIs->GetYaxis()->SetTitle("# POIs");
  fControlHistogramsList->Add(fCorrelationNoRPsVsNoPOIs);
  // b4) <2>, <4>, <6> and <8> vs multiplicity (#RPs, #POIs or external):
  TString sCorrelation[4] = {"#LT2#GT","#LT4#GT","#LT6#GT","#LT8#GT"};
  TString sMultiplicity = "";
  if(fMultiplicityIs==AliFlowCommonConstants::kRP)
  {
    sMultiplicity = "# RPs";
  } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
  {
    sMultiplicity = "Reference multiplicity (from ESD)";
  } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
  {
    sMultiplicity = "# POIs";
  }
  for(Int_t ci=0;ci<4;ci++)
  {
    fCorrelation2468VsMult[ci] = new TH2D(Form("%s vs M",sCorrelation[ci].Data()),Form("%s vs M",sCorrelation[ci].Data()),fnBinsMult,fMinMult,fMaxMult,fnBinsForCorrelations,fMinValueOfCorrelation[ci],fMaxValueOfCorrelation[ci]);
    fCorrelation2468VsMult[ci]->SetTickLength(-0.01,"Y");
    fCorrelation2468VsMult[ci]->SetLabelSize(0.04);
    fCorrelation2468VsMult[ci]->SetLabelOffset(0.02,"Y");
    fCorrelation2468VsMult[ci]->SetStats(kTRUE);
    fCorrelation2468VsMult[ci]->GetXaxis()->SetTitle(sMultiplicity.Data());
    fCorrelation2468VsMult[ci]->GetYaxis()->SetTitle(sCorrelation[ci].Data());
    fControlHistogramsList->Add(fCorrelation2468VsMult[ci]);
  } // end of for(Int_t ci=0;ci<4;ci++)
  // b5) <2><4>, <2><6>, <2><8>, <4><6> etc. vs multiplicity (#RPs, #POIs or external):
  TString sCorrelationProduct[1] = {"#LT2#GT#LT4#GT"}; // TBI: add the other ones when needed first time
  for(Int_t cpi=0;cpi<1;cpi++) // TBI: hardwired 1
  {
    fCorrelationProduct2468VsMult[cpi] = new TH2D(Form("%s vs M",sCorrelationProduct[cpi].Data()),Form("%s vs M",sCorrelationProduct[cpi].Data()),fnBinsMult,fMinMult,fMaxMult,fnBinsForCorrelations,fMinValueOfCorrelationProduct[cpi],fMaxValueOfCorrelationProduct[cpi]);
    fCorrelationProduct2468VsMult[cpi]->SetTickLength(-0.01,"Y");
    fCorrelationProduct2468VsMult[cpi]->SetLabelSize(0.04);
    fCorrelationProduct2468VsMult[cpi]->SetLabelOffset(0.02,"Y");
    fCorrelationProduct2468VsMult[cpi]->SetStats(kTRUE);
    fCorrelationProduct2468VsMult[cpi]->GetXaxis()->SetTitle(sMultiplicity.Data());
    fCorrelationProduct2468VsMult[cpi]->GetYaxis()->SetTitle(sCorrelationProduct[cpi].Data());
    fControlHistogramsList->Add(fCorrelationProduct2468VsMult[cpi]);
  } // end of for(Int_t cpi=0;cpi<4;cpi++)
  // b6) |Qn|^2/M, |Q2n|^2/M, |Qn|^4/(M(2M-1)), Re[Q2nQn^*Qn^*]/M, ... vs multiplicity (#RPs, #POIs or external)
  if(fUseQvectorTerms)
  {
    TString sQvectorTerms[4] = {"#frac{|Q_{n}|^{2}}{M}","#frac{|Q_{2n}|^{2}}{M}","#frac{|Q_{n}|^{4}}{M(2M-1)}","#frac{Re[Q_{2n}Q_{n}^{*}Q_{n}^{*}]}{M^{3/2}}"}; // TBI: add the other ones when needed first time
    for(Int_t qvti=0;qvti<4;qvti++) // TBI: hardwired 4
    {
      fQvectorTermsVsMult[qvti] = new TH2D(Form("%s vs M",sQvectorTerms[qvti].Data()),Form("%s vs M",sQvectorTerms[qvti].Data()),fnBinsMult,fMinMult,fMaxMult,fnBinsForCorrelations,fMinValueOfQvectorTerms[qvti],fMaxValueOfQvectorTerms[qvti]);
      fQvectorTermsVsMult[qvti]->SetTickLength(-0.01,"Y");
      fQvectorTermsVsMult[qvti]->SetLabelSize(0.04);
      fQvectorTermsVsMult[qvti]->SetLabelOffset(0.02,"Y");
      fQvectorTermsVsMult[qvti]->SetStats(kTRUE);
      fQvectorTermsVsMult[qvti]->GetXaxis()->SetTitle(sMultiplicity.Data());
      fQvectorTermsVsMult[qvti]->GetYaxis()->SetTitle(sQvectorTerms[qvti].Data());
      fControlHistogramsList->Add(fQvectorTermsVsMult[qvti]);
    } // end of for(Int_t qvti=0;qvti<4;qvti++)
  } // end of if(fUseQvectorTerms)

} // end of void AliFlowAnalysisCRC::BookEverythingForControlHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForBootstrap()
{
  // Book all objects needed for bootstrap.

  // a) Book profile to hold all flags for bootstrap;
  // b) Book local random generator;
  // c) Book all bootstrap objects;
  // d) Book all bootstrap objects 'vs M'.

  // a) Book profile to hold all flags for bootstrap;
  TString bootstrapFlagsName = "fBootstrapFlags";
  bootstrapFlagsName += fAnalysisLabel->Data();
  fBootstrapFlags = new TProfile(bootstrapFlagsName.Data(),"Flags for bootstrap",3,0,3);
  fBootstrapFlags->SetTickLength(-0.01,"Y");
  fBootstrapFlags->SetMarkerStyle(25);
  fBootstrapFlags->SetLabelSize(0.04);
  fBootstrapFlags->SetLabelOffset(0.02,"Y");
  fBootstrapFlags->SetStats(kFALSE);
  fBootstrapFlags->GetXaxis()->SetBinLabel(1,"fUseBootstrap");
  fBootstrapFlags->GetXaxis()->SetBinLabel(2,"fUseBootstrapVsM");
  fBootstrapFlags->GetXaxis()->SetBinLabel(3,"fnSubsamples");
  fBootstrapList->Add(fBootstrapFlags);

  // c) Book all bootstrap objects:
  TString correlationFlag[4] = {"#LT#LT2#GT#GT","#LT#LT4#GT#GT","#LT#LT6#GT#GT","#LT#LT8#GT#GT"};
  TString cumulantFlag[4] = {"QC{2}","QC{4}","QC{6}","QC{8}"};
  if(fUseBootstrap)
  {
    // ....
    TString bootstrapCorrelationsName = "fBootstrapCorrelations";
    bootstrapCorrelationsName += fAnalysisLabel->Data();
    fBootstrapCorrelations = new TProfile2D(bootstrapCorrelationsName.Data(),"Bootstrap Correlations",4,0.,4.,fnSubsamples,0,fnSubsamples); // x-axis => <2>, <4>, <6>, <8>; y-axis => subsample #
    fBootstrapCorrelations->SetStats(kFALSE);
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      fBootstrapCorrelations->GetXaxis()->SetBinLabel(ci+1,correlationFlag[ci].Data());
    } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    for(Int_t ss=0;ss<fnSubsamples;ss++)
    {
      fBootstrapCorrelations->GetYaxis()->SetBinLabel(ss+1,Form("#%d",ss));
    } // end of for(Int_t ss=0;ss<fnSubsamples;ss++)
    fBootstrapProfilesList->Add(fBootstrapCorrelations);
    // ....
    TString bootstrapCumulantsName = "fBootstrapCumulants";
    bootstrapCumulantsName += fAnalysisLabel->Data();
    fBootstrapCumulants = new TH2D(bootstrapCumulantsName.Data(),"Bootstrap Cumulants",4,0.,4.,fnSubsamples,0,fnSubsamples); // x-axis => QC{2}, QC{4}, QC{6}, QC{8}; y-axis => subsample #
    fBootstrapCumulants->SetStats(kFALSE);
    for(Int_t co=0;co<4;co++) // cumulant order
    {
      fBootstrapCumulants->GetXaxis()->SetBinLabel(co+1,cumulantFlag[co].Data());
    } // end of for(Int_t co=0;co<4;co++) // cumulant order
    for(Int_t ss=0;ss<fnSubsamples;ss++)
    {
      fBootstrapCumulants->GetYaxis()->SetBinLabel(ss+1,Form("#%d",ss));
    } // end of for(Int_t ss=0;ss<fnSubsamples;ss++)
    fBootstrapResultsList->Add(fBootstrapCumulants);
  } // end of if(fUseBootstrap)

  // d) Book all bootstrap objects 'vs M':
  TString sMultiplicity = "";
  if(fMultiplicityIs==AliFlowCommonConstants::kRP)
  {
    sMultiplicity = "# RPs";
  } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
  {
    sMultiplicity = "Reference multiplicity (from ESD)";
  } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
  {
    sMultiplicity = "# POIs";
  }
  if(fUseBootstrapVsM)
  {
    // ....
    TString bootstrapCorrelationsVsMName = "fBootstrapCorrelationsVsM";
    bootstrapCorrelationsVsMName += fAnalysisLabel->Data();
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      fBootstrapCorrelationsVsM[ci] = new TProfile2D(Form("%s, %s",bootstrapCorrelationsVsMName.Data(),correlationFlag[ci].Data()),
                                                     Form("Bootstrap Correlations Vs. M, %s",correlationFlag[ci].Data()),
                                                     fnBinsMult,fMinMult,fMaxMult,fnSubsamples,0,fnSubsamples); // index => <2>, <4>, <6>, <8>; x-axis => multiplicity; y-axis => subsample #
      fBootstrapCorrelationsVsM[ci]->SetStats(kFALSE);
      fBootstrapCorrelationsVsM[ci]->GetXaxis()->SetTitle(sMultiplicity.Data());
      for(Int_t ss=0;ss<fnSubsamples;ss++)
      {
        fBootstrapCorrelationsVsM[ci]->GetYaxis()->SetBinLabel(ss+1,Form("#%d",ss));
      } // end of for(Int_t ss=0;ss<fnSubsamples;ss++)
      fBootstrapProfilesList->Add(fBootstrapCorrelationsVsM[ci]);
    } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    // ....
    TString bootstrapCumulantsVsMName = "fBootstrapCumulantsVsM";
    bootstrapCumulantsVsMName += fAnalysisLabel->Data();
    for(Int_t co=0;co<4;co++) // cumulant order
    {
      fBootstrapCumulantsVsM[co] = new TH2D(Form("%s, %s",bootstrapCumulantsVsMName.Data(),cumulantFlag[co].Data()),
                                            Form("Bootstrap Cumulants Vs. M, %s",cumulantFlag[co].Data()),
                                            fnBinsMult,fMinMult,fMaxMult,fnSubsamples,0,fnSubsamples); // index => <2>, <4>, <6>, <8>; x-axis => multiplicity; y-axis => subsample #
      fBootstrapCumulantsVsM[co]->SetStats(kFALSE);
      fBootstrapCumulantsVsM[co]->GetXaxis()->SetTitle(sMultiplicity.Data());
      for(Int_t ss=0;ss<fnSubsamples;ss++)
      {
        fBootstrapCumulantsVsM[co]->GetYaxis()->SetBinLabel(ss+1,Form("#%d",ss));
      } // end of for(Int_t ss=0;ss<fnSubsamples;ss++)
      fBootstrapResultsList->Add(fBootstrapCumulantsVsM[co]);
    } // end of for(Int_t co=0;co<4;co++) // correlation index
  } // end of if(fUseBootstrapVsM)

} // end of void AliFlowAnalysisCRC::BookEverythingForBootstrap()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForMixedHarmonics()
{
  // Book all objects for mixed harmonics.

  // a) Book profile to hold all flags for mixed harmonics;
  // b) Book all objects in TList fMixedHarmonicsProfiles;
  // c) Book all objects in TList fMixedHarmonicsResults;
  // d) Book all objects in TList fMixedHarmonicsErrorPropagation.

  // a) Book profile to hold all flags for mixed harmonics:
  TString mixedHarmonicsFlagsName = "fMixedHarmonicsFlags";
  mixedHarmonicsFlagsName += fAnalysisLabel->Data();
  fMixedHarmonicsFlags = new TProfile(mixedHarmonicsFlagsName.Data(),"Flags for Mixed Harmonics",4,0,4);
  fMixedHarmonicsFlags->SetTickLength(-0.01,"Y");
  fMixedHarmonicsFlags->SetMarkerStyle(25);
  fMixedHarmonicsFlags->SetLabelSize(0.04);
  fMixedHarmonicsFlags->SetLabelOffset(0.02,"Y");
  fMixedHarmonicsFlags->SetStats(kFALSE);
  fMixedHarmonicsFlags->GetXaxis()->SetBinLabel(1,"Calculate Mixed Harmonics");
  fMixedHarmonicsFlags->GetXaxis()->SetBinLabel(2,"Generic Harmonic");
  fMixedHarmonicsFlags->GetXaxis()->SetBinLabel(3,"Calculate vs Multiplicity");
  fMixedHarmonicsFlags->GetXaxis()->SetBinLabel(4,"Multiplicity Weight");
  fMixedHarmonicsList->Add(fMixedHarmonicsFlags);

  if(!fCalculateMixedHarmonics){return;}

  // b) Book all objects in TList fMixedHarmonicsProfiles:
  //  b1) 2-p correlations:
  TString s2pCorrelationsName = "f2pCorrelations";
  s2pCorrelationsName += fAnalysisLabel->Data();
  f2pCorrelations = new TProfile(s2pCorrelationsName.Data(),Form("2-particle correlations (n = %d)",fHarmonic),6,0,6,"s");
  f2pCorrelations->SetTickLength(-0.01,"Y");
  f2pCorrelations->SetMarkerStyle(25);
  f2pCorrelations->SetLabelSize(0.04);
  f2pCorrelations->SetLabelOffset(0.02,"Y");
  f2pCorrelations->SetStats(kFALSE);
  f2pCorrelations->Sumw2();
  f2pCorrelations->GetXaxis()->SetBinLabel(1,Form("#LT#LT2#GT#GT_{%dn|%dn}",1*fHarmonic,1*fHarmonic));
  f2pCorrelations->GetXaxis()->SetBinLabel(2,Form("#LT#LT2#GT#GT_{%dn|%dn}",2*fHarmonic,2*fHarmonic));
  f2pCorrelations->GetXaxis()->SetBinLabel(3,Form("#LT#LT2#GT#GT_{%dn|%dn}",3*fHarmonic,3*fHarmonic));
  f2pCorrelations->GetXaxis()->SetBinLabel(4,Form("#LT#LT2#GT#GT_{%dn|%dn}",4*fHarmonic,4*fHarmonic));
  f2pCorrelations->GetXaxis()->SetBinLabel(5,Form("#LT#LT2#GT#GT_{%dn|%dn}",5*fHarmonic,5*fHarmonic));
  f2pCorrelations->GetXaxis()->SetBinLabel(6,Form("#LT#LT2#GT#GT_{%dn|%dn}",6*fHarmonic,6*fHarmonic));
  fMixedHarmonicsProfiles->Add(f2pCorrelations);
  //  b2) 3-p correlations (3+6):
  TString s3pCorrelationsName = "f3pCorrelations";
  s3pCorrelationsName += fAnalysisLabel->Data();
  f3pCorrelations = new TProfile(s3pCorrelationsName.Data(),Form("3-particle correlations (n = %d)",fHarmonic),10,0,10,"s");
  f3pCorrelations->SetTickLength(-0.01,"Y");
  f3pCorrelations->SetMarkerStyle(25);
  f3pCorrelations->SetLabelSize(0.04);
  f3pCorrelations->SetLabelOffset(0.02,"Y");
  f3pCorrelations->SetStats(kFALSE);
  f3pCorrelations->Sumw2();
  // 3-p correlations sensitive to two distinct harmonics (3):
  f3pCorrelations->GetXaxis()->SetBinLabel(1,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(2,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(3,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(4,""); // empty
  // 3-p correlations sensitive to three distinct harmonics (6):
  f3pCorrelations->GetXaxis()->SetBinLabel(5,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,1*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(6,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,1*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(7,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,2*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(8,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,1*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(9,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,2*fHarmonic));
  f3pCorrelations->GetXaxis()->SetBinLabel(10,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicsProfiles->Add(f3pCorrelations);
  //  b3) 4-p correlations (6+15+2+10+8):
  TString s4pCorrelationsName = "f4pCorrelations";
  s4pCorrelationsName += fAnalysisLabel->Data();
  f4pCorrelations = new TProfile(s4pCorrelationsName.Data(),Form("4-particle correlations (n = %d)",fHarmonic),45,0,45,"s");
  f4pCorrelations->SetTickLength(-0.01,"Y");
  f4pCorrelations->SetMarkerStyle(25);
  f4pCorrelations->SetLabelSize(0.03);
  f4pCorrelations->SetLabelOffset(0.02,"Y");
  f4pCorrelations->SetStats(kFALSE);
  f4pCorrelations->Sumw2();
  // "same harmonic" (6):
  f4pCorrelations->GetXaxis()->SetBinLabel(1,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(2,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(3,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(4,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(5,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(6,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,6*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(7,""); // empty
  // "standard candles" (15):
  f4pCorrelations->GetXaxis()->SetBinLabel(8,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(9,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(10,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(11,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(12,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(13,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(14,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(15,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(16,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(17,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(18,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,6*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(19,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(20,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(21,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,4*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(22,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,5*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(23,""); // empty
  // 4-p correlations sensitive to two distinct harmonics (2):
  f4pCorrelations->GetXaxis()->SetBinLabel(24,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(25,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(26,""); // empty
  // 4-p correlations sensitive to three distinct harmonics (10):
  f4pCorrelations->GetXaxis()->SetBinLabel(27,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(28,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(29,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(30,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(31,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(32,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(33,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(34,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(35,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,4*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(36,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,5*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(37,""); // empty
  // 4-p correlations sensitive to four distinct harmonics (8):
  f4pCorrelations->GetXaxis()->SetBinLabel(38,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(39,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(40,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(41,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(42,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,2*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(43,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(44,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,3*fHarmonic));
  f4pCorrelations->GetXaxis()->SetBinLabel(45,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicsProfiles->Add(f4pCorrelations);
  //  b3) 5-p correlations (30+9+30+11+3):
  TString s5pCorrelationsName = "f5pCorrelations";
  s5pCorrelationsName += fAnalysisLabel->Data();
  f5pCorrelations = new TProfile(s5pCorrelationsName.Data(),Form("5-particle correlations (n = %d)",fHarmonic),87,0,87,"s");
  f5pCorrelations->SetTickLength(-0.01,"Y");
  f5pCorrelations->SetMarkerStyle(25);
  f5pCorrelations->SetLabelSize(0.02);
  f5pCorrelations->SetLabelOffset(0.02,"Y");
  f5pCorrelations->SetStats(kFALSE);
  f5pCorrelations->Sumw2();
  // "standard candles" (30):
  f5pCorrelations->GetXaxis()->SetBinLabel(1,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(2,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(3,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(4,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(5,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(6,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(7,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(8,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(9,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(10,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(11,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(12,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(13,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(14,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(15,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(16,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(17,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(18,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(19,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(20,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(21,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(22,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(23,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(24,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(25,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(26,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(27,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(28,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(29,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(30,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,4*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(31,""); // empty
  // 5-p correlations sensitive to two distinct harmonics (9):
  f5pCorrelations->GetXaxis()->SetBinLabel(32,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(33,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(34,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(35,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(36,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(37,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(38,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(39,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(40,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(41,""); // empty
  // 5-p correlations sensitive to three distinct harmonics (30):
  f5pCorrelations->GetXaxis()->SetBinLabel(42,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(43,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(44,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(45,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(46,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(47,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(48,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(49,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(50,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(51,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(52,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(53,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(54,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(55,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(56,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(57,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(58,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(59,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(60,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(61,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(62,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(63,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(64,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(65,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(66,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(67,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,5*fHarmonic,5*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(68,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(69,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,5*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(70,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,4*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(71,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,5*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(72,""); // empty
  // 5-p correlations sensitive to four distinct harmonics (11):
  f5pCorrelations->GetXaxis()->SetBinLabel(73,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(74,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(75,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(76,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(77,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(78,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(79,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,5*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(80,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(81,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(82,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,5*fHarmonic,5*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(83,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(84,""); // empty
  // 5-p correlations sensitive to five distinct harmonics (3):
  f5pCorrelations->GetXaxis()->SetBinLabel(85,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(86,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,1*fHarmonic,5*fHarmonic,4*fHarmonic));
  f5pCorrelations->GetXaxis()->SetBinLabel(87,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicsProfiles->Add(f5pCorrelations);
  //  b4) 6-p correlations (??+??+??+??+??):
  TString s6pCorrelationsName = "f6pCorrelations";
  s6pCorrelationsName += fAnalysisLabel->Data();
  f6pCorrelations = new TProfile(s6pCorrelationsName.Data(),Form("6-particle correlations (n = %d)",fHarmonic),1,0.,1.);
  f6pCorrelations->SetTickLength(-0.01,"Y");
  f6pCorrelations->SetMarkerStyle(25);
  f6pCorrelations->SetLabelSize(0.02);
  f6pCorrelations->SetLabelOffset(0.02,"Y");
  f6pCorrelations->SetStats(kFALSE);
  f6pCorrelations->Sumw2();
  //fMixedHarmonicsProfiles->Add(f6pCorrelations); // TBI
  //  b5) 7-p correlations (??+??+??+??+??):
  TString s7pCorrelationsName = "f7pCorrelations";
  s7pCorrelationsName += fAnalysisLabel->Data();
  f7pCorrelations = new TProfile(s7pCorrelationsName.Data(),Form("7-particle correlations (n = %d)",fHarmonic),1,0.,1.);
  f7pCorrelations->SetTickLength(-0.01,"Y");
  f7pCorrelations->SetMarkerStyle(25);
  f7pCorrelations->SetLabelSize(0.02);
  f7pCorrelations->SetLabelOffset(0.02,"Y");
  f7pCorrelations->SetStats(kFALSE);
  f7pCorrelations->Sumw2();
  //fMixedHarmonicsProfiles->Add(f7pCorrelations); // TBI
  //  b6) 8-p correlations (??+??+??+??+??):
  TString s8pCorrelationsName = "f8pCorrelations";
  s8pCorrelationsName += fAnalysisLabel->Data();
  f8pCorrelations = new TProfile(s8pCorrelationsName.Data(),Form("8-particle correlations (n = %d)",fHarmonic),1,0.,1.);
  f8pCorrelations->SetTickLength(-0.01,"Y");
  f8pCorrelations->SetMarkerStyle(25);
  f8pCorrelations->SetLabelSize(0.02);
  f8pCorrelations->SetLabelOffset(0.02,"Y");
  f8pCorrelations->SetStats(kFALSE);
  f8pCorrelations->Sumw2();
  //fMixedHarmonicsProfiles->Add(f8pCorrelations); // TBI

  // c) Book all objects in TList fMixedHarmonicsResults:
  // QC{2}:
  f2pCumulants = f2pCorrelations->ProjectionX("f2pCumulants");
  f2pCumulants->SetTitle(Form("2-particle cumulants (n = %d)",fHarmonic));
  f2pCumulants->SetStats(kFALSE);
  f2pCumulants->SetMarkerStyle(kFullSquare);
  f2pCumulants->SetMarkerColor(kBlack);
  f2pCumulants->SetLineColor(kBlack);
  fMixedHarmonicsResults->Add(f2pCumulants);
  // QC{3}:
  f3pCumulants = f3pCorrelations->ProjectionX("f3pCumulants");
  f3pCumulants->SetTitle(Form("3-particle cumulants (n = %d)",fHarmonic));
  f3pCumulants->SetStats(kFALSE);
  f3pCumulants->SetMarkerStyle(kFullSquare);
  f3pCumulants->SetMarkerColor(kGreen+2);
  f3pCumulants->SetLineColor(kGreen+2);
  fMixedHarmonicsResults->Add(f3pCumulants);
  // QC{4}:
  f4pCumulants = f4pCorrelations->ProjectionX("f4pCumulants");
  f4pCumulants->SetTitle(Form("4-particle cumulants (n = %d)",fHarmonic));
  f4pCumulants->SetStats(kFALSE);
  f4pCumulants->SetMarkerStyle(kFullSquare);
  f4pCumulants->SetMarkerColor(kRed);
  f4pCumulants->SetLineColor(kRed);
  fMixedHarmonicsResults->Add(f4pCumulants);
  // QC{5}:
  f5pCumulants = f5pCorrelations->ProjectionX("f5pCumulants");
  f5pCumulants->SetTitle(Form("5-particle cumulants (n = %d)",fHarmonic));
  f5pCumulants->SetStats(kFALSE);
  f5pCumulants->SetMarkerStyle(kFullSquare);
  f5pCumulants->SetMarkerColor(kBlue);
  f5pCumulants->SetLineColor(kBlue);
  fMixedHarmonicsResults->Add(f5pCumulants);

  // d) Book all objects in TList fMixedHarmonicsErrorPropagation:
  // Sum of linear and quadratic event weights for mixed harmonics => [0=linear 1,1=quadratic]:
  TString mixedHarmonicEventWeightsName = "fMixedHarmonicEventWeights";
  mixedHarmonicEventWeightsName += fAnalysisLabel->Data();
  TString powerFlag[2] = {"linear","quadratic"};
  for(Int_t power=0;power<2;power++)
  {
    fMixedHarmonicEventWeights[power] = new TH1D(Form("%s: %s",mixedHarmonicEventWeightsName.Data(),powerFlag[power].Data()),Form("Sum of %s event weights for correlations",powerFlag[power].Data()),8,0.,8.);
    fMixedHarmonicEventWeights[power]->SetLabelSize(0.04);
    fMixedHarmonicEventWeights[power]->SetMarkerStyle(25);
    fMixedHarmonicEventWeights[power]->SetStats(kFALSE);
    if(power == 0)
    {
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(1,"#sum w_{#LT1#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(2,"#sum w_{#LT2#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(3,"#sum w_{#LT3#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(4,"#sum w_{#LT4#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(5,"#sum w_{#LT5#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(6,"#sum w_{#LT6#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(7,"#sum w_{#LT7#GT}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(8,"#sum w_{#LT8#GT}");
    } else if (power == 1)
    {
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(1,"#sum w_{#LT1#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(2,"#sum w_{#LT2#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(3,"#sum w_{#LT3#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(4,"#sum w_{#LT4#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(5,"#sum w_{#LT5#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(6,"#sum w_{#LT6#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(7,"#sum w_{#LT7#GT}^{2}");
      (fMixedHarmonicEventWeights[power]->GetXaxis())->SetBinLabel(8,"#sum w_{#LT8#GT}^{2}");
    }
    fMixedHarmonicsErrorPropagation->Add(fMixedHarmonicEventWeights[power]);
  } // end of for(Int_t power=0;power<2;power++)

  // Sums of products of event weights for mixed harmonics:
  TString mixedHarmonicProductOfEventWeightsName = "fMixedHarmonicProductOfEventWeights";
  mixedHarmonicProductOfEventWeightsName += fAnalysisLabel->Data();
  fMixedHarmonicProductOfEventWeights = new TH2D(mixedHarmonicProductOfEventWeightsName.Data(),"Sums of products of event weights",8,0.,8.,8,0.,8.);
  fMixedHarmonicProductOfEventWeights->SetStats(kFALSE);
  fMixedHarmonicProductOfEventWeights->GetXaxis()->SetLabelSize(0.05);
  fMixedHarmonicProductOfEventWeights->GetYaxis()->SetLabelSize(0.05);
  for(Int_t b=1;b<=8;b++)
  {
    fMixedHarmonicProductOfEventWeights->GetXaxis()->SetBinLabel(b,Form("w_{#LT%i#GT}",b));
    fMixedHarmonicProductOfEventWeights->GetYaxis()->SetBinLabel(b,Form("w_{#LT%i#GT}",b));
  }
  fMixedHarmonicsErrorPropagation->Add(fMixedHarmonicProductOfEventWeights);

  // Averages of products of mixed harmonics correlations:
  TString mixedHarmonicProductOfCorrelationsName = "fMixedHarmonicProductOfCorrelations";
  mixedHarmonicProductOfCorrelationsName += fAnalysisLabel->Data();
  fMixedHarmonicProductOfCorrelations = new TProfile2D(mixedHarmonicProductOfCorrelationsName.Data(),"Averages of products of mixed correlators",139,0.,139.,139,0.,139.);
  fMixedHarmonicProductOfCorrelations->Sumw2();
  fMixedHarmonicProductOfCorrelations->SetStats(kFALSE);
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetLabelSize(0.015);
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetLabelSize(0.015);
  // x-axis:
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(1,Form("#LT#LT2#GT#GT_{%dn|%dn}",1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(2,Form("#LT#LT2#GT#GT_{%dn|%dn}",2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(3,Form("#LT#LT2#GT#GT_{%dn|%dn}",3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(4,Form("#LT#LT2#GT#GT_{%dn|%dn}",4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(5,Form("#LT#LT2#GT#GT_{%dn|%dn}",5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(6,Form("#LT#LT2#GT#GT_{%dn|%dn}",6*fHarmonic,6*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(7,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(8,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(9,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(10,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(11,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(12,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(13,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(14,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(15,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(16,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(17,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(18,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(19,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(20,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(21,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,6*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(22,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(23,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(24,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(25,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(26,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(27,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(28,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(29,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(30,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(31,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(32,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,6*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(33,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(34,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(35,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(36,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(37,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(38,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(39,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(40,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(41,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(42,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(43,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(44,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(45,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(46,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(47,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(48,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(49,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(50,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(51,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(52,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(53,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(54,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(55,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(56,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(57,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(58,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(59,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(60,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(61,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(62,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(63,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(64,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(65,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(66,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(67,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(68,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(69,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(70,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(71,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(72,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(73,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(74,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(75,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(76,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(77,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(78,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(79,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(80,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(81,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(82,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(83,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(84,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(85,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(86,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(87,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(88,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(89,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(90,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(91,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(92,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(93,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(94,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(95,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(96,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(97,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(98,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(99,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(100,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(101,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(102,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(103,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(104,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(105,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(106,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(107,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(108,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(109,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(110,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(111,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(112,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(113,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(114,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(115,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(116,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(117,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(118,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(119,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(120,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(121,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(122,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(123,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(124,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(125,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(126,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(127,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(128,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(129,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(130,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(131,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(132,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(133,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(134,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(135,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(136,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(137,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(138,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,1*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetXaxis()->SetBinLabel(139,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  // y-axis:
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(1,Form("#LT#LT2#GT#GT_{%dn|%dn}",1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(2,Form("#LT#LT2#GT#GT_{%dn|%dn}",2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(3,Form("#LT#LT2#GT#GT_{%dn|%dn}",3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(4,Form("#LT#LT2#GT#GT_{%dn|%dn}",4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(5,Form("#LT#LT2#GT#GT_{%dn|%dn}",5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(6,Form("#LT#LT2#GT#GT_{%dn|%dn}",6*fHarmonic,6*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(7,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(8,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(9,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(10,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(11,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(12,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(13,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(14,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(15,Form("#LT#LT3#GT#GT_{%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(16,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(17,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(18,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(19,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(20,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(21,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,6*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(22,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",2*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(23,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(24,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(25,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(26,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(27,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(28,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(29,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(30,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(31,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(32,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,6*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(33,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(34,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(35,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(36,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(37,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(38,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(39,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(40,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(41,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(42,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(43,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(44,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(45,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(46,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(47,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(48,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(49,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(50,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(51,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(52,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(53,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(54,Form("#LT#LT4#GT#GT_{%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(55,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(56,Form("#LT#LT4#GT#GT_{%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(57,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(58,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(59,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(60,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(61,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(62,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(63,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(64,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(65,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(66,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(67,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(68,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(69,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(70,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(71,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(72,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(73,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,4*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(74,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(75,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(76,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,5*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(77,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(78,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(79,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(80,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,6*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(81,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,6*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(82,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(83,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,6*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(84,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(85,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(86,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,6*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(87,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(88,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(89,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(90,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(91,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(92,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(93,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(94,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(95,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(96,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,1*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(97,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(98,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(99,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,1*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(100,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",4*fHarmonic,1*fHarmonic,1*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(101,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(102,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(103,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",4*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(104,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(105,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,2*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(106,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(107,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(108,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,1*fHarmonic,4*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(109,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(110,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(111,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(112,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(113,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(114,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,5*fHarmonic,5*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(115,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(116,Form("#LT#LT5#GT#GT_{%dn|%dn,%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(117,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(118,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,5*fHarmonic,1*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(119,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(120,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,4*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(121,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,2*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(122,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,5*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(123,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,5*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(124,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,4*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(125,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,6*fHarmonic,5*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(126,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,2*fHarmonic,3*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(127,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,1*fHarmonic,1*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(128,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",5*fHarmonic,3*fHarmonic,4*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(129,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",5*fHarmonic,2*fHarmonic,1*fHarmonic,4*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(130,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,1*fHarmonic,3*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(131,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,4*fHarmonic,4*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(132,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,1*fHarmonic,1*fHarmonic,5*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(133,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,3*fHarmonic,5*fHarmonic,2*fHarmonic,2*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(134,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,5*fHarmonic,4*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(135,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,3*fHarmonic,1*fHarmonic,5*fHarmonic,5*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(136,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,6*fHarmonic,5*fHarmonic,4*fHarmonic,3*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(137,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,2*fHarmonic,4*fHarmonic,3*fHarmonic,1*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(138,Form("#LT#LT5#GT#GT_{%dn,%dn,%dn|%dn,%dn}",6*fHarmonic,2*fHarmonic,1*fHarmonic,5*fHarmonic,4*fHarmonic));
  fMixedHarmonicProductOfCorrelations->GetYaxis()->SetBinLabel(139,Form("#LT#LT5#GT#GT_{%dn,%dn|%dn,%dn,%dn}",6*fHarmonic,4*fHarmonic,5*fHarmonic,3*fHarmonic,2*fHarmonic));
  fMixedHarmonicsErrorPropagation->Add(fMixedHarmonicProductOfCorrelations);

} // end of void AliFlowAnalysisCRC::BookEverythingForMixedHarmonics()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForNestedLoops()
{
  // Initialize arrays of all objects relevant for calculations with nested loops.

  // integrated flow:
  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    fIntFlowDirectCorrectionTermsForNUA[sc] = NULL;
  }

  // differential flow:
  // correlations:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        fDiffFlowDirectCorrelations[t][pe][ci] = NULL;
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // correction terms for non-uniform acceptance:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti] = NULL;
        }
      }
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

  // other differential correlators:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t ci=0;ci<1;ci++) // correlator index
        {
          fOtherDirectDiffCorrelators[t][pe][sc][ci] = NULL;
        }
      }
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

} // end of void AliFlowAnalysisCRC::InitializeArraysForNestedLoops()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForMixedHarmonics()
{
  // Initialize arrays of all objects relevant for mixed harmonics.

  for(Int_t power=0;power<2;power++) // linear or quadratic
  {
    fMixedHarmonicEventWeights[power] = NULL;
  }

} // end of void AliFlowAnalysisCRC::InitializeArraysForMixedHarmonics()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForControlHistograms()
{
  // Initialize arrays of all objects relevant for control histograms.

  for(Int_t ci=0;ci<4;ci++) // correlation index
  {
    fCorrelation2468VsMult[ci] = NULL;
  }
  for(Int_t cpi=0;cpi<1;cpi++) // correlation product index TBI: hardwired 1
  {
    fCorrelationProduct2468VsMult[cpi] = NULL;
  }
  for(Int_t qwti=0;qwti<4;qwti++) // q-vector terms index TBI: hardwired 4
  {
    fQvectorTermsVsMult[qwti] = NULL;
  }

} // end of void AliFlowAnalysisCRC::InitializeArraysForControlHistograms()


//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForBootstrap()
{
  // Initialize arrays of all objects relevant for control histograms.

  for(Int_t ci=0;ci<4;ci++) // correlation index
  {
    fBootstrapCorrelationsVsM[ci] = NULL;
    fBootstrapCumulantsVsM[ci] = NULL;
  }

} // end of void AliFlowAnalysisCRC::InitializeArraysForBootstrap()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForNestedLoops()
{
  // Book all objects relevant for calculations with nested loops.

  TString sinCosFlag[2] = {"sin","cos"}; // to be improved (should I promote this to data members?)
  TString typeFlag[2] = {"RP","POI"}; // to be improved (should I promote this to data members?)
  TString ptEtaFlag[2] = {"p_{T}","#eta"}; // to be improved (should I promote this to data members?)
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"}; // to be improved (should I promote this to data members?)
  Double_t lowerPtEtaEdge[2] = {fPtMin+(fCrossCheckInPtBinNo-1)*fPtBinWidth,fEtaMin+(fCrossCheckInEtaBinNo-1)*fEtaBinWidth};
  Double_t upperPtEtaEdge[2] = {fPtMin+fCrossCheckInPtBinNo*fPtBinWidth,fEtaMin+fCrossCheckInEtaBinNo*fEtaBinWidth};

  TString evaluateNestedLoopsName = "fEvaluateNestedLoops";
  evaluateNestedLoopsName += fAnalysisLabel->Data();
  fEvaluateNestedLoops = new TProfile(evaluateNestedLoopsName.Data(),"Flags for nested loops",4,0,4);
  fEvaluateNestedLoops->SetLabelSize(0.03);
  fEvaluateNestedLoops->SetStats(kFALSE);
  (fEvaluateNestedLoops->GetXaxis())->SetBinLabel(1,"fEvaluateIntFlowNestedLoops");
  (fEvaluateNestedLoops->GetXaxis())->SetBinLabel(2,"fEvaluateDiffFlowNestedLoops");
  (fEvaluateNestedLoops->GetXaxis())->SetBinLabel(3,"fCrossCheckInPtBinNo");
  (fEvaluateNestedLoops->GetXaxis())->SetBinLabel(4,"fCrossCheckInEtaBinNo");
  fEvaluateNestedLoops->Fill(0.5,(Int_t)fEvaluateIntFlowNestedLoops);
  fEvaluateNestedLoops->Fill(1.5,(Int_t)fEvaluateDiffFlowNestedLoops);
  fEvaluateNestedLoops->Fill(2.5,fCrossCheckInPtBinNo);
  fEvaluateNestedLoops->Fill(3.5,fCrossCheckInEtaBinNo);
  fNestedLoopsList->Add(fEvaluateNestedLoops);
  // nested loops for integrated flow:
  if(fEvaluateIntFlowNestedLoops)
  {
    // correlations:
    TString intFlowDirectCorrelationsName = "fIntFlowDirectCorrelations";
    intFlowDirectCorrelationsName += fAnalysisLabel->Data();
    fIntFlowDirectCorrelations = new TProfile(intFlowDirectCorrelationsName.Data(),"Multiparticle correlations calculated with nested loops (for int. flow)",64,0,64,"s");
    fNestedLoopsList->Add(fIntFlowDirectCorrelations);
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    {
      TString intFlowExtraDirectCorrelationsName = "fIntFlowExtraDirectCorrelations";
      intFlowExtraDirectCorrelationsName += fAnalysisLabel->Data();
      fIntFlowExtraDirectCorrelations = new TProfile(intFlowExtraDirectCorrelationsName.Data(),"Extra multiparticle correlations calculated with nested loops (for int. flow)",100,0,100,"s");
      fNestedLoopsList->Add(fIntFlowExtraDirectCorrelations);
    } // end of if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    // correction terms for non-uniform acceptance:
    for(Int_t sc=0;sc<2;sc++) // sin or cos terms
    {
      TString intFlowDirectCorrectionTermsForNUAName = "fIntFlowDirectCorrectionTermsForNUA";
      intFlowDirectCorrectionTermsForNUAName += fAnalysisLabel->Data();
      fIntFlowDirectCorrectionTermsForNUA[sc] = new TProfile(Form("%s: %s terms",intFlowDirectCorrectionTermsForNUAName.Data(),sinCosFlag[sc].Data()),Form("Correction terms for non-uniform acceptance (%s terms)",sinCosFlag[sc].Data()),10,0,10,"s");
      fNestedLoopsList->Add(fIntFlowDirectCorrectionTermsForNUA[sc]);
    } // end of for(Int_t sc=0;sc<2;sc++)
    // Mixed harmonics:
    if(fCalculateMixedHarmonics)
    {
      TString mixedHarmonicsNestedLoopsName = "fMixedHarmonicsNestedLoops";
      mixedHarmonicsNestedLoopsName += fAnalysisLabel->Data();
      fMixedHarmonicsNestedLoops = new TProfile(mixedHarmonicsNestedLoopsName.Data(),"Mixed harmonics calculated with nested loops",200,0,200); // TBI hardwired 200
      fNestedLoopsList->Add(fMixedHarmonicsNestedLoops);
    } // end of if(fCalculateMixedHarmonics)
  } // end of if(fEvaluateIntFlowNestedLoops)

  // nested loops for differential flow:
  if(fEvaluateDiffFlowNestedLoops)
  {
    // reduced correlations:
    TString diffFlowDirectCorrelationsName = "fDiffFlowDirectCorrelations";
    diffFlowDirectCorrelationsName += fAnalysisLabel->Data();
    for(Int_t t=0;t<2;t++) // type: RP or POI
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
      {
        for(Int_t rci=0;rci<4;rci++) // reduced correlation index
        {
          // reduced correlations:
          fDiffFlowDirectCorrelations[t][pe][rci] = new TProfile(Form("%s, %s, %s, %s",diffFlowDirectCorrelationsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),Form("%s, %s, %s, %s",diffFlowDirectCorrelationsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),1,lowerPtEtaEdge[pe],upperPtEtaEdge[pe],"s");
          fDiffFlowDirectCorrelations[t][pe][rci]->SetXTitle(ptEtaFlag[pe].Data());
          fNestedLoopsList->Add(fDiffFlowDirectCorrelations[t][pe][rci]); // to be improved (add dedicated list to hold reduced correlations)
        } // end of for(Int_t rci=0;rci<4;rci++) // correlation index
      } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
    } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

    // correction terms for non-uniform acceptance:
    TString diffFlowDirectCorrectionTermsForNUAName = "fDiffFlowDirectCorrectionTermsForNUA";
    diffFlowDirectCorrectionTermsForNUAName += fAnalysisLabel->Data();
    for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
      {
        for(Int_t sc=0;sc<2;sc++) // sin or cos
        {
          for(Int_t cti=0;cti<9;cti++) // correction term index
          {
            fDiffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti] = new TProfile(Form("%s, %s, %s, %s, cti = %d",diffFlowDirectCorrectionTermsForNUAName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),Form("%s, %s, %s, %s, cti = %d",diffFlowDirectCorrectionTermsForNUAName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),1,lowerPtEtaEdge[pe],upperPtEtaEdge[pe],"s");
            fNestedLoopsList->Add(fDiffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti]);
          }
        }
      }
    }
    // other differential correlators:
    TString otherDirectDiffCorrelatorsName = "fOtherDirectDiffCorrelators";
    otherDirectDiffCorrelatorsName += fAnalysisLabel->Data();
    for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
      {
        for(Int_t sc=0;sc<2;sc++) // sin or cos
        {
          for(Int_t ci=0;ci<1;ci++) // correlator index
          {
            fOtherDirectDiffCorrelators[t][pe][sc][ci] = new TProfile(Form("%s, %s, %s, %s, ci = %d",otherDirectDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1),Form("%s, %s, %s, %s, ci = %d",otherDirectDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1),1,lowerPtEtaEdge[pe],upperPtEtaEdge[pe]);
            fNestedLoopsList->Add(fOtherDirectDiffCorrelators[t][pe][sc][ci]);
          }
        }
      }
    }
    // number of RPs and POIs in selected pt and eta bins for cross-checkings:
    TString noOfParticlesInBinName = "fNoOfParticlesInBin";
    fNoOfParticlesInBin = new TH1D(noOfParticlesInBinName.Data(),"Number of RPs and POIs in selected p_{T} and #eta bin",4,0,4);
    fNoOfParticlesInBin->GetXaxis()->SetBinLabel(1,"# of RPs in p_{T} bin");
    fNoOfParticlesInBin->GetXaxis()->SetBinLabel(2,"# of RPs in #eta bin");
    fNoOfParticlesInBin->GetXaxis()->SetBinLabel(3,"# of POIs in p_{T} bin");
    fNoOfParticlesInBin->GetXaxis()->SetBinLabel(4,"# of POIs in #eta bin");
    fNestedLoopsList->Add(fNoOfParticlesInBin);
  } // end of if(fEvaluateDiffFlowNestedLoops)

} // end of AliFlowAnalysisCRC::BookEverythingForNestedLoops()

//=========================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrelations()
{}

//=====================================================================================================

void AliFlowAnalysisCRC::CalculateMixedHarmonics()
{}

//===================================================================================================================

void AliFlowAnalysisCRC::CalculateCumulantsMixedHarmonics()
{}

//===================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowProductOfCorrelations()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowProductOfCorrectionTermsForNUA()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCovariancesIntFlow()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCovariancesNUAIntFlow()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCorrelationsIntFlow()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FillAverageMultiplicities(Int_t nRP)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCumulantsIntFlow()
{}

//================================================================================================================================

void AliFlowAnalysisCRC::CalculateCumulantsForBootstrap()
{}

//================================================================================================================================

void AliFlowAnalysisCRC::CalculateReferenceFlow()
{}

//================================================================================================================================

void AliFlowAnalysisCRC::FillCommonHistResultsIntFlow()
{}

//================================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrelationsUsingParticleWeights()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForIntFlow()
{
  // Initialize all arrays used to calculate integrated flow.

  for(Int_t sc=0;sc<2;sc++) // sin or cos terms
  {
    fIntFlowCorrectionTermsForNUAEBE[sc] = NULL;
    fIntFlowEventWeightForCorrectionTermsForNUAEBE[sc] = NULL;
    fIntFlowCorrectionTermsForNUAPro[sc] = NULL;
    fIntFlowCorrectionTermsForNUAHist[sc] = NULL;
    for(Int_t ci=0;ci<4;ci++) // correction term index (to be improved - hardwired 4)
    {
      fIntFlowCorrectionTermsForNUAVsMPro[sc][ci] = NULL;
    }
    for(Int_t power=0;power<2;power++) // linear or quadratic
    {
      fIntFlowSumOfEventWeightsNUA[sc][power] = NULL;
    }
  }
  for(Int_t power=0;power<2;power++) // linear or quadratic
  {
    fIntFlowSumOfEventWeights[power] = NULL;
  }
  for(Int_t i=0;i<4;i++) // print on the screen the final results (0=RF, 1=RP, 2=POI, 3=RF (rebbined in M))
  {
    fPrintFinalResults[i] = kTRUE;
  }
  for(Int_t ci=0;ci<4;ci++) // correlation index or cumulant order
  {
    fIntFlowCorrelationsVsMPro[ci] = NULL;
    fIntFlowSquaredCorrelationsVsMPro[ci] = NULL;
    fIntFlowCorrelationsVsMHist[ci] = NULL;
    fIntFlowQcumulantsVsM[ci] = NULL;
    fIntFlowVsM[ci] = NULL;
    fIntFlowDetectorBiasVsM[ci] = NULL;
    for(Int_t lc=0;lc<2;lc++)
    {
      fIntFlowSumOfEventWeightsVsM[ci][lc] = NULL;
    }
  }
  for(Int_t pi=0;pi<6;pi++) // product or covariance index
  {
    fIntFlowProductOfCorrelationsVsMPro[pi] = NULL;
    fIntFlowCovariancesVsM[pi] = NULL;
    fIntFlowSumOfProductOfEventWeightsVsM[pi] = NULL;
  }
  for(Int_t ci=0;ci<64;ci++) // correlation index for all correlations vs M profiles (to be improved - hardwired 64)
  {
    fIntFlowCorrelationsAllVsMPro[ci] = NULL;
  }

} // end of void AliFlowAnalysisCRC::InitializeArraysForIntFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForDiffFlow()
{
  // Initialize all arrays needed to calculate differential flow.
  //  a) Initialize lists holding profiles;
  //  b) Initialize lists holding histograms;
  //  c) Initialize event-by-event quantities;
  //  d) Initialize profiles;
  //  e) Initialize histograms holding final results.

  // a) Initialize lists holding profiles;
  for(Int_t t=0;t<2;t++) // type (RP, POI)
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      fDiffFlowCorrelationsProList[t][pe] = NULL;
      fDiffFlowProductOfCorrelationsProList[t][pe] = NULL;
      fDiffFlowCorrectionsProList[t][pe] = NULL;
    }
    // 2D:
    f2DDiffFlowCorrelationsProList[t] = NULL;
  }

  // b) Initialize lists holding histograms;
  for(Int_t t=0;t<2;t++) // type (RP, POI)
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      fDiffFlowCorrelationsHistList[t][pe] = NULL;
      for(Int_t power=0;power<2;power++)
      {
        fDiffFlowSumOfEventWeightsHistList[t][pe][power] = NULL;
      } // end of for(Int_t power=0;power<2;power++)
      fDiffFlowSumOfProductOfEventWeightsHistList[t][pe] = NULL;
      fDiffFlowCorrectionsHistList[t][pe] = NULL;
      fDiffFlowCovariancesHistList[t][pe] = NULL;
      fDiffFlowCumulantsHistList[t][pe] = NULL;
      fDiffFlowDetectorBiasHistList[t][pe] = NULL;
      fDiffFlowHistList[t][pe] = NULL;
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // enf of for(Int_t t=0;t<2;t++) // type (RP, POI)

  // c) Initialize event-by-event quantities:
  // 1D:
  for(Int_t t=0;t<3;t++) // type (RP, POI, POI&&RP)
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t m=0;m<4;m++) // multiple of harmonic
      {
        for(Int_t k=0;k<9;k++) // power of weight
        {
          fReRPQ1dEBE[t][pe][m][k] = NULL;
          fImRPQ1dEBE[t][pe][m][k] = NULL;
          fs1dEBE[t][pe][k] = NULL; // to be improved (this doesn't need to be within loop over m)
        }
      }
    }
  }
  // 1D:
  for(Int_t t=0;t<2;t++) // type (RP or POI)
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAEBE[t][pe][sc][cti] = NULL;
        }
      }
    }
  }
  // 2D:
  for(Int_t t=0;t<3;t++) // type (RP, POI, POI&&RP)
  {
    for(Int_t m=0;m<4;m++) // multiple of harmonic
    {
      for(Int_t k=0;k<9;k++) // power of weight
      {
        fReRPQ2dEBE[t][m][k] = NULL;
        fImRPQ2dEBE[t][m][k] = NULL;
        fs2dEBE[t][k] = NULL; // to be improved (this doesn't need to be within loop over m)
      }
    }
  }

  // d) Initialize profiles:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        fDiffFlowCorrelationsPro[t][pe][ci] = NULL;
        fDiffFlowSquaredCorrelationsPro[t][pe][ci] = NULL;
      } // end of for(Int_t ci=0;ci<4;ci++)
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=0;mci2<8;mci2++) // mixed correlation index
        {
          fDiffFlowProductOfCorrelationsPro[t][pe][mci1][mci2] = NULL;
        } // end of for(Int_t mci2=0;mci2<8;mci2++) // mixed correlation index
      } // end of for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      // correction terms for nua:
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAPro[t][pe][sc][cti] = NULL;
        }
      }
      // other differential correlators:
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t ci=0;ci<1;ci++) // correction term index
        {
          fOtherDiffCorrelators[t][pe][sc][ci] = NULL;
        }
      }
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      f2DDiffFlowCorrelationsPro[t][ci] = NULL;
    }
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

  // e) Initialize histograms holding final results.
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        fDiffFlowCorrelationsHist[t][pe][ci] = NULL;
        fDiffFlowCumulants[t][pe][ci] = NULL;
        fDiffFlowDetectorBias[t][pe][ci] = NULL;
        fDiffFlow[t][pe][ci] = NULL;
      } // end of for(Int_t ci=0;ci<4;ci++)
      for(Int_t covarianceIndex=0;covarianceIndex<5;covarianceIndex++)
      {
        fDiffFlowCovariances[t][pe][covarianceIndex] = NULL;
      } // end of for(Int_t covarianceIndex=0;covarianceIndex<5;covarianceIndex++)
      // correction terms for nua:
      for(Int_t sc=0;sc<2;sc++) // sin or cos terms
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAHist[t][pe][sc][cti] = NULL;
        }
      }
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      f2DDiffFlowCumulants[t][ci] = NULL;
      f2DDiffFlow[t][ci] = NULL;
    }
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

  // sum of event weights for reduced correlations:
  for(Int_t t=0;t<2;t++) // type = RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t p=0;p<2;p++) // power of weight is 1 or 2
      {
        for(Int_t ew=0;ew<4;ew++) // event weight index for reduced correlations
        {
          fDiffFlowSumOfEventWeights[t][pe][p][ew] = NULL;
        }
      }
    }
  }
  // product of event weights for both types of correlations:
  for(Int_t t=0;t<2;t++) // type = RP or POI
  {
    for(Int_t pe=0;pe<2;pe++) // pt or eta
    {
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=0;mci2<8;mci2++) // mixed correlation index
        {
          fDiffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2] = NULL;
        }
      }
    }
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForDiffFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeCostantsForCRC()
{
  // CRCPt
  fCRCPtnPtBin = 3;
  fCRCPtMinPt = 0.2;
  fCRCPtMaxPt = 5.0;
  fCRCPtwPtBin = (fCRCPtMaxPt-fCRCPtMinPt)/fCRCPtnPtBin;
  fCRCPtvarPtBins = new Double_t[4];
  Double_t bins[] = {0.2,0.4,0.8,5.0};
  for(Int_t r=0; r<4; r++) {
    fCRCPtvarPtBins[r] = bins[r];
  }

  fCRCPtnCenBin = 20;
  fCRCPtCenMin = 0.;
  fCRCPtCenMax = 100.;
  fCRCPtwCenBin = (fCRCPtCenMax-fCRCPtCenMin)/fCRCPtnCenBin;

  // fPtDiffNBins = 26;
  // fCRCPtBins = new Double_t[27];
  // Double_t PtBins[27] = {0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.,1.2,1.4,1.6,1.8,2.,2.33,2.66,3.,3.5,4.,5.,6.,8.,10.,14.,20.,30.,50.};
  // for(Int_t r=0; r<27; r++) {
  //   fCRCPtBins[r] = PtBins[r];
  // }

  fPtDiffNBins = 36;
  fCRCPtBins = new Double_t[37];
  Double_t PtBins[] = {0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.,1.25,1.5,1.75,2.,2.25,2.5,2.75,3.,3.25,3.5,3.75,4.,4.5,5.,5.5,6.,7.,8.,9.,10.,12.,14.,17.,20.,25.,30.,40.,50.};
  for(Int_t r=0; r<37; r++) {
    fCRCPtBins[r] = PtBins[r];
  }

  fZDCEPweightEbE = new Double_t[3];
  fZDCEPweightEbE[0]=1.;
  fZDCEPweightEbE[1]=1.;
  fZDCEPweightEbE[2]=1.;

  fCorrMap = new Double_t[90];
  Double_t CorrMap[90] = {3.560467e-01, 4.546940e-01, 5.517416e-01, 6.353035e-01, 7.213249e-01, 8.144493e-01, 8.919082e-01, 9.569955e-01, 1.030360e+00, 1.102777e+00, 1.156254e+00, 1.229825e+00, 1.281096e+00, 1.348774e+00, 1.394619e+00, 1.457919e+00, 1.491964e+00, 1.535202e+00, 1.590917e+00, 1.622521e+00, 1.630109e+00, 1.664196e+00, 1.690919e+00, 1.739245e+00, 1.775229e+00, 1.787735e+00, 1.829441e+00, 1.825088e+00, 1.844297e+00, 1.848143e+00, 1.858541e+00, 1.860540e+00, 1.908495e+00, 1.898985e+00, 1.894655e+00, 1.908905e+00, 1.885567e+00, 1.891935e+00, 1.883991e+00, 1.874601e+00, 1.878468e+00, 1.863729e+00, 1.854691e+00, 1.853367e+00, 1.834473e+00, 1.818142e+00, 1.803534e+00, 1.787149e+00, 1.790569e+00, 1.754662e+00, 1.728960e+00, 1.709801e+00, 1.668947e+00, 1.664165e+00, 1.619436e+00, 1.615641e+00, 1.555998e+00, 1.541695e+00, 1.520922e+00, 1.505968e+00, 1.452864e+00, 1.407158e+00, 1.380039e+00, 1.334520e+00, 1.281019e+00, 1.263069e+00, 1.231441e+00, 1.155737e+00, 1.138802e+00, 1.090618e+00, 1.060680e+00, 1.015759e+00, 9.835138e-01, 9.273367e-01, 9.013176e-01, 8.226471e-01, 7.811623e-01, 7.459602e-01, 6.798878e-01, 6.366282e-01, 6.528206e-01, 6.415005e-01, 5.730953e-01, 5.413170e-01, 5.330439e-01, 5.183582e-01, 4.493151e-01, 4.687033e-01, 3.770695e-01, 3.543272e-01};
  for(Int_t r=0; r<90; r++) {
    fCorrMap[r] = CorrMap[r];
  }

  fchisqVA = new Double_t[100];
  Double_t chisqVA[100] = {2.058204e-01, 2.678239e-01, 3.468365e-01, 4.378232e-01, 5.306461e-01, 6.300584e-01, 7.260945e-01, 8.247221e-01, 9.004370e-01, 9.930541e-01, 1.058070e+00, 1.136051e+00, 1.210349e+00, 1.267961e+00, 1.321012e+00, 1.365149e+00, 1.394400e+00, 1.436808e+00, 1.467405e+00, 1.437101e+00, 1.466517e+00, 1.485500e+00, 1.495933e+00, 1.489669e+00, 1.477477e+00, 1.475400e+00, 1.469771e+00, 1.436223e+00, 1.417268e+00, 1.387202e+00, 1.373434e+00, 1.334234e+00, 1.308695e+00, 1.271537e+00, 1.233558e+00, 1.198560e+00, 1.173832e+00, 1.138134e+00, 1.080285e+00, 1.046300e+00, 9.925676e-01, 9.657525e-01, 9.120576e-01, 8.737640e-01, 8.196305e-01, 7.861619e-01, 7.405199e-01, 7.068762e-01, 6.604538e-01, 6.308338e-01, 5.791931e-01, 5.582053e-01, 5.429884e-01, 5.173915e-01, 4.833746e-01, 4.521545e-01, 5.322479e-01, 4.876274e-01, 6.015146e-01, 1.358191e+01, 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.};
  for(Int_t r=0; r<100; r++) {
    fchisqVA[r] = chisqVA[r];
  }

  fchisqVC = new Double_t[100];
  Double_t chisqVC[100] = {3.724545e-01, 4.642180e-01, 5.767802e-01, 7.342306e-01, 8.810820e-01, 1.027654e+00, 1.189490e+00, 1.337055e+00, 1.457956e+00, 1.567234e+00, 1.685211e+00, 1.794037e+00, 1.873710e+00, 1.967082e+00, 2.034767e+00, 2.095108e+00, 2.147735e+00, 2.243596e+00, 2.246522e+00, 2.268164e+00, 2.257514e+00, 2.320304e+00, 2.292496e+00, 2.284371e+00, 2.287693e+00, 2.277734e+00, 2.254947e+00, 2.222800e+00, 2.180778e+00, 2.166021e+00, 2.128814e+00, 2.082405e+00, 2.011501e+00, 1.979084e+00, 1.930953e+00, 1.870370e+00, 1.808454e+00, 1.757923e+00, 1.695050e+00, 1.621177e+00, 1.589009e+00, 1.507901e+00, 1.444427e+00, 1.362583e+00, 1.305624e+00, 1.230577e+00, 1.173567e+00, 1.126184e+00, 1.058322e+00, 9.864961e-01, 9.502204e-01, 8.909636e-01, 8.569579e-01, 7.976766e-01, 7.642371e-01, 7.242234e-01, 7.464142e-01, 5.379628e-01, 7.842149e-01, 1.599951e+01, 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.};
  for(Int_t r=0; r<100; r++) {
    fchisqVC[r] = chisqVC[r];
  }

  fZDCESENBins = 100;
  fZDCESELCtot = 1.800004698536e+04; // hardwired, TBI
  fZDCESELC2tot = 4.489404e+01; // hardwired, TBI

} // end of AliFlowAnalysisCRC::InitializeCostantsForCRC()

//=======================================================================================================================

void AliFlowAnalysisCRC::SetRunList()
{
  Int_t dAny[1] = {1};

  Int_t dRun10h[92] = {139510, 139507, 139505, 139503, 139465, 139438, 139437, 139360, 139329, 139328, 139314, 139310, 139309, 139173, 139107, 139105, 139038, 139037, 139036, 139029, 139028, 138872, 138871, 138870, 138837, 138732, 138730, 138666, 138662, 138653, 138652, 138638, 138624, 138621, 138583, 138582, 138579, 138578, 138534, 138469, 138442, 138439, 138438, 138396, 138364, 138275, 138225, 138201, 138197, 138192, 138190, 137848, 137844, 137752, 137751, 137724, 137722, 137718, 137704, 137693, 137692, 137691, 137686, 137685, 137639, 137638, 137608, 137595, 137549, 137546, 137544, 137541, 137539, 137531, 137530, 137443, 137441, 137440, 137439, 137434, 137432, 137431, 137430, 137366, 137243, 137236, 137235, 137232, 137231, 137230, 137162, 137161};

  Int_t dRun10hPos[92] = {139510, 139507, 139505, 139503, 139465, 139438, 139437, 139360, 139329, 139328, 139314, 139310, 139309, 139173, 139107, 139105, 139038, 139037, 139036, 139029, 139028, 138872, 138871, 138870, 138837, 138732, 138730, 138666, 138662, 138653, 138652, 138638, 138624, 138621, 138583, 138582, 138579, 138578, 138534, 138469, 138442, 138439, 138438, 138396, 138364};

  Int_t dRun10hNeg[92] = {138275, 138225, 138201, 138197, 138192, 138190, 137848, 137844, 137752, 137751, 137724, 137722, 137718, 137704, 137693, 137692, 137691, 137686, 137685, 137639, 137638, 137608, 137595, 137549, 137546, 137544, 137541, 137539, 137531, 137530, 137443, 137441, 137440, 137439, 137434, 137432, 137431, 137430, 137366, 137243, 137236, 137235, 137232, 137231, 137230, 137162, 137161};

  Int_t dRun11h[119] = {167902, 167903, 167915, 167920, 167985, 167987, 167988, 168066, 168068, 168069, 168076, 168104, 168105, 168107, 168108, 168115, 168212, 168310, 168311, 168322, 168325, 168341, 168342, 168361, 168362, 168458, 168460, 168461, 168464, 168467, 168511, 168512, 168514, 168777, 168826, 168984, 168988, 168992, 169035, 169040, 169044, 169045, 169091, 169094, 169099, 169138, 169143, 169144, 169145, 169148, 169156, 169160, 169167, 169238, 169411, 169415, 169417, 169418, 169419, 169420, 169475, 169498, 169504, 169506, 169512, 169515, 169550, 169553, 169554, 169555, 169557, 169586, 169587, 169588, 169590, 169591, 169835, 169837, 169838, 169846, 169855, 169858, 169859, 169923, 169956, 169965, 170027, 170036,170040, 170081, 170083, 170084, 170085, 170088, 170089, 170091, 170155, 170159, 170163, 170193, 170203, 170204, 170207, 170228, 170230, 170268, 170269, 170270, 170306, 170308, 170309, 170311, 170312, 170313, 170315, 170387, 170388, 170572, 170593};

  // 12 low IR: 244917, 244918, 244975, 244980, 244982, 244983, 245064, 245066, 245068, 246390, 246391, 246392
  // 78 high IR ("CentralBarrelTracking" good runs): 246994, 246991, 246989, 246984, 246982, 246980, 246948, 246945, 246928, 246871, 246870, 246867, 246865, 246864, 246859, 246858, 246851, 246847, 246846, 246845, 246844, 246810, 246809, 246808, 246807, 246805, 246804, 246766, 246765, 246763, 246760, 246759, 246758, 246757, 246751, 246750, 246540, 246495, 246493, 246488, 246487, 246434, 246431, 246428, 246424, 246276, 246275, 246272, 246271, 246225, 246222, 246217, 246185, 246182, 246181, 246180, 246178, 246153, 246152, 246151, 246115, 246113, 246089, 246087, 246053, 246052, 246049, 246048, 246042, 246037, 246036, 246012, 246003, 246001, 245954, 245952, 245949, 245923, 245833, 245831, 245829, 245705, 245702, 245700, 245692, 245683

  Int_t dRun15h[] = {244917, 244918, 244975, 244980, 244982, 244983, 245064, 245066, 245068, 246390, 246391, 246392, 246994, 246991, 246989, 246984, 246982, 246980, 246948, 246945, 246928, 246851, 246847, 246846, 246845, 246844, 246810, 246809, 246808, 246807, 246805, 246804, 246766, 246765, 246763, 246760, 246759, 246758, 246757, 246751, 246750, 246495, 246493, 246488, 246487, 246434, 246431, 246428, 246424, 246276, 246275, 246272, 246271, 246225, 246222, 246217, 246185, 246182, 246181, 246180, 246178, 246153, 246152, 246151, 246115, 246113, 246089, 246087, 246053, 246052, 246049, 246048, 246042, 246037, 246036, 246012, 246003, 246001, 245954, 245952, 245949, 245923, 245833, 245831, 245829, 245705, 245702, 245700, 245692, 245683};

  Int_t dRun15ov6[] = {244918, 244975, 244980, 244982, 244983, 245064, 245066, 245068, 246390, 246391, 246392, 246994, 246991, 246989, 246984, 246982, 246980, 246948, 246945, 246928, 246851, 246847, 246846, 246845, 246844, 246810, 246809, 246808, 246807, 246805, 246804, 246766, 246765, 246763, 246760, 246759, 246758, 246757, 246751, 246750, 246495, 246493, 246488, 246487, 246434, 246431, 246428, 246424, 246276, 246275, 246272, 246271, 246225, 246222, 246217, 246185, 246182, 246181, 246180, 246178, 246153, 246152, 246151, 246148, 246115, 246113, 246089, 246087, 246053, 246052, 246049, 246048, 246042, 246037, 246036, 246012, 246003, 246001, 245963, 245954, 245952, 245949, 245923, 245833, 245831, 245829, 245705, 245702, 245700, 245692, 245683};

  Int_t dRun15opidfix[] = {245145, 245146, 245151, 245152, 245231, 245232, 245259, 245343, 245345, 245346, 245347, 245349, 245353, 245396, 245397, 245401, 245407, 245409, 245441, 245446, 245450, 245454, 245496, 245497, 245501, 245504, 245505, 245507, 245535, 245540, 245542, 245543, 245544, 245545, 245554};

  Int_t dRun15hHIR[] = {246982, 246980, 246948, 246945, 246928, 246851, 246847, 246846, 246845, 246844, 246805, 246804, 246751, 246750, 246488, 246487, 246431, 246428, 246424, 246271, 246217, 246180, 246178, 246115, 246113, 246042, 246037, 246036, 245923, 245683};

  Int_t dRun15hLIR[] = {246994, 246991, 246989, 246810, 246809, 246766, 246765, 246763, 246760, 246495, 246493, 246276, 246275, 246225, 246185, 246153, 246089, 246053, 246052, 246012, 246003, 245954, 245952, 245949, 245833, 245831, 245705, 245702, 245700};

  Int_t dRun15hPos[] = {246390, 246391, 246392, 246994, 246991, 246989, 246984, 246982, 246980, 246948, 246945, 246928, 246851, 246847, 246846, 246845, 246844, 246810, 246809, 246808, 246807, 246805, 246804, 246766, 246765, 246763, 246760, 246759, 246758, 246757, 246751, 246750, 246495, 246493, 246488, 246487, 246434, 246431, 246428, 246424};

  Int_t dRun15hNeg[] = {244917, 244918, 244975, 244980, 244982, 244983, 245064, 245066, 245068, 246276, 246275, 246272, 246271, 246225, 246222, 246217, 246185, 246182, 246181, 246180, 246178, 246153, 246152, 246151, 246115, 246113, 246089, 246087, 246053, 246052, 246049, 246048, 246042, 246037, 246036, 246012, 246003, 246001, 245954, 245952, 245949, 245923, 245833, 245831, 245829, 245705, 245702, 245700, 245692, 245683};

  Double_t dVtxPosX15o[] = {0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,7.619407e-02, 7.612905e-02, 7.609009e-02, 7.610981e-02, 7.608885e-02, 7.609981e-02, 7.559263e-02, 7.563009e-02, 7.551201e-02, 7.570994e-02, 7.571927e-02, 7.575639e-02, 7.571133e-02, 7.570653e-02, 7.528412e-02, 7.535235e-02, 7.539954e-02, 7.535435e-02, 7.541641e-02, 7.543658e-02, 7.527343e-02, 7.526024e-02, 7.528295e-02, 7.533821e-02, 7.540461e-02, 7.538317e-02, 7.531677e-02, 7.539861e-02, 7.537667e-02, 7.659318e-02, 7.656796e-02, 7.662898e-02, 7.664257e-02, 7.597872e-02, 7.597437e-02, 7.599091e-02, 7.601310e-02, 7.000359e-02, 6.999659e-02, 6.992559e-02, 6.996793e-02, 7.028519e-02, 7.032696e-02, 7.033503e-02, 6.952509e-02, 6.956378e-02, 6.952446e-02, 6.959759e-02, 6.956048e-02, 6.933134e-02, 6.932882e-02, 6.939338e-02, 6.950613e-02, 6.943631e-02, 6.946196e-02, 6.950454e-02, 7.030973e-02, 7.030203e-02, 7.032272e-02, 7.030936e-02, 7.038967e-02, 7.035136e-02, 7.024752e-02, 6.942316e-02, 6.940115e-02, 6.936367e-02, 6.860689e-02, 6.881501e-02, 6.886743e-02, 6.932714e-02, 6.970325e-02, 6.966504e-02, 6.957355e-02, 6.932303e-02, 6.938184e-02, 6.944933e-02, 6.952461e-02, 6.964167e-02};
  Double_t dVtxPosY15o[] = {0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,3.361709e-01, 3.361818e-01, 3.362205e-01, 3.363199e-01, 3.363092e-01, 3.362369e-01, 3.374328e-01, 3.374148e-01, 3.375140e-01, 3.361514e-01, 3.361743e-01, 3.362329e-01, 3.361395e-01, 3.361633e-01, 3.367675e-01, 3.366963e-01, 3.366845e-01, 3.366490e-01, 3.366937e-01, 3.366825e-01, 3.373764e-01, 3.373762e-01, 3.373721e-01, 3.373705e-01, 3.373943e-01, 3.373675e-01, 3.374071e-01, 3.373368e-01, 3.373442e-01, 3.375773e-01, 3.375333e-01, 3.377335e-01, 3.378285e-01, 3.362674e-01, 3.362492e-01, 3.362604e-01, 3.363473e-01, 3.295003e-01, 3.295046e-01, 3.295761e-01, 3.296100e-01, 3.291527e-01, 3.292071e-01, 3.290824e-01, 3.299371e-01, 3.300008e-01, 3.300078e-01, 3.300391e-01, 3.300740e-01, 3.300345e-01, 3.300776e-01, 3.301195e-01, 3.289427e-01, 3.289736e-01, 3.296084e-01, 3.297025e-01, 3.297724e-01, 3.298166e-01, 3.298278e-01, 3.298682e-01, 3.297381e-01, 3.296875e-01, 3.297720e-01, 3.298361e-01, 3.298561e-01, 3.299325e-01, 3.300111e-01, 3.301161e-01, 3.302630e-01, 3.289954e-01, 3.292915e-01, 3.293319e-01, 3.294174e-01, 3.314355e-01, 3.314431e-01, 3.316189e-01, 3.318682e-01, 3.323906e-01};
  Double_t dVtxPosZ15o[] = {0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,5.559279e-01, 3.535446e-01, 4.846955e-01, 4.525585e-01, 3.684501e-01, 2.485494e-01, 2.372653e-01, 1.707859e-01, 3.314213e-01, 1.709195e-01, 2.209753e-01, 3.125757e-01, 3.422085e-01, 3.868156e-01, 4.859695e-01, 4.780697e-01, 4.400149e-01, 4.014992e-01, 3.049883e-01, 3.708501e-01, 3.883566e-01, 3.940632e-01, 4.197670e-01, 3.938399e-01, 3.814413e-01, 3.335539e-01, 3.181929e-01, 2.300734e-01, 2.722395e-01, 5.241033e-01, 3.225908e-01, 1.925791e-01, 1.892765e-01, 3.384066e-01, 2.026459e-01, 2.495699e-01, 3.569992e-01, 3.891381e-01, 4.603724e-01, 3.696685e-01, 3.002207e-01, 2.929533e-01, 3.095468e-01, 3.517200e-01, 2.784445e-01, 3.866626e-01, 3.058719e-01, 3.336752e-01, 3.226473e-01, 3.222815e-01, 3.428469e-01, 3.728514e-01, 2.858642e-01, 2.832485e-01, 3.378933e-01, 3.547548e-01, 3.799414e-01, 4.043543e-01, 4.314049e-01, 4.141138e-01, 3.888746e-01, 4.103586e-01, 3.871045e-01, 4.614473e-01, 4.023404e-01, 4.203531e-01, 4.401272e-01, 6.450558e-01, 6.819582e-01, 2.588529e-01, 3.693471e-01, 3.990708e-01, 3.813842e-01, 3.471682e-01, 3.356156e-01, 2.550150e-01, 3.830723e-01, 4.293259e-01};
  Double_t dVtxPosX15oPos[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 7.619407e-02, 7.612905e-02, 7.609009e-02, 7.610981e-02, 7.608885e-02, 7.609981e-02, 7.559263e-02, 7.563009e-02, 7.551201e-02, 7.570994e-02, 7.571927e-02, 7.575639e-02, 7.571133e-02, 7.570653e-02, 7.528412e-02, 7.535235e-02, 7.539954e-02, 7.535435e-02, 7.541641e-02, 7.543658e-02, 7.527343e-02, 7.526024e-02, 7.528295e-02, 7.533821e-02, 7.540461e-02, 7.538317e-02, 7.531677e-02, 7.539861e-02, 7.537667e-02, 7.659318e-02, 7.656796e-02, 7.662898e-02, 7.664257e-02, 7.597872e-02, 7.597437e-02, 7.599091e-02, 7.601310e-02};
  Double_t dVtxPosY15oPos[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 3.361709e-01, 3.361818e-01, 3.362205e-01, 3.363199e-01, 3.363092e-01, 3.362369e-01, 3.374328e-01, 3.374148e-01, 3.375140e-01, 3.361514e-01, 3.361743e-01, 3.362329e-01, 3.361395e-01, 3.361633e-01, 3.367675e-01, 3.366963e-01, 3.366845e-01, 3.366490e-01, 3.366937e-01, 3.366825e-01, 3.373764e-01, 3.373762e-01, 3.373721e-01, 3.373705e-01, 3.373943e-01, 3.373675e-01, 3.374071e-01, 3.373368e-01, 3.373442e-01, 3.375773e-01, 3.375333e-01, 3.377335e-01, 3.378285e-01, 3.362674e-01, 3.362492e-01, 3.362604e-01, 3.363473e-01};
  Double_t dVtxPosZ15oPos[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 5.559279e-01, 3.535446e-01, 4.846955e-01, 4.525585e-01, 3.684501e-01, 2.485494e-01, 2.372653e-01, 1.707859e-01, 3.314213e-01, 1.709195e-01, 2.209753e-01, 3.125757e-01, 3.422085e-01, 3.868156e-01, 4.859695e-01, 4.780697e-01, 4.400149e-01, 4.014992e-01, 3.049883e-01, 3.708501e-01, 3.883566e-01, 3.940632e-01, 4.197670e-01, 3.938399e-01, 3.814413e-01, 3.335539e-01, 3.181929e-01, 2.300734e-01, 2.722395e-01, 5.241033e-01, 3.225908e-01, 1.925791e-01, 1.892765e-01, 3.384066e-01, 2.026459e-01, 2.495699e-01, 3.569992e-01};
  Double_t dVtxPosX15oNeg[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 7.000359e-02, 6.999659e-02, 6.992559e-02, 6.996793e-02, 7.028519e-02, 7.032696e-02, 7.033503e-02, 6.952509e-02, 6.956378e-02, 6.952446e-02, 6.959759e-02, 6.956048e-02, 6.933134e-02, 6.932882e-02, 6.939338e-02, 6.950613e-02, 6.943631e-02, 6.946196e-02, 6.950454e-02, 7.030973e-02, 7.030203e-02, 7.032272e-02, 7.030936e-02, 7.038967e-02, 7.035136e-02, 7.024752e-02, 6.942316e-02, 6.940115e-02, 6.936367e-02, 6.860689e-02, 6.881501e-02, 6.886743e-02, 6.932714e-02, 6.970325e-02, 6.966504e-02, 6.957355e-02, 6.932303e-02, 6.938184e-02, 6.944933e-02, 6.952461e-02, 6.964167e-02};
  Double_t dVtxPosY15oNeg[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 3.295003e-01, 3.295046e-01, 3.295761e-01, 3.296100e-01, 3.291527e-01, 3.292071e-01, 3.290824e-01, 3.299371e-01, 3.300008e-01, 3.300078e-01, 3.300391e-01, 3.300740e-01, 3.300345e-01, 3.300776e-01, 3.301195e-01, 3.289427e-01, 3.289736e-01, 3.296084e-01, 3.297025e-01, 3.297724e-01, 3.298166e-01, 3.298278e-01, 3.298682e-01, 3.297381e-01, 3.296875e-01, 3.297720e-01, 3.298361e-01, 3.298561e-01, 3.299325e-01, 3.300111e-01, 3.301161e-01, 3.302630e-01, 3.289954e-01, 3.292915e-01, 3.293319e-01, 3.294174e-01, 3.314355e-01, 3.314431e-01, 3.316189e-01, 3.318682e-01, 3.323906e-01};
  Double_t dVtxPosZ15oNeg[] = {0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 0.000000e+00, 3.891381e-01, 4.603724e-01, 3.696685e-01, 3.002207e-01, 2.929533e-01, 3.095468e-01, 3.517200e-01, 2.784445e-01, 3.866626e-01, 3.058719e-01, 3.336752e-01, 3.226473e-01, 3.222815e-01, 3.428469e-01, 3.728514e-01, 2.858642e-01, 2.832485e-01, 3.378933e-01, 3.547548e-01, 3.799414e-01, 4.043543e-01, 4.314049e-01, 4.141138e-01, 3.888746e-01, 4.103586e-01, 3.871045e-01, 4.614473e-01, 4.023404e-01, 4.203531e-01, 4.401272e-01, 6.450558e-01, 6.819582e-01, 2.588529e-01, 3.693471e-01, 3.990708e-01, 3.813842e-01, 3.471682e-01, 3.356156e-01, 2.550150e-01, 3.830723e-01, 4.293259e-01};
  Double_t dVtxPosX15oHI[] = {7.608885e-02, 7.609981e-02, 7.559263e-02, 7.563009e-02, 7.551201e-02, 7.570994e-02, 7.571927e-02, 7.575639e-02, 7.571133e-02, 7.570653e-02, 7.541641e-02, 7.543658e-02, 7.539861e-02, 7.537667e-02, 7.662898e-02, 7.664257e-02, 7.597437e-02, 7.599091e-02, 7.601310e-02, 6.996793e-02, 7.033503e-02, 6.959759e-02, 6.956048e-02, 6.950613e-02, 6.943631e-02, 7.038967e-02, 7.035136e-02, 7.024752e-02, 6.932714e-02, 6.964167e-02};
  Double_t dVtxPosY15oHI[] = {3.363092e-01, 3.362369e-01, 3.374328e-01, 3.374148e-01, 3.375140e-01, 3.361514e-01, 3.361743e-01, 3.362329e-01, 3.361395e-01, 3.361633e-01, 3.366937e-01, 3.366825e-01, 3.373368e-01, 3.373442e-01, 3.377335e-01, 3.378285e-01, 3.362492e-01, 3.362604e-01, 3.363473e-01, 3.296100e-01, 3.290824e-01, 3.300391e-01, 3.300740e-01, 3.289427e-01, 3.289736e-01, 3.297381e-01, 3.296875e-01, 3.297720e-01, 3.289954e-01, 3.323906e-01};
  Double_t dVtxPosZ15oHI[] = {3.684501e-01, 2.485494e-01, 2.372653e-01, 1.707859e-01, 3.314213e-01, 1.709195e-01, 2.209753e-01, 3.125757e-01, 3.422085e-01, 3.868156e-01, 3.049883e-01, 3.708501e-01, 2.300734e-01, 2.722395e-01, 1.925791e-01, 1.892765e-01, 2.026459e-01, 2.495699e-01, 3.569992e-01, 3.002207e-01, 3.517200e-01, 3.336752e-01, 3.226473e-01, 2.858642e-01, 2.832485e-01, 3.888746e-01, 4.103586e-01, 3.871045e-01, 2.588529e-01, 4.293259e-01};
  Double_t dVtxPosX15oLI[] = {7.619407e-02, 7.612905e-02, 7.609009e-02, 7.528412e-02, 7.535235e-02, 7.527343e-02, 7.526024e-02, 7.528295e-02, 7.533821e-02, 7.659318e-02, 7.656796e-02, 7.000359e-02, 6.999659e-02, 7.028519e-02, 6.952509e-02, 6.933134e-02, 6.946196e-02, 7.030973e-02, 7.030203e-02, 6.942316e-02, 6.940115e-02, 6.860689e-02, 6.881501e-02, 6.886743e-02, 6.970325e-02, 6.966504e-02, 6.932303e-02, 6.938184e-02, 6.944933e-02};
  Double_t dVtxPosY15oLI[] = {3.361709e-01, 3.361818e-01, 3.362205e-01, 3.367675e-01, 3.366963e-01, 3.373764e-01, 3.373762e-01, 3.373721e-01, 3.373705e-01, 3.375773e-01, 3.375333e-01, 3.295003e-01, 3.295046e-01, 3.291527e-01, 3.299371e-01, 3.300345e-01, 3.296084e-01, 3.297724e-01, 3.298166e-01, 3.298361e-01, 3.298561e-01, 3.300111e-01, 3.301161e-01, 3.302630e-01, 3.292915e-01, 3.293319e-01, 3.314355e-01, 3.314431e-01, 3.316189e-01};
  Double_t dVtxPosZ15oLI[] = {5.559279e-01, 3.535446e-01, 4.846955e-01, 4.859695e-01, 4.780697e-01, 3.883566e-01, 3.940632e-01, 4.197670e-01, 3.938399e-01, 5.241033e-01, 3.225908e-01, 3.891381e-01, 4.603724e-01, 2.929533e-01, 2.784445e-01, 3.222815e-01, 3.378933e-01, 3.799414e-01, 4.043543e-01, 4.614473e-01, 4.023404e-01, 4.401272e-01, 6.450558e-01, 6.819582e-01, 3.693471e-01, 3.990708e-01, 3.471682e-01, 3.356156e-01, 2.550150e-01};
  Int_t InEvRbR[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1041837, 284865, 2046572, 1371621, 120035, 2122479, 268047, 595924, 50724, 387311, 539797, 229419, 375195, 249722, 122848, 1446667, 55789, 952960, 982841, 406604, 93217, 237924, 398054, 707103, 63508, 462518, 222559, 456809, 720679, 261426, 838890, 2640961, 296971, 1302825, 638981, 81286, 957516, 414835, 745119, 2065488, 795171, 788238, 1497695, 1408541, 135788, 1116152, 1089236, 746357, 349322, 2419892, 241610, 1119258, 144318, 504444, 207053, 5421086, 1133858, 110452, 1655491, 166314, 1439016, 494122, 90017, 716385, 469564, 1625482, 1948001, 2530161, 432644, 100636, 305525, 1332600, 879753, 404590, 123586, 672729, 890654, 1182816};
  Double_t dVtxPosX15opidfix[] = {6.793435e-02, 6.802185e-02, 6.801235e-02, 6.804823e-02, 6.842972e-02, 6.839652e-02, 6.851932e-02, 6.976507e-02, 6.989692e-02, 6.994544e-02, 6.994261e-02, 6.997887e-02, 7.001687e-02, 6.934462e-02, 6.958349e-02, 6.907266e-02, 6.905944e-02, 6.895395e-02, 7.006562e-02, 7.008493e-02, 7.012736e-02, 6.964645e-02, 6.960466e-02, 6.962255e-02, 6.979086e-02, 6.985343e-02, 6.983755e-02, 6.957177e-02, 6.875991e-02, 6.871756e-02, 6.871021e-02, 6.871769e-02, 6.869493e-02, 6.874049e-02, 6.860300e-02};
  Double_t dVtxPosY15opidfix[] = {3.315020e-01, 3.312268e-01, 3.310778e-01, 3.310524e-01, 3.314478e-01, 3.312986e-01, 3.311297e-01, 3.324064e-01, 3.322524e-01, 3.322019e-01, 3.321221e-01, 3.321050e-01, 3.319118e-01, 3.317922e-01, 3.314658e-01, 3.315735e-01, 3.316331e-01, 3.316525e-01, 3.308030e-01, 3.308038e-01, 3.306947e-01, 3.305741e-01, 3.316492e-01, 3.316117e-01, 3.314973e-01, 3.314110e-01, 3.313450e-01, 3.313649e-01, 3.325841e-01, 3.324226e-01, 3.323649e-01, 3.323381e-01, 3.322566e-01, 3.322077e-01, 3.320860e-01};
  Double_t dVtxPosZ15opidfix[] = {4.723797e-01, 4.684324e-01, 4.609304e-01, 4.554974e-01, 4.523016e-01, 3.769890e-01, 4.485548e-01, 5.024484e-01, 5.200088e-01, 5.261731e-01, 5.392851e-01, 5.399264e-01, 5.155504e-01, 4.267668e-01, 5.348764e-01, 4.526746e-01, 4.045626e-01, 4.261759e-01, 5.889205e-01, 6.364843e-01, 5.896163e-01, 3.768637e-01, 4.440771e-01, 4.687029e-01, 4.794467e-01, 4.313422e-01, 3.954777e-01, 3.983129e-01, 3.608064e-01, 2.627038e-01, 3.665826e-01, 4.275667e-01, 3.335445e-01, 3.250815e-01, 3.022907e-01};

  switch(fDataSet) {
    case kAny:
      fCRCnRun=1;
      fRunList=TArrayI(1,dAny);
      break;
    case k2010:
      if(fInteractionRate==kAll) {
        fCRCnRun=92;
        fRunList=TArrayI(fCRCnRun,dRun10h);
      } else if (fInteractionRate==kPos) {
        fCRCnRun=45;
        fRunList=TArrayI(fCRCnRun,dRun10hPos);
      } else if (fInteractionRate==kNeg) {
        fCRCnRun=47;
        fRunList=TArrayI(fCRCnRun,dRun10hNeg);
      }
      fEnNucl=1380.;
      break;
    case k2011:
      fCRCnRun=119;
      fRunList=TArrayI(fCRCnRun,dRun11h);
      fEnNucl=1380.;
      break;
    case k2015:
      if(fInteractionRate==kAll) {
        fCRCnRun=90;
        fRunList=TArrayI(fCRCnRun,dRun15h);
        fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15o);
        fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15o);
        fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15o);
        fnEvRbR=TArrayI(fCRCnRun,InEvRbR);
      } else if (fInteractionRate==kHigh) {
        fCRCnRun=30;
        fRunList=TArrayI(fCRCnRun,dRun15hHIR);
        fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15oHI);
        fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15oHI);
        fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15oHI);
      } else if (fInteractionRate==kLow) {
        fCRCnRun=29;
        fRunList=TArrayI(fCRCnRun,dRun15hLIR);
        fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15oLI);
        fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15oLI);
        fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15oLI);
      } else if (fInteractionRate==kPos) {
        fCRCnRun=40;
        fRunList=TArrayI(fCRCnRun,dRun15hPos);
        fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15oPos);
        fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15oPos);
        fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15oPos);
      } else if (fInteractionRate==kNeg) {
        fCRCnRun=50;
        fRunList=TArrayI(fCRCnRun,dRun15hNeg);
        fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15oNeg);
        fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15oNeg);
        fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15oNeg);
      }
      fEnNucl=2511.;
      break;
    case k2015v6:
      fCRCnRun=91;
      fRunList=TArrayI(fCRCnRun,dRun15ov6);
      fEnNucl=2511.;
      break;
    case k2015pidfix:
      fCRCnRun=35;
      fRunList=TArrayI(fCRCnRun,dRun15opidfix);
      fAvVtxPosX=TArrayD(fCRCnRun,dVtxPosX15opidfix);
      fAvVtxPosY=TArrayD(fCRCnRun,dVtxPosY15opidfix);
      fAvVtxPosZ=TArrayD(fCRCnRun,dVtxPosZ15opidfix);
      fEnNucl=2511.;
      break;
  }

} // end of AliFlowAnalysisCRC::SetRunList()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCRC()
{
  for(Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRCQRe[c][h] = NULL;
      fCRCQIm[c][h] = NULL;
      fCRCMult[c][h] = NULL;
    }
  }
  for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {
      fCRCCFunHist[eg][h] = NULL;
      for(Int_t c=0;c<fCRCnCorr;c++) {
        fCRCCorrProdTempHist[c][eg][h] = NULL;
        fCRCCumHist[c][eg][h] = NULL;
        fCRCCorrHist[c][eg][h] = NULL;
        fCRCCorrProd2p2pPro[c][eg][h] = NULL;
        fCRCCovHist[c][eg][h] = NULL;
      } // end of for(Int_t c=0;c<2;c++)
      for(Int_t c=0;c<fCRCnNUA;c++) {
        fCRCNUATermsHist[c][eg][h] = NULL;
      } // end of for(Int_t c=0;c<4;c++)
    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCIntRunsList[r] = NULL;
    for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        for(Int_t c=0;c<fCRCnCorr;c++) {
          fCRCCorrPro[r][c][eg][h] = NULL;
          fCRCSumWeigHist[r][c][eg][h] = NULL;
        } // end of for(Int_t c=0;c<2;c++)
        for(Int_t c=0;c<fCRCnNUA;c++) {
          fCRCNUATermsPro[r][c][eg][h] = NULL;
        } // end of for(Int_t c=0;c<4;c++)
      } // end of for (Int_t h=0;h<fCRCnCen;h++)
    } // for(Int_t eg=0;eg<fCRCnEtaGap;eg++)
  } // end of for(Int_t r=0;r<fCRCnRun;r++)

} // end of AliFlowAnalysisCRC::InitializeArraysForCRC()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCRC2()
{
  for(Int_t c=0;c<3;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRC2QRe[c][h] = NULL;
      fCRC2QIm[c][h] = NULL;
      fCRC2Mul[c][h] = NULL;
    }
  }
  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      for(Int_t e=0;e<2;e++) {
        fCRC2CorHist[h][c][e] = NULL;
      } // end of for(Int_t e=0;e<2;e++)
      for(Int_t e=0;e<4;e++) {
        fCRC2NUAHist[h][c][e] = NULL;
      } // end of for(Int_t e=0;e<2;e++)
      for(Int_t e=0;e<fkNCorCRC2;e++) {
        fCRC2CovPro[h][c][e] = NULL;
        fCRC2CovHist[h][c][e] = NULL;
      } // end of for(Int_t e=0;e<2;e++)
    } // end of for(Int_t c=0;c<2;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      fCRC2CorPro[h][c] = NULL;
      for(Int_t e=0;e<4;e++) {
        fCRC2NUAPro[h][c][e] = NULL;
      } // end of for(Int_t e=0;e<4;e++)
    } // end of for(Int_t c=0;c<3;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)
} // end of AliFlowAnalysisCRC::InitializeArraysForCRC2()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCRCVZ()
{
  for(Int_t c=0; c<2; c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fVZFlowVect[c][h] = AliFlowVector();
    }
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t j=0; j<fkNHistCRCVZ; j++) {
      fCRCVZEROetaPro[h][j] = NULL;
      fCRCVZEROetaHist[h][j] = NULL;
    }
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForCRCVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCRCZDC()
{
  for(Int_t c=0;c<2;c++) {
    fZDCFlowVect[c] = AliFlowVector();
  }

  for(Int_t c=0;c<4;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRCZDCQRe[c][h] = NULL;
      fCRCZDCQIm[c][h] = NULL;
      fCRCZDCMult[c][h] = NULL;
    }
  }

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {
      fCRCZDCCFunHist[eg][h] = NULL;
      fCRCZDCSpectra[eg][h] = NULL;
      for(Int_t c=0;c<2;c++) {
        fCRCZDCCorrProdTempHist[c][eg][h] = NULL;
        fCRCZDCCorrHist[c][eg][h] = NULL;
        fCRCZDCCovHist[c][eg][h] = NULL;
      } // end of for(Int_t c=0;c<2;c++)
    } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)
  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCZDCRunsList[r] = NULL;
    for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        for(Int_t c=0;c<2;c++) {
          fCRCZDCCorrPro[r][c][eg][h] = NULL;
          fCRCZDCCorrProd2p2pHist[r][c][eg][h] = NULL;
        }
        for(Int_t c=0;c<4;c++) {
          fCRCZDCNUAPro[r][c][eg][h] = NULL;
        }
      } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)
    } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)
  } // end of for(Int_t r=0;r<fCRCnRun;r++)

} // end of AliFlowAnalysisCRC::InitializeArraysForCRCZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForQVec()
{
  // CRC Q Vectors
//  fCRCZDCQVecResvsEAsym = NULL;
//  fCRCZDCQVecResvsETot = NULL;
//  fCRCZDCQVecResvsESum = NULL;
  fCRCQVecEtaPhiList = NULL;
  fCRCQVecPtHistMagField = NULL;
  fCRCQVecPhiHist = NULL;
  for(Int_t h=0;h<2;h++) {
    fCRCQVecPhiHistCh[h] = NULL;
    fCRCQVecHarCosProCh[h] = NULL;
    fCRCQVecHarSinProCh[h] = NULL;
  }
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
    fCRCQVecPhiHistRefMul[cb] = NULL;
    fCRCQVecPhiHistVtxAll[cb] = NULL;
  }
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
    for(Int_t r=0;r<fCRCnRun;r++) {
      fCRCQVecPhiHistVtx[cb][r] = NULL;
    }
  }
  //  for(Int_t h=0;h<fkQVecPhiVtxHistNEtaBins;h++) {
  //    fCRCQVecPhiVtxHist[h] = NULL;
  //  }

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCQVecListRun[r] = NULL;
    fFlowQCVtxList[r] = NULL;
    // @Shi uncommented to save RbR phi eta dis
        fCRCQVecPhiRbRHist[r] = NULL;
        for(Int_t h=0;h<2;h++) {
          fCRCQVecPhiRbRHistCh[r][h] = NULL;
        }
    for(Int_t i=0; i<fkFlowQCRbRnHar; i++) {
      if(r==0) {
        for(Int_t k=0; k<fkFlowQCRbRnVar; k++) {
          for(Int_t j=0; j<fkFlowQCRbRnHist; j++) {
            fFlowQCIntProEta[i][k][j] = NULL;
          }
        }
        // for(Int_t k=0; k<fkFlowQCRbRnVar2; k++) {
        //   for(Int_t j=0; j<fkFlowQCRbRnHist2; j++) {
        //     fFlowQCIntRbRProTotal[i][k][j] = NULL;
        //   }
        // }
      }
    }
    //    for(Int_t i=0; i<fkNRbRFlowHar; i++) {
    //      for (Int_t c=0; c<fkNRbRIntFlow; c++) {
    //        fCRCFlowQCRbRIntFlow[r][i][c] = NULL;
    //        fCRCFlowQCRbRMulFlow[r][i][c] = NULL;
    //      }
    //    }
    for(Int_t h=0;h<fCRCnHar;h++) {
      fCRCVZCosnA[r][h] = NULL;
      fCRCVZSinnA[r][h] = NULL;
      fCRCVZCosnC[r][h] = NULL;
      fCRCVZSinnC[r][h] = NULL;
    }
//    for(Int_t h=0;h<fkNHistQVecCorrv1eta;h++) {
//      fCRCQVecEtaHist[r][h] = NULL;
//    }
//    for(Int_t i=0;i<3;i++) {
//      for(Int_t j=0;j<4;j++) {
//        fCRCTPCQVecCenVtxTime[r][i][j] = NULL;
//        fCRCZDCQVecCenVtxTime[r][i][j] = NULL;
//      }
//    }
    for (Int_t k=0; k<4; k++) {
//      fCRCZDCQVecCenEComTot[r][k] = NULL;
//      fCRCZDCQVecCenRefMulTot[r][k] = NULL;
//      fCRCTPCQVecCenEComTot[r][k] = NULL;
//      fCRCTPCQVecCenRefMulTot[r][k] = NULL;
    }
//    fMulvsCenRbR[r] = NULL;
    for(Int_t c=0;c<fCRCnCen;c++) {
      fCRCVZEPA[r][c] = NULL;
      fCRCVZEPC[r][c] = NULL;
    }
    for(Int_t i=0;i<2;i++) {
      fCRCZDCQVecA[r][i] = NULL;
      fCRCZDCQVecC[r][i] = NULL;
      fCRCZDCQVecACorr[r][i] = NULL;
      fCRCZDCQVecCCorr[r][i] = NULL;
//      fCRCVZQVecA[r][i] = NULL;
//      fCRCVZQVecC[r][i] = NULL;
    }
//    for(Int_t i=0;i<4;i++) {
//      fCRCZDCQVecEP[r][i] = NULL;
//    }
    for (Int_t i=0;i<4;i++) {
      fCRCZDCQVecRes[r][i] = NULL;
    }
    for (Int_t i=0;i<7;i++) {
      fCRCZDCQVecTest[r][i] = NULL;
    }
//    for(Int_t i=0;i<fCRCQVecnCov;i++) {
//      fCRCZDCQVecCov[r][i] = NULL;
//    }
//    for(Int_t h=0;h<fCRCnHar;h++) {
//      fCRCVZEROQVec[r][h] = NULL;
//    }
    //    for(Int_t i=0;i<16;i++) {
    //      fCRCVZvsZDCCov[r][i] = NULL;
    //    }
    //    fCRCZDCResCenEn = NULL;
    for(Int_t c=0;c<4;c++) {
      fCRCZDCQVecVtxPos[r][c] = NULL;
//      fCRCZDCQVecECom[r][c] = NULL;
    }
    for(Int_t h=0;h<fCRCnHar;h++) {
      fCRCQnRe[r][h] = NULL;
      fCRCQnIm[r][h] = NULL;
      fCRCQnReCorr[r][h] = NULL;
      fCRCQnImCorr[r][h] = NULL;
    }
  }
  for(Int_t c=0;c<4;c++) {
    fCRCZDCQVecCorSteps[c] = NULL;
  }
//  for(Int_t i=0;i<2;i++) {
//    for (Int_t j=0;j<3;j++) {
//      fCRCZDCQVecResVtx[i][j] = NULL;
//      fCRCZDCQVecResEZDC[i][j] = NULL;
//      fCRCZDCQVecResv1QA[i][j] = NULL;
//      fCRCZDCQVecResv1QC[i][j] = NULL;
//      fCRCZDCQVecResv1Cross[i][j] = NULL;
//
//      fCRCZDCQVecResCrossC[i][j] = NULL;
//      fCRCZDCQVecResCrossA[i][j] = NULL;
//    }
//  }
  for(Int_t i=0;i<2;i++) {
    for(Int_t c=0;c<fCRCnCen;c++) {
      for (Int_t j=0;j<2;j++) {
        fCRCZDCQVecDis[i][c][j] = NULL;
      }
    }
  }
  for(Int_t c=0;c<fkCRCnCQVecVtxPos;c++) {
//    for (Int_t cb=0; cb<fCRCnCen; cb++) {
//      fCRCZDCQVecVtxPosCen[cb][c] = NULL;
//    }
    for(Int_t i=0;i<3;i++) {
      fCRCZDCQVecVtxCenEZDC[i][c] = NULL;
    }
    for (Int_t i=0; i<fCRCnCen; i++) {
      for (Int_t k=0; k<fknEZDCBins; k++) {
        fCRCZDCQVecVtxCenEZDC3D[i][k][c] = NULL;
      }
    }
  }
//  for (Int_t i=0; i<fCRCnCen; i++) {
//    fCRCZDCQVecDummyEZDCBins[i] = NULL;
//  }
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
    for (Int_t eb=0; eb<fCRCZDCnEtaBin; eb++) {
      for (Int_t k=0; k<6; k++) {
        fCRCTPCQVecVtxPosCen[cb][eb][k] = NULL;
      }
    }
  }
  for (Int_t h=0;h<fCRCnHar;h++) {
    fTPCQnRecenter[h] = AliFlowVector();
  }
  for(Int_t h=0; h<fCRCnHar; h++) {
    for(Int_t k=0; k<2; k++) {
      fTPCQHist[h][k] =  NULL;
    }
  }
  for(Int_t k=0; k<12; k++) {
    fZDCQHist[k] = NULL;
  }
  for(Int_t k=0; k<fkNZDCResHist; k++) {
    fZDCResHist[k] = NULL;
  }
  fZDCQHist2 = NULL;
  for(Int_t k=0; k<2; k++) {
    fZDCEPHist[k] = NULL;
  }
  fFitPol0EP = NULL;
  for(Int_t k=0; k<4; k++) {
    fZDCVtxHist[k] = NULL;
    fZDCEcomHist[k] = NULL;
    fZDCEcomTotHist[k] = NULL;
    fZDCVtxFitHist[k] = NULL;
    for(Int_t i=0; i<3; i++) {
      fZDCVtxFitCenProjHist[k][i] = NULL;
    }
    fZDCVtxFitHist2[k] = NULL;
    for(Int_t i=0; i<3; i++) {
      fZDCVtxFitCenProjHist2[k][i] = NULL;
    }
  }
  for(Int_t c=0; c<10; c++) {
    fZDCBinsCenRefMult[c] = NULL;
  }
  for(Int_t k=0; k<4; k++) {
    fZDCBinsCenRefMultRbR[k] = NULL;
    fZDCBinsCenRefMultTot[k] = NULL;
    for(Int_t c=0; c<10; c++) {
      fZDCBinsCenRefMultRbRProf[c][k] = NULL;
      fZDCBinsCenRefMultTotProf[c][k] = NULL;
      fZDCBinsCenRefMultRbRProj[c][k] = NULL;
      fZDCBinsCenRefMultTotProj[c][k] = NULL;
    }
  }
  for(Int_t i=0; i<3; i++) {
    for(Int_t k=0; k<4; k++) {
      fZDCBinsVtxCenEZDC[i][k] = NULL;
    }
  }
  for(Int_t i=0; i<10; i++) {
    for(Int_t z=0; z<10; z++) {
      for(Int_t k=0; k<4; k++) {
        fZDCQVecVtxCenEZDC3D[i][z][k] = NULL;
      }
    }
  }
  for(Int_t i=0; i<2; i++) {
    for(Int_t z=0; z<10; z++) {
      fCRCZDC2DCutZDCC[i][z] = NULL;
      fCRCZDC2DCutZDCA[i][z] = NULL;
    }
  }
  fZDCQVecVtxCenEZDCFit0 = NULL;
  fZDCQVecVtxCenEZDCFit1 = NULL;
  for(Int_t k=0; k<12; k++) {
    fZDCEcomTotvsVtxHist[k] = NULL;
  }
  for(Int_t c=0; c<10; c++) {
    for(Int_t k=0; k<4; k++) {
      fZDCVtxCenHist[c][k] = NULL;
    }
    for(Int_t k=0; k<8; k++) {
      fZDCVtxCenHistMagPol[c][k] = NULL;
    }
  }
  for (Int_t i=0; i<3; i++) {
    fVZEROCenHist[i] = NULL;
  }
  for (Int_t i=0; i<4; i++) {
    fZDCFitSec[i] = NULL;
  }
  for(Int_t k=0; k<2; k++) {
    fZDCESEMinHist[k] =  NULL;
    fZDCESEMaxHist[k] =  NULL;
    fZDCESEAvHist[k] =  NULL;
    fZDCESEMinMetricHist[k] =  NULL;
    fZDCESEMaxMetricHist[k] =  NULL;
  }
  for(Int_t k=0; k<fZDCESEnPol; k++) {
    fZDCESECutsHist[k] =  NULL;
  }
//  for(Int_t k=0; k<fkNHistQVecCorrv1eta; k++) {
//    fTPCEtaHist[k] = NULL;
//  }
  for (Int_t c=0; c<2; c++) {
    for (Int_t et=0; et<4; et++) {
        fTPCQVecProTemp[c][et] = NULL;
    }
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForQVec()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCME()
{
  for(Int_t c=0;c<4;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCMEQRe[c][h] = NULL;
      fCMEQIm[c][h] = NULL;
      fCMEMult[c][h] = NULL;
    }
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {
      fCMEZDCCorHist[eg][h] = NULL;
      fCMEZDCCovHist[eg][h] = NULL;
      for (Int_t k=0;k<fCMEZDCnDist;k++) {
        fCMEZDCDistHist[eg][h][k] = NULL;
      }
    } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {
      fCMEZDCCorPro[eg][h] = NULL;
      fCMEZDCCovPro[eg][h] = NULL;
      fCMEZDCNUAPro[eg][h] = NULL;
    } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    for (Int_t h=0; h<fCMETPCnHist; h++) {
      fCMETPCCorPro[k][h] = NULL;
      fCMETPCCorHist[k][h] = NULL;
      fCMETPCFinalHist[k][h] = NULL;
    }
  }

  for (Int_t i=0; i<fCMETPCnHist2D; i++) {
    fCMETPCCorPro2D[i] = NULL;
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForCME()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForFlowSPZDC()
{
  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarmZDC; i++) {
      for(Int_t j=0; j<fFlowNPro; j++) {
        fFlowSPZDCCorHist[h][i][j] = NULL;
        fFlowSPZDCFinalPtDifHist[h][i][j] = NULL;
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      fFlowSPZDCIntHist[i][j] = NULL;
      fFlowSPZDCIntFinalHist[i][j] = NULL;
    }
  }
  for(Int_t j=0; j<fkNv1evenCor; j++) {
    fFlowSPZDCv1evenCorPro[j] = NULL;
  }
  for(Int_t j=0; j<fkNZDCDistPro; j++) {
    fFlowSPZDCDistPro[j] = NULL;
  }
//  for(Int_t j=0; j<fkNHistv1eta; j++) {
//    fFlowSPZDCv1etaProPhi[j] = NULL;
//    fFlowSPZDCv1etaProITS[j] = NULL;
//  }
//  for (Int_t k=0; k<2; k++) {
//    for (Int_t i=0; i<fkNITStypes; i++) {
//      fFlowSPZDCv1etaProITSDis[k][i] = NULL;
//    }
//  }
  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t k=0; k<fkNHarv1eta; k++) {
      for(Int_t j=0; j<fkNHistv1eta; j++) {
        fFlowSPZDCv1etaPro[h][k][j] = NULL;
        fFlowSPZDCv1etaHist[h][k][j] = NULL;
        fFlowSPZDCv1etaNUAPro[h][k][j] = NULL;
      }
    }
    for(Int_t j=0; j<fkNHistv1eta; j++) {
      fFlowSPZDCv1etaProImag[h][j] = NULL;
    }
    for (Int_t k=0; k<fkNHistv1etaPt; k++) {
      fFlowSPZDCv1etaPtPro[h][k] = NULL;
      fFlowSPZDCv1etaPtHist[h][k] = NULL;
    }
    for(Int_t j=0; j<fkNHistv1etaCov; j++) {
      fFlowSPZDCv1etaCovPro[h][j] = NULL;
      fFlowSPZDCv1etaCovHist[h][j] = NULL;
    }
  }
  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      fFlowSPZDCIntPro[i][j] = NULL;
      for (Int_t h=0; h<fCRCnCen; h++) {
        fFlowSPZDCCorPro[h][i][j] = NULL;
      }
    }
  }
  for(Int_t j=0; j<fFlowNNUA; j++) {
    fFlowSPZDCIntNUA[j] = NULL;
    for (Int_t h=0; h<fCRCnCen; h++) {
      fFlowSPZDCCorNUA[h][j] = NULL;
    }
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForFlowSPZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForFlowQC()
{
  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarm; i++) {
      for(Int_t j=0; j<fFlowQCNPro; j++) {
        fFlowQCCorPro[h][i][j] = NULL;
        fFlowQCCorHist[h][i][j] = NULL;
        fFlowQCCorProPhi[h][i][j] = NULL;
      }
      for(Int_t j=0; j<fFlowQCNProPhiEta; j++) {
        fFlowQCIntCorProPhiEta[h][i][j] = NULL;
      }
      // for(Int_t k=0; k<fkNITStypes; k++) {
      //   fFlowQCCorProPhiEtaITSType[h][i][k] = NULL;
      // }
      for(Int_t k=0; k<fFlowQCNNUA; k++) {
        fFlowQCCorNUAPro[h][i][k] = NULL;
        fFlowQCCorNUAHist[h][i][k] = NULL;
      }
      for(Int_t k=0; k<fFlowQCNCov; k++) {
        fFlowQCCorCovPro[h][i][k] = NULL;
        fFlowQCCorCovHist[h][i][k] = NULL;
        fFlowQCFinalPtDifHist[h][i][k] = NULL;
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)
  fFlowQCSpectra = NULL;
  for (Int_t k=0; k<2; k++) {
    fFlowQCSpectraCharge[k] = NULL;
  }
  fFlowQCSpectraPubBin = NULL;

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    fFlowQCNewCenSpec[k] = NULL;
    fFlowQCCenSpec[k] = NULL;
  }

  // reference flow
//  for(Int_t i=0; i<fFlowNHarm; i++) {
//    for(Int_t j=0; j<fkNOrdMag; j++) {
//      for(Int_t k=0; k<fkNHistOrdMag; k++) {
//        fFlowQCIntCorHistOrdMag[i][j][k] = NULL;
//      }
//    }
//  }
  for(Int_t i=0; i<fFlowNHarm; i++) {
    for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
      fFlowQCIntCorPro[i][j] = NULL;
      fFlowQCIntCorHist[i][j] = NULL;
      fFlowQCIntCumHist[i][j] = NULL;
    }
    for(Int_t j=0; j<6; j++) {
      fFlowQCIntCorNUAPro[i][j] = NULL;
      fFlowQCIntCorNUAHist[i][j] = NULL;
    }
    fFlowQCIntCorProEG[i] = NULL;
    fFlowQCIntCorHistEG[i] = NULL;
    for(Int_t j=0; j<4; j++) {
      fFlowQCIntCorNUAProEG[i][j] = NULL;
      fFlowQCIntCorNUAHistEG[i][j] = NULL;
    }

    for(Int_t pt=0; pt<fkFlowQCnPtRanges; pt++) {
      for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
        fFlowQCIntPtRanCorPro[pt][i][j] = NULL;
        fFlowQCIntPtRanCorHist[pt][i][j] = NULL;
        fFlowQCIntPtRanCumHist[pt][i][j] = NULL;
      }
      for(Int_t j=0; j<6; j++) {
        fFlowQCIntPtRanCorNUAPro[pt][i][j] = NULL;
        fFlowQCIntPtRanCorNUAHist[pt][i][j] = NULL;
      }
      fFlowQCIntPtRanCorProEG[pt][i] = NULL;
      fFlowQCIntPtRanCorHistEG[pt][i] = NULL;
      for(Int_t j=0; j<4; j++) {
        fFlowQCIntPtRanCorNUAProEG[pt][i][j] = NULL;
        fFlowQCIntPtRanCorNUAHistEG[pt][i][j] = NULL;
      }
    }

    for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++) {
      for(Int_t j=0; j<fkFlowQCnIntCorTest; j++) {
        fFlowQCIntCorProTest[i][k][j] = NULL;
        fFlowQCIntCorHistTest[i][k][j] = NULL;
        fFlowQCIntCumHistTest[i][k][j] = NULL;
        fFlowQCIntFinHistTest[i][k][j] = NULL;
      }
    }
    for(Int_t k=0; k<fkFlowQCnNUATest; k++) {
      fFlowQCIntCorNUAProTest[i][k] = NULL;
    }
    for(Int_t j=0; j<fFlowQCNRef; j++) {
      fFlowQCRefCorPro[i][j] = NULL;
      fFlowQCRefCorHist[i][j] = NULL;
    }
    for(Int_t j=0; j<4; j++) {
      fFlowQCRefCorFinal[i][j] = NULL;
    }
  }

  for(Int_t i=0; i<fSCv2vsZNHarm; i++) {
    for(Int_t bng=0; bng<fkSCNHist; bng++) {
      fFlowSCProdPro[i][bng] = NULL;
      fFlowSCProdHist[i][bng] = NULL;
      fFlowSCFinalHist[i][bng] = NULL;
      fFlowSCCovHist[i][bng] = NULL;
    }
    for (Int_t k=0; k<fkFlowSCNvar; k++) {
      for (Int_t z=0; z<fkFlowSCNvar; z++) {
        fFlowSCCrossProdPro[i][k][z] = NULL;
        fFlowSCCrossProdProMult[i][k][z] = NULL;
      }
    }
  }

} // end of AliFlowAnalysisCRC::InitializeArraysForFlowQC()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForFlowGF()
{
  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNOrde; i++) {
      fFlowGFIntCorPro[h][i] = NULL;
      fFlowGFIntCorHist[h][i] = NULL;
      fFlowGFIntCumHist[h][i] = NULL;
      fFlowGFIntFinalHist[h][i] = NULL;
      for(Int_t k=0; k<fkFlowGFNOrde; k++) {
        fFlowGFIntCovPro[h][i][k] = NULL;
        fFlowGFIntCovHist[h][i][k] = NULL;
      }
      for(Int_t s=0; s<fkFlowGFNSubSampling; s++) {
        fFlowGFIntCorProSS[s][h][i] = NULL;
        fFlowGFIntCorHistSS[s][h][i] = NULL;
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          fFlowGFIntCovProSS[s][h][i][k] = NULL;
          fFlowGFIntCovHistSS[s][h][i][k] = NULL;
        }
      }
      for(Int_t s=0; s<fkGFPtB; s++) {
        fFlowGFIntCorProPtB[s][h][i] = NULL;
        fFlowGFIntCorHistPtB[s][h][i] = NULL;
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          fFlowGFIntCovProPtB[s][h][i][k] = NULL;
          fFlowGFIntCovHistPtB[s][h][i][k] = NULL;
        }
      }
    }
    for(Int_t i=0; i<fkFlowGFNExtra; i++) {
      fFlowGFIntExtraHist[h][i] = NULL;
    }
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNHarm; i++) {
      fFlowGFMixedCorPro[h][i] = NULL;
      fFlowGFMixedCorHist[h][i] = NULL;
      fFlowGFMixedFinalHist[h][i] = NULL;
    }
  }
} // end of AliFlowAnalysisCRC::InitializeArraysForFlowGF()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForFlowEbE()
{
  for (Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIPtDiffQRe[c][h] = NULL;
      fPOIPtDiffQIm[c][h] = NULL;
      fPOIPtDiffMul[c][h] = NULL;
      for(Int_t k=0;k<2;k++) {
        fPOIPtDiffQReCh[k][c][h] = NULL;
        fPOIPtDiffQImCh[k][c][h] = NULL;
        fPOIPtDiffMulCh[k][c][h] = NULL;
      }
    }
  }
  for(Int_t k=0;k<2;k++) {
    for(Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        fPOIPtDiffQReEG[k][c][h] = NULL;
        fPOIPtDiffQImEG[k][c][h] = NULL;
        fPOIPtDiffMulEG[k][c][h] = NULL;
      }
    }
  }
  for (Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIPhiDiffQRe[c][h] = NULL;
      fPOIPhiDiffQIm[c][h] = NULL;
      fPOIPhiDiffMul[c][h] = NULL;
      fPOIPhiEtaDiffQRe[c][h] = NULL;
      fPOIPhiEtaDiffQIm[c][h] = NULL;
      fPOIPhiEtaDiffMul[c][h] = NULL;
    }
  }
  for(Int_t k=0;k<2;k++) {
    for(Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        fPOIPhiDiffQReEG[k][c][h] = NULL;
        fPOIPhiDiffQImEG[k][c][h] = NULL;
        fPOIPhiDiffMulEG[k][c][h] = NULL;
      }
    }
  }
  for (Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fEtaDiffQRe[c][h] = NULL;
      fEtaDiffQIm[c][h] = NULL;
      fEtaDiffMul[c][h] = NULL;
    }
  }
  for(Int_t k=0;k<2;k++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIEtaPtQRe[k][h] = NULL;
      fPOIEtaPtQIm[k][h] = NULL;
      fPOIEtaPtMul[k][h] = NULL;
    }
  }
}

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForFlowSPVZ()
{
  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fCRCnHar; i++) {
      for(Int_t j=0; j<fkFlowSPVZnHist; j++) {
        fFlowSPVZCorPro[h][i][j] = NULL;
        fFlowSPVZCorHist[h][i][j] = NULL;
        fFlowSPVZNUAPro[h][i][j] = NULL;
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

} // end of AliFlowAnalysisCRC::InitializeArraysForFlowSPVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForEbEFlow()
{
  fEBEFlowMulBin = 0;
  for (Int_t h=0; h<26; h++) {
    fEbEFlowAzimDis[h] = NULL;
  }
  for(Int_t i=0; i<2; i++) {
    fEBEFlowRChiSqHist[i] = NULL;
    fEBEFlowpValueHist[i] = NULL;
  }
  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<2; i++) {
      fEBEFlowCrosPro[h][i] = NULL;
    }
    for(Int_t i=0; i<4; i++) {
      fEBEFlowFlucHis[h][i] = NULL;
    }
  }
  for(Int_t h=0; h<fEBEFlowNResPro; h++) {
    fEBEFlowResVZPro[h] = NULL;
  }
  FourierExp = NULL;
} // end of AliFlowAnalysisCRC::InitializeArraysForFlowSPVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForCRCPt()
{
} // end of AliFlowAnalysisCRC::InitializeArraysForCRCPt()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCumulants(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::Calculate2DDiffFlowCumulants(TString type)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateFinalResultsForRPandPOIIntegratedFlow(TString type)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForDistributions()
{
  // Initialize all arrays used for distributions.

  // a) Initialize arrays of histograms used to hold distributions of correlations;
  // b) Initialize array to hold min and max values of correlations;
  // c) Initialize default min and max values of correlation products;
  // d) Initialize default min and max values of q-vector terms.

  // a) Initialize arrays of histograms used to hold distributions of correlations:
  for(Int_t di=0;di<4;di++) // distribution index
  {
    fDistributions[di] = NULL;
  }

  // b) Initialize default min and max values of correlations:
  //    (Remark: The default values bellow were chosen for v2=5% and M=500)
  fMinValueOfCorrelation[0] = -0.01; // <2>_min
  fMaxValueOfCorrelation[0] = 0.04; // <2>_max
  fMinValueOfCorrelation[1] = -0.00002; // <4>_min
  fMaxValueOfCorrelation[1] = 0.00015; // <4>_max
  fMinValueOfCorrelation[2] = -0.0000003; // <6>_min
  fMaxValueOfCorrelation[2] = 0.0000006; // <6>_max
  fMinValueOfCorrelation[3] = -0.000000006; // <8>_min
  fMaxValueOfCorrelation[3] = 0.000000003; // <8>_max

  // c) Initialize default min and max values of correlation products:
  //    (Remark: The default values bellow were chosen for v2=5% and M=500)
  fMinValueOfCorrelationProduct[0] = -0.01; // <2><4>_min
  fMaxValueOfCorrelationProduct[0] = 0.04; // <2><4>_max

  // d) Initialize default min and max values of q-vector terms:
  fMinValueOfQvectorTerms[0] = 0.;
  fMaxValueOfQvectorTerms[0] = 30.;
  fMinValueOfQvectorTerms[1] = 0.;
  fMaxValueOfQvectorTerms[1] = 20.;
  fMinValueOfQvectorTerms[2] = 0.;
  fMaxValueOfQvectorTerms[2] = 200.;
  fMinValueOfQvectorTerms[3] = -30.;
  fMaxValueOfQvectorTerms[3] = 80.;

} // end of void AliFlowAnalysisCRC::InitializeArraysForDistributions()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForVarious()
{
  // Initialize all arrays used for various unclassified objects.
  fMultHist = NULL;
  fV0MMultHist = NULL;
  fCenHist = NULL;
  fEventCounter = NULL;
  for(Int_t k=0; k<3; k++) {
    fVtxHist[k] = NULL;
  }
  fRefMulRecHist = NULL;
//  for (Int_t c=0; c<2; c++) {
//    fhZNCenDis[c] = NULL;
//  }
  fCenWeightsHist = NULL;
  fRefMultRbRPro = NULL;
  fAvEZDCCRbRPro = NULL;
  fAvEZDCARbRPro = NULL;
  fCenWeigCalHist = NULL;
  fPhiExclZoneHist = NULL;
  fVtxPos[0]=0.;
  fVtxPos[1]=0.;
  fVtxPos[2]=0.;
  fVtxPosCor[0]=0.;
  fVtxPosCor[1]=0.;
  fVtxPosCor[2]=0.;
  for(Int_t i=0; i<2; i++) {
    fTwoTrackDistanceLS[i] = NULL;
    fTwoTrackDistanceUS[i] = NULL;
  }
  for(Int_t c=0; c<10; c++) {
    fPtWeightsHist[c] = NULL;
    for(Int_t b=0; b<21; b++) {
      for(Int_t k=0; k<2; k++) {
        fEtaWeightsHist[c][b][k] = NULL;
      }
    }
  }
  for(Int_t h=0; h<2; h++) {
    for (Int_t c=0; c<2; c++) {
      fNvsCenCut[h][c]=NULL;
    }
  }
  for(Int_t h=0; h<fCRCnCen; h++) {
    fhZNCvsZNA[h] = NULL;
  }
  for (Int_t c=0; c<2; c++) {
    fhZNvsCen[c] = NULL;
    fhZNvsTCen[c] = NULL;
  }
  for (Int_t c=0; c<fZDCESEnCl+1; c++) {
    fhCenvsMul[c] = NULL;
    fhCenvsSpec[c] = NULL;
  }
//  for (Int_t c=0; c<2; c++) {
//    for (Int_t k=0; k<4; k++) {
//      fCRCTPCQVecCenEtaRefMulTot[c][k] = NULL;
//    }
//  }
  fhAvRefMulRbR = NULL;
  fhAvQMCRbR = NULL;
  fhAvQMARbR = NULL;
  fhAvAbsOrbit = NULL;
  fhZNvsMul = NULL;
  fMultCutMin = NULL;
  fMultCutMax = NULL;
  fMultCutAv = NULL;
//  for(Int_t k=0; k<10; k++) {
//    fRMSRefMulCenBins[k] = NULL;
//  }
  fEZNCutMin = NULL;
  fEZNCutMax = NULL;
  for(Int_t k=0; k<2; k++) {
    fPolMin[k] = NULL;
    fPolMax[k] = NULL;
    fPolAv[k] = NULL;
    //    fPolDer[k] = NULL;
    //    fPolInt[k] = NULL;
    fPolDist[k] = NULL;
    fPolSlope[k] = NULL;
  }
  for(Int_t k=0; k<fZDCESEnPol; k++) {
    fPolCuts[k] = NULL;
  }
  fCenMetric = NULL;
  for(Int_t k=0; k<fZDCESEnCl; k++) {
    fZDCESEMultWeightsHist[k] = NULL;
  }

} //  end of void AliFlowAnalysisCRC::InitializeArraysForVarious()

//=======================================================================================================================

void AliFlowAnalysisCRC::InitializeArraysForParticleWeights()
{
  fWeightsList = new TList();
  fPtWeightsCent = NULL;
  fPhiEtaWeights = NULL;
  fPhiEtaRbRWeights = NULL;
  for (Int_t i=0; i<2; i++) {
    fPhiEtaWeightsCh[i] = NULL;
    fPhiEtaRbRWeightsCh[i] = NULL;
  }
  for (Int_t i=0; i<2; i++) {
    for (Int_t j=0; j<3; j++) {
      fPhiEtaWeightsChPt[i][j] = NULL;
    }
  }
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
    fPhiEtaWeightsVtx[cb] = NULL;
  }

  // fPhiDistrRefRPs = NULL;
  // fPtDistrRefRPs = NULL;
  // fEtaDistrRefRPs = NULL;
  // fPhiEtaDistrRefRPs = NULL;
  //
  // fPhiWeightsRPs = NULL;
  // fPtWeightsRPs = NULL;
  // fEtaWeightsRPs = NULL;

} //  end of void AliFlowAnalysisCRC::InitializeArraysForParticleWeights()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForDistributions()
{
  // a) Book profile to hold all flags for distributions of correlations;
  // b) Book all histograms to hold distributions of correlations.

  TString correlationIndex[4] = {"#LT2#GT","#LT4#GT","#LT6#GT","#LT8#GT"}; // TBI (should I promote this to data members?)

  // a) Book profile to hold all flags for distributions of correlations:
  TString distributionsFlagsName = "fDistributionsFlags";
  distributionsFlagsName += fAnalysisLabel->Data();
  fDistributionsFlags = new TProfile(distributionsFlagsName.Data(),"Flags for Distributions of Correlations",10,0,10);
  fDistributionsFlags->SetTickLength(-0.01,"Y");
  fDistributionsFlags->SetMarkerStyle(25);
  fDistributionsFlags->SetLabelSize(0.05);
  fDistributionsFlags->SetLabelOffset(0.02,"Y");
  fDistributionsFlags->SetStats(kFALSE);
  fDistributionsFlags->GetXaxis()->SetBinLabel(1,"Store or not?");
  fDistributionsFlags->GetXaxis()->SetBinLabel(2,"#LT2#GT_{min}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(3,"#LT2#GT_{max}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(4,"#LT4#GT_{min}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(5,"#LT4#GT_{max}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(6,"#LT6#GT_{min}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(7,"#LT6#GT_{max}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(8,"#LT8#GT_{min}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(9,"#LT8#GT_{max}");
  fDistributionsFlags->GetXaxis()->SetBinLabel(10,"fnBinsForCorrelations");
  fDistributionsList->Add(fDistributionsFlags);

  // b) Book all histograms to hold distributions of correlations.
  if(fStoreDistributions)
  {
    TString distributionsName = "fDistributions";
    distributionsName += fAnalysisLabel->Data();
    for(Int_t di=0;di<4;di++) // distribution index
    {
      fDistributions[di] = new TH1D(Form("Distribution of %s",correlationIndex[di].Data()),Form("Distribution of %s",correlationIndex[di].Data()),fnBinsForCorrelations,fMinValueOfCorrelation[di],fMaxValueOfCorrelation[di]);
      fDistributions[di]->SetXTitle(correlationIndex[di].Data());
      fDistributionsList->Add(fDistributions[di]);
    } // end of for(Int_t di=0;di<4;di++) // distribution index
  } // end of if(fStoreDistributions)

} // end of void AliFlowAnalysisCRC::BookEverythingForDistributions()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForVarious()
{
  // Book all objects for various unclassified quantities.

  TString fUseParticleWeightsName = "fUseParticleWeightsQC";
  fUseParticleWeightsName += fAnalysisLabel->Data();
  fUseParticleWeights = new TProfile(fUseParticleWeightsName.Data(),"0 = particle weight not used, 1 = particle weight used ",8,0,8);
  fUseParticleWeights->SetLabelSize(0.06);
  fUseParticleWeights->SetStats(kFALSE);
  (fUseParticleWeights->GetXaxis())->SetBinLabel(1,"w_{#phi,#eta}");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(2,"w_{#phi,#eta} ch_dep");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(3,"w_{#phi,#eta} vtx_dep");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(4,"w_{#phi,#eta} ch_pt_dep");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(5,"w_{#phi,#eta} run_dep");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(6,"w_{#phi,#eta} ch_run_dep");
  (fUseParticleWeights->GetXaxis())->SetBinLabel(7,"w_{#phi,#eta} vtx_run_dep");
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhi) fUseParticleWeights->Fill(0.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiCh) fUseParticleWeights->Fill(1.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiVtx) fUseParticleWeights->Fill(2.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiChPt) fUseParticleWeights->Fill(3.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiRbR) fUseParticleWeights->Fill(4.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiChRbR) fUseParticleWeights->Fill(5.5,1);
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiVtxRbR) fUseParticleWeights->Fill(6.5,1);
  fVariousList->Add(fUseParticleWeights);

  fMultHist = new TH1D("Multiplicity","Multiplicity",fnBinsMult,fMinMult,fMaxMult);
  fVariousList->Add(fMultHist);
  Double_t MulMax = ((fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) ? 40.E3 : 25.E3);
  fV0MMultHist = new TH1D("V0MMultiplicity","V0MMultiplicity",3.E3,0.,MulMax);
  fVariousList->Add(fV0MMultHist);
  fCenHist = new TH1D("Centrality","Centrality",100,0.,100.);
  fVariousList->Add(fCenHist);
  fEventCounter = new TH1D("EventCounter","EventCounter",10,0.,10.);
  fEventCounter->GetXaxis()->SetBinLabel(1,"input events");
  fEventCounter->GetXaxis()->SetBinLabel(2,"vn{SPZDC} & SC");
  fEventCounter->GetXaxis()->SetBinLabel(3,"vn{QC}");
  fVariousList->Add(fEventCounter);
  for (Int_t c=0; c<3; c++) {
    fVtxHist[c] = new TH3D(Form("fVtxHist[%d]",c),Form("fVtxHist[%d]",c),fCRCnRun,0.,1.*fCRCnRun,10,0.,100.,100,(c<2?-0.5:-20.),(c<2?0.5:20.));
    for (Int_t rb=1; rb<=fVtxHist[c]->GetXaxis()->GetNbins(); rb++) {
      fVtxHist[c]->GetXaxis()->SetBinLabel(rb,Form("%d",fRunList[rb-1]));
    }
    fVariousList->Add(fVtxHist[c]);
  }
  if(fRemoveSplitMergedTracks) {
    for (Int_t c=0; c<2; c++) {
      fTwoTrackDistanceLS[c] = new TH3F(Form("fTwoTrackDistanceLS[%d]",c), ";#Delta#eta;#Delta#varphi;#Delta p_{T}/2.", 100, -0.1, 0.1, 100, -TMath::Pi()/2., TMath::Pi()/2., 24, 0.2, 5.);
      fVariousList->Add(fTwoTrackDistanceLS[c]);
      fTwoTrackDistanceUS[c] = new TH3F(Form("fTwoTrackDistanceUS[%d]",c), ";#Delta#eta;#Delta#varphi;#Delta p_{T}/2.", 100, -0.1, 0.1, 100, -TMath::Pi()/2., TMath::Pi()/2., 24, 0.2, 5.);
      fVariousList->Add(fTwoTrackDistanceUS[c]);
    }
  }
  Double_t cenbins[101] = {0.};
  for (Int_t i=0; i<101; i++) {
    cenbins[i] = i*1.;
  }
  Double_t RefMulbins[51] = {0.};
  for (Int_t i=0; i<51; i++) {
    RefMulbins[i] = -600 + i*(1200./50.);
  }
  fRefMulRecHist = new TH2D("fRefMulRecHist","fRefMulRecHist",100,cenbins,50,RefMulbins);
  fVariousList->Add(fRefMulRecHist);
//  for (Int_t c=0; c<2; c++) {
//    fhZNCenDis[c] = new TH3D(Form("fhZNCenDis[%d]",c), Form("fhZNCenDis[%d]",c), 100, 0., 100., 100, -2., 2. , 100., -2., 2.);
//    fVariousList->Add(fhZNCenDis[c]);
//  }
  // Double_t phibinsforphihist[101] = {0.};
  // for (Int_t phib=0; phib<101; phib++) {
  //   phibinsforphihist[phib] = phib*TMath::TwoPi()/100.;
  // }
  for(Int_t h=0; h<fCRCnCen; h++) {
    fhZNCvsZNA[h] = new TH2F(Form("hZNCvsZNA[%d]",h),Form("hZNCvsZNA[%d]",h), 100, 0., 100., 100, 0., 100.);
    fVariousList->Add(fhZNCvsZNA[h]);
  }
  for (Int_t c=0; c<2; c++) {
    fhZNvsCen[c] = new TH2F(Form("fhZNvsCen[%d]",c), Form("fhZNvsCen[%d]",c), 100, 0., 100., 500, 0., 200.);
    fhZNvsCen[c]->Sumw2();
    fVariousList->Add(fhZNvsCen[c]);
    fhZNvsTCen[c] = new TH2F(Form("fhZNvsTCen[%d]",c), Form("fhZNvsTCen[%d]",c), 100, 0., 100., 500, 0., 200.);
    fhZNvsTCen[c]->Sumw2();
    fVariousList->Add(fhZNvsTCen[c]);
  }
  for (Int_t c=0; c<fZDCESEnCl+1; c++) {
    if(c<2) fhCenvsMul[c] = new TH2F(Form("fhCenvsMul[%d]",c), Form("fhCenvsMul[%d]",c), 100, 0., 100., 150, 0., 3000.);
    else    fhCenvsMul[c] = new TH2F(Form("fhCenvsMul[%d]",c), Form("fhCenvsMul[%d]",c), 150, 0., 3000., 150, 0., 3000.);
    fhCenvsMul[c]->Sumw2();
    fVariousList->Add(fhCenvsMul[c]);
    fhCenvsSpec[c] = new TH2F(Form("fhCenvsSpec[%d]",c), Form("fhCenvsSpec[%d]",c), 100, 0., 100., fPtDiffNBins, fCRCPtBins);
    fhCenvsSpec[c]->Sumw2();
    fVariousList->Add(fhCenvsSpec[c]);
  }
  fhZNvsMul = new TH2F("fhZNvsMul","fhZNvsMul", 300, 0., MulMax, 250, 0., 200.);
  fhZNvsMul->Sumw2();
  fVariousList->Add(fhZNvsMul);

  fMultCutMin = new TH1F("fMultCutMin","fMultCutMin",90,0.,90.);
  Double_t xcutmin[] = {1.702092e+03, 1.659690e+03, 1.594381e+03, 1.530953e+03, 1.469878e+03, 1.411837e+03, 1.354687e+03, 1.300595e+03, 1.248377e+03, 1.198430e+03, 1.149708e+03, 1.102213e+03, 1.057167e+03, 1.013113e+03, 9.712141e+02, 9.295018e+02, 8.904428e+02, 8.518189e+02, 8.149603e+02, 7.785151e+02, 7.446684e+02, 7.110022e+02, 6.784082e+02, 6.467663e+02, 6.168426e+02, 5.874845e+02, 5.590562e+02, 5.316805e+02, 5.050987e+02, 4.798622e+02, 4.549363e+02, 4.310033e+02, 4.081221e+02, 3.862957e+02, 3.646275e+02, 3.439611e+02, 3.247634e+02, 3.051531e+02, 2.865213e+02, 2.690371e+02, 2.520364e+02, 2.356551e+02, 2.201636e+02, 2.052666e+02, 1.909701e+02, 1.770509e+02, 1.641352e+02, 1.515636e+02, 1.394562e+02, 1.282475e+02, 1.172621e+02, 1.072948e+02, 9.723249e+01, 8.826328e+01, 7.950206e+01, 7.095379e+01, 6.349188e+01, 5.601530e+01, 4.910669e+01, 4.276826e+01, 3.667785e+01, 3.096218e+01, 2.581305e+01, 2.112812e+01, 1.660213e+01, 1.255342e+01, 8.751017e+00, 5.289824e+00, 2.208584e+00, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
  for (Int_t i=1; i<=90; i++) { fMultCutMin->SetBinContent(i,xcutmin[i-1]); }
  fVariousList->Add(fMultCutMin);
  fMultCutMax = new TH1F("fMultCutMax","fMultCutMax",90,0.,90.);
  Double_t xcutmax[] = {2.977831e+03, 2.789981e+03, 2.672021e+03, 2.563939e+03, 2.463466e+03, 2.368142e+03, 2.279347e+03, 2.194917e+03, 2.114559e+03, 2.037801e+03, 1.964346e+03, 1.894544e+03, 1.827056e+03, 1.762559e+03, 1.699773e+03, 1.640634e+03, 1.582244e+03, 1.526511e+03, 1.472669e+03, 1.420538e+03, 1.369823e+03, 1.321126e+03, 1.274265e+03, 1.228004e+03, 1.183782e+03, 1.140569e+03, 1.098898e+03, 1.058714e+03, 1.019339e+03, 9.809862e+02, 9.442490e+02, 9.083504e+02, 8.735706e+02, 8.394027e+02, 8.070248e+02, 7.755483e+02, 7.442536e+02, 7.149877e+02, 6.864865e+02, 6.583045e+02, 6.312841e+02, 6.048965e+02, 5.792457e+02, 5.545794e+02, 5.306581e+02, 5.079286e+02, 4.853815e+02, 4.638178e+02, 4.430323e+02, 4.228056e+02, 4.034712e+02, 3.844499e+02, 3.667303e+02, 3.490117e+02, 3.322493e+02, 3.164227e+02, 3.005651e+02, 2.856931e+02, 2.713716e+02, 2.575504e+02, 2.443261e+02, 2.315942e+02, 2.193395e+02, 2.075676e+02, 1.964631e+02, 1.857374e+02, 1.755505e+02, 1.657988e+02, 1.563373e+02, 1.475873e+02, 1.390231e+02, 1.310338e+02, 1.233011e+02, 1.159695e+02, 1.090223e+02, 1.024656e+02, 9.602331e+01, 9.007991e+01, 8.425771e+01, 7.879926e+01, 7.353029e+01, 6.864368e+01, 6.395624e+01, 5.952758e+01, 5.516085e+01, 5.105927e+01, 4.718699e+01, 4.349916e+01, 4.015761e+01, 3.710833e+01};
  for (Int_t i=1; i<=90; i++) { fMultCutMax->SetBinContent(i,xcutmax[i-1]); }
  fVariousList->Add(fMultCutMax);
  fMultCutAv = new TH1F("fMultCutAv","fMultCutAv",90,0.,90.);
  Double_t xav[] = {2.324784e+03, 2.212053e+03, 2.120706e+03, 2.034993e+03, 1.954277e+03, 1.877610e+03, 1.804846e+03, 1.735610e+03, 1.669782e+03, 1.606641e+03, 1.545644e+03, 1.487097e+03, 1.431140e+03, 1.377076e+03, 1.324829e+03, 1.274444e+03, 1.226002e+03, 1.178903e+03, 1.133614e+03, 1.089623e+03, 1.047356e+03, 1.006281e+03, 9.667492e+02, 9.278635e+02, 8.907950e+02, 8.548160e+02, 8.197275e+02, 7.861789e+02, 7.532557e+02, 7.216491e+02, 6.908557e+02, 6.611987e+02, 6.324036e+02, 6.047124e+02, 5.777042e+02, 5.517775e+02, 5.266738e+02, 5.023742e+02, 4.790001e+02, 4.563775e+02, 4.344788e+02, 4.133227e+02, 3.928839e+02, 3.732591e+02, 3.542738e+02, 3.362057e+02, 3.186165e+02, 3.017719e+02, 2.855503e+02, 2.700526e+02, 2.550622e+02, 2.407724e+02, 2.271138e+02, 2.139625e+02, 2.014145e+02, 1.894186e+02, 1.779280e+02, 1.670108e+02, 1.565556e+02, 1.466505e+02, 1.371798e+02, 1.281117e+02, 1.195846e+02, 1.115543e+02, 1.038702e+02, 9.662303e+01, 8.979202e+01, 8.334000e+01, 7.720447e+01, 7.142981e+01, 6.605105e+01, 6.101889e+01, 5.625787e+01, 5.185071e+01, 4.768692e+01, 4.382575e+01, 4.016922e+01, 3.681930e+01, 3.370155e+01, 3.076244e+01, 2.804824e+01, 2.552284e+01, 2.315275e+01, 2.098654e+01, 1.904220e+01, 1.729321e+01, 1.574531e+01, 1.437631e+01, 1.320221e+01, 1.218386e+01};
  for (Int_t i=1; i<=90; i++) { fMultCutAv->SetBinContent(i,xav[i-1]); }
  fVariousList->Add(fMultCutAv);

//  Double_t xrms[] = {1.123455e+02,9.187739e+01,7.417559e+01,5.736270e+01,4.455476e+01,3.413385e+01,2.539997e+01,1.816070e+01,1.232850e+01,7.905321e+00};
//  for (Int_t c=0; c<10; c++) {
//    fRMSRefMulCenBins[c] = new TH1F(Form("fRMSRefMulCenBins[%d]",c),Form("fRMSRefMulCenBins[%d]",c),6,-3.*xrms[c],3.*xrms[c]);
//    fVariousList->Add(fRMSRefMulCenBins[c]);
//  }

  fEZNCutMin = new TH1F("fEZNCutMin","fEZNCutMin",90,0.,90.);
  Double_t ecutmin[] = {5.679458e+00, 7.607178e+00, 1.068261e+01, 1.404126e+01, 1.738144e+01, 2.053910e+01, 2.374938e+01, 2.678917e+01, 2.969818e+01, 3.224316e+01, 3.484165e+01, 3.706608e+01, 3.916280e+01, 4.150452e+01, 4.349076e+01, 4.506416e+01, 4.706689e+01, 4.854908e+01, 4.999278e+01, 5.126242e+01, 5.268097e+01, 5.404030e+01, 5.528360e+01, 5.611058e+01, 5.719087e+01, 5.779483e+01, 5.885472e+01, 5.962037e+01, 5.999710e+01, 6.095082e+01, 6.131383e+01, 6.178263e+01, 6.213514e+01, 6.273090e+01, 6.296995e+01, 6.341473e+01, 6.347308e+01, 6.371836e+01, 6.378971e+01, 6.374707e+01, 6.363084e+01, 6.344150e+01, 6.365763e+01, 6.374055e+01, 6.311442e+01, 6.304190e+01, 6.244914e+01, 6.215758e+01, 6.182734e+01, 6.109873e+01, 6.081862e+01, 6.007977e+01, 5.950013e+01, 5.840487e+01, 5.762088e+01, 5.683201e+01, 5.579488e+01, 5.453968e+01, 5.337461e+01, 5.212841e+01, 5.088454e+01, 4.925251e+01, 4.765313e+01, 4.580473e+01, 4.431336e+01, 4.231223e+01, 4.012934e+01, 3.824709e+01, 3.588116e+01, 3.379921e+01, 3.105872e+01, 2.873682e+01, 2.618550e+01, 2.325735e+01, 2.037027e+01, 1.757194e+01, 1.411580e+01, 1.130037e+01, 8.275737e+00, 5.348862e+00, 2.500213e+00, -3.652928e-01, -2.176934e+00, -5.381661e+00, -7.183125e+00, -9.352529e+00, -1.137439e+01, -1.380040e+01, -1.547430e+01, -1.662124e+01};
  for (Int_t i=1; i<=90; i++) { fEZNCutMin->SetBinContent(i,ecutmin[i-1]); }
  fVariousList->Add(fEZNCutMin);
  fEZNCutMax = new TH1F("fEZNCutMax","fEZNCutMax",90,0.,90.);
  Double_t ecutmax[] = {3.054919e+01, 3.692352e+01, 4.254322e+01, 4.777653e+01, 5.259061e+01, 5.719378e+01, 6.133480e+01, 6.523429e+01, 6.885126e+01, 7.244460e+01, 7.568765e+01, 7.893172e+01, 8.196279e+01, 8.447118e+01, 8.702351e+01, 8.971290e+01, 9.168324e+01, 9.397844e+01, 9.609081e+01, 9.811322e+01, 9.979812e+01, 1.013239e+02, 1.028019e+02, 1.045299e+02, 1.058101e+02, 1.073907e+02, 1.083592e+02, 1.094939e+02, 1.108315e+02, 1.114612e+02, 1.125904e+02, 1.134947e+02, 1.143157e+02, 1.148556e+02, 1.155402e+02, 1.159961e+02, 1.166812e+02, 1.170944e+02, 1.175560e+02, 1.180785e+02, 1.185336e+02, 1.189505e+02, 1.188809e+02, 1.188482e+02, 1.194567e+02, 1.193798e+02, 1.197406e+02, 1.197367e+02, 1.196424e+02, 1.198297e+02, 1.195133e+02, 1.195347e+02, 1.192998e+02, 1.194903e+02, 1.192825e+02, 1.190254e+02, 1.188784e+02, 1.188011e+02, 1.185301e+02, 1.182328e+02, 1.179031e+02, 1.177838e+02, 1.175172e+02, 1.174881e+02, 1.168439e+02, 1.167271e+02, 1.166109e+02, 1.161081e+02, 1.159685e+02, 1.153956e+02, 1.154842e+02, 1.149880e+02, 1.146008e+02, 1.145904e+02, 1.143930e+02, 1.140997e+02, 1.142903e+02, 1.139589e+02, 1.136466e+02, 1.133392e+02, 1.128740e+02, 1.125602e+02, 1.110557e+02, 1.110887e+02, 1.099240e+02, 1.092136e+02, 1.084315e+02, 1.081597e+02, 1.075144e+02, 1.062025e+02};
  for (Int_t i=1; i<=90; i++) { fEZNCutMax->SetBinContent(i,ecutmax[i-1]); }
  fVariousList->Add(fEZNCutMax);

} // end of void AliFlowAnalysisCRC::BookEverythingForVarious()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreFlagsForDistributions()
{
  // Store all flags for distributiuons of correlations in profile fDistributionsFlags.

  if(!fDistributionsFlags)
  {
    cout<<"WARNING: fDistributionsFlags is NULL in AFAWQC::SDF() !!!!"<<endl;
    exit(0);
  }

  fDistributionsFlags->Fill(0.5,(Int_t)fStoreDistributions); // histos with distributions of correlations stored or not in the output file
  // store min and max values of correlations:
  for(Int_t di=0;di<4;di++) // distribution index
  {
    fDistributionsFlags->Fill(1.5+2.*(Double_t)di,fMinValueOfCorrelation[di]);
    fDistributionsFlags->Fill(2.5+2.*(Double_t)di,fMaxValueOfCorrelation[di]);
  }
  fDistributionsFlags->Fill(9.5,fnBinsForCorrelations);

} // end of void AliFlowAnalysisCRC::StoreFlagsForDistributions()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreDistributionsOfCorrelations()
{
  // Store distributions of correlations.

  if(!(fIntFlowCorrelationsEBE && fIntFlowEventWeightsForCorrelationsEBE))
  {
    cout<<"WARNING: fIntFlowCorrelationsEBE && fIntFlowEventWeightsForCorrelationsEBE"<<endl;
    cout<<"         is NULL in AFAWQC::SDOC() !!!!"<<endl;
    exit(0);
  }

  for(Int_t di=0;di<4;di++) // distribution index
  {
    if(!fDistributions[di])
    {
      cout<<"WARNING: fDistributions[di] is NULL in AFAWQC::SDOC() !!!!"<<endl;
      cout<<"di = "<<di<<endl;
      exit(0);
    } else
    {
      fDistributions[di]->Fill(fIntFlowCorrelationsEBE->GetBinContent(di+1),fIntFlowEventWeightsForCorrelationsEBE->GetBinContent(di+1));
    }
  } // end of for(Int_t di=0;di<4;di++) // distribution index

} // end of void AliFlowAnalysisCRC::StoreDistributionsOfCorrelations()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookAndNestAllLists()
{
  // Book and nest all lists nested in the base list fHistList.
  //  a) Book and nest lists for integrated flow;
  //  b) Book and nest lists for differential flow;
  //  c) Book and nest list for particle weights;
  //  d) Book and nest list for distributions;
  //  e) Book and nest list for various unclassified objects;
  //  f) Book and nest list for other differential correlators;
  //  g) Book and nest list for nested loops;
  //  h) Book and nest lists for mixed harmonics;
  //  i) Book and nest lists for control histograms;
  //  j) Book and nest lists for bootstrap;
  //  k) Book and nest list for QEA.

  // a) Book and nest all lists for integrated flow:
  //  Base list for integrated flow:
  fIntFlowList = new TList();
  fIntFlowList->SetName("Integrated Flow");
  fIntFlowList->SetOwner(kTRUE);
  fHistList->Add(fIntFlowList);
  //  List holding profiles:
  fIntFlowProfiles = new TList();
  fIntFlowProfiles->SetName("Profiles");
  fIntFlowProfiles->SetOwner(kTRUE);
  fIntFlowList->Add(fIntFlowProfiles);
  //  List holding all profiles with results for correlations vs M:
  if(fCalculateAllCorrelationsVsM)
  {
    fIntFlowAllCorrelationsVsM = new TList();
    fIntFlowAllCorrelationsVsM->SetName("Correlations vs M");
    fIntFlowAllCorrelationsVsM->SetOwner(kTRUE);
    fIntFlowProfiles->Add(fIntFlowAllCorrelationsVsM);
  } // end of if(fCalculateAllCorrelationsVsM)
  //  List holding histograms with results:
  fIntFlowResults = new TList();
  fIntFlowResults->SetName("Results");
  fIntFlowResults->SetOwner(kTRUE);
  fIntFlowList->Add(fIntFlowResults);

  // b) Book and nest lists for differential flow:
  this->BookAndNestListsForDifferentialFlow();

  // c) Book and nest list for particle weights:
  fWeightsList->SetName("Weights");
  fWeightsList->SetOwner(kTRUE);
  fTempList->Add(fWeightsList);

  // d) Book and nest list for distributions:
  fDistributionsList = new TList();
  fDistributionsList->SetName("Distributions");
  fDistributionsList->SetOwner(kTRUE);
  fHistList->Add(fDistributionsList);

  // e) Book and nest list for various unclassified objects:
  fVariousList = new TList();
  fVariousList->SetName("Various");
  fVariousList->SetOwner(kTRUE);
  fHistList->Add(fVariousList);

  // f) Book and nest list for other differential correlators:
  fOtherDiffCorrelatorsList = new TList();
  fOtherDiffCorrelatorsList->SetName("Other differential correlators");
  fOtherDiffCorrelatorsList->SetOwner(kTRUE);
  if(fCalculateDiffFlow){fHistList->Add(fOtherDiffCorrelatorsList);} // TBI: Use another flag here instead of fCalculateDiffFlow

  // g) Book and nest list for nested loops:
  fNestedLoopsList = new TList();
  fNestedLoopsList->SetName("Nested Loops");
  fNestedLoopsList->SetOwner(kTRUE);
  fHistList->Add(fNestedLoopsList);

  // h) Book and nest lists for mixed harmonics:
  //  Base list for mixed harmonics:
  fMixedHarmonicsList = new TList();
  fMixedHarmonicsList->SetName("Mixed Harmonics");
  fMixedHarmonicsList->SetOwner(kTRUE);
  fHistList->Add(fMixedHarmonicsList);
  //  List holding profiles:
  fMixedHarmonicsProfiles = new TList();
  fMixedHarmonicsProfiles->SetName("Profiles");
  fMixedHarmonicsProfiles->SetOwner(kTRUE);
  if(fCalculateMixedHarmonics){fMixedHarmonicsList->Add(fMixedHarmonicsProfiles);}
  //  List holding histograms with results:
  fMixedHarmonicsResults = new TList();
  fMixedHarmonicsResults->SetName("Results");
  fMixedHarmonicsResults->SetOwner(kTRUE);
  if(fCalculateMixedHarmonics){fMixedHarmonicsList->Add(fMixedHarmonicsResults);}
  //  List holding objects for statistical error propagation of mixed harmonics:
  fMixedHarmonicsErrorPropagation = new TList();
  fMixedHarmonicsErrorPropagation->SetName("Error Propagation");
  fMixedHarmonicsErrorPropagation->SetOwner(kTRUE);
  if(fCalculateMixedHarmonics){fMixedHarmonicsList->Add(fMixedHarmonicsErrorPropagation);}

  // i) Book and nest lists for control histograms:
  //  Base list for mixed harmonics:
  fControlHistogramsList = new TList();
  fControlHistogramsList->SetName("Control Histograms");
  fControlHistogramsList->SetOwner(kTRUE);
  fHistList->Add(fControlHistogramsList);

  // j) Book and nest lists for bootstrap:
  fBootstrapList = new TList();
  fBootstrapList->SetName("Bootstrap");
  fBootstrapList->SetOwner(kTRUE);
  fHistList->Add(fBootstrapList);
  //  List holding profiles:
  fBootstrapProfilesList = new TList();
  fBootstrapProfilesList->SetName("Profiles");
  fBootstrapProfilesList->SetOwner(kTRUE);
  if(fUseBootstrap||fUseBootstrapVsM){fBootstrapList->Add(fBootstrapProfilesList);}
  //  List holding histograms with results:
  fBootstrapResultsList = new TList();
  fBootstrapResultsList->SetName("Results");
  fBootstrapResultsList->SetOwner(kTRUE);
  if(fUseBootstrap||fUseBootstrapVsM){fBootstrapList->Add(fBootstrapResultsList);}

  // k) Book and nest list for QEA:
  fCRCList = new TList();
  fCRCList->SetName("Charge-Rapidity Correlations");
  fCRCList->SetOwner(kTRUE);
  fHistList->Add(fCRCList);

  fCRCIntList = new TList();
  fCRCIntList->SetName("Integrated CRC");
  fCRCIntList->SetOwner(kTRUE);
  fCRCList->Add(fCRCIntList);

  fCRCIntRbRList = new TList();
  fCRCIntRbRList->SetName("Run-by-Run");
  fCRCIntRbRList->SetOwner(kTRUE);
  fCRCIntList->Add(fCRCIntRbRList);

  fCRCVZList = new TList();
  fCRCVZList->SetName("VZERO CRC");
  fCRCVZList->SetOwner(kTRUE);
  fCRCList->Add(fCRCVZList);

  fCRCZDCList = new TList();
  fCRCZDCList->SetName("ZDC CRC");
  fCRCZDCList->SetOwner(kTRUE);
  fCRCList->Add(fCRCZDCList);

  fCRCZDCRbRList = new TList();
  fCRCZDCRbRList->SetName("Run-by-Run");
  fCRCZDCRbRList->SetOwner(kTRUE);
  fCRCZDCList->Add(fCRCZDCRbRList);

  fCRCQVecList = new TList();
  fCRCQVecList->SetName("Q Vectors");
  fCRCQVecList->SetOwner(kTRUE);
  fHistList->Add(fCRCQVecList);

  fCRCQVecEtaPhiList = new TList();
  fCRCQVecEtaPhiList->SetName("Track Distribution");
  fCRCQVecEtaPhiList->SetOwner(kTRUE);
  fCRCQVecList->Add(fCRCQVecEtaPhiList);

  fCRCPtList = new TList();
  fCRCPtList->SetName("Pt differential CRC");
  fCRCPtList->SetOwner(kTRUE);
  fCRCList->Add(fCRCPtList);

  fCMEList = new TList();
  fCMEList->SetName("CME");
  fCMEList->SetOwner(kTRUE);
  fHistList->Add(fCMEList);

  fCMETPCList = new TList();
  fCMETPCList->SetName("CME TPC only");
  fCMETPCList->SetOwner(kTRUE);
  fCMEList->Add(fCMETPCList);

  fCMEZDCList = new TList();
  fCMEZDCList->SetName("CME TPC-ZDCs");
  fCMEZDCList->SetOwner(kTRUE);
  fCMEList->Add(fCMEZDCList);

  fCRC2List = new TList();
  fCRC2List->SetName("CRC2");
  fCRC2List->SetOwner(kTRUE);
  fCRCList->Add(fCRC2List);

  fFlowQCList = new TList();
  fFlowQCList->SetName("Flow QC");
  fFlowQCList->SetOwner(kTRUE);
  fHistList->Add(fFlowQCList);

  fFlowQCCorrZDCList = new TList();
  fFlowQCCorrZDCList->SetName("Corr ZDC");
  fFlowQCCorrZDCList->SetOwner(kTRUE);
  fFlowQCList->Add(fFlowQCCorrZDCList);

  fFlowGFList = new TList();
  fFlowGFList->SetName("Flow GF");
  fFlowGFList->SetOwner(kTRUE);
  fHistList->Add(fFlowGFList);

  fFlowSPZDCList = new TList();
  fFlowSPZDCList->SetName("Flow SP ZDC");
  fFlowSPZDCList->SetOwner(kTRUE);
  fHistList->Add(fFlowSPZDCList);

  fFlowSPVZList = new TList();
  fFlowSPVZList->SetName("Flow SP VZ");
  fFlowSPVZList->SetOwner(kTRUE);
  fHistList->Add(fFlowSPVZList);

  fEbEFlowList = new TList();
  fEbEFlowList->SetName("EbE Flow");
  fEbEFlowList->SetOwner(kTRUE);
  fHistList->Add(fEbEFlowList);

} // end of void AliFlowAnalysisCRC::BookAndNestAllLists()

//=====================================================================================================================

void AliFlowAnalysisCRC::BookAndNestListsForDifferentialFlow()
{
  // Book and nest lists for differential flow.

  // Base list for differential flow objects:
  fDiffFlowList = new TList();
  fDiffFlowList->SetName("Differential Flow");
  fDiffFlowList->SetOwner(kTRUE);
  fHistList->Add(fDiffFlowList);

  // Local flags:
  TString typeFlag[2] = {"RP","POI"};
  TString ptEtaFlag[2] = {"p_{T}","#eta"};
  TString powerFlag[2] = {"linear","quadratic"};

  // 2D:
  if(fCalculate2DDiffFlow)
  {
    fDiffFlow2D = new TList();
    fDiffFlow2D->SetName("2D");
    fDiffFlow2D->SetOwner(kTRUE);
    fDiffFlowList->Add(fDiffFlow2D);
    for(Int_t t=0;t<2;t++)
    {
      f2DDiffFlowCorrelationsProList[t] = new TList();
      f2DDiffFlowCorrelationsProList[t]->SetOwner(kTRUE);
      f2DDiffFlowCorrelationsProList[t]->SetName(Form("Profiles with 2D correlations (%s)",typeFlag[t].Data()));
      fDiffFlow2D->Add(f2DDiffFlowCorrelationsProList[t]);
    } // end of for(Int_t t=0;t<2;t++)
  } // end of if(fCalculate2DDiffFlow)

  // What follows bellow in this method is relevant only for 1D differential flow:
  if(!fCalculateDiffFlow){return;}

  // List holding profiles:
  fDiffFlowProfiles = new TList();
  fDiffFlowProfiles->SetName("Profiles");
  fDiffFlowProfiles->SetOwner(kTRUE);
  fDiffFlowList->Add(fDiffFlowProfiles);
  // List holding histograms with results:
  fDiffFlowResults = new TList();
  fDiffFlowResults->SetName("Results");
  fDiffFlowResults->SetOwner(kTRUE);
  fDiffFlowList->Add(fDiffFlowResults);
  // Flags used for naming nested lists in list fDiffFlowProfiles and fDiffFlowResults:
  TList list;
  list.SetOwner(kTRUE);
  // Nested lists in fDiffFlowProfiles (~/Differential Flow/Profiles):
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      // list holding profiles with correlations:
      fDiffFlowCorrelationsProList[t][pe] = (TList*)list.Clone();
      fDiffFlowCorrelationsProList[t][pe]->SetName(Form("Profiles with correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowProfiles->Add(fDiffFlowCorrelationsProList[t][pe]);
      // list holding profiles with products of correlations:
      fDiffFlowProductOfCorrelationsProList[t][pe] = (TList*)list.Clone();
      fDiffFlowProductOfCorrelationsProList[t][pe]->SetName(Form("Profiles with products of correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowProfiles->Add(fDiffFlowProductOfCorrelationsProList[t][pe]);
      // list holding profiles with corrections:
      fDiffFlowCorrectionsProList[t][pe] = (TList*)list.Clone();
      fDiffFlowCorrectionsProList[t][pe]->SetName(Form("Profiles with correction terms for NUA (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowProfiles->Add(fDiffFlowCorrectionsProList[t][pe]);
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // nested lists in fDiffFlowResults (~/Differential Flow/Results):
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      // list holding histograms with correlations:
      fDiffFlowCorrelationsHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowCorrelationsHistList[t][pe]->SetName(Form("Correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowCorrelationsHistList[t][pe]);
      // list holding histograms with corrections:
      fDiffFlowCorrectionsHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowCorrectionsHistList[t][pe]->SetName(Form("Histograms with correction terms for NUA (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowCorrectionsHistList[t][pe]);
      for(Int_t power=0;power<2;power++)
      {
        // list holding histograms with sums of event weights:
        fDiffFlowSumOfEventWeightsHistList[t][pe][power] = (TList*)list.Clone();
        fDiffFlowSumOfEventWeightsHistList[t][pe][power]->SetName(Form("Sum of %s event weights (%s, %s)",powerFlag[power].Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data()));
        fDiffFlowResults->Add(fDiffFlowSumOfEventWeightsHistList[t][pe][power]);
      } // end of for(Int_t power=0;power<2;power++)
      // list holding histograms with sums of products of event weights:
      fDiffFlowSumOfProductOfEventWeightsHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowSumOfProductOfEventWeightsHistList[t][pe]->SetName(Form("Sum of products of event weights (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowSumOfProductOfEventWeightsHistList[t][pe]);
      // list holding histograms with covariances of correlations:
      fDiffFlowCovariancesHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowCovariancesHistList[t][pe]->SetName(Form("Covariances of correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowCovariancesHistList[t][pe]);
      // list holding histograms with differential Q-cumulants:
      fDiffFlowCumulantsHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowCumulantsHistList[t][pe]->SetName(Form("Differential Q-cumulants (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowCumulantsHistList[t][pe]);
      // list holding histograms which quantify detector bias to differential Q-cumulants:
      fDiffFlowDetectorBiasHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowDetectorBiasHistList[t][pe]->SetName(Form("Detector bias (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowDetectorBiasHistList[t][pe]);
      // list holding histograms with differential flow estimates from Q-cumulants:
      fDiffFlowHistList[t][pe] = (TList*)list.Clone();
      fDiffFlowHistList[t][pe]->SetName(Form("Differential flow (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data()));
      fDiffFlowResults->Add(fDiffFlowHistList[t][pe]);
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

} // end of void AliFlowAnalysisCRC::BookAndNestListsForDifferentialFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::FillCommonHistResultsDiffFlow(TString type)
{
  // Fill common result histograms for differential flow.

  Int_t t = 0;

  if(type == "RP")
  {
    t = 0;
  } else if(type == "POI")
  {
    t = 1;
  }

  // to be improved - check all pointers used in this method

  if(!(fCommonHistsResults2nd && fCommonHistsResults4th && fCommonHistsResults6th && fCommonHistsResults8th))
  {
    cout<<"WARNING: fCommonHistsResults2nd && fCommonHistsResults4th && fCommonHistsResults6th && fCommonHistsResults8th"<<endl;
    cout<<"         is NULL in AFAWQC::FCHRIF() !!!!"<<endl;
    exit(0);
  }

  // pt:
  for(Int_t p=1;p<=fnBinsPt;p++)
  {
    Double_t v2 = fDiffFlow[t][0][0]->GetBinContent(p);
    Double_t v4 = fDiffFlow[t][0][1]->GetBinContent(p);
    Double_t v6 = fDiffFlow[t][0][2]->GetBinContent(p);
    Double_t v8 = fDiffFlow[t][0][3]->GetBinContent(p);

    Double_t v2Error = fDiffFlow[t][0][0]->GetBinError(p);
    Double_t v4Error = fDiffFlow[t][0][1]->GetBinError(p);
    //Double_t v6Error = fFinalFlow1D[t][pW][nua][0][2]->GetBinError(p);
    //Double_t v8Error = fFinalFlow1D[t][pW][nua][0][3]->GetBinError(p);

    if(type == "RP")
    {
      fCommonHistsResults2nd->FillDifferentialFlowPtRP(p,v2,v2Error);
      fCommonHistsResults4th->FillDifferentialFlowPtRP(p,v4,v4Error);
      fCommonHistsResults6th->FillDifferentialFlowPtRP(p,v6,0.);
      fCommonHistsResults8th->FillDifferentialFlowPtRP(p,v8,0.);
    } else if(type == "POI")
    {
      fCommonHistsResults2nd->FillDifferentialFlowPtPOI(p,v2,v2Error);
      fCommonHistsResults4th->FillDifferentialFlowPtPOI(p,v4,v4Error);
      fCommonHistsResults6th->FillDifferentialFlowPtPOI(p,v6,0.);
      fCommonHistsResults8th->FillDifferentialFlowPtPOI(p,v8,0.);
    }
  } // end of for(Int_t p=1;p<=fnBinsPt;p++)

  // eta:
  if(!fCalculateDiffFlowVsEta){return;}
  for(Int_t e=1;e<=fnBinsEta;e++)
  {
    Double_t v2 = fDiffFlow[t][1][0]->GetBinContent(e);
    Double_t v4 = fDiffFlow[t][1][1]->GetBinContent(e);
    Double_t v6 = fDiffFlow[t][1][2]->GetBinContent(e);
    Double_t v8 = fDiffFlow[t][1][3]->GetBinContent(e);

    Double_t v2Error = fDiffFlow[t][1][0]->GetBinError(e);
    Double_t v4Error = fDiffFlow[t][1][1]->GetBinError(e);
    //Double_t v6Error = fDiffFlow[t][1][2]->GetBinError(e);
    //Double_t v8Error = fDiffFlow[t][1][3]->GetBinError(e);

    if(type == "RP")
    {
      fCommonHistsResults2nd->FillDifferentialFlowEtaRP(e,v2,v2Error);
      fCommonHistsResults4th->FillDifferentialFlowEtaRP(e,v4,v4Error);
      fCommonHistsResults6th->FillDifferentialFlowEtaRP(e,v6,0.);
      fCommonHistsResults8th->FillDifferentialFlowEtaRP(e,v8,0.);
    } else if(type == "POI")
    {
      fCommonHistsResults2nd->FillDifferentialFlowEtaPOI(e,v2,v2Error);
      fCommonHistsResults4th->FillDifferentialFlowEtaPOI(e,v4,v4Error);
      fCommonHistsResults6th->FillDifferentialFlowEtaPOI(e,v6,0.);
      fCommonHistsResults8th->FillDifferentialFlowEtaPOI(e,v8,0.);
    }
  } // end of for(Int_t e=1;e<=fnBinsEta;e++)

} // end of void AliFlowAnalysisCRC::FillCommonHistResultsDiffFlow(TString type, Bool_t useParticleWeights, TString eventWeights, Bool_t correctedForNUA)

//=======================================================================================================================

void AliFlowAnalysisCRC::CommonConstants(TString method)
{
  // Access and store common constants.

  // a) If this method was called in Init() access common constants from AliFlowCommonConstants;
  // b) If this method was called in Init() book and fill TProfile to hold constants accessed in a);
  // c) If this method was called in Finish() access common constants from TProfile booked and filled in b).

  if(method == "Init") {
    // a) If this method was called in Init() access common constants from AliFlowCommonConstants:
    fnBinsPhi = AliFlowCommonConstants::GetMaster()->GetNbinsPhi();
    fPhiMin = AliFlowCommonConstants::GetMaster()->GetPhiMin();
    fPhiMax = AliFlowCommonConstants::GetMaster()->GetPhiMax();
    if(fnBinsPhi){fPhiBinWidth = (fPhiMax-fPhiMin)/fnBinsPhi;}
    fnBinsPt = AliFlowCommonConstants::GetMaster()->GetNbinsPt();
    fPtMin = AliFlowCommonConstants::GetMaster()->GetPtMin();
    fPtMax = AliFlowCommonConstants::GetMaster()->GetPtMax();
    if(fnBinsPt){fPtBinWidth = (fPtMax-fPtMin)/fnBinsPt;}
    fnBinsEta = AliFlowCommonConstants::GetMaster()->GetNbinsEta();
    fEtaMin = AliFlowCommonConstants::GetMaster()->GetEtaMin();
    fEtaMax = AliFlowCommonConstants::GetMaster()->GetEtaMax();
    if(fnBinsEta){fEtaBinWidth = (fEtaMax-fEtaMin)/fnBinsEta;}

    // b) If this method was called in Init() book and fill TProfile to hold constants accessed in a):
    TString fCommonConstantsName = "fCommonConstants";
    fCommonConstantsName += fAnalysisLabel->Data();
    fCommonConstants = new TProfile(fCommonConstantsName.Data(),"Common constants",9,0.,9.);
    fCommonConstants->SetLabelSize(0.05);
    fCommonConstants->GetXaxis()->SetBinLabel(1,"nBins (#phi)");
    fCommonConstants->Fill(0.5,fnBinsPhi);
    fCommonConstants->GetXaxis()->SetBinLabel(2,"#phi_{min}");
    fCommonConstants->Fill(1.5,fPhiMin);
    fCommonConstants->GetXaxis()->SetBinLabel(3,"#phi_{max}");
    fCommonConstants->Fill(2.5,fPhiMax);
    fCommonConstants->GetXaxis()->SetBinLabel(4,"nBins (p_{t})");
    fCommonConstants->Fill(3.5,fnBinsPt);
    fCommonConstants->GetXaxis()->SetBinLabel(5,"(p_{t})_{min}");
    fCommonConstants->Fill(4.5,fPtMin);
    fCommonConstants->GetXaxis()->SetBinLabel(6,"(p_{t})_{max}");
    fCommonConstants->Fill(5.5,fPtMax);
    fCommonConstants->GetXaxis()->SetBinLabel(7,"nBins (#eta)");
    fCommonConstants->Fill(6.5,fnBinsEta);
    fCommonConstants->GetXaxis()->SetBinLabel(8,"#eta_{min}");
    fCommonConstants->Fill(7.5,fEtaMin);
    fCommonConstants->GetXaxis()->SetBinLabel(9,"#eta_{max}");
    fCommonConstants->Fill(8.5,fEtaMax);
    fHistList->Add(fCommonConstants);
  } // end of if(method == "Init")

  else if(method == "Finish") {
    // c) If this method was called in Finish() access common constants from TProfile booked and filled in b):
    if(!fCommonConstants) {
      printf("\n WARNING (QC): fCommonConstants is NULL in AFAWQC::AC(\"%s\") !!!!\n\n",method.Data());
      exit(0);
    }
    fnBinsPhi = (Int_t)fCommonConstants->GetBinContent(1);
    fPhiMin = fCommonConstants->GetBinContent(2);
    fPhiMax = fCommonConstants->GetBinContent(3);
    if(fnBinsPhi){fPhiBinWidth = (fPhiMax-fPhiMin)/fnBinsPhi;}
    fnBinsPt = (Int_t)fCommonConstants->GetBinContent(4);
    fPtMin = fCommonConstants->GetBinContent(5);
    fPtMax = fCommonConstants->GetBinContent(6);
    if(fnBinsPt){fPtBinWidth = (fPtMax-fPtMin)/fnBinsPt;}
    fnBinsEta = (Int_t)fCommonConstants->GetBinContent(7);
    fEtaMin = fCommonConstants->GetBinContent(8);
    fEtaMax = fCommonConstants->GetBinContent(9);
    if(fnBinsEta){fEtaBinWidth = (fEtaMax-fEtaMin)/fnBinsEta;}
  } // end of else if(method == "Finish")

} // end of void AliFlowAnalysisCRC::CommonConstants(TString method)

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckSettings()
{
  // a) Cross-check if the choice for multiplicity weights make sense;
  // b) Cross-check if the choice for multiplicity itself make sense.

  // a) Cross-check if the choice for multiplicity weights make sense:
  if((!fMultiplicityWeight->Contains("combinations")) &&
     (!fMultiplicityWeight->Contains("unit")) &&
     (!fMultiplicityWeight->Contains("multiplicity")) )
  {
    cout<<"WARNING (QC): Multiplicity weight can be either \"combinations\", \"unit\""<<endl;
    cout<<"              or \"multiplicity\". Certainly not \""<<fMultiplicityWeight->Data()<<"\"."<<endl;
    exit(0);
  }

} // end of void AliFlowAnalysisCRC::CrossCheckSettings()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowSumOfEventWeights()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowSumOfEventWeightsNUA()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowSumOfProductOfEventWeights()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowSumOfProductOfEventWeightsNUA()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrelations(TString type, TString ptOrEta)
{}

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetCRCBin(Int_t cf, Int_t yf, Int_t c2f, Int_t y2f)
{
  Int_t CRCBin=0;
  Int_t bin=1;
  for(Int_t c=0;c<2;c++) {
    for(Int_t y=0;y<2;y++) {
      for(Int_t c2=0;c2<2;c2++) {
        for(Int_t y2=0;y2<2;y2++) {
          if (c==cf && y==yf && c2==c2f && y2==y2f) CRCBin = bin;
          else bin++;
        }
      }
    }
  }
  return CRCBin;
} // end of AliFlowAnalysisCRC::GetCRCBin();

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetCRCVZBin(Int_t cf, Int_t c2f)
{
  Int_t CRCBin=0;
  Int_t bin=1;
  for(Int_t c=0;c<2;c++) {
    for(Int_t c2=0;c2<2;c2++) {
      if (c==cf && c2==c2f) CRCBin = bin;
      else bin++;
    }
  }
  return CRCBin;
} // end of AliFlowAnalysisCRC::GetCRCVZBin();

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetCRCQVecBin(Int_t cf, Int_t yf)
{
  Int_t CRCBin=0,bin=0;
  for(Int_t c=0;c<2;c++) {
    for(Int_t y=0; y<fCRCnEtaBins; y++) {
      if (c==cf && y==yf) CRCBin = bin;
      else bin++;
    }
  }
  return CRCBin;
} // end of AliFlowAnalysisCRC::GetCRCQVecBin();

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetCRCRunBin(Int_t RunNum)
{
  Int_t CRCBin=-1,bin=0;
  for(Int_t c=0;c<fCRCnRun;c++) {
    if(fRunList[c]==RunNum) CRCBin=bin;
    else bin++;
  }
  return CRCBin;
} // end of AliFlowAnalysisCRC::GetCRCRunBin();

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetCRCCenBin(Double_t Centrality)
{
  Int_t CenBin=-1;
  if (Centrality>0. && Centrality<5.) CenBin=0;
  if (Centrality>5. && Centrality<10.) CenBin=1;
  if (Centrality>10. && Centrality<20.) CenBin=2;
  if (Centrality>20. && Centrality<30.) CenBin=3;
  if (Centrality>30. && Centrality<40.) CenBin=4;
  if (Centrality>40. && Centrality<50.) CenBin=5;
  if (Centrality>50. && Centrality<60.) CenBin=6;
  if (Centrality>60. && Centrality<70.) CenBin=7;
  if (Centrality>70. && Centrality<80.) CenBin=8;
  if (Centrality>80. && Centrality<90.) CenBin=9;
  if (Centrality>90. && Centrality<100.) CenBin=10;
  if (CenBin>=fCRCnCen) CenBin=-1;
  if (fCRCnCen==1) CenBin=0;
  return CenBin;
} // end of AliFlowAnalysisCRC::GetCRCCenBin(Double_t Centrality)

//=======================================================================================================================

Int_t AliFlowAnalysisCRC::GetWideCenBin(Double_t Centrality)
{
  Int_t CenBin=-1;
  if (Centrality>0. && Centrality<=20.) CenBin=0;
  if (Centrality>20. && Centrality<=40.) CenBin=1;
  if (Centrality>40. && Centrality<=60.) CenBin=2;
  if (Centrality>60. && Centrality<=80.) CenBin=3;
  return CenBin;
} // end of AliFlowAnalysisCRC::GetCRCCenBin(Double_t Centrality)

//=======================================================================================================================

void AliFlowAnalysisCRC::RecenterCRCQVec()
{
  // fill profiles uncorrected q-vectors
  for(Int_t h=0;h<fCRCnHar;h++) {
    Double_t Q2Re=0., Q2Im=0., QM=0.;
    for(Int_t pt=1; pt<=fPtDiffNBins; pt++) {
      Q2Re += fPOIPtDiffQRe[1][h]->GetBinContent(pt);
      Q2Im += fPOIPtDiffQIm[1][h]->GetBinContent(pt);
      QM   += fPOIPtDiffMul[1][h]->GetBinContent(pt);
    }

    if(QM>0) {
      fCRCQnRe[fRunBin][h]->Fill(fCentralityEBE,Q2Re);
      fCRCQnIm[fRunBin][h]->Fill(fCentralityEBE,Q2Im);
    }

//    if(!fCRCQVecWeightsList) {
//      cout << " WARNING: no weights provided for Q vector recentering !!! " << endl;
//      return;
//    }
//
//    if(fRunNum!=fCachedRunNum) {
//      fTPCQHist[h][0] = (TProfile*)(fCRCQVecWeightsList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fTPCQnRe[%d][%d]",fRunNum,h)));
//      fTPCQHist[h][1] = (TProfile*)(fCRCQVecWeightsList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fTPCQnIm[%d][%d]",fRunNum,h)));
//    }

    if (!fTPCQHist[h][0] || !fTPCQHist[h][1]) continue;

    Double_t AvQ2Re = fTPCQHist[h][0]->GetBinContent(fTPCQHist[h][0]->FindBin(fCentralityEBE));
    // Double_t SDQ2Re = fTPCQHist[h][0]->GetBinError(fTPCQHist[h][0]->FindBin(fCentralityEBE));
    Double_t AvQ2Im = fTPCQHist[h][1]->GetBinContent(fTPCQHist[h][1]->FindBin(fCentralityEBE));
    // Double_t SDQ2Im = fTPCQHist[h][1]->GetBinError(fTPCQHist[h][1]->FindBin(fCentralityEBE));

    if(AvQ2Re && AvQ2Im && QM>0) {
      Double_t Q2ReR = Q2Re-AvQ2Re;
      Double_t Q2ImR = Q2Im-AvQ2Im;
      //        if(fDivSigma && SDQ2Re>0. && SDQ2Im>0.) {
      //          Q2ReR /= SDQ2Re;
      //          Q2ImR /= SDQ2Im;
      //        }
      fTPCQnRecenter[h].Set(Q2ReR,Q2ImR);
      fCRCQnReCorr[fRunBin][h]->Fill(fCentralityEBE,Q2ReR);
      fCRCQnImCorr[fRunBin][h]->Fill(fCentralityEBE,Q2ImR);
    }

  }

} // end of AliFlowAnalysisCRC::RecenterCRCQVec()

//=======================================================================================================================

void AliFlowAnalysisCRC::RecenterCRCQVecVZERO()
{
  if(!fCRCVZEROCalibList) {
    cout << " WARNING: no weights provided for VZERO recentering !!! " << endl;
    return;
  }

  if(fRunNum!=fCachedRunNum) {
    for(Int_t k=0; k<3; k++) {
      fVZEROCenHist[k] = (TProfile2D*)(fCRCVZEROCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCVZEROQVec[%d][%d]",fRunNum,k)));
    }
  }

  for(Int_t k=0; k<3; k++) {
    // ZDCN-C
    Double_t QCRe = fVZFlowVect[0][k].X();
    Double_t QCIm = fVZFlowVect[0][k].Y();
    Double_t QMC  = fVZFlowVect[0][k].GetMult();
    // ZDCN-A
    Double_t QARe = fVZFlowVect[1][k].X();
    Double_t QAIm = fVZFlowVect[1][k].Y();
    Double_t QMA  = fVZFlowVect[1][k].GetMult();

    Double_t QCReR=QCRe, QCImR=QCIm, QAReR=QARe, QAImR=QAIm;
    if(QMC<1. || QMA < 1.) return;

    // recenter vs centrality
    if (fVZEROCenHist[k]) {
      Double_t AvQCRe = fVZEROCenHist[k]->GetBinContent(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      // Double_t SDQCRe = fVZEROCenHist[k]->GetBinError(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      Double_t AvQCIm = fVZEROCenHist[k]->GetBinContent(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      // Double_t SDQCIm = fVZEROCenHist[k]->GetBinError(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));

      Double_t AvQARe = fVZEROCenHist[k]->GetBinContent(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      // Double_t SDQARe = fVZEROCenHist[k]->GetBinError(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      Double_t AvQAIm = fVZEROCenHist[k]->GetBinContent(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));
      // Double_t SDQAIm = fVZEROCenHist[k]->GetBinError(fVZEROCenHist[k]->FindBin((Double_t)k+0.5,fCentralityEBE));

      if(std::isfinite(AvQCRe) && std::isfinite(AvQCIm)) {
        QCReR = QCRe-AvQCRe;
        QCImR = QCIm-AvQCIm;
//        if(SDQCRe>0. && SDQCIm>0.) {
//          QCReR /= SDQCRe;
//          QCImR /= SDQCIm;
//        }
        fVZFlowVect[0][k].Set(QCReR,QCImR);
      }

      if(std::isfinite(AvQCRe) && std::isfinite(AvQCIm)) {
        QAReR = QARe-AvQARe;
        QAImR = QAIm-AvQAIm;
//        if(SDQARe>0. && SDQAIm>0.) {
//          QAReR /= SDQARe;
//          QAImR /= SDQAIm;
//        }
        fVZFlowVect[1][k].Set(QAReR,QAImR);
      }
    }
  }

}

//=======================================================================================================================

void AliFlowAnalysisCRC::RecenterCRCQVecZDC()
{
  if(!fCRCZDCCalibList) {
    cout << " WARNING: no weights provided for ZDC recentering !!! " << endl;
    return;
  }

  Int_t qb[4] = {0};
  if(fbFlagIsPosMagField) { qb[0]=0; qb[1]=1; qb[2]=4; qb[3]=5; }
  else                    { qb[0]=2; qb[1]=3; qb[2]=6; qb[3]=7; }
  Int_t bw = (fbFlagIsPosMagField==kTRUE?0:1);

  if(fRunNum!=fCachedRunNum) {
    fZDCQHist[0] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecC[%d][%d]",fRunNum,0)));
    fZDCQHist[1] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecC[%d][%d]",fRunNum,1)));
    fZDCQHist[2] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecA[%d][%d]",fRunNum,0)));
    fZDCQHist[3] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecA[%d][%d]",fRunNum,1)));
    fZDCQHist[4] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecCCorr[%d][%d]",fRunNum,0)));
    fZDCQHist[5] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecCCorr[%d][%d]",fRunNum,1)));
    fZDCQHist[6] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecACorr[%d][%d]",fRunNum,0)));
    fZDCQHist[7] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecACorr[%d][%d]",fRunNum,1)));
    fZDCQHist[8] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecCAdd[%d][%d]",fRunNum,0)));
    fZDCQHist[9] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecCAdd[%d][%d]",fRunNum,1)));
    fZDCQHist[10] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecAAdd[%d][%d]",fRunNum,0)));
    fZDCQHist[11] = (TProfile*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecAAdd[%d][%d]",fRunNum,1)));

    for(Int_t k=0; k<4; k++) {
      fZDCVtxHist[k] = (TProfile3D*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecVtxPos540[%d][%d]",fRunNum,k)));

      fZDCEcomHist[k] = (TProfile2D*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecECom[%d][%d]",fRunNum,k)));
      fZDCEcomTotHist[k] = (TProfile2D*)(fCRCZDCCalibList->FindObject(Form("fCRCZDCQVecEComTot[%d]",k)));
    }
    for(Int_t k=0; k<12; k++) {
      fZDCEcomTotvsVtxHist[k] = (TProfile3D*)(fCRCZDCCalibList->FindObject(Form("fCRCZDCQVecEComTotVtx[%d]",k)));
    }

    for(Int_t c=0; c<10; c++) {
      for(Int_t k=0; k<4; k++) {
        fZDCVtxCenHist[c][k] = (TProfile3D*)(fCRCZDCCalibList->FindObject(Form("fCRCZDCQVecVtxPosCen[%d][%d]",c,k)));
      }
    }

    if(fCRCZDCResList) {
      // ZNC
      fZDCResHist[0] = (TH1D*)(fCRCZDCResList->FindObject(Form("fZNPhase[%d][%d]",fRunNum,0)));
      fZDCResHist[1] = (TH1D*)(fCRCZDCResList->FindObject(Form("fZNRatio[%d][%d]",fRunNum,0)));
      // ZNA
      fZDCResHist[2] = (TH1D*)(fCRCZDCResList->FindObject(Form("fZNPhase[%d][%d]",fRunNum,1)));
      fZDCResHist[3] = (TH1D*)(fCRCZDCResList->FindObject(Form("fZNRatio[%d][%d]",fRunNum,1)));
    }

     for(Int_t k=0; k<4; k++) {
       fZDCVtxFitHist[k] = (TH3D*)fCRCZDCCalibList->FindObject(Form("TH3SlopeRunCenVtx[%d]",k));
       if(fZDCVtxFitHist[k]) {
         fZDCVtxFitHist[k]->Sumw2(kFALSE);
         Int_t runbin = fZDCVtxFitHist[k]->GetXaxis()->FindBin(Form("%d",fRunNum));
         fZDCVtxFitHist[k]->GetXaxis()->SetRange(runbin,runbin);
         for(Int_t i=0; i<3; i++) {
           fZDCVtxFitHist[k]->GetZaxis()->SetRange(i+1,i+1);
           fZDCVtxFitCenProjHist[k][i] = (TH1D*)fZDCVtxFitHist[k]->Project3D("y")->Clone(Form("proj[%d][%d]",k,i));
         }
       }
     }
    for(Int_t k=0; k<4; k++) {
      fZDCVtxFitHist2[k] = (TH3D*)fCRCZDCCalibList->FindObject(Form("TH3SlopePol3RunVtx[%d]",k));
      if(fZDCVtxFitHist2[k]) {
        fZDCVtxFitHist2[k]->Sumw2(kFALSE);
        Int_t runbin = fZDCVtxFitHist2[k]->GetXaxis()->FindBin(Form("%d",fRunNum));
        fZDCVtxFitHist2[k]->GetXaxis()->SetRange(runbin,runbin);
        for(Int_t i=0; i<3; i++) {
          fZDCVtxFitHist2[k]->GetZaxis()->SetRange(i+1,i+1);
          fZDCVtxFitCenProjHist2[k][i] = (TH1D*)fZDCVtxFitHist2[k]->Project3D("y")->Clone(Form("proj2[%d][%d]",k,i));
        }
      }
    }
    for(Int_t c=0; c<10; c++) {
      for(Int_t k=0; k<8; k++) {
        fZDCVtxCenHistMagPol[c][k] = (TProfile3D*)(fCRCZDCCalibList->FindObject(Form("fZDCVtxCenHistMagPol[%d][%d]",c,k)));
      }
    }
    for(Int_t c=0; c<10; c++) {
      fZDCBinsCenRefMult[c] = (TH3D*)(fCRCZDCCalibList->FindObject(Form("ZDCQVecCenRefMul[%d]",c)));
    }
    for(Int_t k=0; k<4; k++) {
      fZDCBinsCenRefMultRbR[k] = (TProfile2D*)(fCRCZDCCalibList->FindObject(Form("Run %d",fRunNum))->FindObject(Form("fCRCZDCQVecCenRefMul[%d][%d]",fRunNum,k)));
      if(fZDCBinsCenRefMultRbR[k]) {
        for(Int_t c=0; c<10; c++) {
          fZDCBinsCenRefMultRbRProf[c][k] = (TProfile*)fZDCBinsCenRefMultRbR[k]->ProfileY(Form("posrbr%d%d",c,k),c+1,c+1)->Clone(Form("posrbr%d%d",c,k));
          Int_t nFullBin=0;
          for (Int_t bx=0; bx<fZDCBinsCenRefMultRbRProf[c][k]->GetNbinsX(); bx++) {
            if(fabs(fZDCBinsCenRefMultRbRProf[c][k]->GetBinContent(bx))>0.) nFullBin++;
          }
          if(nFullBin>10) {
            Int_t rebn = (Int_t)nFullBin/10.;
            fZDCBinsCenRefMultRbRProf[c][k]->Rebin(rebn+1);
          }
          fZDCBinsCenRefMultRbRProj[c][k] = (TH1D*)fZDCBinsCenRefMultRbRProf[c][k]->Clone(Form("poshisrbr%d%d",c,k));
        }
      }
    }
    for(Int_t k=0; k<4; k++) {
      fZDCBinsCenRefMultTot[k] = (TProfile2D*)(fCRCZDCCalibList->FindObject(Form("fCRCZDCQVecCenRefMulTot[%d][%d]",bw,k)));
      if(fZDCBinsCenRefMultTot[k]) {
        for(Int_t c=0; c<10; c++) {
          fZDCBinsCenRefMultTotProf[c][k] = (TProfile*)fZDCBinsCenRefMultTot[k]->ProfileY(Form("postot%d%d",c,k),c+1,c+1)->Clone(Form("postot%d%d",c,k));
          Int_t nFullBin=0;
          for (Int_t bx=0; bx<fZDCBinsCenRefMultTotProf[c][k]->GetNbinsX(); bx++) {
            if(fabs(fZDCBinsCenRefMultTotProf[c][k]->GetBinContent(bx))>0.) nFullBin++;
          }
          if(nFullBin>10) {
            Int_t rebn = (Int_t)nFullBin/10.;
            fZDCBinsCenRefMultTotProf[c][k]->Rebin(rebn+1);
          }
          fZDCBinsCenRefMultTotProj[c][k] = (TH1D*)fZDCBinsCenRefMultTotProf[c][k]->Clone(Form("poshistot%d%d",c,k));
        }
      }
    }

    for(Int_t i=0; i<3; i++) {
      for(Int_t k=0; k<4; k++) {
        fZDCBinsVtxCenEZDC[i][k] = (TH3D*)(fCRCZDCCalibList->FindObject(Form("ZDCQVecVtxCenEZDC[%d][%d]",i,qb[k])));
      }
    }
    fZDCQVecVtxCenEZDCFit0 = (TH3D*)(fCRCZDCCalibList->FindObject("ZDCQVecVtxCenEZDCFit0"));
    fZDCQVecVtxCenEZDCFit1 = (TH3D*)(fCRCZDCCalibList->FindObject("ZDCQVecVtxCenEZDCFit1"));

    for(Int_t i=0; i<10; i++) {
      for(Int_t z=0; z<10; z++) {
        for(Int_t k=0; k<4; k++) {
          fZDCQVecVtxCenEZDC3D[i][z][k] = (TH3D*)(fCRCZDCCalibList->FindObject(Form("ZDCQVecVtxCenEZDC3D[%d][%d][%d]",i,z,qb[k])));
        }
      }
    }

  }

  if(!fQAZDCCutsFlag) return;

  // ZDCN-C
  Double_t QCRe = fZDCFlowVect[0].X();
  Double_t QCIm = fZDCFlowVect[0].Y();
  Double_t QMC  = fZDCFlowVect[0].GetMult();
  // ZDCN-A
  Double_t QARe = fZDCFlowVect[1].X();
  Double_t QAIm = fZDCFlowVect[1].Y();
  Double_t QMA  = fZDCFlowVect[1].GetMult();

  // get re-centered QM*
  Double_t QMCrec = QMC;
  Double_t QMArec = QMA;
  if(fAvEZDCCRbRPro && fAvEZDCARbRPro) {
    Int_t runbin = fAvEZDCCRbRPro->GetXaxis()->FindBin(Form("%d",fRunNum));
    Int_t cenbin = fAvEZDCCRbRPro->GetYaxis()->FindBin(fCentralityEBE);
    QMCrec -= fAvEZDCCRbRPro->GetBinContent(runbin,cenbin);
    QMArec -= fAvEZDCARbRPro->GetBinContent(runbin,cenbin);
  }

  Double_t QCReR=QCRe, QCImR=QCIm, QAReR=QARe, QAImR=QAIm;

  Double_t fillstep=0.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // recenter vs centrality
  if (fZDCQHist[0]) {
    Double_t AvQCRe = fZDCQHist[0]->GetBinContent(fZDCQHist[0]->FindBin(fCentralityEBE));
    Double_t SDQCRe = fZDCQHist[0]->GetBinError(fZDCQHist[0]->FindBin(fCentralityEBE));
    Double_t AvQCIm = fZDCQHist[1]->GetBinContent(fZDCQHist[1]->FindBin(fCentralityEBE));
    Double_t SDQCIm = fZDCQHist[1]->GetBinError(fZDCQHist[1]->FindBin(fCentralityEBE));

    Double_t AvQARe = fZDCQHist[2]->GetBinContent(fZDCQHist[2]->FindBin(fCentralityEBE));
    Double_t SDQARe = fZDCQHist[2]->GetBinError(fZDCQHist[2]->FindBin(fCentralityEBE));
    Double_t AvQAIm = fZDCQHist[3]->GetBinContent(fZDCQHist[3]->FindBin(fCentralityEBE));
    Double_t SDQAIm = fZDCQHist[3]->GetBinError(fZDCQHist[3]->FindBin(fCentralityEBE));

    if(AvQCRe && AvQCIm && QMC>0. && sqrt(QCRe*QCRe+QCIm*QCIm)>1.E-6) {
      QCReR = QCRe-AvQCRe;
      QCImR = QCIm-AvQCIm;
      if(fDivSigma && SDQCRe>0. && SDQCIm>0.) {
        QCReR /= SDQCRe;
        QCImR /= SDQCIm;
      }
      fZDCFlowVect[0].Set(QCReR,QCImR);
    }

    if(AvQARe && AvQAIm && QMA>0. && sqrt(QARe*QARe+QAIm*QAIm)>1.E-6) {
      QAReR = QARe-AvQARe;
      QAImR = QAIm-AvQAIm;
      if(fDivSigma && SDQARe>0. && SDQAIm>0.) {
        QAReR /= SDQARe;
        QAImR /= SDQAIm;
      }
      fZDCFlowVect[1].Set(QAReR,QAImR);
    }
  }

  fillstep=1.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  Bool_t pass = kTRUE;

  if(!fZDCVtxCenHist[fCenBin][0]) {
//    if(fCentralityEBE>5. && fCentralityEBE<60.) {
//      if(QMC>0. && sqrt(QCRe*QCRe+QCIm*QCIm)>1.E-6) {
//        fCRCZDCQVecVtxPos[fRunBin][0]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
//        fCRCZDCQVecVtxPos[fRunBin][1]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
//      }
//      if(QMA>0. && sqrt(QARe*QARe+QAIm*QAIm)>1.E-6) {
//        fCRCZDCQVecVtxPos[fRunBin][2]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
//        fCRCZDCQVecVtxPos[fRunBin][3]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
//      }
//    }
  }

  if (fZDCVtxCenHist[fCenBin][0]) {
    Bool_t withinvtx = kTRUE;
      // method #2: recenter vs vtx in centrality bins
    if(fVtxPosCor[0] < fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetXmin() || fVtxPosCor[0] > fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetXmax()) withinvtx = kFALSE;
    if(fVtxPosCor[1] < fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmin() || fVtxPosCor[1] > fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmax()) withinvtx = kFALSE;
    if(fVtxPosCor[2] < fZDCVtxCenHist[fCenBin][0]->GetZaxis()->GetXmin() || fVtxPosCor[2] > fZDCVtxCenHist[fCenBin][0]->GetZaxis()->GetXmax()) withinvtx = kFALSE;

    if(withinvtx) {
      QCReR -= fZDCVtxCenHist[fCenBin][0]->GetBinContent(fZDCVtxCenHist[fCenBin][0]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QCImR -= fZDCVtxCenHist[fCenBin][1]->GetBinContent(fZDCVtxCenHist[fCenBin][1]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      fZDCFlowVect[0].Set(QCReR,QCImR);
      QAReR -= fZDCVtxCenHist[fCenBin][2]->GetBinContent(fZDCVtxCenHist[fCenBin][2]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QAImR -= fZDCVtxCenHist[fCenBin][3]->GetBinContent(fZDCVtxCenHist[fCenBin][3]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      fZDCFlowVect[1].Set(QAReR,QAImR);
    } else {
      Double_t vx = fVtxPosCor[0];
      Double_t vy = fVtxPosCor[1];
      Double_t vz = fVtxPosCor[2];
      if(fVtxPosCor[0] < fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetXmin()) vx = fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetBinCenter(1);
      if(fVtxPosCor[0] > fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetXmax()) vx = fZDCVtxCenHist[fCenBin][0]->GetXaxis()->GetBinCenter(fZDCVtxCenHist[fCenBin][0]->GetNbinsX());
      if(fVtxPosCor[1] < fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmin()) vy = fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetBinCenter(1);
      if(fVtxPosCor[1] > fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmax()) vy = fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetBinCenter(fZDCVtxCenHist[fCenBin][0]->GetNbinsY());
      if(fVtxPosCor[2] < fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmin()) vz = fZDCVtxCenHist[fCenBin][0]->GetZaxis()->GetBinCenter(1);
      if(fVtxPosCor[2] > fZDCVtxCenHist[fCenBin][0]->GetYaxis()->GetXmax()) vz = fZDCVtxCenHist[fCenBin][0]->GetZaxis()->GetBinCenter(fZDCVtxCenHist[fCenBin][0]->GetNbinsZ());
      QCReR -= fZDCVtxCenHist[fCenBin][0]->GetBinContent(fZDCVtxCenHist[fCenBin][0]->FindBin(vx,vy,vz));
      QCImR -= fZDCVtxCenHist[fCenBin][1]->GetBinContent(fZDCVtxCenHist[fCenBin][1]->FindBin(vx,vy,vz));
      fZDCFlowVect[0].Set(QCReR,QCImR);
      QAReR -= fZDCVtxCenHist[fCenBin][2]->GetBinContent(fZDCVtxCenHist[fCenBin][2]->FindBin(vx,vy,vz));
      QAImR -= fZDCVtxCenHist[fCenBin][3]->GetBinContent(fZDCVtxCenHist[fCenBin][3]->FindBin(vx,vy,vz));
      fZDCFlowVect[1].Set(QAReR,QAImR);
    }
  }

  fillstep=2.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // intermediate step: save vtx pos run-by-run
  //    if(fCentralityEBE>5. && fCentralityEBE<60.) {
  //      if(QMC>0. && sqrt(QCRe*QCRe+QCIm*QCIm)>1.E-6) {
  //        fCRCZDCQVecVtxPos[fRunBin][0]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
  //        fCRCZDCQVecVtxPos[fRunBin][1]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
  //      }
  //      if(QMA>0. && sqrt(QARe*QARe+QAIm*QAIm)>1.E-6) {
  //        fCRCZDCQVecVtxPos[fRunBin][2]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
  //        fCRCZDCQVecVtxPos[fRunBin][3]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
  //      }
  //    }

  // correct vs vtx vs run number in centrality 5-40% (only for 15opidfix)
  if (fZDCVtxHist[0]) {
    // check if possible to interpolate
    Bool_t bInterp = kTRUE;
    Int_t bx = fZDCVtxHist[0]->GetXaxis()->FindBin(fVtxPosCor[0]);
    Int_t by = fZDCVtxHist[0]->GetYaxis()->FindBin(fVtxPosCor[1]);
    Int_t bz = fZDCVtxHist[0]->GetZaxis()->FindBin(fVtxPosCor[2]);
    if(bx==1 || bx==fZDCVtxHist[0]->GetXaxis()->GetNbins()) bInterp = kFALSE;
    if(by==1 || by==fZDCVtxHist[0]->GetYaxis()->GetNbins()) bInterp = kFALSE;
    if(bz==1 || bz==fZDCVtxHist[0]->GetZaxis()->GetNbins()) bInterp = kFALSE;
    if(bInterp) {
      QCReR -= fZDCVtxHist[0]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
      QCImR -= fZDCVtxHist[1]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
      QAReR -= fZDCVtxHist[2]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
      QAImR -= fZDCVtxHist[3]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
    } else {
      QCReR -= fZDCVtxHist[0]->GetBinContent(bx,by,bz);
      QCImR -= fZDCVtxHist[1]->GetBinContent(bx,by,bz);
      QAReR -= fZDCVtxHist[2]->GetBinContent(bx,by,bz);
      QAImR -= fZDCVtxHist[3]->GetBinContent(bx,by,bz);
    }
    fZDCFlowVect[0].Set(QCReR,QCImR);
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=3.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  //    Int_t EPCenBin = fCRCZDCQVecEP[fRunBin][0]->GetXaxis()->FindBin(fCentralityEBE)-1;
  //    if (fZDCEPHist[EPCenBin][0]) {
  //      Double_t EvPlZDCC = TMath::ATan2(QCImR,QCReR);
  //      fZDCEPweightEbE[0] = fZDCEPHist[EPCenBin][0]->GetBinContent(fZDCEPHist[EPCenBin][0]->FindBin(EvPlZDCC));
  //      Double_t EvPlZDCA = TMath::ATan2(QAImR,QAReR);
  //      fZDCEPweightEbE[1] = fZDCEPHist[EPCenBin][1]->GetBinContent(fZDCEPHist[EPCenBin][1]->FindBin(EvPlZDCA));
  //      Double_t EvPlZDCfull = TMath::ATan2(QAImR-QCImR,-QAReR-QCReR); // WARNING: fInvertZDC implicit
  //      fZDCEPweightEbE[2] = fZDCEPHist[EPCenBin][2]->GetBinContent(fZDCEPHist[EPCenBin][2]->FindBin(EvPlZDCfull));
  //    }
  //    for (Int_t k=0; k<3; k++) {
  //      if(fZDCEPweightEbE[k]==0) fZDCEPweightEbE[k]=1.;
  //    }

  //  // store cos/sin terms of event planes
  //  if(QMC>0. && sqrt(QCRe*QCRe+QCIm*QCIm)>1.E-6) {
  //    Double_t EvPlZDCC = TMath::ATan2(QCImR,QCReR);
  //    fCRCZDCQVecRes[fRunBin][4]->Fill(fCentralityEBE,cos(2.*EvPlZDCC));
  //    fCRCZDCQVecRes[fRunBin][5]->Fill(fCentralityEBE,sin(2.*EvPlZDCC));
  //  }
  //  if(QMA>0. && sqrt(QARe*QARe+QAIm*QAIm)>1.E-6) {
  //    Double_t EvPlZDCA = TMath::ATan2(QAImR,QAReR);
  //    fCRCZDCQVecRes[fRunBin][6]->Fill(fCentralityEBE,cos(2.*EvPlZDCA));
  //    fCRCZDCQVecRes[fRunBin][7]->Fill(fCentralityEBE,sin(2.*EvPlZDCA));
  //  }

  // rotate, correct, rotate back
  if(fZDCResHist[0] && fZDCResHist[1] && fZDCResHist[2] && fZDCResHist[3]) {
    // ZNA
    Double_t thetaC = fZDCResHist[0]->GetBinContent(fZDCResHist[0]->FindBin(fCentralityEBE));
    Double_t corrfC = fZDCResHist[1]->GetBinContent(fZDCResHist[1]->FindBin(fCentralityEBE));
    // ZNC
    Double_t thetaA = fZDCResHist[2]->GetBinContent(fZDCResHist[2]->FindBin(fCentralityEBE));
    Double_t corrfA = fZDCResHist[3]->GetBinContent(fZDCResHist[3]->FindBin(fCentralityEBE));

    if(corrfC>0. && corrfA>0.) {
      Double_t QCReRt = TMath::Cos(thetaC)*QCReR - TMath::Sin(thetaC)*QCImR;
      Double_t QCImRt = TMath::Sin(thetaC)*QCReR + TMath::Cos(thetaC)*QCImR;
      Double_t QAReRt = TMath::Cos(thetaA)*QAReR - TMath::Sin(thetaA)*QAImR;
      Double_t QAImRt = TMath::Sin(thetaA)*QAReR + TMath::Cos(thetaA)*QAImR;

      QCReRt /= corrfC;
      QAReRt /= corrfA;

      QCReR = TMath::Cos(-thetaC)*QCReRt - TMath::Sin(-thetaC)*QCImRt;
      QCImR = TMath::Sin(-thetaC)*QCReRt + TMath::Cos(-thetaC)*QCImRt;
      QAReR = TMath::Cos(-thetaA)*QAReRt - TMath::Sin(-thetaA)*QAImRt;
      QAImR = TMath::Sin(-thetaA)*QAReRt + TMath::Cos(-thetaA)*QAImRt;
    }
  }

  // if possible, correct Q-vectors vs Energy in the common tower
//  if(fZDCEcomHist[0]) {
//    QCReR -= fZDCEcomHist[0]->GetBinContent(fZDCEcomHist[0]->FindBin(fCentralityEBE,fZNCQ0));
//    QCImR -= fZDCEcomHist[1]->GetBinContent(fZDCEcomHist[1]->FindBin(fCentralityEBE,fZNCQ0));
//    fZDCFlowVect[0].Set(QCReR,QCImR);
//    QAReR -= fZDCEcomHist[2]->GetBinContent(fZDCEcomHist[2]->FindBin(fCentralityEBE,fZNAQ0));
//    QAImR -= fZDCEcomHist[3]->GetBinContent(fZDCEcomHist[3]->FindBin(fCentralityEBE,fZNAQ0));
//    fZDCFlowVect[1].Set(QAReR,QAImR);
//  }
  if(fZDCEcomTotHist[0]) {
    QCReR -= fZDCEcomTotHist[0]->GetBinContent(fZDCEcomTotHist[0]->FindBin(fCentralityEBE,fZNCQ0));
    QCImR -= fZDCEcomTotHist[1]->GetBinContent(fZDCEcomTotHist[1]->FindBin(fCentralityEBE,fZNCQ0));
    fZDCFlowVect[0].Set(QCReR,QCImR);
    QAReR -= fZDCEcomTotHist[2]->GetBinContent(fZDCEcomTotHist[2]->FindBin(fCentralityEBE,fZNAQ0));
    QAImR -= fZDCEcomTotHist[3]->GetBinContent(fZDCEcomTotHist[3]->FindBin(fCentralityEBE,fZNAQ0));
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=4.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  if(fZDCEcomTotvsVtxHist[0]) {
    QCReR -= fZDCEcomTotvsVtxHist[0]->GetBinContent(fZDCEcomTotvsVtxHist[0]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[0]));
    QCImR -= fZDCEcomTotvsVtxHist[1]->GetBinContent(fZDCEcomTotvsVtxHist[1]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[0]));
    QCReR -= fZDCEcomTotvsVtxHist[4]->GetBinContent(fZDCEcomTotvsVtxHist[4]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[1]));
    QCImR -= fZDCEcomTotvsVtxHist[5]->GetBinContent(fZDCEcomTotvsVtxHist[5]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[1]));
    QCReR -= fZDCEcomTotvsVtxHist[8]->GetBinContent(fZDCEcomTotvsVtxHist[8]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[2]));
    QCImR -= fZDCEcomTotvsVtxHist[9]->GetBinContent(fZDCEcomTotvsVtxHist[9]->FindBin(fCentralityEBE,fZNCQ0,fVtxPosCor[2]));
    fZDCFlowVect[0].Set(QCReR,QCImR);
    QAReR -= fZDCEcomTotvsVtxHist[2]->GetBinContent(fZDCEcomTotvsVtxHist[2]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[0]));
    QAImR -= fZDCEcomTotvsVtxHist[3]->GetBinContent(fZDCEcomTotvsVtxHist[3]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[0]));
    QAReR -= fZDCEcomTotvsVtxHist[6]->GetBinContent(fZDCEcomTotvsVtxHist[6]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[1]));
    QAImR -= fZDCEcomTotvsVtxHist[7]->GetBinContent(fZDCEcomTotvsVtxHist[7]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[1]));
    QAReR -= fZDCEcomTotvsVtxHist[10]->GetBinContent(fZDCEcomTotvsVtxHist[10]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[2]));
    QAImR -= fZDCEcomTotvsVtxHist[11]->GetBinContent(fZDCEcomTotvsVtxHist[11]->FindBin(fCentralityEBE,fZNAQ0,fVtxPosCor[2]));
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=5.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // store Q-vectors vs Energy in the common tower
  if(QMC>0. && QMA>0. && sqrt(QCRe*QCRe+QCIm*QCIm)>1.E-6 && sqrt(QARe*QARe+QAIm*QAIm)>1.E-6) {
//    fCRCZDCQVecECom[fRunBin][0]->Fill(fCentralityEBE,fZNCQ0,QCReR);
//    fCRCZDCQVecECom[fRunBin][1]->Fill(fCentralityEBE,fZNCQ0,QCImR);
//    fCRCZDCQVecECom[fRunBin][2]->Fill(fCentralityEBE,fZNAQ0,QAReR);
//    fCRCZDCQVecECom[fRunBin][3]->Fill(fCentralityEBE,fZNAQ0,QAImR);
//    fCRCZDCQVecEComTot[0]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[0],QCReR);
//    fCRCZDCQVecEComTot[1]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[0],QCImR);
//    fCRCZDCQVecEComTot[2]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[0],QAReR);
//    fCRCZDCQVecEComTot[3]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[0],QAImR);
//    fCRCZDCQVecEComTot[4]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[1],QCReR);
//    fCRCZDCQVecEComTot[5]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[1],QCImR);
//    fCRCZDCQVecEComTot[6]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[1],QAReR);
//    fCRCZDCQVecEComTot[7]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[1],QAImR);
//    fCRCZDCQVecEComTot[8]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[2],QCReR);
//    fCRCZDCQVecEComTot[9]->Fill(fCentralityEBE,fZNCQ0,fVtxPosCor[2],QCImR);
//    fCRCZDCQVecEComTot[10]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[2],QAReR);
//    fCRCZDCQVecEComTot[11]->Fill(fCentralityEBE,fZNAQ0,fVtxPosCor[2],QAImR);
  }

  // final recentering vs centrality (if needed)
  if (fZDCQHist[4]) {
    //      Double_t EvPlZDCC = TMath::ATan2(QCImR,QCReR);
    //      Double_t AvCos2C = fZDCFitSec[0]->Eval(fCentralityEBE);
    //      Double_t AvSin2C = fZDCFitSec[1]->Eval(fCentralityEBE);
    //      EvPlZDCC += -AvSin2C*cos(2.*EvPlZDCC) + AvCos2C*sin(2.*EvPlZDCC);
    //      if(EvPlZDCC<-TMath::Pi()) EvPlZDCC += TMath::TwoPi();
    //      if(EvPlZDCC> TMath::Pi()) EvPlZDCC -= TMath::TwoPi();
    //      fZDCFlowVect[0].SetMagPhi(sqrt(QCReR*QCReR+QCImR*QCImR),EvPlZDCC,QMC);
    //      QCReR = fZDCFlowVect[0].X();
    //      QCImR = fZDCFlowVect[0].Y();
    //
    //      Double_t EvPlZDCA = TMath::ATan2(QAImR,QAReR);
    //      Double_t AvCos2A = fZDCFitSec[2]->Eval(fCentralityEBE);
    //      Double_t AvSin2A = fZDCFitSec[3]->Eval(fCentralityEBE);
    //      EvPlZDCA += -AvSin2A*cos(2.*EvPlZDCA) + AvCos2A*sin(2.*EvPlZDCA);
    //      if(EvPlZDCA<-TMath::Pi()) EvPlZDCA += TMath::TwoPi();
    //      if(EvPlZDCA> TMath::Pi()) EvPlZDCA -= TMath::TwoPi();
    //      fZDCFlowVect[1].SetMagPhi(sqrt(QAReR*QAReR+QAImR*QAImR),EvPlZDCA,QMA);
    //      QAReR = fZDCFlowVect[1].X();
    //      QAImR = fZDCFlowVect[1].Y();

    Double_t AvQCRe = fZDCQHist[4]->GetBinContent(fZDCQHist[4]->FindBin(fCentralityEBE));
    Double_t AvQCIm = fZDCQHist[5]->GetBinContent(fZDCQHist[5]->FindBin(fCentralityEBE));

    Double_t AvQARe = fZDCQHist[6]->GetBinContent(fZDCQHist[6]->FindBin(fCentralityEBE));
    Double_t AvQAIm = fZDCQHist[7]->GetBinContent(fZDCQHist[7]->FindBin(fCentralityEBE));

    QCReR -= AvQCRe;
    QCImR -= AvQCIm;
    fZDCFlowVect[0].Set(QCReR,QCImR);

    QAReR -= AvQARe;
    QAImR -= AvQAIm;
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=6.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // recenter vs vtx vs cen vs run number (through fits)

  if(fZDCVtxFitHist[0]) {
    for (Int_t i=0; i<3; i++) {
      QCReR -= fVtxPosCor[i]*fZDCVtxFitCenProjHist[0][i]->Interpolate(fCentralityEBE);
      QCImR -= fVtxPosCor[i]*fZDCVtxFitCenProjHist[1][i]->Interpolate(fCentralityEBE);
      QAReR -= fVtxPosCor[i]*fZDCVtxFitCenProjHist[2][i]->Interpolate(fCentralityEBE);
      QAImR -= fVtxPosCor[i]*fZDCVtxFitCenProjHist[3][i]->Interpolate(fCentralityEBE);
    }
    fZDCFlowVect[0].Set(QCReR,QCImR);
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=7.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // second iteration (2D)

  if (fZDCVtxCenHistMagPol[fCenBin][0]) {
    if(fbFlagIsPosMagField) {
      QCReR -= fZDCVtxCenHistMagPol[fCenBin][0]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][0]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QCImR -= fZDCVtxCenHistMagPol[fCenBin][1]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][1]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QAReR -= fZDCVtxCenHistMagPol[fCenBin][4]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][4]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QAImR -= fZDCVtxCenHistMagPol[fCenBin][5]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][5]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
    } else {
      QCReR -= fZDCVtxCenHistMagPol[fCenBin][2]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][2]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QCImR -= fZDCVtxCenHistMagPol[fCenBin][3]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][3]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QAReR -= fZDCVtxCenHistMagPol[fCenBin][6]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][6]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
      QAImR -= fZDCVtxCenHistMagPol[fCenBin][7]->GetBinContent(fZDCVtxCenHistMagPol[fCenBin][7]->FindBin(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]));
    }
    fZDCFlowVect[0].Set(QCReR,QCImR);
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=8.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  if(fZDCVtxFitHist2[0]) {
    for (Int_t i=0; i<3; i++) {
      Double_t c1 = fZDCVtxFitCenProjHist2[0][i]->GetBinContent(1);
      Double_t c2 = fZDCVtxFitCenProjHist2[0][i]->GetBinContent(2);
      Double_t c3 = fZDCVtxFitCenProjHist2[0][i]->GetBinContent(3);
      QCReR -= fVtxPosCor[i]*c1 + fVtxPosCor[i]*fVtxPosCor[i]*c2 + fVtxPosCor[i]*fVtxPosCor[i]*fVtxPosCor[i]*c3;
      c1 = fZDCVtxFitCenProjHist2[1][i]->GetBinContent(1);
      c2 = fZDCVtxFitCenProjHist2[1][i]->GetBinContent(2);
      c3 = fZDCVtxFitCenProjHist2[1][i]->GetBinContent(3);
      QCImR -= fVtxPosCor[i]*c1 + fVtxPosCor[i]*fVtxPosCor[i]*c2 + fVtxPosCor[i]*fVtxPosCor[i]*fVtxPosCor[i]*c3;
      c1 = fZDCVtxFitCenProjHist2[2][i]->GetBinContent(1);
      c2 = fZDCVtxFitCenProjHist2[2][i]->GetBinContent(2);
      c3 = fZDCVtxFitCenProjHist2[2][i]->GetBinContent(3);
      QAReR -= fVtxPosCor[i]*c1 + fVtxPosCor[i]*fVtxPosCor[i]*c2 + fVtxPosCor[i]*fVtxPosCor[i]*fVtxPosCor[i]*c3;
      c1 = fZDCVtxFitCenProjHist2[3][i]->GetBinContent(1);
      c2 = fZDCVtxFitCenProjHist2[3][i]->GetBinContent(2);
      c3 = fZDCVtxFitCenProjHist2[3][i]->GetBinContent(3);
      QAImR -= fVtxPosCor[i]*c1 + fVtxPosCor[i]*fVtxPosCor[i]*c2 + fVtxPosCor[i]*fVtxPosCor[i]*fVtxPosCor[i]*c3;
    }
    fZDCFlowVect[0].Set(QCReR,QCImR);
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=9.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  Double_t recRefMul = fReferenceMultiplicityEBE-fMultCutAv->GetBinContent(fMultCutAv->FindBin(fCentralityEBE));
  if(fZDCBinsCenRefMultRbRProj[fCenBin][0]) {
    QCReR -= fZDCBinsCenRefMultRbRProj[fCenBin][0]->Interpolate(recRefMul);
    QCImR -= fZDCBinsCenRefMultRbRProj[fCenBin][1]->Interpolate(recRefMul);
    QAReR -= fZDCBinsCenRefMultRbRProj[fCenBin][2]->Interpolate(recRefMul);
    QAImR -= fZDCBinsCenRefMultRbRProj[fCenBin][3]->Interpolate(recRefMul);
    fZDCFlowVect[0].Set(QCReR,QCImR);
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  fillstep=10.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

//  Int_t EZDCCBin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMCrec)-1;
//  Int_t EZDCABin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMArec)-1;
//
//  if(fZDCQVecVtxCenEZDC3D[0][0][0]) {
//    Bool_t pass2=kTRUE;
//    // exclude events with vtx outside of range
//    if(fVtxPosCor[0] < fZDCQVecVtxCenEZDC3D[0][0][0]->GetXaxis()->GetXmin() || fVtxPosCor[0] > fZDCQVecVtxCenEZDC3D[0][0][0]->GetXaxis()->GetXmax()) pass2 = kFALSE;
//    if(fVtxPosCor[1] < fZDCQVecVtxCenEZDC3D[0][0][0]->GetYaxis()->GetXmin() || fVtxPosCor[1] > fZDCQVecVtxCenEZDC3D[0][0][0]->GetYaxis()->GetXmax()) pass2 = kFALSE;
//    if(fVtxPosCor[2] < fZDCQVecVtxCenEZDC3D[0][0][0]->GetZaxis()->GetXmin() || fVtxPosCor[2] > fZDCQVecVtxCenEZDC3D[0][0][0]->GetZaxis()->GetXmax()) pass2 = kFALSE;
//    // exclude events with EZDC outside of range
//    Int_t EZDCCBin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMCrec)-1;
//    Int_t EZDCABin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMArec)-1;
////    if(EZDCCBin<=0 || EZDCCBin>=10 || EZDCABin<=0 || EZDCABin>=10) pass2 = kFALSE;
//    if(EZDCCBin<0) EZDCCBin=0;
//    if(EZDCCBin>9) EZDCCBin=9;
//    if(EZDCABin<0) EZDCABin=0;
//    if(EZDCABin>9) EZDCABin=9;
//    if(pass2) {
//      // check if possible to interpolate
//      Bool_t bInterp = kTRUE;
//      Int_t bx = fZDCQVecVtxCenEZDC3D[0][0][0]->GetXaxis()->FindBin(fVtxPosCor[0]);
//      Int_t by = fZDCQVecVtxCenEZDC3D[0][0][0]->GetYaxis()->FindBin(fVtxPosCor[1]);
//      Int_t bz = fZDCQVecVtxCenEZDC3D[0][0][0]->GetZaxis()->FindBin(fVtxPosCor[2]);
//      if(bx==1 || bx==fZDCQVecVtxCenEZDC3D[0][0][0]->GetXaxis()->GetNbins()) bInterp = kFALSE;
//      if(by==1 || by==fZDCQVecVtxCenEZDC3D[0][0][0]->GetYaxis()->GetNbins()) bInterp = kFALSE;
//      if(bz==1 || bz==fZDCQVecVtxCenEZDC3D[0][0][0]->GetZaxis()->GetNbins()) bInterp = kFALSE;
//      if(bInterp) {
//        QCReR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][0]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
//        QCImR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][1]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
//        QAReR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][2]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
//        QAImR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][3]->Interpolate(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2]);
//      } else {
//        QCReR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][0]->GetBinContent(bx,by,bz);
//        QCImR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][1]->GetBinContent(bx,by,bz);
//        QAReR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][2]->GetBinContent(bx,by,bz);
//        QAImR -= fZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][3]->GetBinContent(bx,by,bz);
//      }
//      fZDCFlowVect[0].Set(QCReR,QCImR);
//      fZDCFlowVect[1].Set(QAReR,QAImR);
//    } else {
//      QCReR = 0.; QCImR = 0.; QAReR = 0.; QAImR = 0.; QMC=0.; QMA=0.;
//      fZDCFlowVect[0].Set(QCReR,QCImR);
//      fZDCFlowVect[0].SetMult(0.);
//      fZDCFlowVect[1].Set(QAReR,QAImR);
//      fZDCFlowVect[1].SetMult(0.);
//    }
//  }

  fillstep=11.5;
  fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
  fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
  fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
  fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

  // if correctly set (via fMinMulZN), cut on ZDC Q-vector distribution
  // WARNING: QARe inverted !!!

  pass = PassCutZDCQVecDis(QCReR,QCImR,-QAReR,QAImR);

  // additional recentering vs centrality (if needed)
  if (fZDCQHist[8]) {
    QCReR -= fZDCQHist[8]->GetBinContent(fZDCQHist[8]->FindBin(fCentralityEBE));
    QCImR -= fZDCQHist[9]->GetBinContent(fZDCQHist[9]->FindBin(fCentralityEBE));
    fZDCFlowVect[0].Set(QCReR,QCImR);

    QAReR -= fZDCQHist[10]->GetBinContent(fZDCQHist[10]->FindBin(fCentralityEBE));
    QAImR -= fZDCQHist[11]->GetBinContent(fZDCQHist[11]->FindBin(fCentralityEBE));
    fZDCFlowVect[1].Set(QAReR,QAImR);
  }

  if(pass) {
    fillstep=12.5;
    fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
    fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
    fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
    fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);
  }

  // ***************************************************************************
  // store results after correction
  // ***************************************************************************

  if(QMC>0. && QMA>0. && sqrt(QCReR*QCReR+QCImR*QCImR)>1.E-6 && sqrt(QAReR*QAReR+QAImR*QAImR)>1.E-6 && pass) {

    fillstep=13.5;
    fCRCZDCQVecCorSteps[0]->Fill(fillstep,fCentralityEBE,-QCReR*QAReR);
    fCRCZDCQVecCorSteps[1]->Fill(fillstep,fCentralityEBE,QCImR*QAImR);
    fCRCZDCQVecCorSteps[2]->Fill(fillstep,fCentralityEBE,QCReR*QAImR);
    fCRCZDCQVecCorSteps[3]->Fill(fillstep,fCentralityEBE,-QCImR*QAReR);

    fCRCZDCQVecCCorr[fRunBin][0]->Fill(fCentralityEBE,QCReR);
    fCRCZDCQVecCCorr[fRunBin][1]->Fill(fCentralityEBE,QCImR);

//    fCRCZDCQVecCov[fRunBin][0]->Fill(fCentralityEBE,fVtxPosCor[0],QCReR);
//    fCRCZDCQVecCov[fRunBin][1]->Fill(fCentralityEBE,fVtxPosCor[1],QCReR);
//    fCRCZDCQVecCov[fRunBin][2]->Fill(fCentralityEBE,fVtxPosCor[2],QCReR);
//    fCRCZDCQVecCov[fRunBin][3]->Fill(fCentralityEBE,fVtxPosCor[0],QCImR);
//    fCRCZDCQVecCov[fRunBin][4]->Fill(fCentralityEBE,fVtxPosCor[1],QCImR);
//    fCRCZDCQVecCov[fRunBin][5]->Fill(fCentralityEBE,fVtxPosCor[2],QCImR);

//    if(fbFlagIsPosMagField) {
//      fCRCZDCQVecVtxPosCen[fCenBin][0]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
//      fCRCZDCQVecVtxPosCen[fCenBin][1]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
//    } else {
//      fCRCZDCQVecVtxPosCen[fCenBin][2]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
//      fCRCZDCQVecVtxPosCen[fCenBin][3]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
//    }

    fCRCZDCQVecACorr[fRunBin][0]->Fill(fCentralityEBE,QAReR);
    fCRCZDCQVecACorr[fRunBin][1]->Fill(fCentralityEBE,QAImR);
//    fCRCZDCQVecCov[fRunBin][6]->Fill(fCentralityEBE,fVtxPosCor[0],QAReR);
//    fCRCZDCQVecCov[fRunBin][7]->Fill(fCentralityEBE,fVtxPosCor[1],QAReR);
//    fCRCZDCQVecCov[fRunBin][8]->Fill(fCentralityEBE,fVtxPosCor[2],QAReR);
//    fCRCZDCQVecCov[fRunBin][9]->Fill(fCentralityEBE,fVtxPosCor[0],QAImR);
//    fCRCZDCQVecCov[fRunBin][10]->Fill(fCentralityEBE,fVtxPosCor[1],QAImR);
//    fCRCZDCQVecCov[fRunBin][11]->Fill(fCentralityEBE,fVtxPosCor[2],QAImR);

//    if(fbFlagIsPosMagField) {
//      fCRCZDCQVecVtxPosCen[fCenBin][4]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
//      fCRCZDCQVecVtxPosCen[fCenBin][5]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
//    } else {
//      fCRCZDCQVecVtxPosCen[fCenBin][6]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
//      fCRCZDCQVecVtxPosCen[fCenBin][7]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
//    }

    fhAvRefMulRbR->Fill(fRunBin+0.5,fCentralityEBE,fReferenceMultiplicityEBE);
    fhAvQMCRbR->Fill(fRunBin+0.5,fCentralityEBE,QMC);
    fhAvQMARbR->Fill(fRunBin+0.5,fCentralityEBE,QMA);

    //      for(Int_t i=0;i<3;i++) {
//        if(fbFlagIsPosMagField) {
//          fCRCZDCQVecVtxCenEZDC[i][0]->Fill(fCentralityEBE,QMCrec,fVtxPosCor[i],QCReR);
//          fCRCZDCQVecVtxCenEZDC[i][1]->Fill(fCentralityEBE,QMCrec,fVtxPosCor[i],QCImR);
//          fCRCZDCQVecVtxCenEZDC[i][4]->Fill(fCentralityEBE,QMArec,fVtxPosCor[i],QAReR);
//          fCRCZDCQVecVtxCenEZDC[i][5]->Fill(fCentralityEBE,QMArec,fVtxPosCor[i],QAImR);
//        } else {
//          fCRCZDCQVecVtxCenEZDC[i][2]->Fill(fCentralityEBE,QMCrec,fVtxPosCor[i],QCReR);
//          fCRCZDCQVecVtxCenEZDC[i][3]->Fill(fCentralityEBE,QMCrec,fVtxPosCor[i],QCImR);
//          fCRCZDCQVecVtxCenEZDC[i][6]->Fill(fCentralityEBE,QMArec,fVtxPosCor[i],QAReR);
//          fCRCZDCQVecVtxCenEZDC[i][7]->Fill(fCentralityEBE,QMArec,fVtxPosCor[i],QAImR);
//        }
//      }
//      Int_t EZDCCBin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMCrec)-1;
//      Int_t EZDCABin = fCRCZDCQVecDummyEZDCBins[fCenBin]->GetXaxis()->FindBin(QMArec)-1;
//      if(fbFlagIsPosMagField) {
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][0]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][1]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][4]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][5]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
//      } else {
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][2]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCReR);
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCCBin][3]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QCImR);
//        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][6]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAReR);
    //        fCRCZDCQVecVtxCenEZDC3D[fCenBin][EZDCABin][7]->Fill(fVtxPosCor[0],fVtxPosCor[1],fVtxPosCor[2],QAImR);
    //      }
    //    }

    if( fInvertZDC ) QAReR = -QAReR;

    //    fhZNCenDis[0]->Fill(fCentralityEBE,QCReR,QCImR);
    //    fhZNCenDis[1]->Fill(fCentralityEBE,QAReR,QAImR);

    // Double_t EvPlZDCfull = TMath::ATan2(QAImR-QCImR,QAReR-QCReR);
    //    fCRCZDCQVecEP[fRunBin][2]->Fill(fCentralityEBE,EvPlZDCfull);
    // EvPlZDCfull = TMath::ATan2(QAImR+QCImR,QAReR+QCReR);
    //    fCRCZDCQVecEP[fRunBin][3]->Fill(fCentralityEBE,EvPlZDCfull);
    fCRCZDCQVecRes[fRunBin][0]->Fill(fCentralityEBE,QCReR*QAReR);
    fCRCZDCQVecRes[fRunBin][1]->Fill(fCentralityEBE,QCImR*QAImR);
    fCRCZDCQVecRes[fRunBin][2]->Fill(fCentralityEBE,QCReR*QAImR);
    fCRCZDCQVecRes[fRunBin][3]->Fill(fCentralityEBE,QCImR*QAReR);

    if(fStoreZDCQVecVtxPos) {
      fCRCZDCQVecDis[bw][fCenBin][0]->Fill(QCReR*QAImR,QCImR*QAReR);
      fCRCZDCQVecDis[bw][fCenBin][1]->Fill(QCReR*QAReR,QCImR*QAImR);
    }

    Double_t EvPlZNC = TMath::ATan2(QCImR,QCReR);
    if(EvPlZNC<0.) EvPlZNC += TMath::TwoPi();
    Double_t EvPlZNA = TMath::ATan2(QAImR,QAReR);
    if(EvPlZNA<0.) EvPlZNA += TMath::TwoPi();
    fZDCEPHist[0]->Fill(fCentralityEBE,EvPlZNC);
    fZDCEPHist[1]->Fill(fCentralityEBE,EvPlZNA);

  } else {
    fQAZDCCutsFlag = kFALSE;
  }

} // end of AliFlowAnalysisCRC::RecenterCRCQVecZDC()

//=======================================================================================================================

Bool_t AliFlowAnalysisCRC::PassCutZDCQVecDis(Double_t ZCRe, Double_t ZCIm, Double_t ZARe, Double_t ZAIm)
{
  Int_t bw = (fbFlagIsPosMagField==kTRUE?0:1);
  Bool_t passcut = kTRUE;

  if(fMinMulZN==13) {
    if(fCRCZDC2DCutZDCC[bw][fCenBin]) {
      if(fRandom->Uniform(0.,1.)>fCRCZDC2DCutZDCC[bw][fCenBin]->GetBinContent(fCRCZDC2DCutZDCC[bw][fCenBin]->GetXaxis()->FindBin(ZCRe),fCRCZDC2DCutZDCC[bw][fCenBin]->GetYaxis()->FindBin(ZCIm))) passcut = kFALSE;
    }
  }

  if(fMinMulZN==14) {
    if(fCRCZDC2DCutZDCA[bw][fCenBin]) {
      if(fRandom->Uniform(0.,1.)>fCRCZDC2DCutZDCA[bw][fCenBin]->GetBinContent(fCRCZDC2DCutZDCA[bw][fCenBin]->GetXaxis()->FindBin(ZARe),fCRCZDC2DCutZDCA[bw][fCenBin]->GetYaxis()->FindBin(ZAIm))) passcut = kFALSE;
    }
  }

  if(fMinMulZN==15) {
    if(fCRCZDC2DCutZDCC[bw][fCenBin] && fCRCZDC2DCutZDCA[bw][fCenBin]) {
      if(fRandom->Uniform(0.,1.)>fCRCZDC2DCutZDCC[bw][fCenBin]->GetBinContent(fCRCZDC2DCutZDCC[bw][fCenBin]->GetXaxis()->FindBin(ZCRe),fCRCZDC2DCutZDCC[bw][fCenBin]->GetYaxis()->FindBin(ZCIm))) passcut = kFALSE;
      if(fRandom->Uniform(0.,1.)>fCRCZDC2DCutZDCA[bw][fCenBin]->GetBinContent(fCRCZDC2DCutZDCA[bw][fCenBin]->GetXaxis()->FindBin(ZARe),fCRCZDC2DCutZDCA[bw][fCenBin]->GetYaxis()->FindBin(ZAIm))) passcut = kFALSE;
    }
  }

  if(fMinMulZN==16) {
    if(fCRCZDC2DCutZDCC[bw][fCenBin]) {
      if(fRandom->Uniform(0.,1.)>fCRCZDC2DCutZDCC[bw][fCenBin]->GetBinContent(fCRCZDC2DCutZDCC[bw][fCenBin]->GetXaxis()->FindBin(ZCRe*ZAIm),fCRCZDC2DCutZDCC[bw][fCenBin]->GetYaxis()->FindBin(ZCIm*ZARe))) passcut = kFALSE;
      if(ZCRe*ZAIm < fCRCZDC2DCutZDCC[bw][fCenBin]->GetXaxis()->GetXmin() || ZCRe*ZAIm > fCRCZDC2DCutZDCC[bw][fCenBin]->GetXaxis()->GetXmax()) passcut = kFALSE;
      if(ZCIm*ZARe < fCRCZDC2DCutZDCC[bw][fCenBin]->GetYaxis()->GetXmin() || ZCIm*ZARe > fCRCZDC2DCutZDCC[bw][fCenBin]->GetYaxis()->GetXmax()) passcut = kFALSE;
    }
  }

  return passcut;
}

//=======================================================================================================================

void AliFlowAnalysisCRC::PassQAZDCCuts()
{
  // VZ eta < 0
  Double_t VZCM = fVZFlowVect[0][1].GetMult();
  // VZ eta > 0
  Double_t VZAM = fVZFlowVect[1][1].GetMult();
  // ZDCN-C
  Double_t QMC  = fZDCFlowVect[0].GetMult();
  // ZDCN-A
  Double_t QMA  = fZDCFlowVect[1].GetMult();

  // get re-centered QM*
  Double_t QMCrec = QMC;
  Double_t QMArec = QMA;
  if(fAvEZDCCRbRPro && fAvEZDCARbRPro) {
    Int_t runbin = fAvEZDCCRbRPro->GetXaxis()->FindBin(Form("%d",fRunNum));
    Int_t cenbin = fAvEZDCCRbRPro->GetYaxis()->FindBin(fCentralityEBE);
    QMCrec -= fAvEZDCCRbRPro->GetBinContent(runbin,cenbin);
    QMArec -= fAvEZDCARbRPro->GetBinContent(runbin,cenbin);
  }

  // cut on multiplicity
  if( fZNCen<=0. || fZNAen<=0. ) fQAZDCCutsFlag = kFALSE;
  // exclude ZDC bad runs
  if(fRunNum==138469 || fRunNum==138870 || fRunNum==139028 || fRunNum==139029 || fRunNum==139036) fQAZDCCutsFlag = kFALSE;
  Int_t CenBin = (Int_t)(fCentralityEBE);

  // cut on #neutrons
  if(fMinMulZN==1) {
    if(fZNCen > fPolMin[0]->Eval(fCentralityEBE) || fZNAen > fPolMin[1]->Eval(fCentralityEBE)) fQAZDCCutsFlag = kFALSE;
  }
  if(fMinMulZN==2) {
    if(fZNCen < fPolMax[0]->Eval(fCentralityEBE) || fZNAen < fPolMax[1]->Eval(fCentralityEBE)) fQAZDCCutsFlag = kFALSE;
  }

  // temporary mapping: Z*M = a*V0M + b, cut at cen. 40
  Double_t ZNM = (fZNCen+fZNAen)/2.;
  Double_t VZM = VZCM+VZAM;

  if(fMinMulZN==3 || fMinMulZN==4) {
    Double_t ZCMd = fZNCen;
    Double_t ZAMd = fZNAen;
    if(fCorrMap[CenBin]) {
      ZAMd += fCorrMap[CenBin];
      ZCMd -= fCorrMap[CenBin];
    }
    if(fMinMulZN==3) {
      if(ZCMd-ZAMd > fPolMin[0]->Eval(fCentralityEBE)) fQAZDCCutsFlag = kFALSE;
    }
    if(fMinMulZN==4) {
      if(ZCMd-ZAMd < fPolMax[0]->Eval(fCentralityEBE)) fQAZDCCutsFlag = kFALSE;
    }

    // new centrality
    if (VZM>5.E3) {
      Double_t par1 = 0.;
      if(VZM<1.E4) par1 = fPolSlope[0]->Eval(VZM);
      else         par1 = fPolSlope[1]->Eval(VZM);
      Double_t par0 = ZNM-par1*VZM;

      fPolDist[0]->SetParameter(0,par0);
      fPolDist[0]->SetParameter(1,par1);
      Double_t VZMint = fPolDist[0]->GetMinimumX();
      fNewMetricLEBE = sqrt(pow(VZMint-5.E3,2.)+pow(fPolAv[0]->Eval(VZMint)-fPolAv[0]->Eval(5.E3),2.));
      fNewMetricL2EBE = sqrt(pow((VZMint-5.E3)/1.E3,2.)+pow(fPolAv[0]->Eval(VZMint)-fPolAv[0]->Eval(5.E3),2.));

      fPolAv[1]->SetParameter(0,par0);
      fPolAv[1]->SetParameter(1,par1);
      fNewMetricDEBE = sqrt(pow(VZM-VZMint,2.)+pow(fPolAv[1]->Eval(VZM)-fPolAv[1]->Eval(VZMint),2.));
      fNewMetricD2EBE = sqrt(pow((VZM-VZMint)/1.E3,2.)+pow(fPolAv[1]->Eval(VZM)-fPolAv[1]->Eval(VZMint),2.));
      if(fPolAv[1]->Eval(VZM)<fPolAv[0]->Eval(VZM)) {
        fNewMetricDEBE *= -1.;
        fNewMetricD2EBE *= -1.;
      }

      fNewCentralityEBE = fCenMetric->Eval(fNewMetricLEBE);
    } else {
      fNewMetricLEBE = -1.;
      fNewMetricDEBE = -1.;
      fNewCentralityEBE = fCentralityEBE;
    }
  }

  if(fMinMulZN==7) {
    if (VZM>5.E3) {
      fQAZDCCutsFlag = kTRUE;
    } else {
      fQAZDCCutsFlag = kFALSE;
    }
  }

  // new ZDC ESE selection
  if(fMinMulZN==5) {
    fZDCESEclEbE=-1;
    Double_t DifMin=1.E3;
    Double_t ZNS = fZNCen+fZNAen;
    for (Int_t k=0; k<fZDCESEnPol; k++) {
      Double_t PolV = fPolCuts[k]->Eval(fCentralityEBE);
      if(ZNS<PolV && PolV-ZNS<DifMin) {
        fZDCESEclEbE=k;
        DifMin=PolV-ZNS;
      }
    }
    if (fZDCESEclEbE==-1) fZDCESEclEbE=fZDCESEnPol;
    if (fCentralityEBE>=90.) fQAZDCCutsFlag = kFALSE;
  }

  fhZNvsCen[0]->Fill(fCentralityEBE,fZNCen+fZNAen);

  // cut on ZDC spectra for LHC15o
  if(fMinMulZN==8) {
    if(fCentralityEBE<90.) {
      if(fZNCen+fZNAen<fEZNCutMin->GetBinContent(fEZNCutMin->FindBin(fCentralityEBE))) fQAZDCCutsFlag = kFALSE;
      if(fZNCen+fZNAen>fEZNCutMax->GetBinContent(fEZNCutMax->FindBin(fCentralityEBE))) fQAZDCCutsFlag = kFALSE;
    }
  }

  if(fMinMulZN==9) {
    if(fabs(fVtxPosCor[0])>4.25e-3) fQAZDCCutsFlag = kFALSE;
    if(fabs(fVtxPosCor[1])>3.9e-3) fQAZDCCutsFlag = kFALSE;
    if(fabs(fVtxPosCor[2])>5.) fQAZDCCutsFlag = kFALSE;
  }

  if(fMinMulZN>=10) {
    if(fRunNum==246087) fQAZDCCutsFlag = kFALSE;
  }

  if(fMinMulZN==11) {
    if(fabs(fVtxPosCor[0])>4.25e-3) fQAZDCCutsFlag = kFALSE;
    if(fabs(fVtxPosCor[1])>3.9e-3) fQAZDCCutsFlag = kFALSE;
    if(fabs(fVtxPosCor[2])>5.) fQAZDCCutsFlag = kFALSE;
  }

  if(fMinMulZN==12) {
    // cut outliers
    if(fabs(QMCrec)>100.) fQAZDCCutsFlag = kFALSE;
    if(fabs(QMArec)>100.) fQAZDCCutsFlag = kFALSE;
  }

  // fill QA plots
  if(fQAZDCCutsFlag) {
    fhZNCvsZNA[fCenBin]->Fill(fZNCen,fZNAen);
    fhZNvsCen[1]->Fill(fCentralityEBE,fZNCen+fZNAen);
    fhZNvsMul->Fill(fNITSCL1EBE,fZNCen+fZNAen,fCenWeightEbE);
  }
}

//=======================================================================================================================

Bool_t AliFlowAnalysisCRC::MultCut2015o()
{
  Bool_t PassMultCut = kTRUE;
  if(fCentralityEBE<90.) {
    if(fReferenceMultiplicityEBE<fMultCutMin->GetBinContent(fMultCutMin->FindBin(fCentralityEBE))) PassMultCut = kFALSE;
    if(fReferenceMultiplicityEBE>fMultCutMax->GetBinContent(fMultCutMax->FindBin(fCentralityEBE))) PassMultCut = kFALSE;
  }
  if(PassMultCut) fhCenvsMul[1]->Fill(fCentralityEBE,fReferenceMultiplicityEBE);
  return PassMultCut;
}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRCQVec()
{
  // VZERO
  //  if(fUseVZERO) {
  //    for(Int_t h=0;h<fCRCnHar;h++) {
  //
  //      // RPS eta < 0
  //      Double_t QReC = fVZFlowVect[0][h].X();
  //      Double_t QImC = fVZFlowVect[0][h].Y();
  //      Double_t QMC  = fVZFlowVect[0][h].GetMult();
  //      // RPS eta > 0
  //      Double_t QReA = fVZFlowVect[1][h].X();
  //      Double_t QImA = fVZFlowVect[1][h].Y();
  //      Double_t QMA  = fVZFlowVect[1][h].GetMult();
  //
  //      if(QMA>0. && QMC>0.) {
  //        if(h==1) {
  //          fCRCVZEPA[fRunBin][fCenBin]->Fill(TMath::ATan2(QImA,QReA));
  //          fCRCVZEPC[fRunBin][fCenBin]->Fill(TMath::ATan2(QImC,QReC));
  //          for(Int_t k=0;k<fCRCnHar;k++) {
  //            fCRCVZCosnA[fRunBin][k]->Fill(fCentralityEBE,cos((k+1)*TMath::ATan2(QImA,QReA)));
  //            fCRCVZSinnA[fRunBin][k]->Fill(fCentralityEBE,sin((k+1)*TMath::ATan2(QImA,QReA)));
  //            fCRCVZCosnC[fRunBin][k]->Fill(fCentralityEBE,cos((k+1)*TMath::ATan2(QImC,QReC)));
  //            fCRCVZSinnC[fRunBin][k]->Fill(fCentralityEBE,sin((k+1)*TMath::ATan2(QImC,QReC)));
  //          }
  //          fCRCVZQVecA[fRunBin][0]->Fill(fCentralityEBE,QReA);
  //          fCRCVZQVecA[fRunBin][1]->Fill(fCentralityEBE,QImA);
  //          fCRCVZQVecC[fRunBin][0]->Fill(fCentralityEBE,QReC);
  //          fCRCVZQVecC[fRunBin][1]->Fill(fCentralityEBE,QImC);
  //        }
  //      }
  //    } // end of for(Int_t h=0;h<fCRCnHar;h++)
  //  } // end of if(fUseVZERO)

  // ZDC
  if(fUseZDC && fRecenterZDC) {
    // ZDC-C (eta < -8.8)
    Double_t VCRe = fZDCFlowVect[0].X();
    Double_t VCIm = fZDCFlowVect[0].Y();
    Double_t VCM  = fZDCFlowVect[0].GetMult();
    if(VCM>0. && sqrt(VCRe*VCRe+VCIm*VCIm)>1.E-6) {
      fCRCZDCQVecC[fRunBin][0]->Fill(fCentralityEBE,VCRe);
      fCRCZDCQVecC[fRunBin][1]->Fill(fCentralityEBE,VCIm);
    }
    // ZDC-A (eta > 8.8)
    Double_t VARe = fZDCFlowVect[1].X();
    Double_t VAIm = fZDCFlowVect[1].Y();
    Double_t VAM  = fZDCFlowVect[1].GetMult();
    if(VAM>0. && sqrt(VARe*VARe+VAIm*VAIm)>1.E-6) {
      fCRCZDCQVecA[fRunBin][0]->Fill(fCentralityEBE,VARe);
      fCRCZDCQVecA[fRunBin][1]->Fill(fCentralityEBE,VAIm);
    }
  } // end of if(fUseVZERO)

} // end of AliFlowAnalysisCRC::CalculateCRCQVec()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRCVZERO()
{
  // RPS eta < 0
  Double_t ZCRe = fVZFlowVect[0][0].X();
  Double_t ZCIm = fVZFlowVect[0][0].Y();
  Double_t ZCM  = fVZFlowVect[0][0].GetMult();
  // RPS eta > 0
  Double_t ZARe = fVZFlowVect[1][0].X();
  Double_t ZAIm = fVZFlowVect[1][0].Y();
  Double_t ZAM  = fVZFlowVect[1][0].GetMult();

  if(ZCM<1. || ZAM<1.) return;

  for(Int_t et=1; et<=fkEtaDiffNBins; et++) {
    Double_t QPRe=0., QPIm=0., QPM=0., QNRe=0., QNIm=0., QNM=0.;
    for(Int_t etm=1; etm<=fkEtaDiffMaxNBins; etm++) {
      if(fFlowSPZDCv1etaPro[0][0][0]->FindBin(fEtaDiffQRe[0][0]->GetBinCenter(etm))==et) {
        QPRe += fEtaDiffQRe[0][0]->GetBinContent(etm);
        QPIm += fEtaDiffQIm[0][0]->GetBinContent(etm);
        QPM  += fEtaDiffMul[0][0]->GetBinContent(etm);
        QNRe += fEtaDiffQRe[1][0]->GetBinContent(etm);
        QNIm += fEtaDiffQIm[1][0]->GetBinContent(etm);
        QNM  += fEtaDiffMul[1][0]->GetBinContent(etm);
      }
    }
    Double_t QRe = QPRe+QNRe;
    Double_t QIm = QPIm+QNIm;
    Double_t QM  = QPM+QNM;
    Double_t etab = fCRCVZEROetaPro[0][0]->GetBinCenter(et);

    if(QPM>0. && QNM>0.) {

      QRe = QRe/QM;
      QIm = QIm/QM;
      QPRe = QPRe/QPM;
      QPIm = QPIm/QPM;
      QNRe = QNRe/QNM;
      QNIm = QNIm/QNM;

      fCRCVZEROetaPro[fCenBin][0]->Fill(etab,QRe*ZARe+QIm*ZAIm,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][1]->Fill(etab,QRe*ZCRe+QIm*ZCIm,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][2]->Fill(etab,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][3]->Fill(etab,QPRe*ZARe+QPIm*ZAIm,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][4]->Fill(etab,QPRe*ZCRe+QPIm*ZCIm,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][5]->Fill(etab,QNRe*ZARe+QNIm*ZAIm,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][6]->Fill(etab,QNRe*ZCRe+QNIm*ZCIm,QNM*fCenWeightEbE);
      // term by term: real part
      fCRCVZEROetaPro[fCenBin][7]->Fill(etab,QRe*ZARe,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][8]->Fill(etab,QRe*ZCRe,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][9]->Fill(etab,ZARe*ZCRe,fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][10]->Fill(etab,QPRe*ZARe,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][11]->Fill(etab,QPRe*ZCRe,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][12]->Fill(etab,QNRe*ZARe,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][13]->Fill(etab,QNRe*ZCRe,QNM*fCenWeightEbE);
      // term by term: imaginary part
      fCRCVZEROetaPro[fCenBin][14]->Fill(etab,QIm*ZAIm,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][15]->Fill(etab,QIm*ZCIm,QM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][16]->Fill(etab,ZAIm*ZCIm,fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][17]->Fill(etab,QPIm*ZAIm,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][18]->Fill(etab,QPIm*ZCIm,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][19]->Fill(etab,QNIm*ZAIm,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][20]->Fill(etab,QNIm*ZCIm,QNM*fCenWeightEbE);
      // NUAs
      fCRCVZEROetaPro[fCenBin][21]->Fill(etab,QRe,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][22]->Fill(etab,QIm,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][23]->Fill(etab,QPRe,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][24]->Fill(etab,QPIm,QPM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][25]->Fill(etab,QNRe,QNM*fCenWeightEbE);
      fCRCVZEROetaPro[fCenBin][26]->Fill(etab,QNIm,QNM*fCenWeightEbE);
    }

  }

} // end of AliFlowAnalysisCRC::CalculateCRCVZERO();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRCZDC()
{
  Int_t h = fHarmonic-1;
  Double_t e = 1E-5;

  // ZDC-C (eta < -8.8)
  Double_t VCRe = fZDCFlowVect[0].X();
  Double_t VCIm = fZDCFlowVect[0].Y();
  Double_t VCM  = fZDCFlowVect[0].GetMult();
  // ZDC-A (eta > 8.8)
  Double_t VARe = fZDCFlowVect[1].X();
  Double_t VAIm = fZDCFlowVect[1].Y();
  Double_t VAM  = fZDCFlowVect[1].GetMult();

  if( fInvertZDC ) VARe = -VARe;

  // cut on centrality >5%
  if( fCentralityEBE<5. ) return;
  // cut on multiplicity
  if( VCM<1. || VAM<1. ) return;

  // Set ZDC weights
  Double_t VAW=0., VCW=0.;
  switch(fCorrWeightZDC) {
    case kUnit:
      VCW = 1.;
      VAW = 1.;
      break;
    case kMultiplicity:
      // scale signal by beam energy [GeV] => number of spectators (?)
      VCW = VCM/fEnNucl;
      VAW = VAM/fEnNucl;
      break;
  }

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {

    Double_t eta = (eg+0.5)*((fCRCEtaMax-fCRCEtaMin)/fCRCZDCnEtaBin)-(fCRCEtaMax-fCRCEtaMin)/2.;

    Double_t QRe=0., QIm=0., QM=0., QW=0.;
    for(Int_t c=0;c<2;c++) {
      QRe += fCRCZDCQRe[c][h]->GetBinContent(fCRCZDCQRe[c][h]->FindBin(eta));
      QIm += fCRCZDCQIm[c][h]->GetBinContent(fCRCZDCQIm[c][h]->FindBin(eta));
      QM  += fCRCZDCMult[c][h]->GetBinContent(fCRCZDCMult[c][h]->FindBin(eta));
    }

    if(QM>1.) {

      // Normalize TPC Q-vector
      QRe /= QM;
      QIm /= QM;
      // Set TPC weights
      QW = ( fCorrWeightTPC==kUnit ? 1. : QM );

      // ZDCs only

      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(4.5,VCRe*VARe,VCW*VAW*fCenWeightEbE);
      fCRCZDCCorrPro[fRunBin][1][eg][fCenBin]->Fill(4.5,VCIm*VAIm,VCW*VAW*fCenWeightEbE);
      fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(5,VCRe*VARe);
      fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(5,VCIm*VAIm);
      fCRCZDCCorrProdTempHist[1][0][fCenBin]->SetBinContent(5,VCW*VAW);
      fCRCZDCNUAPro[fRunBin][0][eg][fCenBin]->Fill(4.5,VCRe,VCW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][1][eg][fCenBin]->Fill(4.5,VARe,VAW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][2][eg][fCenBin]->Fill(4.5,VCIm,VCW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][3][eg][fCenBin]->Fill(4.5,VAIm,VAW*fCenWeightEbE);

      // TPC Q - ZDCs

      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(5.5,QRe*VCRe,QW*VCW*fCenWeightEbE);
      fCRCZDCCorrPro[fRunBin][1][eg][fCenBin]->Fill(5.5,QIm*VCIm,QW*VCW*fCenWeightEbE);
      fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(6,QRe*VCRe);
      fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(6,QIm*VCIm);
      fCRCZDCCorrProdTempHist[1][0][fCenBin]->SetBinContent(6,QW*VCW);
      fCRCZDCNUAPro[fRunBin][0][eg][fCenBin]->Fill(5.5,QRe,QW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][1][eg][fCenBin]->Fill(5.5,VCRe,VCW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][2][eg][fCenBin]->Fill(5.5,QIm,QW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][3][eg][fCenBin]->Fill(5.5,VCIm,VCW*fCenWeightEbE);

      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(6.5,QRe*VARe,QW*VAW*fCenWeightEbE);
      fCRCZDCCorrPro[fRunBin][1][eg][fCenBin]->Fill(6.5,QIm*VAIm,QW*VAW*fCenWeightEbE);
      fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(7,QRe*VARe);
      fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(7,QIm*VAIm);
      fCRCZDCCorrProdTempHist[1][0][fCenBin]->SetBinContent(7,QW*VAW);
      fCRCZDCNUAPro[fRunBin][0][eg][fCenBin]->Fill(6.5,QRe,QW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][1][eg][fCenBin]->Fill(6.5,VARe,VAW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][2][eg][fCenBin]->Fill(6.5,QIm,QW*fCenWeightEbE);
      fCRCZDCNUAPro[fRunBin][3][eg][fCenBin]->Fill(6.5,VAIm,VAW*fCenWeightEbE);

      for(Int_t c=0;c<2;c++) {

        Double_t uRe = fCRCZDCQRe[c][h]->GetBinContent(fCRCZDCQRe[c][h]->FindBin(eta));
        Double_t uIm = fCRCZDCQIm[c][h]->GetBinContent(fCRCZDCQIm[c][h]->FindBin(eta));
        Double_t uM  = fCRCZDCMult[c][h]->GetBinContent(fCRCZDCMult[c][h]->FindBin(eta));

        if(uM>1.) {

          // Normalize TPC q-vector
          uRe /= uM;
          uIm /= uM;
          // Set TPC weights
          Double_t uW = ( fCorrWeightTPC==kUnit ? 1. : uM );

          // TPC q - ZDCs

          fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(c+e,uRe*VCRe,uW*VCW*fCenWeightEbE);
          fCRCZDCCorrPro[fRunBin][1][eg][fCenBin]->Fill(c+e,uIm*VCIm,uW*VCW*fCenWeightEbE);
          fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(c+1,uRe*VCRe);
          fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(c+1,uIm*VCIm);
          fCRCZDCCorrProdTempHist[1][0][fCenBin]->SetBinContent(c+1,uW*VCW);
          fCRCZDCNUAPro[fRunBin][0][eg][fCenBin]->Fill(c+e,uRe,uW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][1][eg][fCenBin]->Fill(c+e,VCRe,VCW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][2][eg][fCenBin]->Fill(c+e,uIm,uW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][3][eg][fCenBin]->Fill(c+e,VCIm,VCW*fCenWeightEbE);
          fCRCZDCSpectra[eg][fCenBin]->Fill(c+e,uM*fCenWeightEbE);

          fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(c+2+e,uRe*VARe,uW*VAW*fCenWeightEbE);
          fCRCZDCCorrPro[fRunBin][1][eg][fCenBin]->Fill(c+2+e,uIm*VAIm,uW*VAW*fCenWeightEbE);
          fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(c+3,uRe*VARe);
          fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(c+3,uIm*VAIm);
          fCRCZDCCorrProdTempHist[1][0][fCenBin]->SetBinContent(c+3,uW*VAW);
          fCRCZDCNUAPro[fRunBin][0][eg][fCenBin]->Fill(c+2+e,uRe,uW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][1][eg][fCenBin]->Fill(c+2+e,VARe,VAW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][2][eg][fCenBin]->Fill(c+2+e,uIm,uW*fCenWeightEbE);
          fCRCZDCNUAPro[fRunBin][3][eg][fCenBin]->Fill(c+2+e,VAIm,VAW*fCenWeightEbE);
          fCRCZDCSpectra[eg][fCenBin]->Fill(c+2+e,uM*fCenWeightEbE);

        } else {
          // effectively disable storing of covariances
          fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(c+1,0.);
          fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(c+1,0.);
          fCRCZDCCorrProdTempHist[0][0][fCenBin]->SetBinContent(c+3,0.);
          fCRCZDCCorrProdTempHist[0][1][fCenBin]->SetBinContent(c+3,0.);
        } // end of if(uNM>1 && uPM>1)

      } // end of for(Int_t c=0;c<2;c++)

      Double_t ARe = fCRCZDCQRe[2][h]->GetBinContent(fCRCZDCQRe[2][h]->FindBin(eta));
      Double_t AIm = fCRCZDCQIm[2][h]->GetBinContent(fCRCZDCQIm[2][h]->FindBin(eta));
      Double_t AM  = fCRCZDCMult[2][h]->GetBinContent(fCRCZDCMult[2][h]->FindBin(eta));
      ARe /= AM;
      AIm /= AM;
      Double_t BRe = fCRCZDCQRe[3][h]->GetBinContent(fCRCZDCQRe[3][h]->FindBin(eta));
      Double_t BIm = fCRCZDCQIm[3][h]->GetBinContent(fCRCZDCQIm[3][h]->FindBin(eta));
      Double_t BM  = fCRCZDCMult[3][h]->GetBinContent(fCRCZDCMult[3][h]->FindBin(eta));
      BRe /= BM;
      BIm /= BM;

      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(7.5,VCRe*VARe+VCIm*VAIm,fCenWeightEbE);
      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(8.5,(ARe*VCRe+AIm*VCIm)*(BRe*VCRe+BIm*VCIm),fCenWeightEbE);
      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(9.5,(ARe*VARe+AIm*VAIm)*(BRe*VARe+BIm*VAIm),fCenWeightEbE);

      Double_t qPVCRe = fCRCZDCCorrProdTempHist[0][0][fCenBin]->GetBinContent(1);
      Double_t qNVCRe = fCRCZDCCorrProdTempHist[0][0][fCenBin]->GetBinContent(2);
      Double_t qPVCIm = fCRCZDCCorrProdTempHist[0][1][fCenBin]->GetBinContent(1);
      Double_t qNVCIm = fCRCZDCCorrProdTempHist[0][1][fCenBin]->GetBinContent(2);
      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(10.5,(qPVCRe+qPVCIm)*(qNVCRe+qNVCIm),fCenWeightEbE);

      Double_t qPVARe = fCRCZDCCorrProdTempHist[0][0][fCenBin]->GetBinContent(3);
      Double_t qNVARe = fCRCZDCCorrProdTempHist[0][0][fCenBin]->GetBinContent(4);
      Double_t qPVAIm = fCRCZDCCorrProdTempHist[0][1][fCenBin]->GetBinContent(3);
      Double_t qNVAIm = fCRCZDCCorrProdTempHist[0][1][fCenBin]->GetBinContent(4);
      fCRCZDCCorrPro[fRunBin][0][eg][fCenBin]->Fill(11.5,(qPVARe+qPVAIm)*(qNVARe+qNVAIm),fCenWeightEbE);

      for(Int_t i=0;i<2;i++) {
        Int_t ce = 0;
        for(Int_t c=0;c<fCRCZDCnCR;c++) {
          for(Int_t c2=0;c2<fCRCZDCnCR;c2++) {
            Double_t CorrA = fCRCZDCCorrProdTempHist[0][i][fCenBin]->GetBinContent(c+1);
            Double_t WeigA = fCRCZDCCorrProdTempHist[1][0][fCenBin]->GetBinContent(c+1);
            Double_t CorrB = fCRCZDCCorrProdTempHist[0][i][fCenBin]->GetBinContent(c2+1);
            Double_t WeigB = fCRCZDCCorrProdTempHist[1][0][fCenBin]->GetBinContent(c2+1);
            if( CorrA != 0. && CorrB != 0.) {
              fCRCZDCCorrProd2p2pHist[fRunBin][i][eg][fCenBin]->Fill(ce+e,CorrA*CorrB,WeigA*WeigB*fCenWeightEbE);
            }
            ce++;
          } // end of for(Int_t c2=0;c2<2;c2++)
        } // end of for(Int_t c=0;c<2;c++)
      } // end of for(Int_t i=0;i<2;i++)

    } // end of if(QNM>1 && QPM>1 && VCM>1. && VAM>1.)

  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)
} // end of AliFlowAnalysisCRC::CalculateCRCZDC();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateVZvsZDC()
{
  // // ZDC-C (eta < -8.8)
  // Double_t ZDCCRe = fZDCFlowVect[0].X();
  // Double_t ZDCCIm = fZDCFlowVect[0].Y();
  // Double_t ZDCCM  = fZDCFlowVect[0].GetMult();
  // // ZDC-A (eta > 8.8)
  // Double_t ZDCARe = fZDCFlowVect[1].X();
  // Double_t ZDCAIm = fZDCFlowVect[1].Y();
  // Double_t ZDCAM  = fZDCFlowVect[1].GetMult();
  // // VZ eta < 0
  // Double_t VZCRe = fVZFlowVect[0][0].X();
  // Double_t VZCIm = fVZFlowVect[0][0].Y();
  // Double_t VZCM  = fVZFlowVect[0][0].GetMult();
  // // VZ eta > 0
  // Double_t VZARe = fVZFlowVect[1][0].X();
  // Double_t VZAIm = fVZFlowVect[1][0].Y();
  // Double_t VZAM  = fVZFlowVect[1][0].GetMult();

  // WARNING: to be consistent with CalculateCRCZDC() and CalculateCRCVZERO()
  //          APPLY THE SAME CUTS !!!

  // if( fInvertZDC ) ZDCARe = -ZDCARe;
  //
  // // cut on multiplicity
  // if( VZCM<1. || VZAM<1. ) return;
  // if( ZDCCM<0. || ZDCAM<0. ) return;
  //
  // // Normalize VZ Q-vector
  // VZCRe /= VZCM;
  // VZCIm /= VZCM;
  // VZARe /= VZAM;
  // VZAIm /= VZAM;

  // VZ-C - ZDC-C
  //  fCRCVZvsZDCCov[fRunBin][0]->Fill(fCentralityEBE,VZCRe*ZDCCRe);
  //  fCRCVZvsZDCCov[fRunBin][1]->Fill(fCentralityEBE,VZCIm*ZDCCIm);
  //  fCRCVZvsZDCCov[fRunBin][2]->Fill(fCentralityEBE,VZCRe*ZDCCIm);
  //  fCRCVZvsZDCCov[fRunBin][3]->Fill(fCentralityEBE,VZCIm*ZDCCRe);
  //  // VZ-C - ZDC-A
  //  fCRCVZvsZDCCov[fRunBin][4]->Fill(fCentralityEBE,VZCRe*ZDCARe);
  //  fCRCVZvsZDCCov[fRunBin][5]->Fill(fCentralityEBE,VZCIm*ZDCAIm);
  //  fCRCVZvsZDCCov[fRunBin][6]->Fill(fCentralityEBE,VZCRe*ZDCAIm);
  //  fCRCVZvsZDCCov[fRunBin][7]->Fill(fCentralityEBE,VZCIm*ZDCARe);
  //  // VZ-A - ZDC-C
  //  fCRCVZvsZDCCov[fRunBin][8]->Fill(fCentralityEBE,VZARe*ZDCCRe);
  //  fCRCVZvsZDCCov[fRunBin][9]->Fill(fCentralityEBE,VZAIm*ZDCCIm);
  //  fCRCVZvsZDCCov[fRunBin][10]->Fill(fCentralityEBE,VZARe*ZDCCIm);
  //  fCRCVZvsZDCCov[fRunBin][11]->Fill(fCentralityEBE,VZAIm*ZDCCRe);
  //  // VZ-A - ZDC-A
  //  fCRCVZvsZDCCov[fRunBin][12]->Fill(fCentralityEBE,VZARe*ZDCARe);
  //  fCRCVZvsZDCCov[fRunBin][13]->Fill(fCentralityEBE,VZAIm*ZDCAIm);
  //  fCRCVZvsZDCCov[fRunBin][14]->Fill(fCentralityEBE,VZARe*ZDCAIm);
  //  fCRCVZvsZDCCov[fRunBin][15]->Fill(fCentralityEBE,VZAIm*ZDCARe);


} // end of AliFlowAnalysisCRC::CalculateVZvsZDC();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRCCorr()
{
  Int_t h = fHarmonic-1;
  // quantities:
  Double_t twoAB=0., dM2AB=0.;
  Double_t mp=0., p1n0kRe=0., p1n0kIm=0.;
  Double_t mR=0., dReR1n=0., dImR1n = 0.;

  Int_t CRCBin=0, EBinMin=0, EBinMax=0, EBinMin2=0, EBinMax2=0;
  Double_t e = 1E-5;

  // VZ eta < 0
  Double_t VZCRe = fVZFlowVect[0][1].X();
  Double_t VZCIm = fVZFlowVect[0][1].Y();
  Double_t VZCM  = fVZFlowVect[0][1].GetMult();
  // VZ eta > 0
  Double_t VZARe = fVZFlowVect[1][1].X();
  Double_t VZAIm = fVZFlowVect[1][1].Y();
  Double_t VZAM  = fVZFlowVect[1][1].GetMult();

  // Normalize VZ Q-vector
  if(VZAM>0. && VZCM>0.) {
    VZCRe /= VZCM;
    VZCIm /= VZCM;
    VZARe /= VZAM;
    VZAIm /= VZAM;
  }

  for(Int_t eg=0; eg<fCRCnEtaGap; eg++) {

    Double_t dEtaGap = eg*0.1;
    Double_t dEtaRange = (((fCRCEtaMax-fCRCEtaMin)/2.)-dEtaGap)/2.;
    Double_t dEtaSymm = dEtaGap/2.;

    for(Int_t c=0;c<2;c++) {
      for(Int_t y=0;y<2;y++) {
        for(Int_t c2=0;c2<2;c2++) {
          for(Int_t y2=0;y2<2;y2++) {

            CRCBin = GetCRCBin(c,y,c2,y2);

            if (y==0 && y2==0) {
              EBinMin = fCRCQRe[c][h]->FindBin(fCRCEtaMin);
              EBinMax = fCRCQRe[c][h]->FindBin(fCRCEtaMin+dEtaRange-e);
              EBinMin2 = fCRCQRe[c2][h]->FindBin(-dEtaRange);
              EBinMax2 = fCRCQRe[c2][h]->FindBin(0-e);
            } if (y==1 && y2==1) {
              EBinMin = fCRCQRe[c][h]->FindBin(0);
              EBinMax = fCRCQRe[c][h]->FindBin(dEtaRange-e);
              EBinMin2 = fCRCQRe[c2][h]->FindBin(fCRCEtaMax-dEtaRange);
              EBinMax2 = fCRCQRe[c2][h]->FindBin(fCRCEtaMax-e);
            } if (y==0 && y2==1) {
              EBinMin = fCRCQRe[c][h]->FindBin(-dEtaSymm-dEtaRange);
              EBinMax = fCRCQRe[c][h]->FindBin(-dEtaSymm-e);
              EBinMin2 = fCRCQRe[c2][h]->FindBin(dEtaSymm);
              EBinMax2 = fCRCQRe[c2][h]->FindBin(dEtaSymm+dEtaRange-e);
            } if (y==1 && y2==0) {
              EBinMin = fCRCQRe[c][h]->FindBin(dEtaSymm);
              EBinMax = fCRCQRe[c][h]->FindBin(dEtaSymm+dEtaRange-e);
              EBinMin2 = fCRCQRe[c2][h]->FindBin(-dEtaSymm-dEtaRange);
              EBinMax2 = fCRCQRe[c2][h]->FindBin(-dEtaSymm-e);
            }

            p1n0kRe=0; p1n0kIm=0; mp=0; dReR1n=0; dImR1n=0; mR=0;
            for(Int_t EBin=EBinMin; EBin<=EBinMax; EBin++) {
              p1n0kRe += fCRCQRe[c][h]->GetBinContent(EBin);
              p1n0kIm += fCRCQIm[c][h]->GetBinContent(EBin);
              mp      += fCRCMult[c][h]->GetBinContent(EBin);
            }
            for(Int_t EBin=EBinMin2; EBin<=EBinMax2; EBin++) {
              dReR1n += fCRCQRe[c2][h]->GetBinContent(EBin);
              dImR1n += fCRCQIm[c2][h]->GetBinContent(EBin);
              mR     += fCRCMult[c2][h]->GetBinContent(EBin);
            }

            fCRCSumWeigHist[fRunBin][0][eg][fCenBin]->Fill(CRCBin-e,(mp+mR)*fCenWeightEbE);
            fCRCSumWeigHist[fRunBin][1][eg][fCenBin]->Fill(CRCBin-e,fCenWeightEbE);

            if(mp>1 && mR>1) {
              dM2AB = mp*mR;
              twoAB = (p1n0kRe*dReR1n+p1n0kIm*dImR1n) / dM2AB;

              fCRCCorrPro[fRunBin][0][eg][fCenBin]->Fill(CRCBin-e,twoAB,dM2AB*fCenWeightEbE);
              fCRCCorrProdTempHist[0][0][0]->SetBinContent(CRCBin,twoAB);
              fCRCCorrProdTempHist[0][1][0]->SetBinContent(CRCBin,dM2AB);
              fCRCNUATermsPro[fRunBin][0][eg][fCenBin]->Fill(CRCBin-e,p1n0kRe/mp,mp*fCenWeightEbE);
              fCRCNUATermsPro[fRunBin][1][eg][fCenBin]->Fill(CRCBin-e,dReR1n/mR,mR*fCenWeightEbE);
              fCRCNUATermsPro[fRunBin][2][eg][fCenBin]->Fill(CRCBin-e,p1n0kIm/mp,mp*fCenWeightEbE);
              fCRCNUATermsPro[fRunBin][3][eg][fCenBin]->Fill(CRCBin-e,dImR1n/mR,mR*fCenWeightEbE);

              // gamma terms
              if(VZAM>0. && VZCM>0.) {
                Double_t GammaAB = ((p1n0kRe*dReR1n-p1n0kIm*dImR1n)*VZCRe + (p1n0kRe*dImR1n+p1n0kIm*dReR1n)*VZCIm) / dM2AB;
                fCRCCorrPro[fRunBin][1][eg][fCenBin]->Fill(CRCBin-e,GammaAB,dM2AB*fCenWeightEbE);
                fCRCCorrProdTempHist[1][0][0]->SetBinContent(CRCBin,GammaAB);
                fCRCCorrProdTempHist[1][1][0]->SetBinContent(CRCBin,dM2AB*fCenWeightEbE);

                GammaAB = ((p1n0kRe*dReR1n-p1n0kIm*dImR1n)*VZARe + (p1n0kRe*dImR1n+p1n0kIm*dReR1n)*VZAIm) / dM2AB;
                fCRCCorrPro[fRunBin][2][eg][fCenBin]->Fill(CRCBin-e,GammaAB,dM2AB*fCenWeightEbE);
                fCRCCorrProdTempHist[2][0][0]->SetBinContent(CRCBin,GammaAB);
                fCRCCorrProdTempHist[2][1][0]->SetBinContent(CRCBin,dM2AB*fCenWeightEbE);

                fCRCNUATermsPro[fRunBin][4][eg][fCenBin]->Fill(CRCBin-e,(p1n0kRe*VZARe+p1n0kIm*VZAIm)/mp,mp*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][5][eg][fCenBin]->Fill(CRCBin-e,(p1n0kIm*VZARe-p1n0kRe*VZAIm)/mp,mp*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][6][eg][fCenBin]->Fill(CRCBin-e,(p1n0kRe*VZCRe+p1n0kIm*VZCIm)/mp,mp*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][7][eg][fCenBin]->Fill(CRCBin-e,(p1n0kIm*VZCRe-p1n0kRe*VZCIm)/mp,mp*fCenWeightEbE);

                fCRCNUATermsPro[fRunBin][8][eg][fCenBin]->Fill(CRCBin-e,(dReR1n*VZARe+dImR1n*VZAIm)/mR,mR*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][9][eg][fCenBin]->Fill(CRCBin-e,(dImR1n*VZARe-dReR1n*VZAIm)/mR,mR*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][10][eg][fCenBin]->Fill(CRCBin-e,(dReR1n*VZCRe+dImR1n*VZCIm)/mR,mR*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][11][eg][fCenBin]->Fill(CRCBin-e,(dImR1n*VZCRe-dReR1n*VZCIm)/mR,mR*fCenWeightEbE);

                fCRCNUATermsPro[fRunBin][12][eg][fCenBin]->Fill(CRCBin-e,(p1n0kRe*dReR1n-p1n0kIm*dImR1n)/dM2AB,dM2AB*fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][13][eg][fCenBin]->Fill(CRCBin-e,(p1n0kIm*dReR1n+p1n0kRe*dImR1n)/dM2AB,dM2AB*fCenWeightEbE);

                fCRCNUATermsPro[fRunBin][0][eg][fCenBin]->Fill(fCRCnCR+1-e,VZCRe,fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][1][eg][fCenBin]->Fill(fCRCnCR+1-e,VZARe,fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][2][eg][fCenBin]->Fill(fCRCnCR+1-e,VZCIm,fCenWeightEbE);
                fCRCNUATermsPro[fRunBin][3][eg][fCenBin]->Fill(fCRCnCR+1-e,VZAIm,fCenWeightEbE);
              }

            } else {
              for(Int_t k=0; k<fCRCnCorr; k++) {
                fCRCCorrProdTempHist[k][0][0]->SetBinContent(CRCBin,0.);
                fCRCCorrProdTempHist[k][1][0]->SetBinContent(CRCBin,0.);
              }
            }

          } // end of for(Int_t y2=0;y2<2;y2++)
        } // end of for(Int_t c2=0;c2<2;c2++)
      } // end of for(Int_t y=0;y<2;y++)
    } // end of for(Int_t c=0;c<2;c++)

    if(VZAM>0. && VZCM>0.) {
      Double_t T2Re=0., T2Im=0., mT=0.;
      for(Int_t EBin=1; EBin<=fCRCnEtaBins; EBin++) {
        for(Int_t k=0; k<2; k++) {
          T2Re += fCRCQRe[k][1]->GetBinContent(EBin);
          T2Im += fCRCQIm[k][1]->GetBinContent(EBin);
          mT   += fCRCMult[k][1]->GetBinContent(EBin);
        }
      }
      Double_t ResAB = VZARe*VZCRe+VZAIm*VZCIm;
      fCRCCorrPro[fRunBin][3][eg][fCenBin]->Fill(1-e,ResAB,fCenWeightEbE);
      fCRCCorrProdTempHist[3][0][0]->SetBinContent(1,ResAB);
      fCRCCorrProdTempHist[3][1][0]->SetBinContent(1,fCenWeightEbE);
      ResAB = (VZARe*T2Re+VZAIm*T2Im)/mT;
      fCRCCorrPro[fRunBin][3][eg][fCenBin]->Fill(2-e,ResAB,mT*fCenWeightEbE);
      fCRCCorrProdTempHist[3][0][0]->SetBinContent(2,ResAB);
      fCRCCorrProdTempHist[3][1][0]->SetBinContent(2,fCenWeightEbE);
      ResAB = (T2Re*VZCRe+T2Im*VZCIm)/mT;
      fCRCCorrPro[fRunBin][3][eg][fCenBin]->Fill(3-e,ResAB,mT*fCenWeightEbE);
      fCRCCorrProdTempHist[3][0][0]->SetBinContent(3,ResAB);
      fCRCCorrProdTempHist[3][1][0]->SetBinContent(3,fCenWeightEbE);

      fCRCNUATermsPro[fRunBin][4][eg][fCenBin]->Fill(fCRCnCR+1-e,T2Re/mT,mT*fCenWeightEbE);
      fCRCNUATermsPro[fRunBin][5][eg][fCenBin]->Fill(fCRCnCR+1-e,T2Im/mT,mT*fCenWeightEbE);
    }

    for(Int_t k=0; k<fCRCnCorr; k++) {
      for(Int_t c=0;c<2;c++) {
        for(Int_t y=0;y<2;y++) {
          for(Int_t c2=0;c2<2;c2++) {
            for(Int_t y2=0;y2<2;y2++) {
              for(Int_t c3=0;c3<2;c3++) {
                for(Int_t y3=0;y3<2;y3++) {
                  for(Int_t c4=0;c4<2;c4++) {
                    for(Int_t y4=0;y4<2;y4++) {
                      Int_t CRCBinA = GetCRCBin(c,y,c2,y2);
                      Double_t CorrA = fCRCCorrProdTempHist[k][0][0]->GetBinContent(CRCBinA);
                      Double_t WeigA = fCRCCorrProdTempHist[k][1][0]->GetBinContent(CRCBinA);
                      Int_t CRCBinB = GetCRCBin(c3,y3,c4,y4);
                      Int_t k2 = (k == 3 ? 1 : k);
                      Double_t CorrB = fCRCCorrProdTempHist[k2][0][0]->GetBinContent(CRCBinB);
                      Double_t WeigB = fCRCCorrProdTempHist[k2][1][0]->GetBinContent(CRCBinB);
                      Int_t CRCBin2 = (CRCBinA-1)*fCRCnCR+CRCBinB;
                      fCRCCorrProd2p2pPro[k][eg][fCenBin]->Fill(CRCBin2-e,CorrA*CorrB,WeigA*WeigB*fCenWeightEbE);
                    }
                  }
                }
              }
            } // end of for(Int_t y2=0;y2<2;y2++)
          } // end of for(Int_t c2=0;c2<2;c2++)
        } // end of for(Int_t y=0;y<2;y++)
      } // end of for(Int_t c=0;c<2;c++)
    }

  } // end of for(Int_t eg=0; eg<fCRCnEtaGap; eg++)


} // end of AliFlowAnalysisCRC::CalculateCRCCorr();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRC2Cor()
{
  // quantities:
  Double_t twoAB=0., dM2AB=0.;
  Double_t mp[2]={0.}, mp0[2]={0.}, mp2[2]={0.}, p1n0kRe[2]={0.}, p1n0kIm[2]={0.};
  Double_t mR=0., mR0=0., dReR1n=0., dImR1n=0.;
  Double_t mA=0., mA0=0., mA2=0., dReA1n=0., dImA1n=0.;
  Double_t CorrA=0., WeigA=0., CorrB=0., WeigB=0.;

  for(Int_t e=1; e<=fCRC2nEtaBins; e++) {

    Double_t EtaBin = fCRC2CorPro[0][0]->GetBinCenter(e);
    Int_t ec = fCRC2nEtaBins+1-e;

    // reset
    dReR1n=0.; dImR1n=0.; mR0=0.; mR=0.;
    // fill
    for(Int_t etm=1; etm<=fkEtaDiffMaxNBins; etm++) {
      if(fCRC2CorPro[0][0]->FindBin(fCRC2QRe[0][0]->GetBinCenter(etm))==ec) {
        for(Int_t c=0; c<2; c++) {
          dReR1n += fCRC2QRe[c][0]->GetBinContent(etm);
          dImR1n += fCRC2QIm[c][0]->GetBinContent(etm);
          mR0    += fCRC2Mul[c][0]->GetBinContent(etm);
          mR     += fCRC2Mul[c][1]->GetBinContent(etm);
        }
      }
    }

    // reset
    for(Int_t c=0; c<2; c++) {
      p1n0kRe[c]=0.; p1n0kIm[c]=0.; mp0[c]=0.; mp[c]=0.; mp2[c]=0.;
    }
    dReA1n=0.; dImA1n=0.; mA0=0.; mA=0.; mA2=0.;
    // fill
    for(Int_t etm=1; etm<=fkEtaDiffMaxNBins; etm++) {
      if(fCRC2CorPro[0][0]->FindBin(fCRC2QRe[0][0]->GetBinCenter(etm))==e) {
        for(Int_t c=0; c<2; c++) {
          p1n0kRe[c] += fCRC2QRe[c][0]->GetBinContent(etm);
          p1n0kIm[c] += fCRC2QIm[c][0]->GetBinContent(etm);
          mp0[c]     += fCRC2Mul[c][0]->GetBinContent(etm);
          mp[c]      += fCRC2Mul[c][1]->GetBinContent(etm);
          mp2[c]     += fCRC2Mul[c][2]->GetBinContent(etm);
        }
        dReA1n += fCRC2QRe[2][0]->GetBinContent(etm);
        dImA1n += fCRC2QIm[2][0]->GetBinContent(etm);
        mA0    += fCRC2Mul[2][0]->GetBinContent(etm);
        mA     += fCRC2Mul[2][1]->GetBinContent(etm);
        mA2    += fCRC2Mul[2][2]->GetBinContent(etm);
      }
    }

    if(mR0>0) {

      if(mA0>0) {
        if(e != ec) {
          dM2AB = mA*mR;
          twoAB = (dReA1n*dReR1n+dImA1n*dImR1n) / dM2AB;
        } else {
          dM2AB = mA*mR - mA2;
          twoAB = (dReA1n*dReR1n+dImA1n*dImR1n-mA2) / dM2AB;
        }
        fCRC2CorPro[fCenBin][2]->Fill(EtaBin,twoAB,dM2AB*fCenWeightEbE);
        fCRC2CorHist[0][2][0]->SetBinContent(1,twoAB);
        fCRC2CorHist[0][2][1]->SetBinContent(1,dM2AB);
        fCRC2NUAPro[fCenBin][2][0]->Fill(EtaBin,dReA1n/mA,mA*fCenWeightEbE);
        fCRC2NUAPro[fCenBin][2][1]->Fill(EtaBin,dImA1n/mA,mA*fCenWeightEbE);
        fCRC2NUAPro[fCenBin][2][2]->Fill(EtaBin,dReR1n/mR,mR*fCenWeightEbE);
        fCRC2NUAPro[fCenBin][2][3]->Fill(EtaBin,dImR1n/mR,mR*fCenWeightEbE);
      } else {
        fCRC2CorHist[0][2][0]->SetBinContent(1,0.);
        fCRC2CorHist[0][2][1]->SetBinContent(1,0.);
      }

      for(Int_t c=0;c<2;c++) {

        if(mp0[c]>0) {
          if(e != ec) {
            dM2AB = mp[c]*mR;
            twoAB = (p1n0kRe[c]*dReR1n+p1n0kIm[c]*dImR1n) / dM2AB;
          } else {
            dM2AB = mp[c]*mR - mp2[c];
            twoAB = (p1n0kRe[c]*dReR1n+p1n0kIm[c]*dImR1n-mp2[c]) / dM2AB;
          }
          fCRC2CorPro[fCenBin][c]->Fill(EtaBin,twoAB,dM2AB*fCenWeightEbE);
          fCRC2CorHist[0][c][0]->SetBinContent(1,twoAB);
          fCRC2CorHist[0][c][1]->SetBinContent(1,dM2AB);

          fCRC2NUAPro[fCenBin][c][0]->Fill(EtaBin,p1n0kRe[c]/mp[c],mp[c]*fCenWeightEbE);
          fCRC2NUAPro[fCenBin][c][1]->Fill(EtaBin,p1n0kIm[c]/mp[c],mp[c]*fCenWeightEbE);
          fCRC2NUAPro[fCenBin][c][2]->Fill(EtaBin,dReR1n/mR,mR*fCenWeightEbE);
          fCRC2NUAPro[fCenBin][c][3]->Fill(EtaBin,dImR1n/mR,mR*fCenWeightEbE);
        } else {
          fCRC2CorHist[0][c][0]->SetBinContent(1,0.);
          fCRC2CorHist[0][c][1]->SetBinContent(1,0.);
        }

      } // end of for(Int_t c=0;c<2;c++)

      // calculate covariances
      for(Int_t c=0;c<fkNCorCRC2;c++) {
        CorrA = fCRC2CorHist[0][c][0]->GetBinContent(1);
        WeigA = fCRC2CorHist[0][c][1]->GetBinContent(1);
        for(Int_t c2=0;c2<fkNCorCRC2;c2++) {
          CorrB = fCRC2CorHist[0][c2][0]->GetBinContent(1);
          WeigB = fCRC2CorHist[0][c2][1]->GetBinContent(1);
          fCRC2CovPro[fCenBin][c][c2]->Fill(EtaBin,CorrA*CorrB,WeigA*WeigB*fCenWeightEbE);
        }
      }

    } // end of if(mR>0)

  } // end of for(Int_t e=1; e<=fCRC2nEtaBins; e++)

} // end of AliFlowAnalysisCRC::CalculateCRC2Cor();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCMETPC()
{
  // ZDC QA cuts
  if(fQAZDCCuts && !fQAZDCCutsFlag) {return;}

  Int_t h = 0;

  Int_t VZH = 2;
  // VZ eta < 0
  Double_t VZCRe = fVZFlowVect[0][VZH-1].X();
  Double_t VZCIm = fVZFlowVect[0][VZH-1].Y();
  Double_t VZCM  = fVZFlowVect[0][VZH-1].GetMult();
  Double_t EvPlVZC = TMath::ATan2(VZCIm,VZCRe)/2.;
  // VZ eta > 0
  Double_t VZARe = fVZFlowVect[1][VZH-1].X();
  Double_t VZAIm = fVZFlowVect[1][VZH-1].Y();
  Double_t VZAM  = fVZFlowVect[1][VZH-1].GetMult();
  Double_t EvPlVZA = TMath::ATan2(VZAIm,VZARe)/2.;

  if( VZCM<1. || VZAM<1. ) return;
  if(fZDCESEclEbE<0 || fZDCESEclEbE>=fZDCESEnCl) return;

  Double_t MulWeig = 1.;
  if(fUseZDCESEMulWeights && fZDCESEMultWeightsHist[fZDCESEclEbE]) {
    Double_t weraw = fZDCESEMultWeightsHist[fZDCESEclEbE]->GetBinContent(fZDCESEMultWeightsHist[fZDCESEclEbE]->FindBin(fCentralityEBE,fNumberOfPOIsEBE));
    if(weraw > 0.) MulWeig = 1./weraw;
  }

  Double_t uPRe=0., uPIm=0., uP2Re=0., uP2Im=0., uP2Re2=0., uP2Im2=0., uPM=0., uP2M=0.;
  Double_t uNRe=0., uNIm=0., uN2Re=0., uN2Im=0., uN2Re2=0., uN2Im2=0., uNM=0., uN2M=0.;

  for(Int_t EBin=1; EBin<=fCMEQRe[0][0]->GetNbinsX(); EBin++) {
    // positive charge
    uPRe += fCMEQRe[0][h]->GetBinContent(EBin);
    uPIm += fCMEQIm[0][h]->GetBinContent(EBin);
    uP2Re += fCMEQRe[0][h+1]->GetBinContent(EBin);
    uP2Im += fCMEQIm[0][h+1]->GetBinContent(EBin);
    uP2Re2 += fCMEQRe[2][h+1]->GetBinContent(EBin);
    uP2Im2 += fCMEQIm[2][h+1]->GetBinContent(EBin);
    uPM += fCMEMult[0][h]->GetBinContent(EBin);
    uP2M += fCMEMult[2][h]->GetBinContent(EBin);
    // negative charge
    uNRe += fCMEQRe[1][h]->GetBinContent(EBin);
    uNIm += fCMEQIm[1][h]->GetBinContent(EBin);
    uN2Re += fCMEQRe[1][h+1]->GetBinContent(EBin);
    uN2Im += fCMEQIm[1][h+1]->GetBinContent(EBin);
    uN2Re2 += fCMEQRe[3][h+1]->GetBinContent(EBin);
    uN2Im2 += fCMEQIm[3][h+1]->GetBinContent(EBin);
    uNM  += fCMEMult[1][h]->GetBinContent(EBin);
    uN2M += fCMEMult[3][h]->GetBinContent(EBin);
  }

  Double_t EvPlTPC = TMath::ATan2(uP2Im+uN2Im,uP2Re+uN2Re)/2.;

  if (uPM*uNM*MulWeig>0. && (uPM*uPM-uP2M)*MulWeig>0. && (uNM*uNM-uN2M)*MulWeig>0.) {

    Double_t TwoQpQn = (uPRe*uNRe+uPIm*uNIm)/(uPM*uNM) ;
    fCMETPCCorPro[fZDCESEclEbE][0]->Fill(fCentralityEBE,TwoQpQn,uPM*uNM*MulWeig);
    fCMETPCSCPro[0][0]->Fill(fCentralityEBE,TwoQpQn,uPM*uNM*MulWeig);
    fCMETPCSCPro[0][1]->Fill(fCentralityEBE,TwoQpQn*(fZNCen+fZNAen),uPM*uNM*MulWeig);

    Double_t TwoQpQp = (uPRe*uPRe+uPIm*uPIm-uP2M)/(uPM*uPM-uP2M) ;
    fCMETPCCorPro[fZDCESEclEbE][1]->Fill(fCentralityEBE,TwoQpQp,(uPM*uPM-uP2M)*MulWeig);
    fCMETPCSCPro[1][0]->Fill(fCentralityEBE,TwoQpQp,(uPM*uPM-uP2M)*MulWeig);
    fCMETPCSCPro[1][1]->Fill(fCentralityEBE,TwoQpQp*(fZNCen+fZNAen),(uPM*uPM-uP2M)*MulWeig);

    Double_t TwoQnQn = (uNRe*uNRe+uNIm*uNIm-uN2M)/(uNM*uNM-uN2M) ;
    fCMETPCCorPro[fZDCESEclEbE][2]->Fill(fCentralityEBE,TwoQnQn,(uNM*uNM-uN2M)*MulWeig);
    fCMETPCSCPro[2][0]->Fill(fCentralityEBE,TwoQnQn,(uNM*uNM-uN2M)*MulWeig);
    fCMETPCSCPro[2][1]->Fill(fCentralityEBE,TwoQnQn*(fZNCen+fZNAen),(uNM*uNM-uN2M)*MulWeig);

    //NUA
    fCMETPCCorPro[fZDCESEclEbE][15]->Fill(fCentralityEBE,uPRe/uPM,uPM*MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][16]->Fill(fCentralityEBE,uPIm/uPM,uPM*MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][17]->Fill(fCentralityEBE,uNRe/uNM,uNM*MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][18]->Fill(fCentralityEBE,uNIm/uNM,uNM*MulWeig);

    Double_t TwoQpQnV = ((uPRe*uNRe-uPIm*uNIm)*cos(2.*EvPlVZC) + (uPRe*uNIm+uPIm*uNRe)*sin(2.*EvPlVZC)) / (uPM*uNM) ;
    fCMETPCCorPro[fZDCESEclEbE][3]->Fill(fCentralityEBE,TwoQpQnV,(uPM*uNM)*MulWeig);
    fCMETPCSCPro[3][0]->Fill(fCentralityEBE,TwoQpQnV,(uPM*uNM)*MulWeig);
    fCMETPCSCPro[3][1]->Fill(fCentralityEBE,TwoQpQnV*(fZNCen+fZNAen),(uPM*uNM)*MulWeig);

    Double_t TwoQpQpV = ((uPRe*uPRe-uPIm*uPIm-uP2Re2)*cos(2.*EvPlVZC) + (2.*uPRe*uPIm-uP2Im2)*sin(2.*EvPlVZC)) / (uPM*uPM-uP2M) ;
    fCMETPCCorPro[fZDCESEclEbE][4]->Fill(fCentralityEBE,TwoQpQpV,(uPM*uPM-uP2M)*MulWeig);
    fCMETPCSCPro[4][0]->Fill(fCentralityEBE,TwoQpQpV,(uPM*uPM-uP2M)*MulWeig);
    fCMETPCSCPro[4][1]->Fill(fCentralityEBE,TwoQpQpV*(fZNCen+fZNAen),(uPM*uPM-uP2M)*MulWeig);

    Double_t TwoQnQnV = ((uNRe*uNRe-uNIm*uNIm-uN2Re2)*cos(2.*EvPlVZC) + (2.*uNRe*uNIm-uN2Im2)*sin(2.*EvPlVZC)) / (uNM*uNM-uN2M) ;
    fCMETPCCorPro[fZDCESEclEbE][5]->Fill(fCentralityEBE,TwoQnQnV,(uNM*uNM-uN2M)*MulWeig);
    fCMETPCSCPro[5][0]->Fill(fCentralityEBE,TwoQnQnV,(uNM*uNM-uN2M)*MulWeig);
    fCMETPCSCPro[5][1]->Fill(fCentralityEBE,TwoQnQnV*(fZNCen+fZNAen),(uNM*uNM-uN2M)*MulWeig);

    TwoQpQnV = ((uPRe*uNRe-uPIm*uNIm)*cos(2.*EvPlVZA) + (uPRe*uNIm+uPIm*uNRe)*sin(2.*EvPlVZA)) / (uPM*uNM) ;
    fCMETPCCorPro[fZDCESEclEbE][6]->Fill(fCentralityEBE,TwoQpQnV,(uPM*uNM)*MulWeig);

    TwoQpQpV = ((uPRe*uPRe-uPIm*uPIm-uP2Re2)*cos(2.*EvPlVZA) + (2.*uPRe*uPIm-uP2Im2)*sin(2.*EvPlVZA)) / (uPM*uPM-uP2M) ;
    fCMETPCCorPro[fZDCESEclEbE][7]->Fill(fCentralityEBE,TwoQpQpV,(uPM*uPM-uP2M)*MulWeig);

    TwoQnQnV = ((uNRe*uNRe-uNIm*uNIm-uN2Re2)*cos(2.*EvPlVZA) + (2.*uNRe*uNIm-uN2Im2)*sin(2.*EvPlVZA)) / (uNM*uNM-uN2M) ;
    fCMETPCCorPro[fZDCESEclEbE][8]->Fill(fCentralityEBE,TwoQnQnV,(uNM*uNM-uN2M)*MulWeig);

    // Resolution corrections

    fCMETPCCorPro[fZDCESEclEbE][9]->Fill(fCentralityEBE,cos(2.*(EvPlVZC-EvPlVZA)),MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][10]->Fill(fCentralityEBE,cos(2.*(EvPlTPC-EvPlVZC)),MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][11]->Fill(fCentralityEBE,cos(2.*(EvPlTPC-EvPlVZA)),MulWeig);

    fCMETPCSCPro[6][0]->Fill(fCentralityEBE,cos(2.*(EvPlVZC-EvPlVZA)),MulWeig);
    fCMETPCSCPro[6][1]->Fill(fCentralityEBE,cos(2.*(EvPlTPC-EvPlVZC)),MulWeig);
    fCMETPCSCPro[7][0]->Fill(fCentralityEBE,cos(2.*(EvPlTPC-EvPlVZA)),MulWeig);

    // ZDC-ESE terms

    fCMETPCCorPro[fZDCESEclEbE][12]->Fill(fCentralityEBE,fZNCen+fZNAen,MulWeig);
    fCMETPCCorPro[fZDCESEclEbE][13]->Fill(fCentralityEBE,uPM+uNM,MulWeig);

    fCMETPCCorPro2D[0]->Fill(VZAM+VZCM,fZNCen+fZNAen,TwoQpQn,(uPM*uNM)*MulWeig);
    fCMETPCCorPro2D[1]->Fill(VZAM+VZCM,fZNCen+fZNAen,TwoQpQp,(uPM*uPM-uP2M)*MulWeig);
    fCMETPCCorPro2D[2]->Fill(VZAM+VZCM,fZNCen+fZNAen,TwoQnQn,(uNM*uNM-uN2M)*MulWeig);

  } // end of if (uPM>1. && uNM>1.)

  // **********************************************************************************************************

  // Eta Gap
  Double_t QARe=0., QAIm=0., QBRe=0., QBIm=0., QAM0=0., QAM=0., QBM0=0., QBM=0.;
  Int_t hr=0;

  for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
    QARe += fPOIPtDiffQReEG[0][1][hr+1]->GetBinContent(pt+1);
    QAIm += fPOIPtDiffQImEG[0][1][hr+1]->GetBinContent(pt+1);
    QBRe += fPOIPtDiffQReEG[1][1][hr+1]->GetBinContent(pt+1);
    QBIm += fPOIPtDiffQImEG[1][1][hr+1]->GetBinContent(pt+1);
    QAM0 += fPOIPtDiffMulEG[0][0][0]->GetBinContent(pt+1);
    QAM  += fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1);
    QBM0 += fPOIPtDiffMulEG[1][0][0]->GetBinContent(pt+1);
    QBM  += fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1);
  }

  Double_t IQM2EG = QAM*QBM;
  if(QAM0+QBM0>1) {
    if(IQM2EG) {
      Double_t IQC2EG = (QARe*QBRe+QAIm*QBIm)/IQM2EG;
      fCMETPCCorPro[fZDCESEclEbE][14]->Fill(fCentralityEBE,IQC2EG,IQM2EG*MulWeig);
    }
  }

} // end of AliFlowAnalysisCRC::CalculateCMETPC();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCMEZDC()
{
  Int_t h = fHarmonic-1;
  Double_t e = 1E-5;

  // ZDC-C (eta < -8.8)
  Double_t VCRe = fZDCFlowVect[0].X();
  Double_t VCIm = fZDCFlowVect[0].Y();
  Double_t VCM  = fZDCFlowVect[0].GetMult();
  // ZDC-A (eta > 8.8)
  Double_t VARe = fZDCFlowVect[1].X();
  Double_t VAIm = fZDCFlowVect[1].Y();
  Double_t VAM  = fZDCFlowVect[1].GetMult();

  if( fInvertZDC ) VARe = -VARe;

  // cut on centrality >5%
  if( fCentralityEBE<5. ) return;
  // cut on multiplicity
  if( VCM<1. || VAM<1. ) return;

  // Common variables

  Double_t uPRe=0., uPIm=0., uPM=0., uP2Re=0., uP2Im=0.;
  Double_t uNRe=0., uNIm=0., uNM=0., uN2Re=0., uN2Im=0.;
  Double_t uARe=0., uAIm=0.;
  Double_t uBRe=0., uBIm=0.;
  Double_t QDRe=0., QDIm=0., QRRe=0., QRIm=0.;
  Double_t B2Re=0., B2Im=0., BM=0.;

  for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {

    Int_t EBin = ( eg == 0 ? fCMEQRe[0][h]->FindBin(0.4) : fCMEQRe[0][h]->FindBin(-0.4) );
    // positive charge
    uPRe = fCMEQRe[0][h]->GetBinContent(EBin);
    uPIm = fCMEQIm[0][h]->GetBinContent(EBin);
    uPM  = fCMEMult[0][h]->GetBinContent(EBin);
    uP2Re = fCMEQRe[0][h+1]->GetBinContent(EBin);
    uP2Im = fCMEQIm[0][h+1]->GetBinContent(EBin);
    // negative charge
    uNRe = fCMEQRe[1][h]->GetBinContent(EBin);
    uNIm = fCMEQIm[1][h]->GetBinContent(EBin);
    uNM  = fCMEMult[1][h]->GetBinContent(EBin);
    uN2Re = fCMEQRe[1][h+1]->GetBinContent(EBin);
    uN2Im = fCMEQIm[1][h+1]->GetBinContent(EBin);
    // random A
    uARe = fCMEQRe[2][h]->GetBinContent(EBin);
    uAIm = fCMEQIm[2][h]->GetBinContent(EBin);
    // random B
    uBRe = fCMEQRe[3][h]->GetBinContent(EBin);
    uBIm = fCMEQIm[3][h]->GetBinContent(EBin);

    QDRe = uPRe-uNRe;
    QDIm = uPIm-uNIm;
    QRRe = uARe-uBRe;
    QRIm = uAIm-uBIm;
    BM = uPM+uNM;
    B2Re = uP2Re+uN2Re;
    B2Im = uP2Im+uN2Im;

    // Event plane

    Double_t VAPsi = TMath::ATan2(VAIm,VARe);
    Double_t VCPsi = TMath::ATan2(VCIm,VCRe);
    Double_t VARe = TMath::Cos(2.*VAPsi);
    Double_t VAIm = TMath::Sin(2.*VAPsi);
    Double_t VCRe = TMath::Cos(2.*VCPsi);
    Double_t VCIm = TMath::Sin(2.*VCPsi);

    // **********************************************************************************************************

    if (uPM>1. && uNM>1.) {

      // ZDC-C Gamma

      Double_t TwoQpQnV = ((uPRe*uNRe-uPIm*uNIm)*VCRe + (uPRe*uNIm+uPIm*uNRe)*VCIm) / (uPM*uNM) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(0+e,TwoQpQnV,fCenWeightEbE);

      Double_t TwoQpQpV = ((uPRe*uPRe-uPIm*uPIm-uP2Re)*VCRe + (2.*uPRe*uPIm-uP2Im)*VCIm) / (uPM*(uPM-1.)) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(1+e,TwoQpQpV,fCenWeightEbE);

      Double_t TwoQnQnV = ((uNRe*uNRe-uNIm*uNIm-uN2Re)*VCRe + (2.*uNRe*uNIm-uN2Im)*VCIm) / (uNM*(uNM-1.)) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(2+e,TwoQnQnV,fCenWeightEbE);

      // ZDC-C Gamma dipole

      Double_t TwoQtDV = ((QDRe*QDRe-QDIm*QDIm-B2Re)*VCRe + (2.*QDRe*QDIm-B2Im)*VCIm) / (BM*(BM-1.));
      fCMEZDCCorPro[eg][fCenBin]->Fill(3+e,TwoQtDV,fCenWeightEbE);

      Double_t TwoQtRV = ((QRRe*QRRe-QRIm*QRIm-B2Re)*VCRe + (2.*QRRe*QRIm-B2Im)*VCIm) / (BM*(BM-1.));
      fCMEZDCCorPro[eg][fCenBin]->Fill(4+e,TwoQtRV,fCenWeightEbE);

      // ZDC-A Gamma

      TwoQpQnV = ((uPRe*uNRe-uPIm*uNIm)*VARe + (uPRe*uNIm+uPIm*uNRe)*VAIm) / (uPM*uNM) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(5+e,TwoQpQnV,fCenWeightEbE);

      TwoQpQpV = ((uPRe*uPRe-uPIm*uPIm-uP2Re)*VARe + (2.*uPRe*uPIm-uP2Im)*VAIm) / (uPM*(uPM-1.)) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(6+e,TwoQpQpV,fCenWeightEbE);

      TwoQnQnV = ((uNRe*uNRe-uNIm*uNIm-uN2Re)*VARe + (2.*uNRe*uNIm-uN2Im)*VAIm) / (uNM*(uNM-1.)) ;
      fCMEZDCCorPro[eg][fCenBin]->Fill(7+e,TwoQnQnV,fCenWeightEbE);

      // ZDC-A Gamma dipole

      TwoQtDV = ((QDRe*QDRe-QDIm*QDIm-B2Re)*VARe + (2.*QDRe*QDIm-B2Im)*VAIm) / (BM*(BM-1.));
      fCMEZDCCorPro[eg][fCenBin]->Fill(8+e,TwoQtDV,fCenWeightEbE);

      TwoQtRV = ((QRRe*QRRe-QRIm*QRIm-B2Re)*VARe + (2.*QRRe*QRIm-B2Im)*VAIm) / (BM*(BM-1.));
      fCMEZDCCorPro[eg][fCenBin]->Fill(9+e,TwoQtRV,fCenWeightEbE);

      // Resolution corrections

      Double_t TPsi = TMath::ATan2(uP2Im,uP2Re)/2.;
      fCMEZDCCorPro[eg][fCenBin]->Fill(10+e,TMath::Cos(2.*(VAPsi-VCPsi)),fCenWeightEbE);
      fCMEZDCCorPro[eg][fCenBin]->Fill(11+e,TMath::Cos(2.*(VAPsi-TPsi)),fCenWeightEbE);
      fCMEZDCCorPro[eg][fCenBin]->Fill(12+e,TMath::Cos(2.*(VCPsi-TPsi)),fCenWeightEbE);

    } // end of if (uPM>1. && uNM>1.)

    // **********************************************************************************************************

    // Distributions

    Double_t PhiD = TMath::ATan2(QDIm,QDRe);
    Double_t PhiR = TMath::ATan2(QRIm,QRRe);

    Double_t Dist = 0.;
    Dist = TMath::Abs(TMath::ATan2(TMath::Sin(PhiD-VAPsi),TMath::Cos(PhiD-VAPsi)));
    if(Dist > TMath::Pi()/2.)  Dist = TMath::Pi() - Dist;
    fCMEZDCDistHist[eg][fCenBin][0]->Fill(Dist,fCenWeightEbE);

    Dist = TMath::Abs(TMath::ATan2(TMath::Sin(PhiR-VAPsi),TMath::Cos(PhiR-VAPsi)));
    if(Dist > TMath::Pi()/2.)  Dist = TMath::Pi() - Dist;
    fCMEZDCDistHist[eg][fCenBin][1]->Fill(Dist,fCenWeightEbE);

    Dist = TMath::Abs(TMath::ATan2(TMath::Sin(PhiD-VCPsi),TMath::Cos(PhiD-VCPsi)));
    if(Dist > TMath::Pi()/2.)  Dist = TMath::Pi() - Dist;
    fCMEZDCDistHist[eg][fCenBin][2]->Fill(Dist,fCenWeightEbE);

    Dist = TMath::Abs(TMath::ATan2(TMath::Sin(PhiR-VCPsi),TMath::Cos(PhiR-VCPsi)));
    if(Dist > TMath::Pi()/2.)  Dist = TMath::Pi() - Dist;
    fCMEZDCDistHist[eg][fCenBin][3]->Fill(Dist,fCenWeightEbE);

  } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)

} // end of AliFlowAnalysisCRC::CalculateCMEZDC();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateFlowSCZDC()
{
  //symmetric cumulants

  Double_t Nspe = fZNCen+fZNAen;
  Double_t Pspe = fZPCen+fZPAen;

  for(Int_t hsc=0; hsc<2; hsc++) {
    Double_t QARe=0., QAIm=0., QBRe=0., QBIm=0., QAM0=0., QAM=0., QBM0=0., QBM=0., AvPt=0.;
    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
      QARe += fPOIPtDiffQReEG[0][1][hsc+1]->GetBinContent(pt+1);
      QAIm += fPOIPtDiffQImEG[0][1][hsc+1]->GetBinContent(pt+1);
      QBRe += fPOIPtDiffQReEG[1][1][hsc+1]->GetBinContent(pt+1);
      QBIm += fPOIPtDiffQImEG[1][1][hsc+1]->GetBinContent(pt+1);
      QAM0 += fPOIPtDiffMulEG[0][0][0]->GetBinContent(pt+1);
      QAM  += fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1);
      QBM0 += fPOIPtDiffMulEG[1][0][0]->GetBinContent(pt+1);
      QBM  += fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1);
      AvPt += fPOIPtDiffMulEG[0][1][0]->GetBinCenter(pt+1)*(fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1)+fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1));
    }

    Double_t fracMulFluct=0.;
    if(fRefMultRbRPro) {
      Int_t runbin = fRefMultRbRPro->GetXaxis()->FindBin(Form("%d",fRunNum));
      Int_t cenbin = fRefMultRbRPro->GetYaxis()->FindBin(fCentralityEBE);
      fracMulFluct = fabs(fReferenceMultiplicityEBE-fRefMultRbRPro->GetBinContent(runbin,cenbin))/fRefMultRbRPro->GetBinContent(runbin,cenbin);
    }

    Double_t IQM2EG = QAM*QBM;
    if(QAM0>1 && QBM0>1) {
      AvPt /= (QAM+QBM);
      if(IQM2EG && fracMulFluct<0.33) {
        Double_t IQC2EG = (QARe*QBRe+QAIm*QBIm)/IQM2EG;

        Double_t ArrVar[fkFlowSCNvar] = {IQC2EG,Nspe,AvPt,QAM+QBM,Pspe,fCentralityEBE};
        for (Int_t k=0; k<fkFlowSCNvar; k++) {
          for (Int_t z=0; z<fkFlowSCNvar; z++) {
            if(k!=z) fFlowSCCrossProdPro[hsc][k][z]->Fill(fCentralityEBE,ArrVar[k]*ArrVar[z],fCenWeightEbE);
            else     fFlowSCCrossProdPro[hsc][k][z]->Fill(fCentralityEBE,ArrVar[k]);
            if(k!=z) fFlowSCCrossProdProMult[hsc][k][z]->Fill(fReferenceMultiplicityEBE,ArrVar[k]*ArrVar[z],fCenWeightEbE);
            else     fFlowSCCrossProdProMult[hsc][k][z]->Fill(fReferenceMultiplicityEBE,ArrVar[k]);
          }
        }
        fFlowSCProdPro[hsc][0]->Fill(fCentralityEBE,IQC2EG*Nspe,fCenWeightEbE);
        fFlowSCProdPro[hsc][1]->Fill(fCentralityEBE,IQC2EG*fCentralityEBE,fCenWeightEbE);
        fFlowSCProdPro[hsc][2]->Fill(fCentralityEBE,Nspe*fCentralityEBE,fCenWeightEbE);
        fFlowSCProdPro[hsc][3]->Fill(fCentralityEBE,IQC2EG,fCenWeightEbE);
        fFlowSCProdPro[hsc][4]->Fill(fCentralityEBE,Nspe,fCenWeightEbE);
        fFlowSCProdPro[hsc][5]->Fill(fCentralityEBE,fCentralityEBE,fCenWeightEbE);
      }
    }
  }

}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateFlowSPZDC(Double_t ZCRe, Double_t ZCIm, Double_t ZARe, Double_t ZAIm, Double_t dPhi, Double_t dEta, Double_t dPt, Double_t wPhiEta, Double_t dCharge, Int_t dCnt)
{

  Double_t QRe = TMath::Cos(dPhi);
  Double_t QIm = TMath::Sin(dPhi);
  Double_t Q2Re = TMath::Cos(2.*dPhi);
  Double_t Q2Im = TMath::Sin(2.*dPhi);

  for(Int_t hr=0; hr<fFlowNHarmZDC; hr++) {

    // integrated flow

    if(hr==0) {

      // standard SP
      fFlowSPZDCIntPro[hr][0]->Fill(fCentralityEBE,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);
      if(dCnt==0) fFlowSPZDCIntPro[hr][1]->Fill(fCentralityEBE,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);

      // individual components
      fFlowSPZDCIntPro[hr][2]->Fill(fCentralityEBE,Q2Re*ZARe*ZCRe,wPhiEta*fCenWeightEbE);
      fFlowSPZDCIntPro[hr][3]->Fill(fCentralityEBE,-Q2Re*ZAIm*ZCIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCIntPro[hr][4]->Fill(fCentralityEBE,Q2Im*ZARe*ZCIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCIntPro[hr][5]->Fill(fCentralityEBE,Q2Im*ZCRe*ZAIm,wPhiEta*fCenWeightEbE);
      if(dCnt==0) {
        fFlowSPZDCIntPro[hr][6]->Fill(fCentralityEBE,ZARe*ZCRe,fCenWeightEbE);
        fFlowSPZDCIntPro[hr][7]->Fill(fCentralityEBE,ZAIm*ZCIm,fCenWeightEbE);
      }

      //NUA
      fFlowSPZDCIntNUA[0]->Fill(fCentralityEBE,Q2Re,wPhiEta*fCenWeightEbE);
      fFlowSPZDCIntNUA[1]->Fill(fCentralityEBE,Q2Im,wPhiEta*fCenWeightEbE);
      //temp different charges
//      if(dCharge== 1)  fFlowSPZDCIntNUA[2]->Fill(fCentralityEBE,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);
//      if(dCharge==-1) fFlowSPZDCIntNUA[3]->Fill(fCentralityEBE,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);

      }

//    if(hr==1) {
//      Qtot = QRe*(ZARe*ZARe*ZCRe-2.*ZARe*ZAIm*ZCIm-ZCRe*ZAIm*ZAIm)
//      + QIm*(-ZAIm*ZAIm*ZCIm+2.*ZAIm*ZARe*ZCRe+ZCIm*ZARe*ZARe);
//      fFlowSPZDCIntPro[hr][0]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QRe*(ZARe*ZARe*ZCRe-2.*ZARe*ZAIm*ZCIm-ZCRe*ZAIm*ZAIm);
//      fFlowSPZDCIntPro[hr][1]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QIm*(-ZAIm*ZAIm*ZCIm+2.*ZAIm*ZARe*ZCRe+ZCIm*ZARe*ZARe);
//      fFlowSPZDCIntPro[hr][2]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QRe*(ZCRe*ZCRe*ZARe-2.*ZCRe*ZCIm*ZAIm-ZARe*ZCIm*ZCIm)
//      + QIm*(-ZCIm*ZCIm*ZAIm+2.*ZCIm*ZCRe*ZARe+ZAIm*ZCRe*ZCRe);
//      fFlowSPZDCIntPro[hr][3]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QRe*(ZCRe*ZCRe*ZARe-2.*ZCRe*ZCIm*ZAIm-ZARe*ZCIm*ZCIm);
//      fFlowSPZDCIntPro[hr][4]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QIm*(-ZCIm*ZCIm*ZAIm+2.*ZCIm*ZCRe*ZARe+ZAIm*ZCRe*ZCRe);
//      fFlowSPZDCIntPro[hr][5]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//    }
//
//    if(hr==2) {
//      Qtot = QRe*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm))
//      + QIm*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
//      fFlowSPZDCIntPro[hr][0]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QRe*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm));
//      fFlowSPZDCIntPro[hr][1]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QIm*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
//      fFlowSPZDCIntPro[hr][2]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = QIm*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm));
//      fFlowSPZDCIntPro[hr][3]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//      Qtot = -QRe*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
//      fFlowSPZDCIntPro[hr][4]->Fill(fCentralityEBE,Qtot/QM,fCenWeightEbE);
//    }

    // pT-differential flow

    // ZDC resolution correction
    if(dCnt==0) {
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(1),ZARe*ZCRe,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(2),ZAIm*ZCIm,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(3),ZARe*ZCIm,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(4),ZAIm*ZCRe,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(5),ZARe*ZCRe*ZAIm*ZCIm,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(6),ZARe*ZCRe*ZAIm*ZCIm,fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(7),ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
    }

    if(hr==0) {
      // real terms (flow)
      fFlowSPZDCCorPro[fCenBin][hr][1]->Fill(dPt,Q2Re*ZARe*ZCRe,wPhiEta*fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][2]->Fill(dPt,Q2Re*ZAIm*ZCIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][3]->Fill(dPt,Q2Im*ZARe*ZCIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCCorPro[fCenBin][hr][4]->Fill(dPt,Q2Im*ZAIm*ZCRe,wPhiEta*fCenWeightEbE);
      //          // imaginary terms (null)
      //          fFlowSPZDCCorPro[fCenBin][hr][5]->Fill(FillPtBin,qpIm*ZARe*ZCRe/qpM/NZC/NZA,qpM*WZA*WZC*fCenWeightEbE);
      //          fFlowSPZDCCorPro[fCenBin][hr][6]->Fill(FillPtBin,qpIm*ZAIm*ZCIm/qpM/NZC/NZA,qpM*WZA*WZC*fCenWeightEbE);
      //          fFlowSPZDCCorPro[fCenBin][hr][7]->Fill(FillPtBin,qpRe*ZARe*ZCIm/qpM/NZC/NZA,qpM*WZA*WZC*fCenWeightEbE);
      //          fFlowSPZDCCorPro[fCenBin][hr][8]->Fill(FillPtBin,qpRe*ZAIm*ZCRe/qpM/NZC/NZA,qpM*WZA*WZC*fCenWeightEbE);
      // NUA terms
      fFlowSPZDCCorNUA[fCenBin][0]->Fill(dPt,Q2Re,wPhiEta*fCenWeightEbE);    // cos(2*phi)
      fFlowSPZDCCorNUA[fCenBin][1]->Fill(dPt,Q2Im,wPhiEta*fCenWeightEbE);    // sin(2*phi)
//      fFlowSPZDCCorNUA[fCenBin][2]->Fill(FillPtBin,Q2Re,wPhiEta*fCenWeightEbE);    // cos(2*phi)
//      fFlowSPZDCCorNUA[fCenBin][3]->Fill(FillPtBin,Q2Im,wPhiEta*fCenWeightEbE);    // sin(2*phi)
    // all vs pos vs neg charges
      fFlowSPZDCCorPro[fCenBin][hr][5]->Fill(dPt,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);
      if(dCharge== 1) fFlowSPZDCCorPro[fCenBin][hr][6]->Fill(dPt,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);
      if(dCharge==-1) fFlowSPZDCCorPro[fCenBin][hr][7]->Fill(dPt,Q2Re*(ZARe*ZCRe-ZAIm*ZCIm)+Q2Im*(ZARe*ZCIm+ZCRe*ZAIm),wPhiEta*fCenWeightEbE);
    }

      //   if(hr+2==3) {
      //    Double_t Q1Z = -qpRe*(ZARe*ZAIm*ZCIm);
      //    Double_t Q2Z = -qpRe*(ZCRe*ZAIm*ZCIm);
      //    Double_t Q3Z = qpIm*(ZARe*ZAIm*ZCRe);
      //    Double_t Q4Z = qpIm*(ZCRe*ZCIm*ZARe);
      //    fFlowSPZDCCorPro[fCenBin][hr][1]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][2]->Fill(FillPtBin,Q2Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][3]->Fill(FillPtBin,Q3Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][4]->Fill(FillPtBin,Q4Z/qpM,fCenWeightEbE);
      //    Q1Z = -qpIm*(ZARe*ZAIm*ZCIm);
      //    Q2Z = -qpIm*(ZCRe*ZAIm*ZCIm);
      //    Q3Z = -qpRe*(ZARe*ZAIm*ZCRe);
      //    Q4Z = -qpRe*(ZCRe*ZCIm*ZARe);
      //    fFlowSPZDCCorPro[fCenBin][hr][5]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][6]->Fill(FillPtBin,Q2Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][7]->Fill(FillPtBin,Q3Z/qpM,fCenWeightEbE);
      //    fFlowSPZDCCorPro[fCenBin][hr][8]->Fill(FillPtBin,Q4Z/qpM,fCenWeightEbE);
      //   }
      //
      //   if(hr+2==4) {
      //    Double_t Q1Z = -qpRe*(ZARe*ZAIm*ZCRe*ZCIm);
      //    fFlowSPZDCCorPro[fCenBin][hr][1]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    Q1Z = -qpIm*(ZARe*ZAIm*ZCRe*ZCIm);
      //    fFlowSPZDCCorPro[fCenBin][hr][2]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    Q1Z = qpRe*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm));
      //    fFlowSPZDCCorPro[fCenBin][hr][3]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    Q1Z = qpIm*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
      //    fFlowSPZDCCorPro[fCenBin][hr][4]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    Q1Z = qpIm*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm));
      //    fFlowSPZDCCorPro[fCenBin][hr][5]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //    Q1Z = -qpRe*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
      //    fFlowSPZDCCorPro[fCenBin][hr][6]->Fill(FillPtBin,Q1Z/qpM,fCenWeightEbE);
      //   }

  } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

  // v1 vs eta *****************************************************************

  fFlowSPZDCv1etaPro[fCenBin][0][0]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaPro[fCenBin][0][1]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  if(dCnt==0) fFlowSPZDCv1etaPro[fCenBin][0][2]->Fill(dEta,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaPro[fCenBin][0][3]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][0][4]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaPro[fCenBin][0][5]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][0][6]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  }

  // term by term: real part
  fFlowSPZDCv1etaPro[fCenBin][1][0]->Fill(dEta,QRe*ZARe,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaPro[fCenBin][1][1]->Fill(dEta,QRe*ZCRe,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaPro[fCenBin][1][2]->Fill(dEta,QRe*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][1][3]->Fill(dEta,QRe*ZCRe,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaPro[fCenBin][1][4]->Fill(dEta,QRe*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][1][5]->Fill(dEta,QRe*ZCRe,wPhiEta*fCenWeightEbE);
  }
  // term by term: imaginary part
  fFlowSPZDCv1etaPro[fCenBin][1][6]->Fill(dEta,QIm*ZAIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaPro[fCenBin][1][7]->Fill(dEta,QIm*ZCIm,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaPro[fCenBin][1][8]->Fill(dEta,QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][1][9]->Fill(dEta,QIm*ZCIm,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaPro[fCenBin][1][10]->Fill(dEta,QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][1][11]->Fill(dEta,QIm*ZCIm,wPhiEta*fCenWeightEbE);
  }
  if(dCnt==0) {
    fFlowSPZDCv1etaPro[fCenBin][1][12]->Fill(dEta,ZARe*ZCRe,fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][1][13]->Fill(dEta,ZAIm*ZCIm,fCenWeightEbE);
  }

  // covariances - standard
  fFlowSPZDCv1etaCovPro[fCenBin][0]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(QRe*ZCRe+QIm*ZCIm),wPhiEta*wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaCovPro[fCenBin][1]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaCovPro[fCenBin][2]->Fill(dEta,(QRe*ZCRe+QIm*ZCIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaCovPro[fCenBin][3]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(QRe*ZCRe+QIm*ZCIm),wPhiEta*wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaCovPro[fCenBin][4]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaCovPro[fCenBin][5]->Fill(dEta,(QRe*ZCRe+QIm*ZCIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaCovPro[fCenBin][6]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(QRe*ZCRe+QIm*ZCIm),wPhiEta*wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaCovPro[fCenBin][7]->Fill(dEta,(QRe*ZARe+QIm*ZAIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaCovPro[fCenBin][8]->Fill(dEta,(QRe*ZCRe+QIm*ZCIm)*(ZARe*ZCRe+ZAIm*ZCIm),wPhiEta*fCenWeightEbE);
  }
  // covariances - cross terms between charges
//  fFlowSPZDCv1etaCovPro[fCenBin][9]->Fill(dEta,(QPRe*ZARe+QPIm*ZAIm)*(QNRe*ZARe+QNIm*ZAIm),QPM*QNM*fCenWeightEbE);
//  fFlowSPZDCv1etaCovPro[fCenBin][10]->Fill(dEta,(QPRe*ZARe+QPIm*ZAIm)*(QNRe*ZCRe+QNIm*ZCIm),QPM*QNM*fCenWeightEbE);
//  fFlowSPZDCv1etaCovPro[fCenBin][11]->Fill(dEta,(QPRe*ZCRe+QPIm*ZCIm)*(QNRe*ZARe+QNIm*ZAIm),QPM*QNM*fCenWeightEbE);
//  fFlowSPZDCv1etaCovPro[fCenBin][12]->Fill(dEta,(QPRe*ZCRe+QPIm*ZCIm)*(QNRe*ZCRe+QNIm*ZCIm),QPM*QNM*fCenWeightEbE);

  // store separately positive and negative magnet polarity
  if(fbFlagIsPosMagField) {
    fFlowSPZDCv1etaPro[fCenBin][2][0]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][2][1]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    if(dCnt==0) fFlowSPZDCv1etaPro[fCenBin][2][2]->Fill(dEta,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
    if(dCharge== 1) {
      fFlowSPZDCv1etaPro[fCenBin][2][3]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCv1etaPro[fCenBin][2][4]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    } else {
      fFlowSPZDCv1etaPro[fCenBin][2][5]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCv1etaPro[fCenBin][2][6]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    }
  } else {
    fFlowSPZDCv1etaPro[fCenBin][2][7]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPro[fCenBin][2][8]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    if(dCnt==0) fFlowSPZDCv1etaPro[fCenBin][2][9]->Fill(dEta,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
    if(dCharge== 1) {
      fFlowSPZDCv1etaPro[fCenBin][2][10]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCv1etaPro[fCenBin][2][11]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    } else {
      fFlowSPZDCv1etaPro[fCenBin][2][12]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fFlowSPZDCv1etaPro[fCenBin][2][13]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    }
  }

  if(dCnt==0) {
    Double_t DistCen = sqrt(pow(ZARe-ZCRe,2.)+pow(ZAIm-ZCIm,2.)); //ZARe*ZCRe+ZAIm*ZCIm
    Double_t EvPlZDCC = TMath::ATan2(ZCIm,ZCRe);
    Double_t EvPlZDCA = TMath::ATan2(ZAIm,ZARe);
    if(fbFlagIsPosMagField) {
      fFlowSPZDCDistPro[0]->Fill(fCentralityEBE,DistCen,ZARe*ZCRe);
      fFlowSPZDCDistPro[1]->Fill(fCentralityEBE,DistCen,ZAIm*ZCIm);
      fFlowSPZDCDistPro[4]->Fill(fCentralityEBE,DistCen,TMath::Cos(EvPlZDCC-EvPlZDCA));
    } else {
      fFlowSPZDCDistPro[2]->Fill(fCentralityEBE,DistCen,ZARe*ZCRe);
      fFlowSPZDCDistPro[3]->Fill(fCentralityEBE,DistCen,ZAIm*ZCIm);
      fFlowSPZDCDistPro[5]->Fill(fCentralityEBE,DistCen,TMath::Cos(EvPlZDCC-EvPlZDCA));
    }
  }

  // sine terms: sin(\phi - \Psi_{A,C})
  fFlowSPZDCv1etaProImag[fCenBin][0]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaProImag[fCenBin][1]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaProImag[fCenBin][2]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaProImag[fCenBin][3]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaProImag[fCenBin][4]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][5]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][6]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][7]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaProImag[fCenBin][8]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][9]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][10]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaProImag[fCenBin][11]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
  }

  // test run-by-run
  if(fCentralityEBE>5. && fCentralityEBE<40.) {
    fCRCZDCQVecTest[fRunBin][0]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fCRCZDCQVecTest[fRunBin][1]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    if(dCnt==0) fCRCZDCQVecTest[fRunBin][2]->Fill(dEta,ZARe*ZCRe+ZAIm*ZCIm,fCenWeightEbE);
    if(dCharge== 1) {
      fCRCZDCQVecTest[fRunBin][3]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fCRCZDCQVecTest[fRunBin][4]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    } else {
      fCRCZDCQVecTest[fRunBin][5]->Fill(dEta,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
      fCRCZDCQVecTest[fRunBin][6]->Fill(dEta,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
    }
  }

  // NUAs
  fFlowSPZDCv1etaNUAPro[fCenBin][0][0]->Fill(dEta,QRe,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaNUAPro[fCenBin][0][1]->Fill(dEta,QIm,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaNUAPro[fCenBin][0][2]->Fill(dEta,QRe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][3]->Fill(dEta,QIm,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaNUAPro[fCenBin][0][4]->Fill(dEta,QRe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][5]->Fill(dEta,QIm,wPhiEta*fCenWeightEbE);
  }
  if(dCnt==0) {
    fFlowSPZDCv1etaNUAPro[fCenBin][0][6]->Fill(dEta,ZARe,fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][7]->Fill(dEta,ZAIm,fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][8]->Fill(dEta,ZCRe,fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][9]->Fill(dEta,ZCIm,fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][10]->Fill(dEta,ZARe*ZCRe,fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][0][11]->Fill(dEta,ZAIm*ZCIm,fCenWeightEbE);
  }
  // mixed terms
  fFlowSPZDCv1etaNUAPro[fCenBin][1][0]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaNUAPro[fCenBin][1][1]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaNUAPro[fCenBin][1][2]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaNUAPro[fCenBin][1][3]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaNUAPro[fCenBin][1][4]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][5]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][6]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][7]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaNUAPro[fCenBin][1][8]->Fill(dEta,QRe*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][9]->Fill(dEta,QIm*ZARe,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][10]->Fill(dEta,QRe*ZCIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaNUAPro[fCenBin][1][11]->Fill(dEta,QIm*ZCRe,wPhiEta*fCenWeightEbE);
  }

  // pT-differential ***********************************************************

  fFlowSPZDCv1etaPtPro[fCenBin][0]->Fill(dEta,dPt,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
  fFlowSPZDCv1etaPtPro[fCenBin][1]->Fill(dEta,dPt,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  if(dCharge== 1) {
    fFlowSPZDCv1etaPtPro[fCenBin][2]->Fill(dEta,dPt,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPtPro[fCenBin][3]->Fill(dEta,dPt,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  } else {
    fFlowSPZDCv1etaPtPro[fCenBin][4]->Fill(dEta,dPt,QRe*ZARe+QIm*ZAIm,wPhiEta*fCenWeightEbE);
    fFlowSPZDCv1etaPtPro[fCenBin][5]->Fill(dEta,dPt,QRe*ZCRe+QIm*ZCIm,wPhiEta*fCenWeightEbE);
  }

  // NUAs
  fFlowSPZDCv1evenCorPro[0]->Fill(fCentralityEBE,dPt,QRe,wPhiEta);
  fFlowSPZDCv1evenCorPro[1]->Fill(fCentralityEBE,dPt,QIm,wPhiEta);
  fFlowSPZDCv1evenCorPro[2]->Fill(fCentralityEBE,dPt,QRe*ZARe,wPhiEta);
  fFlowSPZDCv1evenCorPro[3]->Fill(fCentralityEBE,dPt,QIm*ZAIm,wPhiEta);
  fFlowSPZDCv1evenCorPro[4]->Fill(fCentralityEBE,dPt,QRe*ZCRe,wPhiEta);
  fFlowSPZDCv1evenCorPro[5]->Fill(fCentralityEBE,dPt,QIm*ZCIm,wPhiEta);

} // end of AliFlowAnalysisCRC::CalculateFlowSPZDC();

//=======================================================================================================================

Double_t AliFlowAnalysisCRC::GetSPZDChar(Int_t har, Double_t QRe, Double_t QIm, Double_t ZARe, Double_t ZAIm, Double_t ZCRe, Double_t ZCIm)
{
  Double_t flow=0.;
  switch (har) {
    case 2:
      flow = QRe*(ZARe*ZCRe-ZAIm*ZCIm)+QIm*(ZARe*ZCIm+ZAIm*ZCRe);
      break;
    case 3:
      flow = QRe*(ZARe*ZARe*ZCRe-2.*ZARe*ZAIm*ZCIm-ZCRe*ZAIm*ZAIm)
      + QIm*(-ZAIm*ZAIm*ZCIm+2.*ZAIm*ZARe*ZCRe+ZCIm*ZARe*ZARe);
      break;
    case 4:
      flow = QRe*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm))
      + QIm*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm));
      break;
    case 5:
      flow = QRe*(ZARe*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm))
                  -ZAIm*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm)))
      + QIm*(ZAIm*((ZARe*ZARe-ZAIm*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)-(ZAIm*ZARe+ZARe*ZAIm)*(ZCIm*ZCRe+ZCRe*ZCIm))
             +ZARe*((ZAIm*ZARe+ZARe*ZAIm)*(ZCRe*ZCRe-ZCIm*ZCIm)+(ZCIm*ZCRe+ZCRe*ZCIm)*(ZARe*ZARe-ZAIm*ZAIm)));
      break;
  }
  return flow;
}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateFlowQC()
{
  fEventCounter->Fill(0.5);

//  Int_t NewCenBin = GetCRCCenBin(fNewCentralityEBE);
  Double_t FillPtBin = 0.;
  Double_t IQC2[fFlowNHarm] = {0.};
  Double_t IQC4[fFlowNHarm] = {0.};
  Double_t IQC2EG[fFlowNHarm] = {0.};
  Double_t IQM2=0., IQM4=0., IQM2EG=0.;
  Double_t WQM2=0., WQM4=0., WQM2EG=0.;
  Double_t dQC2=0., dQC4=0., dQC2EG=0., dQC2EGB=0.;
  Double_t dQM2=0., dQM4=0., dQM2EG=0., dQM2EGB=0.;
  Double_t WdQM2=0., WdQM4=0., WdQM2EG=0., WdQM2EGB=0.;
  Double_t WM=0., dM11=0., WM11=0., dM111=0., WM111=0.;
  Double_t sinP1=0., cosP1=0., sinP1W1=0., cosP1W1=0., sinP1nM1nM1nW1W1W1=0., cosP1nM1nM1nW1W1W1=0.;
  Double_t WAM=0., WBM=0.;
  Double_t QRe=0., QIm=0., Q2Re2=0., Q2Im2=0., QRe3=0., QIm3=0., QM0=0., QM=0., QM2=0., QM3=0., QM4=0.;
  Double_t QARe=0., QAIm=0., QBRe=0., QBIm=0., QAM0=0., QAM=0., QBM0=0., QBM=0., QARe0=0., QAIm0=0., QBRe0=0., QBIm0=0.;

  Double_t qpARe=0, qpAIm=0., qpAM=0., qpAM0=0.;
  Double_t qpBRe=0, qpBIm=0., qpBM=0., qpBM0=0.;
  Double_t qpRe0=0., qpIm0=0., qpRe2=0., qpIm2=0., qp2Re=0., qp2Im=0., qpM0=0., qpM=0., qpM2=0., qpM3=0.;
  Double_t WqpM0=0., WqpAM=0.;

  Bool_t Q2f=kFALSE, Q4f=kFALSE, dQ2f=kFALSE, dQ4f=kFALSE, Q2EGf=kFALSE, dQ2EGf=kFALSE;
  Bool_t WeigMul = (fCorrWeightTPC==kMultiplicity ? kTRUE : kFALSE);

  for(Int_t hr=0; hr<fFlowNHarm; hr++) {

    for(Int_t ptr=0; ptr<fkFlowQCnPtRanges; ptr++) {
      Double_t ptmax = (ptr==0?3.:(ptr==1?5.:50.));
      if(fMinMulZN==99 && ptr==0) ptmax=1.;

      // pT-integrated, 2- and 4-particle cumulants *************************
      QRe=0.; QIm=0.; Q2Re2=0.; Q2Im2=0.; QRe3=0.;
      QIm3=0.; QM0=0.; QM=0.; QM2=0.; QM3=0.; QM4=0.;

      for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
        if(fPOIPtDiffQRe[0][0]->GetXaxis()->GetBinUpEdge(pt+1)<=ptmax) {
          QRe += fPOIPtDiffQRe[1][hr+1]->GetBinContent(pt+1);
          QIm += fPOIPtDiffQIm[1][hr+1]->GetBinContent(pt+1);
          Q2Re2 += fPOIPtDiffQRe[2][2*hr+3]->GetBinContent(pt+1);
          Q2Im2 += fPOIPtDiffQIm[2][2*hr+3]->GetBinContent(pt+1);
          QRe3 += fPOIPtDiffQRe[3][hr+1]->GetBinContent(pt+1);
          QIm3 += fPOIPtDiffQIm[3][hr+1]->GetBinContent(pt+1);

          QM0 += fPOIPtDiffMul[0][0]->GetBinContent(pt+1);
          QM  += fPOIPtDiffMul[1][0]->GetBinContent(pt+1);
          QM2 += fPOIPtDiffMul[2][0]->GetBinContent(pt+1);
          QM3 += fPOIPtDiffMul[3][0]->GetBinContent(pt+1);
          QM4 += fPOIPtDiffMul[4][0]->GetBinContent(pt+1);
        }
      }

      IQM2 = QM*QM-QM2;
      WQM2 = (WeigMul? IQM2 : 1.);
      if(QM0>1) {
        if(hr==0)fEventCounter->Fill(2.5);
        IQC2[hr] = (QRe*QRe+QIm*QIm-QM2)/IQM2;
        fFlowQCIntPtRanCorPro[ptr][hr][0]->Fill(fCentralityEBE,IQC2[hr],WQM2*fCenWeightEbE);
        Q2f = kTRUE;
      }

      IQM4 = QM*QM*QM*QM - 6.*QM2*QM*QM + 8.*QM3*QM + 3.*QM2*QM2 - 6.*QM4;
      WQM4 = (WeigMul? IQM4 : 1.);
      if(QM0>3) {
        IQC4[hr] = ((QRe*QRe+QIm*QIm)*(QRe*QRe+QIm*QIm)
        - 2.*(QRe*QRe*Q2Re2+2.*QRe*QIm*Q2Im2-QIm*QIm*Q2Re2)
        + 8.*(QRe3*QRe+QIm3*QIm)
        + (Q2Re2*Q2Re2+Q2Im2*Q2Im2)
        - 4.*QM2*(QRe*QRe+QIm*QIm)
        - 6.*QM4 + 2.*QM2*QM2) / IQM4;
        fFlowQCIntPtRanCorPro[ptr][hr][1]->Fill(fCentralityEBE,IQC4[hr],WQM4*fCenWeightEbE);
        Q4f = kTRUE;
      }

      // product of correlations or covariances
      if(Q2f && Q4f) {
        fFlowQCIntPtRanCorPro[ptr][hr][2]->Fill(fCentralityEBE,IQC2[hr]*IQC4[hr],WQM2*WQM4*fCenWeightEbE);
      }

      // NUA
      WM = (WeigMul? QM : 1.);
      if(QM0>0) {
        sinP1 = QIm/QM;
        cosP1 = QRe/QM;
        fFlowQCIntPtRanCorNUAPro[ptr][hr][0]->Fill(fCentralityEBE,cosP1,WM*fCenWeightEbE);
        fFlowQCIntPtRanCorNUAPro[ptr][hr][1]->Fill(fCentralityEBE,sinP1,WM*fCenWeightEbE);
      }
      dM11 = QM*QM - QM2; // dM11 = sum_{i,j=1,i!=j}^M w_i w_j
      WM11 = (WeigMul? dM11 : 1.);
      if(QM0>1) {
        sinP1W1 = (2.*QRe*QIm-Q2Im2)/dM11;
        cosP1W1 = (QRe*QRe-QIm*QIm-Q2Re2)/dM11;
        fFlowQCIntPtRanCorNUAPro[ptr][hr][2]->Fill(fCentralityEBE,sinP1W1,WM11*fCenWeightEbE); //sin(n*(phi1+phi2))
        fFlowQCIntPtRanCorNUAPro[ptr][hr][3]->Fill(fCentralityEBE,cosP1W1,WM11*fCenWeightEbE); //cos(n*(phi1+phi2))
      }
      dM111 = QM*QM*QM - 3.*QM2*QM + 2.*QM3; // dM111 = sum_{i,j,k=1,i!=j!=k}^M w_i w_j w_k
      WM111 = (WeigMul? dM111 : 1.);
      if(QM0>2) {
        sinP1nM1nM1nW1W1W1 = (-QIm*(pow(QRe,2)+pow(QIm,2))
        + QRe*Q2Im2-QIm*Q2Re2
        + 2.*QM2*QIm
        - 2.*QIm3) / dM111;
        cosP1nM1nM1nW1W1W1 = (QRe*(pow(QRe,2)+pow(QIm,2))
        - QRe*Q2Re2-QIm*Q2Im2
        - 2.*QM2*QRe
        + 2.*QRe3) / dM111;
        fFlowQCIntPtRanCorNUAPro[ptr][hr][4]->Fill(fCentralityEBE,sinP1nM1nM1nW1W1W1,WM111*fCenWeightEbE); //sin(n*(phi1-phi2-phi3))
        fFlowQCIntPtRanCorNUAPro[ptr][hr][5]->Fill(fCentralityEBE,cosP1nM1nM1nW1W1W1,WM111*fCenWeightEbE); //cos(n*(phi1-phi2-phi3))
      }

      // pT-integrated, 2-particle with Eta Gap *****************************
      QARe=0.; QAIm=0.; QBRe=0.; QBIm=0.; QAM0=0.; QAM=0.; QBM0=0.; QBM=0.;
      QARe0=0.; QAIm0=0.; QBRe0=0.; QBIm0=0.;

      for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
        if(fPOIPtDiffQReEG[0][0][0]->GetXaxis()->GetBinUpEdge(pt+1)<=ptmax) {
          QARe += fPOIPtDiffQReEG[0][1][hr+1]->GetBinContent(pt+1);
          QAIm += fPOIPtDiffQImEG[0][1][hr+1]->GetBinContent(pt+1);
          QBRe += fPOIPtDiffQReEG[1][1][hr+1]->GetBinContent(pt+1);
          QBIm += fPOIPtDiffQImEG[1][1][hr+1]->GetBinContent(pt+1);
          QAM0 += fPOIPtDiffMulEG[0][0][0]->GetBinContent(pt+1);
          QAM  += fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1);
          QBM0 += fPOIPtDiffMulEG[1][0][0]->GetBinContent(pt+1);
          QBM  += fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1);
          QARe0 += fPOIPtDiffQReEG[0][0][hr+1]->GetBinContent(pt+1);
          QAIm0 += fPOIPtDiffQImEG[0][0][hr+1]->GetBinContent(pt+1);
          QBRe0 += fPOIPtDiffQReEG[1][0][hr+1]->GetBinContent(pt+1);
          QBIm0 += fPOIPtDiffQImEG[1][0][hr+1]->GetBinContent(pt+1);
        }
      }

      IQM2EG = QAM*QBM;
      WQM2EG = (WeigMul? IQM2EG : 1.);
      if(QAM0>0 && QBM0>0) {
        if(IQM2EG) {
          IQC2EG[hr] = (QARe*QBRe+QAIm*QBIm)/IQM2EG;
          fFlowQCIntPtRanCorProEG[ptr][hr]->Fill(fCentralityEBE,IQC2EG[hr],WQM2EG*fCenWeightEbE);
          Q2EGf = kTRUE;
        }
        Double_t mul = QAM0*QBM;
        Double_t flow = (QARe0*QBRe+QAIm0*QBIm)/mul;
        fFlowQCIntPtRanCorPro[ptr][hr][3]->Fill(fCentralityEBE,flow,mul*fCenWeightEbE);
        mul = QAM*QBM0;
        flow = (QARe*QBRe0+QAIm*QBIm0)/mul;
        fFlowQCIntPtRanCorPro[ptr][hr][4]->Fill(fCentralityEBE,flow,mul*fCenWeightEbE);
      }

      // NUA
      WAM = (WeigMul? QAM : 1.);
      if(QAM0>0) {
        cosP1 = QARe/QAM;
        sinP1 = QAIm/QAM;
        fFlowQCIntPtRanCorNUAProEG[ptr][hr][0]->Fill(fCentralityEBE,cosP1,WAM*fCenWeightEbE);
        fFlowQCIntPtRanCorNUAProEG[ptr][hr][1]->Fill(fCentralityEBE,sinP1,WAM*fCenWeightEbE);
      }
      WBM = (WeigMul? QBM : 1.);
      if(QBM0>0) {
        cosP1 = QBRe/QBM;
        sinP1 = QBIm/QBM;
        fFlowQCIntPtRanCorNUAProEG[ptr][hr][2]->Fill(fCentralityEBE,cosP1,WBM*fCenWeightEbE);
        fFlowQCIntPtRanCorNUAProEG[ptr][hr][3]->Fill(fCentralityEBE,sinP1,WBM*fCenWeightEbE);
      }
    } // end of for(Int_t ptr=0; ptr<fkFlowQCnPtRanges; pt++)

    // ********************************************************************
    // pT-integrated: {2}, {4}, {2,EG} ************************************
    // ********************************************************************

    // store reference flow (2 and 4p) ***********************************
    QRe=0.; QIm=0.; Q2Re2=0.; Q2Im2=0.; QRe3=0.; QIm3=0.;
    QM0=0.; QM=0.; QM2=0.; QM3=0.; QM4=0.;
    Q2f=kFALSE; Q4f=kFALSE;

    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
      QRe += fPOIPtDiffQRe[1][hr+1]->GetBinContent(pt+1);
      QIm += fPOIPtDiffQIm[1][hr+1]->GetBinContent(pt+1);
      Q2Re2 += fPOIPtDiffQRe[2][2*hr+3]->GetBinContent(pt+1);
      Q2Im2 += fPOIPtDiffQIm[2][2*hr+3]->GetBinContent(pt+1);
      QRe3 += fPOIPtDiffQRe[3][hr+1]->GetBinContent(pt+1);
      QIm3 += fPOIPtDiffQIm[3][hr+1]->GetBinContent(pt+1);

      QM0 += fPOIPtDiffMul[0][0]->GetBinContent(pt+1);
      QM  += fPOIPtDiffMul[1][0]->GetBinContent(pt+1);
      QM2 += fPOIPtDiffMul[2][0]->GetBinContent(pt+1);
      QM3 += fPOIPtDiffMul[3][0]->GetBinContent(pt+1);
      QM4 += fPOIPtDiffMul[4][0]->GetBinContent(pt+1);
    }

    IQM2 = QM*QM-QM2;
    WQM2 = (WeigMul? IQM2 : 1.);
    if(QM0>1) {
      IQC2[hr] = (QRe*QRe+QIm*QIm-QM2)/IQM2;
      fFlowQCIntCorPro[hr][0]->Fill(fCentralityEBE,IQC2[hr],WQM2*fCenWeightEbE);
      fFlowQCIntCorProTest[hr][0][0]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,IQC2[hr],WQM2*fCenWeightEbE);
      fFlowQCRefCorPro[hr][0]->Fill(fCentralityEBE,IQC2[hr],WQM2*fCenWeightEbE);
      Q2f = kTRUE;
    }

    IQM4 = QM*QM*QM*QM - 6.*QM2*QM*QM + 8.*QM3*QM + 3.*QM2*QM2 - 6.*QM4;
    WQM4 = (WeigMul? IQM4 : 1.);
    if(QM0>3) {
      IQC4[hr] = ((QRe*QRe+QIm*QIm)*(QRe*QRe+QIm*QIm)
                  - 2.*(QRe*QRe*Q2Re2+2.*QRe*QIm*Q2Im2-QIm*QIm*Q2Re2)
                  + 8.*(QRe3*QRe+QIm3*QIm)
                  + (Q2Re2*Q2Re2+Q2Im2*Q2Im2)
                  - 4.*QM2*(QRe*QRe+QIm*QIm)
                  - 6.*QM4 + 2.*QM2*QM2) / IQM4;

      fFlowQCIntCorPro[hr][1]->Fill(fCentralityEBE,IQC4[hr],WQM4*fCenWeightEbE);
      fFlowQCIntCorProTest[hr][1][0]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,IQC4[hr],WQM4*fCenWeightEbE);
      fFlowQCRefCorPro[hr][1]->Fill(fCentralityEBE,IQC4[hr],WQM4*fCenWeightEbE);
      Q4f = kTRUE;
    }

    // product of correlations or covariances
    if(Q2f && Q4f) {
      fFlowQCIntCorPro[hr][2]->Fill(fCentralityEBE,IQC2[hr]*IQC4[hr],WQM2*WQM4*fCenWeightEbE);
      fFlowQCRefCorPro[hr][13]->Fill(fCentralityEBE,IQC2[hr]*IQC4[hr],WQM2*WQM4*fCenWeightEbE);
    }

    // NUA
    WM = (WeigMul? QM : 1.);
    if(QM0>0) {
      sinP1 = QIm/QM;
      cosP1 = QRe/QM;
      fFlowQCIntCorNUAPro[hr][0]->Fill(fCentralityEBE,cosP1,WM*fCenWeightEbE);
      fFlowQCIntCorNUAPro[hr][1]->Fill(fCentralityEBE,sinP1,WM*fCenWeightEbE);
      fFlowQCIntCorNUAProTest[hr][0]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,cosP1,WM*fCenWeightEbE);
      fFlowQCIntCorNUAProTest[hr][1]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,sinP1,WM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][3]->Fill(fCentralityEBE,cosP1,WM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][4]->Fill(fCentralityEBE,sinP1,WM*fCenWeightEbE);
    }
    dM11 = QM*QM - QM2; // dM11 = sum_{i,j=1,i!=j}^M w_i w_j
    WM11 = (WeigMul? dM11 : 1.);
    if(QM0>1) {
      sinP1W1 = (2.*QRe*QIm-Q2Im2)/dM11;
      cosP1W1 = (QRe*QRe-QIm*QIm-Q2Re2)/dM11;
      fFlowQCIntCorNUAPro[hr][2]->Fill(fCentralityEBE,sinP1W1,WM11*fCenWeightEbE); //sin(n*(phi1+phi2))
      fFlowQCIntCorNUAPro[hr][3]->Fill(fCentralityEBE,cosP1W1,WM11*fCenWeightEbE); //cos(n*(phi1+phi2))
      fFlowQCIntCorNUAProTest[hr][2]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,sinP1W1,WM11*fCenWeightEbE);
      fFlowQCIntCorNUAProTest[hr][3]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,cosP1W1,WM11*fCenWeightEbE);
      fFlowQCRefCorPro[hr][5]->Fill(fCentralityEBE,sinP1W1,WM11*fCenWeightEbE);
      fFlowQCRefCorPro[hr][6]->Fill(fCentralityEBE,cosP1W1,WM11*fCenWeightEbE);
    }
    dM111 = QM*QM*QM - 3.*QM2*QM + 2.*QM3; // dM111 = sum_{i,j,k=1,i!=j!=k}^M w_i w_j w_k
    WM111 = (WeigMul? dM111 : 1.);
    if(QM0>2) {
      sinP1nM1nM1nW1W1W1 = (-QIm*(pow(QRe,2)+pow(QIm,2))
                                     + QRe*Q2Im2-QIm*Q2Re2
                                     + 2.*QM2*QIm
                                     - 2.*QIm3) / dM111;
      cosP1nM1nM1nW1W1W1 = (QRe*(pow(QRe,2)+pow(QIm,2))
                                     - QRe*Q2Re2-QIm*Q2Im2
                                     - 2.*QM2*QRe
                                     + 2.*QRe3) / dM111;
      fFlowQCRefCorPro[hr][7]->Fill(fCentralityEBE,sinP1nM1nM1nW1W1W1,WM111*fCenWeightEbE);
      fFlowQCRefCorPro[hr][8]->Fill(fCentralityEBE,cosP1nM1nM1nW1W1W1,WM111*fCenWeightEbE);
      fFlowQCIntCorNUAPro[hr][4]->Fill(fCentralityEBE,sinP1nM1nM1nW1W1W1,WM111*fCenWeightEbE); //sin(n*(phi1-phi2-phi3))
      fFlowQCIntCorNUAPro[hr][5]->Fill(fCentralityEBE,cosP1nM1nM1nW1W1W1,WM111*fCenWeightEbE); //cos(n*(phi1-phi2-phi3))
      fFlowQCIntCorNUAProTest[hr][4]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,sinP1nM1nM1nW1W1W1,WM111*fCenWeightEbE);
      fFlowQCIntCorNUAProTest[hr][5]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,cosP1nM1nM1nW1W1W1,WM111*fCenWeightEbE);
    }

    // store reference flow (2p with ega-gap) *****************************
    QARe=0.; QAIm=0.; QBRe=0.; QBIm=0.; QAM0=0.; QAM=0.; QBM0=0.; QBM=0.;
    QARe0=0., QAIm0=0., QBRe0=0., QBIm0=0.;
    Q2EGf=kFALSE;

    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
      QARe += fPOIPtDiffQReEG[0][1][hr+1]->GetBinContent(pt+1);
      QAIm += fPOIPtDiffQImEG[0][1][hr+1]->GetBinContent(pt+1);
      QBRe += fPOIPtDiffQReEG[1][1][hr+1]->GetBinContent(pt+1);
      QBIm += fPOIPtDiffQImEG[1][1][hr+1]->GetBinContent(pt+1);
      QAM0 += fPOIPtDiffMulEG[0][0][0]->GetBinContent(pt+1);
      QAM  += fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1);
      QBM0 += fPOIPtDiffMulEG[1][0][0]->GetBinContent(pt+1);
      QBM  += fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1);
      QARe0 += fPOIPtDiffQReEG[0][0][hr+1]->GetBinContent(pt+1);
      QAIm0 += fPOIPtDiffQImEG[0][0][hr+1]->GetBinContent(pt+1);
      QBRe0 += fPOIPtDiffQReEG[1][0][hr+1]->GetBinContent(pt+1);
      QBIm0 += fPOIPtDiffQImEG[1][0][hr+1]->GetBinContent(pt+1);
    }

    IQM2EG = QAM*QBM;
    WQM2EG = (WeigMul? IQM2EG : 1.);
    if(QAM0>0 && QBM0>0) {
      if(IQM2EG) {
        IQC2EG[hr] = (QARe*QBRe+QAIm*QBIm)/IQM2EG;
        fFlowQCIntCorProEG[hr]->Fill(fCentralityEBE,IQC2EG[hr],WQM2EG*fCenWeightEbE);
        fFlowQCIntCorProTest[hr][2][0]->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,IQC2EG[hr],WQM2EG*fCenWeightEbE);
        fFlowQCRefCorPro[hr][2]->Fill(fCentralityEBE,IQC2EG[hr],WQM2EG*fCenWeightEbE);
        Q2EGf = kTRUE;
      }
      Double_t mul = QAM0*QBM;
      Double_t flow = (QARe0*QBRe+QAIm0*QBIm)/mul;
      fFlowQCIntCorPro[hr][3]->Fill(fCentralityEBE,flow,mul*fCenWeightEbE);
      mul = QAM*QBM0;
      flow = (QARe*QBRe0+QAIm*QBIm0)/mul;
      fFlowQCIntCorPro[hr][4]->Fill(fCentralityEBE,flow,mul*fCenWeightEbE);
    }

    // NUA
    WAM = (WeigMul? QAM : 1.);
    if(QAM0>0) {
      cosP1 = QARe/QAM;
      sinP1 = QAIm/QAM;
      fFlowQCIntCorNUAProEG[hr][0]->Fill(fCentralityEBE,cosP1,WAM*fCenWeightEbE);
      fFlowQCIntCorNUAProEG[hr][1]->Fill(fCentralityEBE,sinP1,WAM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][9]->Fill(fCentralityEBE,cosP1,WAM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][10]->Fill(fCentralityEBE,sinP1,WAM*fCenWeightEbE);
    }
    WBM = (WeigMul? QBM : 1.);
    if(QBM0>0) {
      cosP1 = QBRe/QBM;
      sinP1 = QBIm/QBM;
      fFlowQCIntCorNUAProEG[hr][2]->Fill(fCentralityEBE,cosP1,WBM*fCenWeightEbE);
      fFlowQCIntCorNUAProEG[hr][3]->Fill(fCentralityEBE,sinP1,WBM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][11]->Fill(fCentralityEBE,cosP1,WBM*fCenWeightEbE);
      fFlowQCRefCorPro[hr][12]->Fill(fCentralityEBE,sinP1,WBM*fCenWeightEbE);
    }

    // ********************************************************************
    // pT-differential: {2}, {4}, {2,EG} **********************************
    // ********************************************************************

    // store pt-differential flow ****************************************
    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {

      FillPtBin = fPOIPtDiffQRe[0][0]->GetBinCenter(pt+1);
      qpRe0=0.; qpIm0=0.; qpRe2=0.; qpIm2=0.; qp2Re=0.; qp2Im=0.; qpM0=0.; qpM=0.; qpM2=0.; qpM3=0.;

      qpRe0 = fPOIPtDiffQRe[0][hr+1]->GetBinContent(pt+1);
      qpIm0 = fPOIPtDiffQIm[0][hr+1]->GetBinContent(pt+1);
      qpRe2 = fPOIPtDiffQRe[2][hr+1]->GetBinContent(pt+1);
      qpIm2 = fPOIPtDiffQIm[2][hr+1]->GetBinContent(pt+1);
      qp2Re = fPOIPtDiffQRe[1][2*hr+3]->GetBinContent(pt+1);
      qp2Im = fPOIPtDiffQIm[1][2*hr+3]->GetBinContent(pt+1);

      qpM0 = fPOIPtDiffMul[0][0]->GetBinContent(pt+1);
      qpM  = fPOIPtDiffMul[1][0]->GetBinContent(pt+1);
      qpM2 = fPOIPtDiffMul[2][0]->GetBinContent(pt+1);
      qpM3 = fPOIPtDiffMul[3][0]->GetBinContent(pt+1);

      if(hr==0) {
       fFlowQCSpectra->Fill(fCentralityEBE,FillPtBin,qpM*fCenWeightEbE);
      }

      dQM2 = qpM0*QM-qpM;
      WdQM2 = (WeigMul? dQM2 : 1.);
      if(qpM0>0 && QM0>0) {
        dQC2 = (qpRe0*QRe+qpIm0*QIm-qpM)/dQM2;
        fFlowQCCorPro[fCenBin][hr][1]->Fill(FillPtBin,dQC2,WdQM2*fCenWeightEbE);
        // NUA
        WqpM0 = (WeigMul? qpM0 : 1.);
        sinP1 = qpIm0/qpM0;
        cosP1 = qpRe0/qpM0;
        fFlowQCCorNUAPro[fCenBin][hr][0]->Fill(FillPtBin,sinP1,WqpM0*fCenWeightEbE); // <<sin n(psi1)>>
        fFlowQCCorNUAPro[fCenBin][hr][1]->Fill(FillPtBin,cosP1,WqpM0*fCenWeightEbE); // <<cos n(psi1)>>
        sinP1W1 = (qpRe0*QIm+qpIm0*QRe-qp2Im)/dQM2;
        cosP1W1 = (qpRe0*QIm+qpIm0*QRe-qp2Im)/dQM2;
        fFlowQCCorNUAPro[fCenBin][hr][2]->Fill(FillPtBin,sinP1W1,WdQM2*fCenWeightEbE); //sin(n*(psi1+phi2))
        fFlowQCCorNUAPro[fCenBin][hr][3]->Fill(FillPtBin,cosP1W1,WdQM2*fCenWeightEbE); //cos(n*(psi1+phi2))
        dQ2f = kTRUE;
      }

      dQM4 = qpM0*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qpM*(QM*QM-QM2)+2.*(qpM3-qpM2*QM));
      WdQM4 = (WeigMul? dQM4 : 1.);
      if(qpM0>0 && QM0>3) {
        dQC4 = ((pow(QRe,2.)+pow(QIm,2.))*(qpRe0*QRe+qpIm0*QIm)
                         - qp2Re*(pow(QRe,2.)-pow(QIm,2.))
                         - 2.*qp2Im*QRe*QIm
                         - qpRe0*(QRe*Q2Re2+QIm*Q2Im2)
                         + qpIm0*(QIm*Q2Re2-QRe*Q2Im2)
                         - 2.*QM2*(qpRe0*QRe+qpIm0*QIm)
                         - 2.*(pow(QRe,2.)+pow(QIm,2.))*qpM
                         + 6.*(qpRe2*QRe+qpIm2*QIm)
                         + 1.*(qp2Re*Q2Re2+qp2Im*Q2Im2)
                         + 2.*(qpRe0*QRe3+qpIm0*QIm3)
                         + 2.*qpM*QM2
                         - 6.*qpM3) / dQM4;
        fFlowQCCorPro[fCenBin][hr][2]->Fill(FillPtBin,dQC4,WdQM4*fCenWeightEbE);

        // NUA
        dM11 = qpM0*(QM*QM-QM2) - 2.*(qpM*QM-qpM2);
        WM11 = (WeigMul? dM11 : 1.);
        sinP1W1 = (qpIm0*(pow(QIm,2.)+pow(QRe,2.))
                                               - qpIm0*QM2
                                               + qp2Re*QIm - qp2Im*QRe
                                               - qpM*QIm
                                               + 2.*qpIm2) / dM11;
        fFlowQCCorNUAPro[fCenBin][hr][4]->Fill(FillPtBin,sinP1W1,WM11*fCenWeightEbE);  //sin(n(psi1+phi2-phi3))

        cosP1W1 = (qpRe0*(pow(QIm,2.)+pow(QRe,2.))
                                               - qpRe0*QM2
                                               - qp2Re*QRe - qp2Im*QIm
                                               - qpM*QRe
                                               + 2.*qpRe2) / dM11;
        fFlowQCCorNUAPro[fCenBin][hr][5]->Fill(FillPtBin,cosP1W1,WM11*fCenWeightEbE); //cos(n(psi1+phi2-phi3))

        sinP1W1 = (qpIm0*(pow(QRe,2.)-pow(QIm,2.))-2.*qpRe0*QRe*QIm
                                               + 1.*(qpRe0*Q2Im2-qpIm0*Q2Re2)
                                               + 2.*qpM*QIm
                                               - 2.*qpIm2) / dM11;
        fFlowQCCorNUAPro[fCenBin][hr][6]->Fill(FillPtBin,sinP1W1,WM11*fCenWeightEbE);  //sin(n(psi1-phi2-phi3))

        cosP1W1 = (qpRe0*(pow(QRe,2.)-pow(QIm,2.))+2.*qpIm0*QRe*QIm
                                               - 1.*(qpRe0*Q2Re2+qpIm0*Q2Im2)
                                               - 2.*qpM*QRe
                                               + 2.*qpRe2) / dM11;
        fFlowQCCorNUAPro[fCenBin][hr][7]->Fill(FillPtBin,cosP1W1,WM11*fCenWeightEbE); //cos(n(psi1-phi2-phi3))

        dQ4f = kTRUE;
      }

      // product of correlations or covariances
      if(Q2f && dQ2f) fFlowQCCorCovPro[fCenBin][hr][0]->Fill(FillPtBin,IQC2[hr]*dQC2,WQM2*WdQM2*fCenWeightEbE);
      if(Q4f && dQ2f) fFlowQCCorCovPro[fCenBin][hr][1]->Fill(FillPtBin,IQC4[hr]*dQC2,WQM4*WdQM2*fCenWeightEbE);
      if(Q2f && dQ4f) fFlowQCCorCovPro[fCenBin][hr][2]->Fill(FillPtBin,IQC2[hr]*dQC4,WQM2*WdQM4*fCenWeightEbE);
      if(dQ2f && dQ4f) fFlowQCCorCovPro[fCenBin][hr][3]->Fill(FillPtBin,dQC2*dQC4,WdQM2*WdQM4*fCenWeightEbE);
      if(Q4f && dQ4f) fFlowQCCorCovPro[fCenBin][hr][4]->Fill(FillPtBin,IQC4[hr]*dQC4,WQM4*WdQM4*fCenWeightEbE);

      // eta-gap
      qpARe = fPOIPtDiffQReEG[0][1][hr+1]->GetBinContent(pt+1);
      qpAIm = fPOIPtDiffQImEG[0][1][hr+1]->GetBinContent(pt+1);
      qpAM  = fPOIPtDiffMulEG[0][1][0]->GetBinContent(pt+1);
      qpBRe = fPOIPtDiffQReEG[1][1][hr+1]->GetBinContent(pt+1);
      qpBIm = fPOIPtDiffQImEG[1][1][hr+1]->GetBinContent(pt+1);
      qpBM  = fPOIPtDiffMulEG[1][1][0]->GetBinContent(pt+1);
      qpAM0 = fPOIPtDiffMulEG[0][0][0]->GetBinContent(pt+1);
      qpBM0 = fPOIPtDiffMulEG[1][0][0]->GetBinContent(pt+1);

      // qA QB
      dQM2EG = qpAM*QBM;
      WdQM2EG = (WeigMul? dQM2EG : 1.);
      if(qpAM0>0 && QBM0>0) {
        dQC2EG = (qpARe*QBRe+qpAIm*QBIm)/dQM2EG;
        fFlowQCCorPro[fCenBin][hr][3]->Fill(FillPtBin,dQC2EG,WdQM2EG*fCenWeightEbE);
        dQ2EGf = kTRUE;
      }
      // NUA
      WqpAM = (WeigMul? qpAM : 1.);
      if(qpAM0>0) {
        cosP1 = qpARe/qpAM;
        sinP1 = qpAIm/qpAM;
        fFlowQCCorNUAPro[fCenBin][hr][8]->Fill(FillPtBin,cosP1,WqpAM*fCenWeightEbE);
        fFlowQCCorNUAPro[fCenBin][hr][9]->Fill(FillPtBin,sinP1,WqpAM*fCenWeightEbE);
      }
      // product of correlations or covariances
      if(Q2EGf && dQ2EGf) fFlowQCCorCovPro[fCenBin][hr][5]->Fill(FillPtBin,IQC2EG[hr]*dQC2EG,WQM2EG*WdQM2EG*fCenWeightEbE);

      // qB QA (reversed)
      dQM2EGB = qpBM*QAM;
      WdQM2EGB = (WeigMul? dQM2EGB : 1.);
      if(qpBM0>0 && QAM0>0) {
        dQC2EGB = (qpBRe*QARe+qpBIm*QAIm)/dQM2EGB;
        fFlowQCCorPro[fCenBin][hr][0]->Fill(FillPtBin,dQC2EGB,WdQM2EGB*fCenWeightEbE);
        dQ2EGf = kTRUE;
      }
      // NUA
      WqpAM = (WeigMul? qpBM : 1.);
      if(qpBM0>0) {
        cosP1 = qpBRe/qpBM;
        sinP1 = qpBIm/qpBM;
        fFlowQCCorNUAPro[fCenBin][hr][10]->Fill(FillPtBin,cosP1,WqpAM*fCenWeightEbE);
        fFlowQCCorNUAPro[fCenBin][hr][11]->Fill(FillPtBin,sinP1,WqpAM*fCenWeightEbE);
      }
      // product of correlations or covariances
      if(Q2EGf && dQ2EGf) fFlowQCCorCovPro[fCenBin][hr][6]->Fill(FillPtBin,IQC2EG[hr]*dQC2EGB,WQM2EG*WdQM2EGB*fCenWeightEbE);

      if(qpBM0>0 && QAM0>0 && qpAM0>0 && QBM0>0) {
        fFlowQCCorCovPro[fCenBin][hr][7]->Fill(FillPtBin,dQC2EG*dQC2EGB,WdQM2EG*WdQM2EGB*fCenWeightEbE);
      }

    } // end of for(Int_t pt=0; pt<fCRCnPtBin; pt++)

    // phi-differential: {2,EG} ************************************************

    for(Int_t pt=0; pt<fPOIPhiDiffQRe[0][0]->GetNbinsX(); pt++) {

      Double_t FillPhiBin = fPOIPhiDiffQRe[0][0]->GetBinCenter(pt+1);
      qpRe0=0.; qpIm0=0.; qpRe2=0.; qpIm2=0.; qp2Re=0.; qp2Im=0.; qpM0=0.; qpM=0.; qpM2=0.; qpM3=0.;

      qpRe0 = fPOIPhiDiffQRe[0][hr+1]->GetBinContent(pt+1);
      qpIm0 = fPOIPhiDiffQIm[0][hr+1]->GetBinContent(pt+1);
      qpRe2 = fPOIPhiDiffQRe[2][hr+1]->GetBinContent(pt+1);
      qpIm2 = fPOIPhiDiffQIm[2][hr+1]->GetBinContent(pt+1);
      qp2Re = fPOIPhiDiffQRe[1][2*hr+3]->GetBinContent(pt+1);
      qp2Im = fPOIPhiDiffQIm[1][2*hr+3]->GetBinContent(pt+1);

      qpM0 = fPOIPhiDiffMul[0][0]->GetBinContent(pt+1);
      qpM  = fPOIPhiDiffMul[1][0]->GetBinContent(pt+1);
      qpM2 = fPOIPhiDiffMul[2][0]->GetBinContent(pt+1);
      qpM3 = fPOIPhiDiffMul[3][0]->GetBinContent(pt+1);

      dQM2 = qpM0*QM-qpM;
      WdQM2 = (WeigMul? dQM2 : 1.);
      if(qpM0>0 && QM0>0) {
        dQC2 = (qpRe0*QRe+qpIm0*QIm-qpM)/dQM2;
        fFlowQCCorProPhi[fCenBin][hr][0]->Fill(FillPhiBin,dQC2,WdQM2*fCenWeightEbE);
      }

      dQM4 = qpM0*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qpM*(QM*QM-QM2)+2.*(qpM3-qpM2*QM));
      WdQM4 = (WeigMul? dQM4 : 1.);
      if(qpM0>0 && QM0>2) {
        dQC4 = ((pow(QRe,2.)+pow(QIm,2.))*(qpRe0*QRe+qpIm0*QIm)
                - qp2Re*(pow(QRe,2.)-pow(QIm,2.))
                - 2.*qp2Im*QRe*QIm
                - qpRe0*(QRe*Q2Re2+QIm*Q2Im2)
                + qpIm0*(QIm*Q2Re2-QRe*Q2Im2)
                - 2.*QM2*(qpRe0*QRe+qpIm0*QIm)
                - 2.*(pow(QRe,2.)+pow(QIm,2.))*qpM
                + 6.*(qpRe2*QRe+qpIm2*QIm)
                + 1.*(qp2Re*Q2Re2+qp2Im*Q2Im2)
                + 2.*(qpRe0*QRe3+qpIm0*QIm3)
                + 2.*qpM*QM2
                - 6.*qpM3) / dQM4;
        fFlowQCCorProPhi[fCenBin][hr][1]->Fill(FillPhiBin,dQC4,WdQM4*fCenWeightEbE);
      }

      // eta-gap
      Double_t qpARe0 = fPOIPhiDiffQReEG[0][0][hr+1]->GetBinContent(pt+1);
      Double_t qpAIm0 = fPOIPhiDiffQImEG[0][0][hr+1]->GetBinContent(pt+1);
      Double_t qpAM0 = fPOIPhiDiffMulEG[0][0][0]->GetBinContent(pt+1);

      dQM2EG = qpAM0*QBM;
      WdQM2EG = (WeigMul? dQM2EG : 1.);
      if(qpAM0>0 && QBM0>0) {
        dQC2EG = (qpARe0*QBRe+qpAIm0*QBIm)/dQM2EG;
        fFlowQCCorProPhi[fCenBin][hr][2]->Fill(FillPhiBin,dQC2EG,WdQM2EG*fCenWeightEbE);
      }

      qpARe0=0.; qpAIm0=0.; qpAM0=0.;

    } // end of for(Int_t pt=0; pt<fPOIPhiDiffQRe[0][0]->GetNbinsX(); pt++)

  } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

  // differential vs pt vs eta ***********************************************

  for(Int_t hr=0; hr<fFlowNHarm; hr++) {
    for(Int_t ptb=1; ptb<=fFlowQCIntCorProPhiEta[0][0][0]->GetNbinsX(); ptb++) {
      for(Int_t etb=1; etb<=fFlowQCIntCorProPhiEta[0][0][0]->GetNbinsY(); etb++) {

        Double_t ptfill = fFlowQCIntCorProPhiEta[0][0][0]->GetXaxis()->GetBinCenter(ptb);
        Double_t etfill = fFlowQCIntCorProPhiEta[0][0][0]->GetYaxis()->GetBinCenter(etb);

        for(Int_t var=0; var<2; var++) {

          // pT-integrated, 2- and 4-particle cumulants
          QRe=0.; QIm=0.; Q2Re2=0.; Q2Im2=0.; QRe3=0.; QIm3=0.; QM0=0.; QM=0.; QM2=0.; QM3=0.;
          // pt-eta-differential
          Double_t qpRe0=0.; qpIm0=0.; qpM0=0.;
          Double_t qqRe2=0., qqIm2=0., qq2Re=0., qq2Im=0., qqM=0., qqM2=0., qqM3=0., qqM4=0., qqRe3=0., qqIm3=0., qq2Re2=0., qq2Im2=0.;

          for(Int_t pt=0; pt<fPOIPhiEtaDiffQRe[0][0]->GetNbinsX(); pt++) {
            for(Int_t et=0; et<fPOIPhiEtaDiffQRe[0][0]->GetNbinsY(); et++) {
              Double_t ptbd = fPOIPhiEtaDiffQRe[0][0]->GetXaxis()->GetBinCenter(pt+1);
              Double_t etbd = fPOIPhiEtaDiffQRe[0][0]->GetYaxis()->GetBinCenter(et+1);
              Bool_t bIsIn = (fFlowQCIntCorProPhiEta[0][0][0]->GetXaxis()->FindBin(ptbd)==ptb && fFlowQCIntCorProPhiEta[0][0][0]->GetYaxis()->FindBin(etbd)==etb);
              if(var==0 || (var==1 && bIsIn==kFALSE)) {
                QRe += fPOIPhiEtaDiffQRe[1][hr+1]->GetBinContent(pt+1,et+1);
                QIm += fPOIPhiEtaDiffQIm[1][hr+1]->GetBinContent(pt+1,et+1);
                Q2Re2 += fPOIPhiEtaDiffQRe[2][2*hr+3]->GetBinContent(pt+1,et+1);
                Q2Im2 += fPOIPhiEtaDiffQIm[2][2*hr+3]->GetBinContent(pt+1,et+1);
                QRe3 += fPOIPhiEtaDiffQRe[3][hr+1]->GetBinContent(pt+1,et+1);
                QIm3 += fPOIPhiEtaDiffQIm[3][hr+1]->GetBinContent(pt+1,et+1);
                QM0  += fPOIPhiEtaDiffMul[0][0]->GetBinContent(pt+1,et+1);
                QM   += fPOIPhiEtaDiffMul[1][0]->GetBinContent(pt+1,et+1);
                QM2  += fPOIPhiEtaDiffMul[2][0]->GetBinContent(pt+1,et+1);
                QM3  += fPOIPhiEtaDiffMul[3][0]->GetBinContent(pt+1,et+1);
              }

              if(bIsIn) {
                qpRe0 += fPOIPhiEtaDiffQRe[0][hr+1]->GetBinContent(pt+1,et+1);
                qpIm0 += fPOIPhiEtaDiffQIm[0][hr+1]->GetBinContent(pt+1,et+1);
                qpM0 += fPOIPhiEtaDiffMul[0][0]->GetBinContent(pt+1,et+1);

                if(var==0) {
                  qqRe2 += fPOIPhiEtaDiffQRe[2][hr+1]->GetBinContent(pt+1,et+1);
                  qqIm2 += fPOIPhiEtaDiffQIm[2][hr+1]->GetBinContent(pt+1,et+1);
                  qq2Re += fPOIPhiEtaDiffQRe[1][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Im += fPOIPhiEtaDiffQIm[1][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Re2 += fPOIPhiEtaDiffQRe[2][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Im2 += fPOIPhiEtaDiffQIm[2][2*hr+3]->GetBinContent(pt+1,et+1);
                  qqRe3 += fPOIPhiEtaDiffQRe[3][hr+1]->GetBinContent(pt+1,et+1);
                  qqIm3 += fPOIPhiEtaDiffQIm[3][hr+1]->GetBinContent(pt+1,et+1);
                  qqM   += fPOIPhiEtaDiffMul[1][0]->GetBinContent(pt+1,et+1);
                  qqM2  += fPOIPhiEtaDiffMul[2][0]->GetBinContent(pt+1,et+1);
                  qqM3  += fPOIPhiEtaDiffMul[3][0]->GetBinContent(pt+1,et+1);
                  qqM4  += fPOIPhiEtaDiffMul[4][0]->GetBinContent(pt+1,et+1);
                }
              }
            }
          }

          dQM2 = qpM0*QM-qqM;
          WdQM2 = (WeigMul? dQM2 : 1.);
          if(qpM0>0 && QM0>0) {
            dQC2 = (qpRe0*QRe+qpIm0*QIm-qqM)/dQM2;
            fFlowQCIntCorProPhiEta[fCenBin][hr][0+2*var]->Fill(ptfill,etfill,dQC2,WdQM2*fCenWeightEbE);
          }
          if(QM0>1) {
            if(var==0) fFlowQCIntCorProPhiEta[fCenBin][hr][4]->Fill(ptfill,etfill,(QRe*QRe+QIm*QIm-QM2)/(QM*QM-QM2),(QM*QM-QM2)*fCenWeightEbE);
            else       fFlowQCIntCorProPhiEta[fCenBin][hr][5]->Fill(ptfill,etfill,(QRe*QRe+QIm*QIm-QM2)/(QM*QM-QM2),(QM*QM-QM2)*fCenWeightEbE);
          }

          dQM4 = qpM0*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qqM*(QM*QM-QM2)+2.*(qqM3-qqM2*QM));

          WdQM4 = (WeigMul? dQM4 : 1.);
          if(qpM0>0 && QM0>2) {
            dQC4 = ((pow(QRe,2.)+pow(QIm,2.))*(qpRe0*QRe+qpIm0*QIm)
            - qq2Re*(pow(QRe,2.)-pow(QIm,2.))
            - 2.*qq2Im*QRe*QIm
            - qpRe0*(QRe*Q2Re2+QIm*Q2Im2)
            + qpIm0*(QIm*Q2Re2-QRe*Q2Im2)
            - 2.*QM2*(qpRe0*QRe+qpIm0*QIm)
            - 2.*(pow(QRe,2.)+pow(QIm,2.))*qqM
            + 6.*(qqRe2*QRe+qqIm2*QIm)
            + 1.*(qq2Re*Q2Re2+qq2Im*Q2Im2)
            + 2.*(qpRe0*QRe3+qpIm0*QIm3)
            + 2.*qqM*QM2
            - 6.*qqM3) / dQM4;
            fFlowQCIntCorProPhiEta[fCenBin][hr][1+2*var]->Fill(ptfill,etfill,dQC4,WdQM4*fCenWeightEbE);
          }

        }// enf of for(Int_t var=0; var<2; var++)
      }
    }
  }

  for(Int_t hr=0; hr<fkFlowQCRbRnHar; hr++) {

    if(fStoreZDCQVecVtxPos) {

      for(Int_t var=0; var<fkFlowQCRbRnVar; var++) {

        for(Int_t etb=1; etb<=fFlowQCIntProEta[0][0][0]->GetNbinsY(); etb++) {

          // pT-integrated, 2- and 4-particle cumulants
          QRe=0.; QIm=0.; Q2Re2=0.; Q2Im2=0.; QRe3=0.; QIm3=0.; QM0=0.; QM=0.; QM2=0.; QM3=0.;

          // eta-differential
          // Double_t qpTRe0=0., qpTIm0=0., qpTM0=0., qpTM=0., qpTRe=0., qpTIm=0.;
          // Double_t qqTRe2=0., qqTIm2=0., qqT2Re=0., qqT2Im=0., qqTM=0., qqTM2=0., qqTM3=0., qqTM4=0., qqTRe3=0., qqTIm3=0., qqT2Re2=0., qqT2Im2=0.;

          // eta-differential
          qpRe0=0.; qpIm0=0.; qpM0=0.;
          Double_t qqRe2=0., qqIm2=0., qq2Re=0., qq2Im=0., qqM=0., qqM2=0., qqM3=0., qpM=0., qqM4=0., qqRe3=0., qqIm3=0., qq2Re2=0., qq2Im2=0., qpRe=0., qpIm=0.;

          Double_t etfill = fFlowQCIntProEta[0][0][0]->GetYaxis()->GetBinCenter(etb);

          for(Int_t pt=0; pt<fPOIPhiEtaDiffQRe[0][0]->GetNbinsX(); pt++) {
            for(Int_t et=0; et<fPOIPhiEtaDiffQRe[0][0]->GetNbinsY(); et++) {
              Int_t etbr = fFlowQCIntProEta[0][0][0]->GetYaxis()->FindBin(fPOIPhiEtaDiffQRe[0][0]->GetYaxis()->GetBinCenter(et+1));
              Bool_t IsIn=kFALSE;
              if(var==1) IsIn = (etbr==etb);
              if(var==2) IsIn = (etbr==etb || etbr==etb-1 || etbr==etb+1);
              if(var==3) IsIn = (etbr==etb || etbr==etb-1 || etbr==etb+1 || etbr==etb-2 || etbr==etb+2);
              if(!IsIn) {
                QRe += fPOIPhiEtaDiffQRe[1][hr+1]->GetBinContent(pt+1,et+1);
                QIm += fPOIPhiEtaDiffQIm[1][hr+1]->GetBinContent(pt+1,et+1);
                Q2Re2 += fPOIPhiEtaDiffQRe[2][2*hr+3]->GetBinContent(pt+1,et+1);
                Q2Im2 += fPOIPhiEtaDiffQIm[2][2*hr+3]->GetBinContent(pt+1,et+1);
                QRe3 += fPOIPhiEtaDiffQRe[3][hr+1]->GetBinContent(pt+1,et+1);
                QIm3 += fPOIPhiEtaDiffQIm[3][hr+1]->GetBinContent(pt+1,et+1);
                QM0  += fPOIPhiEtaDiffMul[0][0]->GetBinContent(pt+1,et+1);
                QM   += fPOIPhiEtaDiffMul[1][0]->GetBinContent(pt+1,et+1);
                QM2  += fPOIPhiEtaDiffMul[2][0]->GetBinContent(pt+1,et+1);
                QM3  += fPOIPhiEtaDiffMul[3][0]->GetBinContent(pt+1,et+1);
              }

              if(etbr==etb) {
                qpRe0 += fPOIPhiEtaDiffQRe[0][hr+1]->GetBinContent(pt+1,et+1);
                qpIm0 += fPOIPhiEtaDiffQIm[0][hr+1]->GetBinContent(pt+1,et+1);
                qpM0  += fPOIPhiEtaDiffMul[0][0]->GetBinContent(pt+1,et+1);
                qpRe += fPOIPhiEtaDiffQRe[1][hr+1]->GetBinContent(pt+1,et+1);
                qpIm += fPOIPhiEtaDiffQIm[1][hr+1]->GetBinContent(pt+1,et+1);
                qpM  += fPOIPhiEtaDiffMul[1][0]->GetBinContent(pt+1,et+1);

                if(!IsIn) {
                  qqRe2 += fPOIPhiEtaDiffQRe[2][hr+1]->GetBinContent(pt+1,et+1);
                  qqIm2 += fPOIPhiEtaDiffQIm[2][hr+1]->GetBinContent(pt+1,et+1);
                  qq2Re += fPOIPhiEtaDiffQRe[1][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Im += fPOIPhiEtaDiffQIm[1][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Re2 += fPOIPhiEtaDiffQRe[2][2*hr+3]->GetBinContent(pt+1,et+1);
                  qq2Im2 += fPOIPhiEtaDiffQIm[2][2*hr+3]->GetBinContent(pt+1,et+1);
                  qqRe3 += fPOIPhiEtaDiffQRe[3][hr+1]->GetBinContent(pt+1,et+1);
                  qqIm3 += fPOIPhiEtaDiffQIm[3][hr+1]->GetBinContent(pt+1,et+1);
                  qqM   += fPOIPhiEtaDiffMul[1][0]->GetBinContent(pt+1,et+1);
                  qqM2  += fPOIPhiEtaDiffMul[2][0]->GetBinContent(pt+1,et+1);
                  qqM3  += fPOIPhiEtaDiffMul[3][0]->GetBinContent(pt+1,et+1);
                  qqM4  += fPOIPhiEtaDiffMul[4][0]->GetBinContent(pt+1,et+1);
                }
              }
            }
          }

          // if((etfill>0. && var==0) || (etfill<0. && var==1)) {
          //   qpTRe0 += qpRe0;
          //   qpTIm0 += qpIm0;
          //   qpTM0 += qpM0;
          //   qpTRe += qpRe;
          //   qpTIm += qpIm;
          //   qpTM += qpM;
          //
          //   qqTRe2 += qqRe2;
          //   qqTIm2 += qqIm2;
          //   qqT2Re += qq2Re;
          //   qqT2Im += qq2Im;
          //   qqT2Re2 += qq2Re2;
          //   qqT2Im2 += qq2Im2;
          //   qqTRe3 += qqRe3;
          //   qqTIm3 += qqIm3;
          //   qqTM += qqM;
          //   qqTM2 += qqM2;
          //   qqTM3 += qqM3;
          //   qqTM4 += qqM4;
          // }

          dQM2 = qpM0*QM-qqM;
          WdQM2 = (WeigMul? dQM2 : 1.);
          if(qpM0>0 && QM0>0) {
            dQC2 = (qpRe0*QRe+qpIm0*QIm-qqM)/dQM2;
            fFlowQCIntProEta[hr][var][0]->Fill(fCentralityEBE,etfill,dQC2,WdQM2*fCenWeightEbE);
          }

          if(QM0>1) {
            fFlowQCIntProEta[hr][var][2]->Fill(fCentralityEBE,etfill,(QRe*QRe+QIm*QIm-QM2)/(QM*QM-QM2),(QM*QM-QM2)*fCenWeightEbE);
          }

          dQM4 = qpM0*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qqM*(QM*QM-QM2)+2.*(qqM3-qqM2*QM));
          WdQM4 = (WeigMul? dQM4 : 1.);
          if(qpM0>0 && QM0>2) {
            dQC4 = ((pow(QRe,2.)+pow(QIm,2.))*(qpRe0*QRe+qpIm0*QIm)
            - qq2Re*(pow(QRe,2.)-pow(QIm,2.))
            - 2.*qq2Im*QRe*QIm
            - qpRe0*(QRe*Q2Re2+QIm*Q2Im2)
            + qpIm0*(QIm*Q2Re2-QRe*Q2Im2)
            - 2.*QM2*(qpRe0*QRe+qpIm0*QIm)
            - 2.*(pow(QRe,2.)+pow(QIm,2.))*qqM
            + 6.*(qqRe2*QRe+qqIm2*QIm)
            + 1.*(qq2Re*Q2Re2+qq2Im*Q2Im2)
            + 2.*(qpRe0*QRe3+qpIm0*QIm3)
            + 2.*qqM*QM2
            - 6.*qqM3) / dQM4;
            fFlowQCIntProEta[hr][var][1]->Fill(fCentralityEBE,etfill,dQC4,WdQM4*fCenWeightEbE);
          }

        } // end of for(Int_t etb=1; etb<=fFlowQCIntProEta[0][0][0]->GetNbinsY(); etb++)

        // if(QM0>1) {
        //   fFlowQCIntRbRProTotal[hr][var][0]->Fill(fCentralityEBE,(QRe*QRe+QIm*QIm-QM2)/(QM*QM-QM2),(QM*QM-QM2)*fCenWeightEbE);
        // }
        //
        // if(qpTM0>0 && QM0>0) {
        //   dQM2 = qpTM*QM-qqTM2;
        //   dQC2 = (qpTRe*QRe+qpTIm*QIm-qqTM2)/dQM2;
        //   fFlowQCIntRbRProTotal[hr][var][1]->Fill(fCentralityEBE,dQC2,dQM2*fCenWeightEbE);
        // }
        //
        // dQM4 = qpTM*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qqTM2*(QM*QM-QM2)+2.*(qqTM4-qqTM3*QM));
        //
        // if(qpTM0>0 && QM0>2) {
        //   dQM4 = qpTM*(QM*QM*QM-3.*QM*QM2+2.*QM3)-3.*(qqTM2*(QM*QM-QM2)+2.*(qqTM4-qqTM3*QM));
        //   dQC4 = ((pow(QRe,2.)+pow(QIm,2.))*(qpTRe*QRe+qpTIm*QIm)
        //   - qqT2Re2*(pow(QRe,2.)-pow(QIm,2.))
        //   - 2.*qqT2Im2*QRe*QIm
        //   - qpTRe*(QRe*Q2Re2+QIm*Q2Im2)
        //   + qpTIm*(QIm*Q2Re2-QRe*Q2Im2)
        //   - 2.*QM2*(qpTRe*QRe+qpTIm*QIm)
        //   - 2.*(pow(QRe,2.)+pow(QIm,2.))*qqTM2
        //   + 6.*(qqTRe3*QRe+qqTIm3*QIm)
        //   + 1.*(qqT2Re2*Q2Re2+qqT2Im2*Q2Im2)
        //   + 2.*(qpTRe*QRe3+qpTIm*QIm3)
        //   + 2.*qqTM2*QM2
        //   - 6.*qqTM4) / dQM4;
        //   fFlowQCIntRbRProTotal[hr][var][2]->Fill(fCentralityEBE,dQC4,dQM4*fCenWeightEbE);
        // }
      }

    } // end loop in var

  } // end of for(Int_t hr=0; hr<fkFlowQCRbRnHar; hr++)

} // end of AliFlowAnalysisCRC::CalculateFlowQC();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateFlowGF()
{
  Int_t order[fkFlowGFNOrde] = {0};
  for(Int_t k=0; k<fkFlowGFNOrde; k++) {
    order[k] = 2*(k+1);
  }

  Int_t SubSamplingBin = fRandom->Integer(fkFlowGFNSubSampling);

  Double_t dMult = (*fReQGF)(0,0);

  for(Int_t hr=0; hr<fkFlowGFNHarm; hr++) {

    Double_t CorrOrd[fkFlowGFNOrde] = {0.};
    Double_t WeigOrd[fkFlowGFNOrde] = {0.};

    for(Int_t no=0; no<fkFlowGFNOrde; no++) {

      if(dMult<order[no]) continue;

      TArrayI harmonics(order[no]);
      Int_t halforder = (Int_t)order[no]/2;
      for(Int_t k=0; k<order[no]; k++) {
        if(k<halforder) harmonics[k] = -(hr+2);
        else            harmonics[k] = hr+2;
      }
      TArrayI emptyness(order[no]);
      for(Int_t k=0; k<order[no]; k++) emptyness[k] = 0;

      std::complex<double> N = this->ucN(order[no], harmonics, -1);
      std::complex<double> D = this->ucN(order[no], emptyness, -1);

      if(D.real()>0.) {
        fFlowGFIntCorPro[hr][no]->Fill(fCentralityEBE,N.real()/D.real(),D.real()*fCenWeightEbE);
        CorrOrd[no] = N.real()/D.real();
        WeigOrd[no] = D.real();
        if(fStoreExtraHistoForSubSampling) fFlowGFIntCorProSS[SubSamplingBin][hr][no]->Fill(fCentralityEBE,N.real()/D.real(),D.real()*fCenWeightEbE);
      }

    } // end of for(Int_t no=0; no<fkFlowGFNOrde; no++)

    for(Int_t no=0; no<fkFlowGFNOrde; no++) {
      for(Int_t no2=0; no2<fkFlowGFNOrde; no2++) {
        if(WeigOrd[no]>0. && WeigOrd[no2]>0.) {
          fFlowGFIntCovPro[hr][no][no2]->Fill(fCentralityEBE,CorrOrd[no]*CorrOrd[no2],WeigOrd[no]*WeigOrd[no2]*fCenWeightEbE*fCenWeightEbE);
          if(fStoreExtraHistoForSubSampling) fFlowGFIntCovProSS[SubSamplingBin][hr][no][no2]->Fill(fCentralityEBE,CorrOrd[no]*CorrOrd[no2],WeigOrd[no]*WeigOrd[no2]*fCenWeightEbE*fCenWeightEbE);
        }
      }
    }

  } // end of for(Int_t hr=0; hr<fkFlowGFNHarm; hr++)

  for(Int_t hr=0; hr<fkFlowGFNHarm; hr++) {
    for(Int_t hr2=0; hr2<fkFlowGFNHarm; hr2++) {

      if(dMult<4) continue;

      TArrayI harmonics(4);
      harmonics[0] = hr+2;
      harmonics[1] = hr2+2;
      harmonics[2] = -(hr+2);
      harmonics[3] = -(hr2+2);

      TArrayI emptyness(4);
      for(Int_t k=0; k<4; k++) emptyness[k] = 0;

      std::complex<double> N = this->ucN(4, harmonics, -1);
      std::complex<double> D = this->ucN(4, emptyness, -1);

      if(D.real()>0.) {
        fFlowGFMixedCorPro[hr][hr2]->Fill(fCentralityEBE,N.real()/D.real(),D.real()*fCenWeightEbE);
      }
    }
  }

  // in wide pt bins
  for(Int_t i=0; i<fkGFPtB; i++) {
    Double_t dMult = (*fReQGFPt[i])(0,0);

    for(Int_t hr=0; hr<fkFlowGFNHarm; hr++) {

      Double_t CorrOrd[fkFlowGFNOrde] = {0.};
      Double_t WeigOrd[fkFlowGFNOrde] = {0.};

      for(Int_t no=0; no<fkFlowGFNOrde; no++) {

        if(dMult<order[no]) continue;

        TArrayI harmonics(order[no]);
        Int_t halforder = (Int_t)order[no]/2;
        for(Int_t k=0; k<order[no]; k++) {
          if(k<halforder) harmonics[k] = -(hr+2);
          else            harmonics[k] = hr+2;
        }
        TArrayI emptyness(order[no]);
        for(Int_t k=0; k<order[no]; k++) emptyness[k] = 0;

        std::complex<double> N = this->ucN(order[no], harmonics, i);
        std::complex<double> D = this->ucN(order[no], emptyness, i);

        if(D.real()>0.) {
          fFlowGFIntCorProPtB[i][hr][no]->Fill(fCentralityEBE,N.real()/D.real(),D.real()*fCenWeightEbE);
          CorrOrd[no] = N.real()/D.real();
          WeigOrd[no] = D.real();
        }

      } // end of for(Int_t no=0; no<fkFlowGFNOrde; no++)

      for(Int_t no=0; no<fkFlowGFNOrde; no++) {
        for(Int_t no2=0; no2<fkFlowGFNOrde; no2++) {
          if(WeigOrd[no]>0. && WeigOrd[no2]>0.) {
            fFlowGFIntCovProPtB[i][hr][no][no2]->Fill(fCentralityEBE,CorrOrd[no]*CorrOrd[no2],WeigOrd[no]*WeigOrd[no2]*fCenWeightEbE*fCenWeightEbE);
          }
        }
      }

    } // end of for(Int_t hr=0; hr<fkFlowGFNHarm; hr++)
  } // end of for(Int_t i=0; i<fkGFPtB; i++)

} // end of AliFlowAnalysisCRC::CalculateFlowGF()

//=====================================================================================================

std::complex<double> AliFlowAnalysisCRC::ucN(const Int_t n, const TArrayI& h, Int_t ptb=-1)
{
  TArrayI cnt(n);
  for (Int_t i = 0; i < n; i++) {
    cnt[i] = 1;
  }
  TArrayI hh(h);

  return ucN2(n, hh, cnt, ptb);
}

std::complex<double> AliFlowAnalysisCRC::ucN2(const Int_t n, TArrayI& h, TArrayI& cnt, Int_t ptb=-1)
{
  Int_t j = n-1;
  std::complex<double> c;
  if(ptb<0) {
    if(h[j] >= 0) {
      c = std::complex<double>((*fReQGF)(h[j],cnt[j]),(*fImQGF)(h[j],cnt[j]));
    } else {
      c = std::complex<double>((*fReQGF)(-h[j],cnt[j]),-(*fImQGF)(-h[j],cnt[j]));
    }
  } else {
    if(h[j] >= 0) {
      c = std::complex<double>((*fReQGFPt[ptb])(h[j],cnt[j]),(*fImQGFPt[ptb])(h[j],cnt[j]));
    } else {
      c = std::complex<double>((*fReQGFPt[ptb])(-h[j],cnt[j]),-(*fImQGFPt[ptb])(-h[j],cnt[j]));
    }
  }

  if (n == 1) return c;

  c *= ucN2(j, h, cnt, ptb);

  if (cnt[j] > 1) return c;

  for (Int_t i = 0; i < (n-1); i++) {
    h[i] += h[j];
    cnt[i] = cnt[i] + 1;
    Double_t factor = 1.*(cnt[i]-1);
    c -= factor * ucN2(j, h, cnt, ptb);
    cnt[i]--;
    h[i] -= h[j];
  }
  return c;
}

//=====================================================================================================

void AliFlowAnalysisCRC::CalculateFlowSPVZ()
{

  // ZDC QA cuts
  if(fQAZDCCuts && !fQAZDCCutsFlag) {return;}

  for(Int_t hr=0; hr<fCRCnHar; hr++) {

    // VZ eta < 0
    Double_t VCRe = fVZFlowVect[0][hr].X();
    Double_t VCIm = fVZFlowVect[0][hr].Y();
    Double_t VCM  = fVZFlowVect[0][hr].GetMult();
    // VZ eta > 0
    Double_t VARe = fVZFlowVect[1][hr].X();
    Double_t VAIm = fVZFlowVect[1][hr].Y();
    Double_t VAM  = fVZFlowVect[1][hr].GetMult();

    if( VCM<1. || VAM<1. ) return;
    if(!std::isfinite(VCRe) || std::isnan(VCRe) || !std::isfinite(VCIm) || std::isnan(VCIm)) return;
    if(!std::isfinite(VARe) || std::isnan(VARe) || !std::isfinite(VAIm) || std::isnan(VAIm)) return;

    Double_t FillPtBin = 0.;
    Double_t QRe=0., QIm=0., QMraw=0., QM=0.;
    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {
      QRe += fPOIPtDiffQRe[1][hr+1]->GetBinContent(pt+1);
      QIm += fPOIPtDiffQIm[1][hr+1]->GetBinContent(pt+1);
      QMraw += fPOIPtDiffMul[0][0]->GetBinContent(pt+1);
      QM  += fPOIPtDiffMul[1][0]->GetBinContent(pt+1);
    }

    if(QMraw>0) {
      FillPtBin = fPOIPtDiffQRe[0][0]->GetBinCenter(1);
      fFlowSPVZCorPro[fCenBin][hr][0]->Fill(FillPtBin,VCRe*VARe+VCIm*VAIm,fCenWeightEbE);
      FillPtBin = fPOIPtDiffQRe[0][0]->GetBinCenter(2);
      fFlowSPVZCorPro[fCenBin][hr][0]->Fill(FillPtBin,(QRe*VCRe+QIm*VCIm)/QM,QM*fCenWeightEbE);
      FillPtBin = fPOIPtDiffQRe[0][0]->GetBinCenter(3);
      fFlowSPVZCorPro[fCenBin][hr][0]->Fill(FillPtBin,(QRe*VARe+QIm*VAIm)/QM,QM*fCenWeightEbE);

      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(1),VCRe,fCenWeightEbE);
      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(2),VARe,fCenWeightEbE);
      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(3),VCIm,fCenWeightEbE);
      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(4),VAIm,fCenWeightEbE);
      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(5),QRe/QM,QM*fCenWeightEbE);
      fFlowSPVZNUAPro[fCenBin][hr][0]->Fill(fPOIPtDiffQRe[0][0]->GetBinCenter(6),QIm/QM,QM*fCenWeightEbE);
    }

    for(Int_t pt=0; pt<fPtDiffNBins; pt++) {

      FillPtBin = fPOIPtDiffQRe[0][0]->GetBinCenter(pt+1);
      Double_t qpRe = fPOIPtDiffQRe[1][hr+1]->GetBinContent(pt+1);
      Double_t qpIm = fPOIPtDiffQIm[1][hr+1]->GetBinContent(pt+1);
      Double_t qpMraw = fPOIPtDiffMul[0][0]->GetBinContent(pt+1);
      Double_t qpM  = fPOIPtDiffMul[1][0]->GetBinContent(pt+1);

      if(qpMraw>0) {
        // Normalize TPC Q-vector
        fFlowSPVZCorPro[fCenBin][hr][1]->Fill(FillPtBin,(qpRe*VCRe+qpIm*VCIm)/qpM,qpM*fCenWeightEbE);
        fFlowSPVZCorPro[fCenBin][hr][2]->Fill(FillPtBin,(qpRe*VARe+qpIm*VAIm)/qpM,qpM*fCenWeightEbE);
        fFlowSPVZNUAPro[fCenBin][hr][1]->Fill(FillPtBin,qpRe/qpM,qpM*fCenWeightEbE);
        fFlowSPVZNUAPro[fCenBin][hr][2]->Fill(FillPtBin,qpIm/qpM,qpM*fCenWeightEbE);
      }

    } // end of for(Int_t pt=0; pt<fCRCnPtBin; pt++)

  } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

} // end of AliFlowAnalysisCRC::CalculateFlowSPVZ();

//=======================================================================================================================

void AliFlowAnalysisCRC::FitEbEFlow()
{
//  if(fEBEFlowMulBin<0) return;
//  Double_t NewCentralityEBE=0.;
//  Int_t NewCenBin=0;
//
//  if(fQAZDCCuts && fMinMulZN==7) {
//    if(fQAZDCCutsFlag) {
//      NewCentralityEBE = fNewCentralityEBE;
//      NewCenBin = GetCRCCenBin(fNewCentralityEBE);
//    } else {
//      return;
//    }
//  } else {
//    NewCentralityEBE = fCentralityEBE;
//    NewCenBin = fCenBin;
//  }
//
//  // VZ eta < 0
//  Double_t VZC2Re = fVZFlowVect[0][1].X();
//  Double_t VZC2Im = fVZFlowVect[0][1].Y();
//  Double_t VZC3Re = fVZFlowVect[0][2].X();
//  Double_t VZC3Im = fVZFlowVect[0][2].Y();
//  // VZ eta > 0
//  Double_t VZA2Re = fVZFlowVect[1][1].X();
//  Double_t VZA2Im = fVZFlowVect[1][1].Y();
//  Double_t VZA3Re = fVZFlowVect[1][2].X();
//  Double_t VZA3Im = fVZFlowVect[1][2].Y();
//
//  Double_t VZCM  = fVZFlowVect[0][1].GetMult();
//  Double_t VZAM  = fVZFlowVect[1][1].GetMult();
//  if( VZCM<1. || VZAM<1. ) return;
//
//  //FourierExp [0]*(1 + 2.*[1]*cos(2.*(x-[3])) + 2.*[2]*cos(3.*(x-[4])))
//
//  Double_t VZApsi2 = TMath::ATan2(VZA2Im,VZA2Re)/2.;
//  if(VZApsi2<0.) VZApsi2 += TMath::TwoPi();
//  Double_t VZCpsi2 = TMath::ATan2(VZC2Im,VZC2Re)/2.;
//  if(VZCpsi2<0.) VZCpsi2 += TMath::TwoPi();
//  Double_t VZApsi3 = TMath::ATan2(VZA3Im,VZA3Re)/3.;
//  if(VZApsi3<0.) VZApsi3 += TMath::TwoPi();
//  Double_t VZCpsi3 = TMath::ATan2(VZC3Im,VZC3Re)/3.;
//  if(VZCpsi3<0.) VZCpsi3 += TMath::TwoPi();
//
//  Int_t CenInt = (Int_t)(fCentralityEBE);
//  Double_t norm = fchisqVC[CenInt]+fchisqVA[CenInt];
//
//  Double_t VZpsi2 = TMath::ATan2((fchisqVC[CenInt]*VZC2Im+fchisqVA[CenInt]*VZA2Im)/norm,(fchisqVC[CenInt]*VZC2Re+fchisqVA[CenInt]*VZA2Re)/norm)/2.;
//  if(VZpsi2<0.) VZpsi2 += TMath::TwoPi();
//  FourierExp->FixParameter(3,VZpsi2);
//
//  Double_t VZpsi3 = TMath::ATan2((fchisqVC[CenInt]*VZC3Im+fchisqVA[CenInt]*VZA3Im)/norm,(fchisqVC[CenInt]*VZC3Re+fchisqVA[CenInt]*VZA3Re)/norm)/3.;
//  if(VZpsi3<0.) VZpsi3 += TMath::TwoPi();
//  FourierExp->FixParameter(4,VZpsi3);
//
//  Int_t DoF = fEbEFlowAzimDis[fEBEFlowMulBin]->GetNbinsX();
//
//  FourierExp->SetParameter(0,(Double_t)(fEbEFlowAzimDis[fEBEFlowMulBin]->GetSumOfWeights()/DoF));
//
//  fEbEFlowAzimDis[fEBEFlowMulBin]->Fit(FourierExp,"QWLB");
//
//  if(FourierExp->GetMinimum(0.,TMath::TwoPi())<0.) return;
//
//  Double_t ChiSq = fEbEFlowAzimDis[fEBEFlowMulBin]->Chisquare(FourierExp);
//  Double_t RChiSq = ChiSq/DoF;
//  fEBEFlowRChiSqHist[0]->Fill(fCentralityEBE,RChiSq);
//
//  Double_t pValue = 1. - TMath::Gamma(DoF/2.,ChiSq/2.);
//  fEBEFlowpValueHist[0]->Fill(fCentralityEBE,pValue);
//
//  if (pValue>0.01) {
//    Double_t v2 = fabs(FourierExp->GetParameter(1));
//    Double_t v3 = fabs(FourierExp->GetParameter(2));
//
//    fEBEFlowFlucHis[fCenBin][0]->Fill(v2);
//    fEBEFlowFlucHis[fCenBin][1]->Fill(v3);
//
//    fEBEFlowCrosPro[fCenBin][0]->Fill(v2,v3);
//
//    fEBEFlowFlucHis[NewCenBin][2]->Fill(v2);
//    fEBEFlowFlucHis[NewCenBin][3]->Fill(v3);
//
//    fEBEFlowCrosPro[NewCenBin][1]->Fill(v2,v3);
//  }
//
//
//  // resolution V0A, V0C
//
//  Double_t Q2Re=0., Q2Im=0., Q3Re=0., Q3Im=0., QMraw=0., QM=0.;
//  for(Int_t et=1; et<=fkEtaDiffNBins; et++) {
//    Q2Re += fEtaDiffQRe[1]->GetBinContent(et);
//    Q2Im += fEtaDiffQIm[1]->GetBinContent(et);
//    Q3Re += fEtaDiffQRe[2]->GetBinContent(et);
//    Q3Im += fEtaDiffQIm[2]->GetBinContent(et);
//    QM  += fEtaDiffMul[1]->GetBinContent(et);
//  }
//
//  Double_t TPCpsi2 = TMath::ATan2(Q2Im,Q2Re)/2.;
//  if(TPCpsi2<0.) TPCpsi2 += TMath::TwoPi();
//  Double_t TPCpsi3 = TMath::ATan2(Q3Im,Q3Re)/3.;
//  if(TPCpsi3<0.) TPCpsi3 += TMath::TwoPi();
//
//  fEBEFlowResVZPro[0]->Fill(fCentralityEBE,cos(2.*(VZApsi2-VZCpsi2)));
//  fEBEFlowResVZPro[1]->Fill(fCentralityEBE,cos(2.*(TPCpsi2-VZApsi2)));
//  fEBEFlowResVZPro[2]->Fill(fCentralityEBE,cos(2.*(TPCpsi2-VZCpsi2)));
//
//  fEBEFlowResVZPro[3]->Fill(fCentralityEBE,cos(3.*(VZApsi3-VZCpsi3)));
//  fEBEFlowResVZPro[4]->Fill(fCentralityEBE,cos(3.*(TPCpsi3-VZApsi3)));
//  fEBEFlowResVZPro[5]->Fill(fCentralityEBE,cos(3.*(TPCpsi3-VZCpsi3)));
//
//  // resolution V0s combined
//
//  Double_t Q2ReA = fEtaDiffQRe[1]->GetBinContent(1);
//  Double_t Q2ImA = fEtaDiffQIm[1]->GetBinContent(1);
//  Double_t Q3ReA = fEtaDiffQRe[2]->GetBinContent(1);
//  Double_t Q3ImA = fEtaDiffQIm[2]->GetBinContent(1);
//
//  Double_t Q2ReC = fEtaDiffQRe[1]->GetBinContent(2);
//  Double_t Q2ImC = fEtaDiffQIm[1]->GetBinContent(2);
//  Double_t Q3ReC = fEtaDiffQRe[2]->GetBinContent(2);
//  Double_t Q3ImC = fEtaDiffQIm[2]->GetBinContent(2);
//
//  Double_t TPCpsi2A = TMath::ATan2(Q2ImA,Q2ReA)/2.;
//  if(TPCpsi2A<0.) TPCpsi2A += TMath::TwoPi();
//  Double_t TPCpsi3A = TMath::ATan2(Q3ImA,Q3ReA)/3.;
//  if(TPCpsi3A<0.) TPCpsi3A += TMath::TwoPi();
//  Double_t TPCpsi2C = TMath::ATan2(Q2ImC,Q2ReC)/2.;
//  if(TPCpsi2C<0.) TPCpsi2C += TMath::TwoPi();
//  Double_t TPCpsi3C = TMath::ATan2(Q3ImC,Q3ReC)/3.;
//  if(TPCpsi3C<0.) TPCpsi3C += TMath::TwoPi();
//
//  fEBEFlowResVZPro[6]->Fill(fCentralityEBE,cos(2.*(TPCpsi2A-TPCpsi2C)));
//  fEBEFlowResVZPro[7]->Fill(fCentralityEBE,cos(2.*(TPCpsi2A-VZpsi2)));
//  fEBEFlowResVZPro[8]->Fill(fCentralityEBE,cos(2.*(TPCpsi2C-VZpsi2)));
//
//  fEBEFlowResVZPro[9]->Fill(fCentralityEBE,cos(3.*(TPCpsi3A-TPCpsi3C)));
//  fEBEFlowResVZPro[10]->Fill(fCentralityEBE,cos(3.*(TPCpsi3A-VZpsi3)));
//  fEBEFlowResVZPro[11]->Fill(fCentralityEBE,cos(3.*(TPCpsi3C-VZpsi3)));
//
//  fEBEFlowResVZPro[12]->Fill(fNewCentralityEBE,cos(2.*(TPCpsi2A-TPCpsi2C)));
//  fEBEFlowResVZPro[13]->Fill(fNewCentralityEBE,cos(2.*(TPCpsi2A-VZpsi2)));
//  fEBEFlowResVZPro[14]->Fill(fNewCentralityEBE,cos(2.*(TPCpsi2C-VZpsi2)));
//
//  fEBEFlowResVZPro[15]->Fill(fNewCentralityEBE,cos(3.*(TPCpsi3A-TPCpsi3C)));
//  fEBEFlowResVZPro[16]->Fill(fNewCentralityEBE,cos(3.*(TPCpsi3A-VZpsi3)));
//  fEBEFlowResVZPro[17]->Fill(fNewCentralityEBE,cos(3.*(TPCpsi3C-VZpsi3)));

}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateCRCPtCorr()
{
}

//=======================================================================================================================

void AliFlowAnalysisCRC::FillVarious()
{
  fMultHist->Fill(fReferenceMultiplicityEBE,fCenWeightEbE);
  fCenHist->Fill(fCentralityEBE,fCenWeightEbE);

  fV0MMultHist->Fill(fNITSCL1EBE,fCenWeightEbE);

  fVtxHist[0]->Fill(fRunBin+0.5,fCentralityEBE,fVtxPos[0]);
  fVtxHist[1]->Fill(fRunBin+0.5,fCentralityEBE,fVtxPos[1]);
  fVtxHist[2]->Fill(fRunBin+0.5,fCentralityEBE,fVtxPos[2]);

  fRefMulRecHist->Fill(fCentralityEBE,fReferenceMultiplicityRecEBE,fNumberOfPOIsEBE);

} // end of AliFlowAnalysisCRC::FillVarious()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateOtherDiffCorrelators(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::Calculate2DDiffFlowCorrelations(TString type)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowSumOfEventWeights(TString type, TString ptOrEta)
{}


//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowSumOfProductOfEventWeights(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeReducedCorrelations(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCRC2Cor()
{
  // calculate final 2- and 4-p products of correlations

  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final CRC2"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      for(Int_t eg=1; eg<=fCRC2nEtaBins; eg++) {

        Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0.;
        Double_t stats[6]={0.};

        fCRC2CorPro[h][c]->GetXaxis()->SetRange(eg,eg);
        fCRC2CorPro[h][c]->GetStats(stats);
        Double_t sumw   = stats[0];
        Double_t sumw2  = stats[1];
        Double_t sumwx  = stats[4];
        Double_t sumwx2 = stats[5];
        if(sumw>0.) {
          SumTwo    += sumwx;
          SumWeig   += sumw;
          SumTwoSq  += sumwx2;
          SumWeigSq += sumw2;
          SumTwoCorr += sumwx;
        } // end of if(sumw>0.)

        if(SumWeig<=0) continue;

        Double_t CorrCorr = SumTwoCorr/SumWeig;
        Double_t Corr = SumTwo/SumWeig;
        Double_t SqCorr = SumTwoSq/SumWeig;
        Double_t Weig = SumWeig;
        Double_t SqWeig = SumWeigSq;
        Double_t spread=0., termA=0., termB=0.;
        if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
        if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
        if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
        Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

        // correct for NUA
        if(fNUAforCRC) {
          Double_t cosA = fCRC2NUAPro[h][c][0]->GetBinContent(eg);
          Double_t sinA = fCRC2NUAPro[h][c][1]->GetBinContent(eg);
          Double_t cosB = fCRC2NUAPro[h][c][2]->GetBinContent(eg);
          Double_t sinB = fCRC2NUAPro[h][c][3]->GetBinContent(eg);
          SumTwoCorr -= cosA*cosB + sinA*sinB;
        }
        // store final corr
        fCRC2CorHist[h][c][0]->SetBinContent(eg,CorrCorr);
        fCRC2CorHist[h][c][0]->SetBinError(eg,CorrErr);

        // temp for covariances
        fCRC2CorHist[h][c][1]->SetBinContent(eg,SumWeig);
        fCRC2CorHist[h][c][1]->SetBinError(eg,Corr);

        // store NUA
        for(Int_t n=0; n<4; n++) {
          Double_t NSumTwo=0., NSumWeig=0., NSumTwoSq=0., NSumWeigSq=0.;
          fCRC2NUAPro[h][c][n]->GetXaxis()->SetRange(eg,eg);
          fCRC2NUAPro[h][c][n]->GetStats(stats);
          if(stats[0]>0.) {
            NSumTwo    += stats[4];
            NSumWeig   += stats[0];
            NSumTwoSq  += stats[5];
            NSumWeigSq += stats[1];
          } // end of if(sumw>0.)
          if(NSumWeig<=0) continue;
          Double_t Corr = NSumTwo/NSumWeig;
          Double_t SqCorr = NSumTwoSq/NSumWeig;
          Double_t Weig = NSumWeig;
          Double_t SqWeig = NSumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          fCRC2NUAHist[h][c][n]->SetBinContent(eg,Corr);
          fCRC2NUAHist[h][c][n]->SetBinError(eg,CorrErr);
        } // end of for(Int_t n=0; n<4; n++)

        // add NUA error? (TBI)
        fCRC2CorPro[h][c]->GetXaxis()->SetRange(1,fCRC2nEtaBins);

      } // end of for(Int_t eg=1;eg<=fCRC2nEtaBins;eg++)
    } // end of for(Int_t c=0;c<fkNCorCRC2;c++)

    // calculate covariances
    Double_t stats[6]={0.};
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      for(Int_t c2=0;c2<fkNCorCRC2;c2++) {
        for(Int_t eg=1; eg<=fCRC2nEtaBins; eg++) {
          fCRC2CovPro[h][c][c2]->GetXaxis()->SetRange(eg,eg);
          fCRC2CovPro[h][c][c2]->GetStats(stats);
          Double_t WeigP = stats[0];
          Double_t CorrP = stats[4];
          Double_t Weig1 = fCRC2CorHist[h][c][1]->GetBinContent(eg);
          Double_t Weig2 = fCRC2CorHist[h][c2][1]->GetBinContent(eg);
          Double_t Corr1 = fCRC2CorHist[h][c][1]->GetBinError(eg);
          Double_t Corr2 = fCRC2CorHist[h][c2][1]->GetBinError(eg);
          if(WeigP>0.) { CorrP = CorrP/WeigP; }
          else continue;
          Double_t spread=0., termA=0., termB=0.;
          spread = CorrP-Corr1*Corr2;
          if((Weig1*Weig2)>0.) { termA = WeigP/(Weig1*Weig2); }
          if((1.-termA)>0.) { termB = 1./(1.-termA); }
          Double_t Cov = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          fCRC2CovHist[h][c][c2]->SetBinContent(eg,Cov);
          fCRC2CovHist[h][c][c2]->SetBinError(eg,0.);
          fCRC2CovPro[h][c][c2]->GetXaxis()->SetRange(1,fCRC2nEtaBins);
        } // end of for(Int_t eg=1;eg<=fCRC2nEtaBins;eg++)
      } // end of for(Int_t c2=0;c2<fkNCorCRC2;c2++)
    } // end of for(Int_t c=1;c<=fkNCorCRC2;c++)

    // set spectra
//    for(Int_t c=0;c<fkNCorCRC2;c++) {
//      for(Int_t eg=1; eg<=fCRC2nEtaBins; eg++) {
//        Double_t SumMul=0.;
//        Double_t stats[6]={0.};
//        for(Int_t r=0;r<fCRCnRun;r++) {
//          fCRC2NUAPro[h][c][0]->GetXaxis()->SetRange(eg,eg);
//          fCRC2NUAPro[h][c][0]->GetStats(stats);
//          if(stats[0]>0.) SumMul += stats[0];
//          fCRC2NUAPro[h][c][2]->GetXaxis()->SetRange(eg,eg);
//          fCRC2NUAPro[h][c][2]->GetStats(stats);
//          if(stats[0]>0.) SumMul += stats[0];
//        } // end of for(Int_t r=0;r<fCRCnRun;r++)
//        if(SumMul<=0) continue;
//        fCRC2CorHist[h][c][1]->SetBinContent(eg,SumMul);
//        fCRC2CorHist[h][c][1]->SetBinError(eg,0.);
//      } // end of for(Int_t eg=1;eg<=fCRC2nEtaBins;eg++)
//    } // end of for(Int_t c=0;c<fkNCorCRC2;c++)

    // calculate correlation functions

    for(Int_t eg=1;eg<=fCRC2nEtaBins;eg++) {
      Double_t CorP  = fCRC2CorHist[h][0][0]->GetBinContent(eg);
      Double_t CorPE = fCRC2CorHist[h][0][0]->GetBinError(eg);
      Double_t CorN  = fCRC2CorHist[h][1][0]->GetBinContent(eg);
      Double_t CorNE = fCRC2CorHist[h][1][0]->GetBinError(eg);
      Double_t CovPN = fCRC2CovHist[h][0][1]->GetBinContent(eg);
      Double_t CovPR = fCRC2CovHist[h][0][2]->GetBinContent(eg);
      Double_t CovNR = fCRC2CovHist[h][1][2]->GetBinContent(eg);
//      Double_t CorR  = fCRC2CorHist[h][2][0]->GetBinContent(eg);
//      Double_t CorRE = fCRC2CorHist[h][2][0]->GetBinError(eg);
      Double_t CorR  = (CorP+CorN)/2.;
      Double_t CorRE = sqrt(pow(CorPE,2.)+pow(CorNE,2.))/2.;

      Double_t CPos = (CorP) / (2.*pow(TMath::Abs(CorR),0.5));
      Double_t CPosE = pow( pow(CorPE/pow(TMath::Abs(CorR),0.5),2.)
                           + pow(CorRE*CorP/(2.*pow(TMath::Abs(CorR),1.5)),2.)
                           - 0.5*(CorP/pow(CorR,2.))*CovPR ,0.5)/2.;

      fCRC2CorHist[h][0][1]->SetBinContent(eg,CPos);
      fCRC2CorHist[h][0][1]->SetBinError(eg,CPosE);

      Double_t CNeg = (CorN) / (2.*pow(TMath::Abs(CorR),0.5));
      Double_t CNegE = pow( pow(CorNE/pow(TMath::Abs(CorR),0.5),2.)
                           + pow(CorRE*CorN/(2.*pow(TMath::Abs(CorR),1.5)),2.)
                           - 0.5*(CorN/pow(CorR,2.))*CovNR ,0.5)/2.;

      fCRC2CorHist[h][1][1]->SetBinContent(eg,CNeg);
      fCRC2CorHist[h][1][1]->SetBinError(eg,CNegE);

      Double_t CFun = (CorP-CorN) / (2.*pow(TMath::Abs(CorR),0.5));
      Double_t CFunE = pow( pow(CorPE/pow(TMath::Abs(CorR),0.5),2.)
                           + pow(CorNE/pow(TMath::Abs(CorR),0.5),2.)
                           + pow(CorRE*(CorP-CorN)/(2.*pow(TMath::Abs(CorR),1.5)),2.)
                           - 2.*CovPN/TMath::Abs(CorR),0.5)/2.;

      fCRC2CorHist[h][2][1]->SetBinContent(eg,CFun);
      fCRC2CorHist[h][2][1]->SetBinError(eg,CFunE);

      // calculate symmetric component

      if(CorR<0. && fCRC2CorHist[h][0][0]->GetXaxis()->GetBinCenter(eg)<0.) CFun *= -1.;
      fCRC2CorHist[h][3][1]->SetBinContent(eg,CFun);
      fCRC2CorHist[h][3][1]->SetBinError(eg,CFunE);

//      Int_t ec = fCRC2nEtaBins+1-eg;
//      Double_t CorPc  = fCRC2CorHist[h][0][0]->GetBinContent(ec);
//      Double_t CorPcE = fCRC2CorHist[h][0][0]->GetBinError(ec);
//      Double_t CorNc  = fCRC2CorHist[h][1][0]->GetBinContent(ec);
//      Double_t CorNcE = fCRC2CorHist[h][1][0]->GetBinError(ec);
//
//      Double_t CFunC = (CorP-CorN)*(CorPc-CorNc) / (4.*CorR);
//      if(CFunC>0.) CFunC = sqrt(CFunC);
//      else CFunC = -sqrt(fabs(CFunC));
//      Double_t CFunCE = CFunE; // TBI
//
//      fCRC2CorHist[h][3][1]->SetBinContent(eg,CFunC);
//      fCRC2CorHist[h][3][1]->SetBinError(eg,CFunCE);

    } // end of for(Int_t eg=1;eg<=fCRC2nEtaBins;eg++) {

  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  cout << "*************************************" << endl;
  cout << endl;

} // end of AliFlowAnalysisCRC::FinalizeCRC2Cor();

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCRCVZERO()
{
  // v1(eta)
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final CRC VZERO"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t j=0; j<fkNHistCRCVZ; j++) {

      for(Int_t c=1;c<=fCRCVZEROetaPro[h][j]->GetNbinsX();c++) {

        Double_t SumTwo=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0.;
        Double_t stats[6]={0.};

        fCRCVZEROetaPro[h][j]->GetXaxis()->SetRange(c,c);
        fCRCVZEROetaPro[h][j]->GetStats(stats);
        Double_t sumw   = stats[0];
        Double_t sumw2  = stats[1];
        Double_t sumwx  = stats[4];
        Double_t sumwx2 = stats[5];
        if(sumw>0.) {
          SumTwo    += sumwx;
          SumWeig   += sumw;
          SumTwoSq  += sumwx2;
          SumWeigSq += sumw2;
        } // end of if(sumw>0.)

        if(!SumWeig) continue;

        Double_t Corr = SumTwo/SumWeig;
        Double_t SqCorr = SumTwoSq/SumWeig;
        Double_t Weig = SumWeig;
        Double_t SqWeig = SumWeigSq;
        Double_t spread=0., termA=0., termB=0.;
        if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
        if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
        if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
        Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

        if(CorrErr>0.) {
          fCRCVZEROetaHist[h][j]->SetBinContent(c,Corr);
          fCRCVZEROetaHist[h][j]->SetBinError(c,CorrErr);
        }

      } // end of for(Int_t c=1;c<=fCRCVZEROetaPro[h][k][j]->GetNbinsX();c++)
    }
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {
      Double_t v1P = fCRCVZEROetaHist[h][0]->GetBinContent(eb+1);
      Double_t v1Per = fCRCVZEROetaHist[h][0]->GetBinError(eb+1);
      Double_t v1T = fCRCVZEROetaHist[h][1]->GetBinContent(eb+1);
      // Double_t v1Ter = fCRCVZEROetaHist[h][1]->GetBinError(eb+1);
      Double_t QAQB = fCRCVZEROetaHist[h][2]->GetBinContent(eb+1);

      //          Double_t QRe = fCRCVZEROetaHist[h][k][7]->GetBinContent(eb+1);
      //          Double_t QIm = fCRCVZEROetaHist[h][k][8]->GetBinContent(eb+1);
      //          Double_t ZARe = fCRCVZEROetaHist[h][k][13]->GetBinContent(eb+1);
      //          Double_t ZAIm = fCRCVZEROetaHist[h][k][14]->GetBinContent(eb+1);
      //          Double_t ZCRe = fCRCVZEROetaHist[h][k][15]->GetBinContent(eb+1);
      //          Double_t ZCIm = fCRCVZEROetaHist[h][k][16]->GetBinContent(eb+1);
      //
      //          if(fNUAforCRC) {
      //            v1P -= QRe*ZARe+QIm*ZAIm;
      //            v1T -= QRe*ZCRe+QIm*ZCIm;
      //          }

      Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
      Double_t v1odder = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][0]->SetBinContent(eb+1,v1odd);
      fCRCVZEROetaHist[h][0]->SetBinError(eb+1,v1odder);

      Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
      Double_t v1eveer = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][1]->SetBinContent(eb+1,v1eve);
      fCRCVZEROetaHist[h][1]->SetBinError(eb+1,v1eveer);

      //positive particles
      v1P = fCRCVZEROetaHist[h][3]->GetBinContent(eb+1);
      v1Per = fCRCVZEROetaHist[h][3]->GetBinError(eb+1);
      v1T = fCRCVZEROetaHist[h][4]->GetBinContent(eb+1);
      // v1Ter = fCRCVZEROetaHist[h][4]->GetBinError(eb+1);

      v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
      v1odder = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][2]->SetBinContent(eb+1,v1odd);
      fCRCVZEROetaHist[h][2]->SetBinError(eb+1,v1odder);

      v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
      v1eveer = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][3]->SetBinContent(eb+1,v1eve);
      fCRCVZEROetaHist[h][3]->SetBinError(eb+1,v1eveer);

      //negative particles
      v1P = fCRCVZEROetaHist[h][5]->GetBinContent(eb+1);
      v1Per = fCRCVZEROetaHist[h][5]->GetBinError(eb+1);
      v1T = fCRCVZEROetaHist[h][6]->GetBinContent(eb+1);
      // v1Ter = fCRCVZEROetaHist[h][6]->GetBinError(eb+1);

      v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
      v1odder = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][4]->SetBinContent(eb+1,v1odd);
      fCRCVZEROetaHist[h][4]->SetBinError(eb+1,v1odder);

      v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
      v1eveer = v1Per/(sqrt(fabs(QAQB))*2.); // TBI
      fCRCVZEROetaHist[h][5]->SetBinContent(eb+1,v1eve);
      fCRCVZEROetaHist[h][5]->SetBinError(eb+1,v1eveer);

    }
  }
} // end of void AliFlowAnalysisCRC::FinalizeCRCVZERO()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCRCZDC()
{
  // calculate final 2- and 4-p products of correlations

  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final ZDC correlations"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {
      for(Int_t i=0;i<2;i++) {

        for(Int_t c=1;c<=10;c++) {

          Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0., NPart=0.;
          Double_t stats[6]={0.};

          for(Int_t r=0;r<fCRCnRun;r++) {
            fCRCZDCCorrPro[r][i][eg][h]->GetXaxis()->SetRange(c,c);
            fCRCZDCCorrPro[r][i][eg][h]->GetStats(stats);
            Double_t sumw   = stats[0];
            Double_t sumw2  = stats[1];
            Double_t sumwx  = stats[4];
            Double_t sumwx2 = stats[5];
            fCRCZDCNUAPro[r][0][eg][h]->GetXaxis()->SetRange(c,c);
            fCRCZDCNUAPro[r][0][eg][h]->GetStats(stats);
            Double_t ReCount = stats[0];
            fCRCZDCNUAPro[r][0][eg][h]->GetXaxis()->SetRange(0,fCRCZDCnEtaBin);
            if(sumw>0.) {
              SumTwo    += sumwx;
              SumWeig   += sumw;
              SumTwoSq  += sumwx2;
              SumWeigSq += sumw2;
              NPart += ReCount;
              if(fNUAforCRC) {
                Int_t NUAbin[2] = {0,0};
                if (i==0) { NUAbin[0] = 0; NUAbin[1] = 1; }
                else      { NUAbin[0] = 2; NUAbin[1] = 3; }
                Double_t NA = fCRCZDCNUAPro[r][NUAbin[0]][eg][h]->GetBinContent(c);
                Double_t NB = fCRCZDCNUAPro[r][NUAbin[1]][eg][h]->GetBinContent(c);
                Double_t TwoCorr = (sumwx/sumw - NA*NB)*sumw;
                SumTwoCorr += TwoCorr;
              } else {
                SumTwoCorr += sumwx;
              }
            } // end of if(sumw>0.)
          } // end of for(Int_t r=0;r<fCRCnRun;r++)

          if(!SumWeig) continue;

          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

          Double_t CorrCorr = SumTwoCorr/SumWeig;
          fCRCZDCCorrHist[i][eg][h]->SetBinContent(c,CorrCorr);
          fCRCZDCCorrHist[i][eg][h]->SetBinError(c,CorrErr);

          fCRCZDCCorrProdTempHist[0][eg][h]->SetBinContent(c,Corr);
          fCRCZDCCorrProdTempHist[1][eg][h]->SetBinContent(c,SumWeig);

          if(c==1) {fCRCZDCCorrHist[i][eg][h]->SetBinContent(11,NPart);}
          if(c==2) {fCRCZDCCorrHist[i][eg][h]->SetBinContent(12,NPart);}

        } // end of for(Int_t c=1;c<=10;c++)

        // calculate covariances
        Int_t ce = 0;
        for(Int_t c=0;c<fCRCZDCnCR;c++) {
          for(Int_t c2=0;c2<fCRCZDCnCR;c2++) {

            Double_t SumTwo=0., SumWeig=0., CorrProd=0.;
            Double_t stats[6]={0.};

            for(Int_t r=0;r<fCRCnRun;r++) {
              fCRCZDCCorrProd2p2pHist[r][i][eg][h]->GetXaxis()->SetRange(ce+1,ce+1);
              fCRCZDCCorrProd2p2pHist[r][i][eg][h]->GetStats(stats);
              if(stats[0]>0.) {
                SumTwo    += stats[4];
                SumWeig   += stats[0];
              }
            } // end of for(Int_t r=0;r<fCRCnRun;r++)

            Double_t Corr1 = fCRCZDCCorrProdTempHist[0][eg][h]->GetBinContent(c+1);
            Double_t Corr2 = fCRCZDCCorrProdTempHist[0][eg][h]->GetBinContent(c2+1);
            Double_t Weig1 = fCRCZDCCorrProdTempHist[1][eg][h]->GetBinContent(c+1);
            Double_t Weig2 = fCRCZDCCorrProdTempHist[1][eg][h]->GetBinContent(c2+1);
            Double_t WeigProd = SumWeig;
            if(SumWeig>0.) { CorrProd = SumTwo/SumWeig; }
            else { CorrProd = 0.; }
            Double_t spread=0., termA=0., termB=0.;
            spread = CorrProd-Corr1*Corr2;
            if((Weig1*Weig2)>0.) { termA = WeigProd/(Weig1*Weig2); }
            if((1.-termA)>0.) { termB = 1./(1.-termA); }
            Double_t Cov = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            fCRCZDCCovHist[i][eg][h]->SetBinContent(c+1,c2+1,Cov);
            ce++;

          } // end of for(Int_t c2=0;c2<4;c2++)
        } // end of for(Int_t c=1;c<=4;c++)

      } // end of for(Int_t i=0;i<2;i++)
    } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)
  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)

  // calculate correlation functions

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {

      Double_t CFun=0., CFunErr=0.;

      for(Int_t i=0;i<2;i++) {

        Double_t VCVA    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(5);
        Double_t VCVAErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(5);
        //    Double_t QVC    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(6);
        //    Double_t QVCErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(6);
        //    Double_t QVA    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(7);
        //    Double_t QVAErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(7);

        Double_t qPVC    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(1);
        Double_t qPVCErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(1);
        Double_t qNVC    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(2);
        Double_t qNVCErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(2);
        Double_t qPVA    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(3);
        Double_t qPVAErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(3);
        Double_t qNVA    = fCRCZDCCorrHist[i][eg][h]->GetBinContent(4);
        Double_t qNVAErr = fCRCZDCCorrHist[i][eg][h]->GetBinError(4);

        if (VCVA != 0.) {
          Double_t OddqPV = pow(2.,0.5) * (qPVA-qPVC) / pow(TMath::Abs(VCVA),0.5);
          Double_t OddqPVErr = pow(qPVAErr/pow(TMath::Abs(VCVA),0.5),2.)
          + pow(qPVCErr/pow(TMath::Abs(VCVA),0.5),2.)
          + pow(VCVAErr*(qPVA-qPVC)/(2.*pow(TMath::Abs(VCVA),1.5)),2.)
          - 2.*fCRCZDCCovHist[i][eg][h]->GetBinContent(1,3)/TMath::Abs(VCVA);
          if(OddqPVErr>0.) OddqPVErr = pow(OddqPVErr,0.5) * pow(2.,0.5);
          else             OddqPVErr = 0.;

          Double_t OddqNV = pow(2.,0.5) * (qNVA-qNVC) / pow(TMath::Abs(VCVA),0.5);
          Double_t OddqNVErr = pow(qNVAErr/pow(TMath::Abs(VCVA),0.5),2.)
          + pow(qNVCErr/pow(TMath::Abs(VCVA),0.5),2.)
          + pow(VCVAErr*(qNVA-qNVC)/(2.*pow(TMath::Abs(VCVA),1.5)),2.)
          - 2.*fCRCZDCCovHist[i][eg][h]->GetBinContent(2,4)/TMath::Abs(VCVA);
          if(OddqNVErr>0.) OddqNVErr = pow(OddqNVErr,0.5) * pow(2.,0.5);
          else             OddqNVErr = 0.;

          fCRCZDCCFunHist[eg][h]->SetBinContent(i+1,OddqPV);
          fCRCZDCCFunHist[eg][h]->SetBinError(i+1,OddqPVErr);
          fCRCZDCCFunHist[eg][h]->SetBinContent(i+3,OddqNV);
          fCRCZDCCFunHist[eg][h]->SetBinError(i+3,OddqNVErr);
        }

      } // end of for(Int_t i=0;i<2;i++)

      CFun = (fCRCZDCCFunHist[eg][h]->GetBinContent(1)+fCRCZDCCFunHist[eg][h]->GetBinContent(2))/4.;
      CFunErr = pow(fCRCZDCCFunHist[eg][h]->GetBinError(1),2.)+pow(fCRCZDCCFunHist[eg][h]->GetBinError(2),2.);
      if(CFunErr>0.) CFunErr = pow(CFunErr,0.5)/4.;
      else           CFunErr = 0.;
      cout << "CFUN-P["<<eg<<"]["<<h<<"]: " << CFun << " " << CFunErr << endl;
      fCRCZDCCFunHist[eg][h]->SetBinContent(5,CFun);
      fCRCZDCCFunHist[eg][h]->SetBinError(5,CFunErr);

      CFun = (fCRCZDCCFunHist[eg][h]->GetBinContent(3)+fCRCZDCCFunHist[eg][h]->GetBinContent(4))/4.;
      CFunErr = pow(fCRCZDCCFunHist[eg][h]->GetBinError(3),2.)+pow(fCRCZDCCFunHist[eg][h]->GetBinError(4),2.);
      if(CFunErr>0.) CFunErr = pow(CFunErr,0.5)/4.;
      else           CFunErr = 0.;
      cout << "CFUN-N["<<eg<<"]["<<h<<"]: " << CFun << " " << CFunErr << endl;
      fCRCZDCCFunHist[eg][h]->SetBinContent(6,CFun);
      fCRCZDCCFunHist[eg][h]->SetBinError(6,CFunErr);

    } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)
  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)

  cout << "*************************************" << endl;
  cout << endl;
} // end of void AliFlowAnalysisCRC::FinalizeCRCZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCRCCorr()
{
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final 2-p correlations"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;
  Double_t stats[6]={0.};

  for(Int_t k=0;k<fCRCnCorr;k++) {
    for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        for(Int_t c=1;c<=fCRCnCR;c++) {

          Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0., SumMul=0., SumEv=0.;

          for(Int_t r=0;r<fCRCnRun;r++) {
            fCRCCorrPro[r][k][eg][h]->GetXaxis()->SetRange(c,c);
            fCRCCorrPro[r][k][eg][h]->GetStats(stats);
            Double_t sumw   = stats[0];
            Double_t sumw2  = stats[1];
            Double_t sumwx  = stats[4];
            Double_t sumwx2 = stats[5];
            Double_t cosA = fCRCNUATermsPro[r][0][eg][h]->GetBinContent(c);
            Double_t cosB = fCRCNUATermsPro[r][1][eg][h]->GetBinContent(c);
            Double_t sinA = fCRCNUATermsPro[r][2][eg][h]->GetBinContent(c);
            Double_t sinB = fCRCNUATermsPro[r][3][eg][h]->GetBinContent(c);
            Double_t cosVZC = fCRCNUATermsPro[r][0][eg][h]->GetBinContent(fCRCnCR+1);
            Double_t cosVZA = fCRCNUATermsPro[r][1][eg][h]->GetBinContent(fCRCnCR+1);
            Double_t sinVZC = fCRCNUATermsPro[r][2][eg][h]->GetBinContent(fCRCnCR+1);
            Double_t sinVZA = fCRCNUATermsPro[r][3][eg][h]->GetBinContent(fCRCnCR+1);
            if(sumw>0.) {
              SumTwo    += sumwx;
              SumWeig   += sumw;
              SumTwoSq  += sumwx2;
              SumWeigSq += sumw2;
              SumMul    += fCRCSumWeigHist[r][0][eg][h]->GetBinContent(c);
              SumEv     += fCRCSumWeigHist[r][1][eg][h]->GetBinContent(c);
              if(fNUAforCRC) {
                Double_t NUACor = 0.;
                if(k==0) NUACor = cosA*cosB + sinA*sinB;
                if(k==1) {
                  NUACor = (cosA*cosB - sinA*sinB)*cosVZC + (cosA*sinB+sinA*cosB)*sinVZC; // TBI
                }
                if(k==2) {
                  NUACor = (cosA*cosB - sinA*sinB)*cosVZA + (cosA*sinB+sinA*cosB)*sinVZA; // TBI
                }
                Double_t TwoCorr = (sumwx/sumw - NUACor)*sumw;
                SumTwoCorr += TwoCorr;
              } else {
                SumTwoCorr += sumwx;
              }
            } // end of if(sumw>0.)
            fCRCCorrPro[r][k][eg][h]->GetXaxis()->SetRange(0.,fCRCnCR);
          } // end of for(Int_t r=0;r<fCRCnRun;r++)

          if(SumWeig<=0) continue;

          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          else { cout<<" WARNING: Imaginary 'spread' for Corr !!!"<<endl; }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

          Double_t CorrCorr = SumTwoCorr/SumWeig;
          fCRCCorrHist[k][eg][h]->SetBinContent(c,CorrCorr);
          fCRCCorrHist[k][eg][h]->SetBinError(c,CorrErr);

          fCRCCorrProdTempHist[0][0][0]->SetBinContent(c,Corr);
          fCRCCorrProdTempHist[1][0][0]->SetBinContent(c,SumWeig);
          fCRCCumHist[k][eg][h]->SetBinContent(c,SumMul);
          fCRCCumHist[k][eg][h]->SetBinError(c,SumEv);

        } // end of for(Int_t c=1;c<=fCRCnCR;c++)

        // calculate covariances
        for(Int_t c=1;c<=fCRCnCR;c++) {
          for(Int_t c2=1;c2<=fCRCnCR;c2++) {
            Double_t Corr1 = fCRCCorrProdTempHist[0][0][0]->GetBinContent(c);
            Double_t Corr2 = fCRCCorrProdTempHist[0][0][0]->GetBinContent(c2);
            Double_t Weig1 = fCRCCorrProdTempHist[1][0][0]->GetBinContent(c);
            Double_t Weig2 = fCRCCorrProdTempHist[1][0][0]->GetBinContent(c2);

            Int_t CRCBin2 = (c-1)*fCRCnCR+c2;
            fCRCCorrProd2p2pPro[k][eg][h]->GetXaxis()->SetRange(CRCBin2,CRCBin2);
            fCRCCorrProd2p2pPro[k][eg][h]->GetStats(stats);
            Double_t WeigProd   = stats[0];
            Double_t CorrProd  = stats[4];

            if(WeigProd>0.) {
              CorrProd = CorrProd/WeigProd;
              Double_t spread=0., termA=0., termB=0.;
              spread = CorrProd-Corr1*Corr2;
              if((Weig1*Weig2)>0.) { termA = WeigProd/(Weig1*Weig2); }
              if((1.-termA)>0.) { termB = 1./(1.-termA); }
              Double_t Cov = termA*spread*termB; // final covariance
              fCRCCovHist[k][eg][h]->SetBinContent(CRCBin2,Cov);
            } else {
              fCRCCovHist[k][eg][h]->SetBinContent(CRCBin2,0.);
            }
          } // end of for(Int_t c2=0;c2<fCRCnCR;c2++)
        } // end of for(Int_t c=1;c<=fCRCnCR;c++)
        fCRCCorrProd2p2pPro[k][eg][h]->GetXaxis()->SetRange(0.,fCRCnCR*fCRCnCR);
      } // end of for(Int_t k=0;k<fCRCnCorr;k++)
    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  // calculate correlation functions

  for(Int_t k=0;k<3;k++) {
    for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {

        Double_t AvCFun=0.,AvCFunErr=0.;
        Int_t CFunBin = 1;
        for(Int_t c=0;c<2;c++) {
          for(Int_t y=0;y<2;y++) {

            Int_t pc = ( c==0 ? 1 : 0);
            Int_t py = ( y==0 ? 1 : 0);
            Int_t CRCBin1 = GetCRCBin(c,y,c,y);
            Int_t CRCBin2 = GetCRCBin(c,y,pc,y);
            Int_t CRCBin3 = GetCRCBin(c,y,c,py);
            Int_t CRCBin4 = GetCRCBin(c,y,pc,py);

            Double_t Corr1    = fCRCCorrHist[k][eg][h]->GetBinContent(CRCBin1);
            Double_t Corr1Err = fCRCCorrHist[k][eg][h]->GetBinError(CRCBin1);
            Double_t Corr2    = fCRCCorrHist[k][eg][h]->GetBinContent(CRCBin2);
            Double_t Corr2Err = fCRCCorrHist[k][eg][h]->GetBinError(CRCBin2);
            Double_t Corr3    = fCRCCorrHist[k][eg][h]->GetBinContent(CRCBin3);
            Double_t Corr3Err = fCRCCorrHist[k][eg][h]->GetBinError(CRCBin3);
            Double_t Corr4    = fCRCCorrHist[k][eg][h]->GetBinContent(CRCBin4);
            Double_t Corr4Err = fCRCCorrHist[k][eg][h]->GetBinError(CRCBin4);

            Double_t Cov12 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin1-1)*fCRCnCR+CRCBin2);
            Double_t Cov13 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin1-1)*fCRCnCR+CRCBin3);
            Double_t Cov14 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin1-1)*fCRCnCR+CRCBin4);
            Double_t Cov23 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin2-1)*fCRCnCR+CRCBin3);
            Double_t Cov24 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin2-1)*fCRCnCR+CRCBin4);
            Double_t Cov34 = fCRCCovHist[k][eg][h]->GetBinContent((CRCBin3-1)*fCRCnCR+CRCBin4);

            Double_t VAVC = fCRCCorrHist[3][eg][h]->GetBinContent(1);
            Double_t QVA = fCRCCorrHist[3][eg][h]->GetBinContent(2);
            Double_t QVC = fCRCCorrHist[3][eg][h]->GetBinContent(3);

            Double_t CFun = Corr1 - Corr2 - Corr3 + Corr4;
            Double_t CFunErr = pow(Corr1Err,2.) + pow(Corr2Err,2.) + pow(Corr3Err,2.) + pow(Corr4Err,2.)
            + 2*(-Cov12-Cov13+Cov14+Cov23-Cov24-Cov34) ;
            if(CFunErr >= 0.) CFunErr = pow(CFunErr,0.5);
            else CFunErr=0.;

            if(k==0) {
              fCRCCFunHist[eg][h]->SetBinContent(CFunBin,CFun);
              fCRCCFunHist[eg][h]->SetBinError(CFunBin,CFunErr);
            }
            if(k==1) {
              Double_t ResCor = QVC*VAVC/QVA;
              CFun /= sqrt(fabs(ResCor));
              CFunErr /= sqrt(fabs(ResCor));
            }
            if(k==2) {
              Double_t ResCor = QVA*VAVC/QVC;
              CFun /= sqrt(fabs(ResCor));
              CFunErr /= sqrt(fabs(ResCor));
            }
            AvCFun += CFun;
            AvCFunErr += pow(CFunErr,2.);

            CFunBin++;

          } // end of for(Int_t y=0;y<2;y++)
        } // end of for(Int_t c=0;c<2;c++)

        if(AvCFunErr>0. && k<2) {
          printf("k %d : cfun[%d][%d]: %e %e \n",k,eg,h,AvCFun/16.,pow(AvCFunErr,0.5)/16.);
        }

      } // end of for(Int_t k=0;k<fCRCnCorr;k++)
    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  cout << "*************************************" << endl;
  cout << endl;

} // end of void AliFlowAnalysisCRC::FinalizeCRCCorr()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCMETPC()
{
  // calculate final 2- and 4-p products of correlations

  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final CME TPC only"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    for (Int_t h=0; h<fCMETPCnHist; h++) {
      for(Int_t c=1;c<=fCMETPCCorPro[k][h]->GetNbinsX();c++) {

        Double_t SumTwo=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0.;
        Double_t stats[6]={0.};

        fCMETPCCorPro[k][h]->GetXaxis()->SetRange(c,c);
        fCMETPCCorPro[k][h]->GetStats(stats);
        Double_t sumw   = stats[0];
        Double_t sumw2  = stats[1];
        Double_t sumwx  = stats[4];
        Double_t sumwx2 = stats[5];
        if(sumw>0.) {
          SumTwo    += sumwx;
          SumWeig   += sumw;
          SumTwoSq  += sumwx2;
          SumWeigSq += sumw2;
        } // end of if(sumw>0.)

        if(!SumWeig) continue;

        Double_t Corr = SumTwo/SumWeig;
        Double_t SqCorr = SumTwoSq/SumWeig;
        Double_t Weig = SumWeig;
        Double_t SqWeig = SumWeigSq;
        Double_t spread=0., termA=0., termB=0.;
        if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
        if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
        if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
        Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

        if(CorrErr>0.) {
          fCMETPCCorHist[k][h]->SetBinContent(c,Corr);
          fCMETPCCorHist[k][h]->SetBinError(c,CorrErr);
        }

      } // end of for(Int_t c=1;c<=fCMEnCR;c++)
    } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)

    // calculate correlation functions

    for(Int_t c=1;c<=fCMETPCCorHist[k][0]->GetNbinsX();c++) {

      // Delta
      Double_t QPQN   = fCMETPCCorHist[k][0]->GetBinContent(c);
      Double_t QPQNer = fCMETPCCorHist[k][0]->GetBinError(c);

      Double_t QPQP   = fCMETPCCorHist[k][1]->GetBinContent(c);
      Double_t QPQPer = fCMETPCCorHist[k][1]->GetBinError(c);

      Double_t QNQN   = fCMETPCCorHist[k][2]->GetBinContent(c);
      Double_t QNQNer = fCMETPCCorHist[k][2]->GetBinError(c);

      //NUA
      Double_t QPRe = fCMETPCCorHist[k][15]->GetBinContent(c);
      Double_t QPIm = fCMETPCCorHist[k][16]->GetBinContent(c);
      Double_t QNRe = fCMETPCCorHist[k][17]->GetBinContent(c);
      Double_t QNIm = fCMETPCCorHist[k][18]->GetBinContent(c);

      // Gamma
      Double_t QPQNGC   = fCMETPCCorHist[k][3]->GetBinContent(c);
      Double_t QPQNGCer = fCMETPCCorHist[k][3]->GetBinError(c);

      Double_t QPQPGC   = fCMETPCCorHist[k][4]->GetBinContent(c);
      Double_t QPQPGCer = fCMETPCCorHist[k][4]->GetBinError(c);

      Double_t QNQNGC   = fCMETPCCorHist[k][5]->GetBinContent(c);
      // Double_t QNQNGCer = fCMETPCCorHist[k][5]->GetBinError(c);

      Double_t QPQNGA   = fCMETPCCorHist[k][6]->GetBinContent(c);
      Double_t QPQNGAer = fCMETPCCorHist[k][6]->GetBinError(c);

      Double_t QPQPGA   = fCMETPCCorHist[k][7]->GetBinContent(c);
      Double_t QPQPGAer = fCMETPCCorHist[k][7]->GetBinError(c);

      Double_t QNQNGA   = fCMETPCCorHist[k][8]->GetBinContent(c);
      // Double_t QNQNGAer = fCMETPCCorHist[k][8]->GetBinError(c);

      Double_t ResVAVC   = fCMETPCCorHist[k][9]->GetBinContent(c);
      Double_t ResVAVCer = fCMETPCCorHist[k][9]->GetBinError(c);
      Double_t ResTPVC   = fCMETPCCorHist[k][10]->GetBinContent(c);
      Double_t ResTPVCer = fCMETPCCorHist[k][10]->GetBinError(c);
      Double_t ResTPVA   = fCMETPCCorHist[k][11]->GetBinContent(c);
      Double_t ResTPVAer = fCMETPCCorHist[k][11]->GetBinError(c);

      Double_t C2   = fCMETPCCorHist[k][14]->GetBinContent(c);
      Double_t C2er = fCMETPCCorHist[k][14]->GetBinError(c);

      if(ResVAVC>0.) {
        Double_t DeltaOp = QPQN;
        Double_t DeltaOper = QPQNer;
        fCMETPCFinalHist[k][0]->SetBinContent(c,DeltaOp);
        fCMETPCFinalHist[k][0]->SetBinError(c,DeltaOper);
        // NUA corrected
        fCMETPCFinalHist[k][10]->SetBinContent(c,DeltaOp-(QPRe*QNRe+QPIm*QNIm));
        fCMETPCFinalHist[k][10]->SetBinError(c,DeltaOper);

        Double_t DeltaSa = (QPQP+QNQN)/2.;
        Double_t DeltaSaer = pow(pow(QPQPer,2.)+pow(QNQNer,2.),0.5)/2.;
        fCMETPCFinalHist[k][1]->SetBinContent(c,DeltaSa);
        fCMETPCFinalHist[k][1]->SetBinError(c,DeltaSaer);
        // NUA corrected
        fCMETPCFinalHist[k][11]->SetBinContent(c,DeltaSa-(QPRe*QPRe+QPIm*QPIm+QNRe*QNRe+QNIm*QNIm)/2.);
        fCMETPCFinalHist[k][11]->SetBinError(c,DeltaSaer);

        Double_t Res = fabs(ResVAVC*ResTPVC/ResTPVA);
        Double_t Reser = sqrt( pow(ResVAVCer*ResTPVC/ResTPVA,2.)+pow(ResTPVCer*ResVAVC/ResTPVA,2.)+pow(ResTPVAer*ResVAVC*ResTPVC/(ResTPVA*ResTPVA),2.) );
        fCMETPCFinalHist[k][8]->SetBinContent(c,Res);
        fCMETPCFinalHist[k][8]->SetBinError(c,Reser);

        Double_t GammaOpC = QPQNGC/sqrt(Res);
        Double_t GammaOpCer = pow(QPQNGCer/(2.*sqrt(Res)),2.) + pow(QPQNGC*Reser/(2.*pow(Res,1.5)),2.);
        GammaOpCer = pow(GammaOpCer,0.5);
        //      printf(" gamma, oppo ch.: %e, %e \n",GammaOp,GammaOper);
        fCMETPCFinalHist[k][2]->SetBinContent(c,GammaOpC);
        fCMETPCFinalHist[k][2]->SetBinError(c,GammaOpCer);

        Double_t GammaSaC = (QPQPGC+QNQNGC)/(2.*sqrt(Res));
        Double_t GammaSaCer = pow(QPQPGCer/(2.*sqrt(Res)),2.) + pow(QPQPGC*Reser/(2.*pow(Res,1.5)),2.);
        GammaSaCer = pow(GammaSaCer,0.5)/2.;
        //      printf(" gamma, same ch.: %e, %e \n",GammaSa,GammaSaer);
        fCMETPCFinalHist[k][3]->SetBinContent(c,GammaSaC);
        fCMETPCFinalHist[k][3]->SetBinError(c,GammaSaCer);

        Res = fabs(ResVAVC*ResTPVA/ResTPVC);
        fCMETPCFinalHist[k][9]->SetBinContent(c,Res);
        fCMETPCFinalHist[k][9]->SetBinError(c,Reser);

        Double_t GammaOpA = QPQNGA/sqrt(Res);
        Double_t GammaOpAer = pow(QPQNGAer/(2.*sqrt(Res)),2.) + pow(QPQNGA*Reser/(2.*pow(Res,1.5)),2.);
        GammaOpAer = pow(GammaOpAer,0.5);
        //      printf(" gamma, oppo ch.: %e, %e \n",GammaOp,GammaOper);
        fCMETPCFinalHist[k][4]->SetBinContent(c,GammaOpA);
        fCMETPCFinalHist[k][4]->SetBinError(c,GammaOpAer);

        Double_t GammaSaA = (QPQPGA+QNQNGA)/(2.*sqrt(Res));
        Double_t GammaSaAer = pow(QPQPGAer/(2.*sqrt(Res)),2.) + pow(QPQPGA*Reser/(2.*pow(Res,1.5)),2.);
        GammaSaAer = pow(GammaSaAer,0.5)/2.;
        //      printf(" gamma, same ch.: %e, %e \n",GammaSa,GammaSaer);
        fCMETPCFinalHist[k][5]->SetBinContent(c,GammaSaA);
        fCMETPCFinalHist[k][5]->SetBinError(c,GammaSaAer);

        // opp - same

        Double_t GammaDiff = (GammaOpC+GammaOpA-GammaSaC-GammaSaA)/2.;
        Double_t GammaDiffer = sqrt(pow(GammaOpCer,2.)+pow(GammaOpAer,2.)+pow(GammaSaCer,2.)+pow(GammaSaAer,2.))/2.;
        fCMETPCFinalHist[k][6]->SetBinContent(c,GammaDiff);
        fCMETPCFinalHist[k][6]->SetBinError(c,GammaDiffer);

        if(C2>0.) {
          Double_t Flow = sqrt(C2);
          Double_t Flower = fabs(Flow/(2.*C2))*C2er;
          fCMETPCFinalHist[k][7]->SetBinContent(c,Flow);
          fCMETPCFinalHist[k][7]->SetBinError(c,Flower);
        }

      }

    } // end of for(Int_t c=1;c<=fCMETPCCorPro->GetNbinsX();c++)

  }

} // end of void AliFlowAnalysisCRC::FinalizeCMETPC()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCMEZDC()
{
  // calculate final 2- and 4-p products of correlations

  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating final CME TPC-ZDCs"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {

      for(Int_t c=1;c<=fCMEZDCnCR;c++) {

        Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0.;
        Double_t stats[6]={0.};

        fCMEZDCCorPro[eg][h]->GetXaxis()->SetRange(c,c);
        fCMEZDCCorPro[eg][h]->GetStats(stats);
        Double_t sumw   = stats[0];
        Double_t sumw2  = stats[1];
        Double_t sumwx  = stats[4];
        Double_t sumwx2 = stats[5];
        if(sumw>0.) {
          SumTwo    += sumwx;
          SumWeig   += sumw;
          SumTwoSq  += sumwx2;
          SumWeigSq += sumw2;
          SumTwoCorr += sumwx;
        } // end of if(sumw>0.)

        if(!SumWeig) continue;

        Double_t Corr = SumTwo/SumWeig;
        Double_t SqCorr = SumTwoSq/SumWeig;
        Double_t Weig = SumWeig;
        Double_t SqWeig = SumWeigSq;
        Double_t spread=0., termA=0., termB=0.;
        if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
        if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
        if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
        Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

        Double_t CorrCorr = SumTwoCorr/SumWeig;
        fCMEZDCCorHist[eg][h]->SetBinContent(c,CorrCorr);
        fCMEZDCCorHist[eg][h]->SetBinError(c,CorrErr);

        // do NOT overwrite fCRCCorrProdTempHist, temporarily covariances disabled
        //    fCRCCorrProdTempHist[0][0][0]->SetBinContent(c,Corr);
        //    fCRCCorrProdTempHist[1][0][0]->SetBinContent(c,SumWeig);

      } // end of for(Int_t c=1;c<=fCMEnCR;c++)

    } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)
  } // end of for (Int_t h=0;h<fCRCZDCnCen;h++)

  // Double_t QPQNG[2]={0.}, QPQNGer[2]={0.}, QPQPG[2]={0.}, QPQPGer[2]={0.}, QNQNG[2]={0.}, QNQNGer[2]={0.};
  // Double_t QDG[2]={0.}, QDGer[2]={0.}, QRG[2]={0.}, QRGer[2]={0.};

  // calculate correlation functions

  // for (Int_t h=0; h<fCRCnCen; h++) {
  //   for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {
  //
  //     // ZDC-C Gamma
  //     QPQNG[0]   = fCMEZDCCorHist[eg][h]->GetBinContent(1);
  //     QPQNGer[0] = fCMEZDCCorHist[eg][h]->GetBinError(1);
  //
  //     QPQPG[0]   = fCMEZDCCorHist[eg][h]->GetBinContent(2);
  //     QPQPGer[0] = fCMEZDCCorHist[eg][h]->GetBinError(2);
  //
  //     QNQNG[0]   = fCMEZDCCorHist[eg][h]->GetBinContent(3);
  //     QNQNGer[0] = fCMEZDCCorHist[eg][h]->GetBinError(3);
  //
  //     // ZDC-C Gamma dipole
  //     QDG[0]   = fCMEZDCCorHist[eg][h]->GetBinContent(4);
  //     QDGer[0] = fCMEZDCCorHist[eg][h]->GetBinError(4);
  //
  //     QRG[0]   = fCMEZDCCorHist[eg][h]->GetBinContent(5);
  //     QRGer[0] = fCMEZDCCorHist[eg][h]->GetBinError(5);
  //
  //     // ZDC-A Gamma
  //     QPQNG[1]   = fCMEZDCCorHist[eg][h]->GetBinContent(6);
  //     QPQNGer[1] = fCMEZDCCorHist[eg][h]->GetBinError(6);
  //
  //     QPQPG[1]   = fCMEZDCCorHist[eg][h]->GetBinContent(7);
  //     QPQPGer[1] = fCMEZDCCorHist[eg][h]->GetBinError(7);
  //
  //     QNQNG[1]   = fCMEZDCCorHist[eg][h]->GetBinContent(8);
  //     QNQNGer[1] = fCMEZDCCorHist[eg][h]->GetBinError(8);
  //
  //     // ZDC-A Gamma dipole
  //     QDG[1]   = fCMEZDCCorHist[eg][h]->GetBinContent(9);
  //     QDGer[1] = fCMEZDCCorHist[eg][h]->GetBinError(9);
  //
  //     QRG[1]   = fCMEZDCCorHist[eg][h]->GetBinContent(10);
  //     QRGer[1] = fCMEZDCCorHist[eg][h]->GetBinError(10);
  //
  //     // Resolution correction
  //     Double_t VAVC   = fCMEZDCCorHist[eg][h]->GetBinContent(11);
  //     Double_t VAVCer = fCMEZDCCorHist[eg][h]->GetBinError(11);
  //
  //     Double_t VAVT   = fCMEZDCCorHist[eg][h]->GetBinContent(12);
  //     Double_t VAVTer = fCMEZDCCorHist[eg][h]->GetBinError(12);
  //
  //     Double_t VCVT   = fCMEZDCCorHist[eg][h]->GetBinContent(13);
  //     Double_t VCVTer = fCMEZDCCorHist[eg][h]->GetBinError(13);
  //
  //     for (Int_t z=0; z<2; z++) {
  //
  //       Double_t V2=0., V2er=0.;
  //       if(z==0) {
  //         V2   = (VAVC*VCVT)/VAVT;
  //         V2er = pow(VAVCer*VCVT/VAVT,2.) + pow(VAVC*VCVTer/VAVT,2.) + pow(VAVC*VCVT*VAVTer/pow(VAVT,2.),2.);
  //       } else {
  //         V2   = (VAVC*VAVT)/VCVT;
  //         V2er = pow(VAVCer*VAVT/VCVT,2.) + pow(VAVC*VAVTer/VCVT,2.) + pow(VAVC*VAVT*VCVTer/pow(VCVT,2.),2.);
  //       }
  //
  //       if(!V2) continue;
  //
  //       Double_t GammaOp = QPQNG[z]/pow(TMath::Abs(V2),0.5);
  //       Double_t GammaOper = pow(QPQNGer[z]/pow(TMath::Abs(V2),0.5),2.) + pow(QPQNG[z]*V2er/(2.*pow(TMath::Abs(V2),1.5)),2.);
  //       GammaOper = pow(GammaOper,0.5);
  //       //        printf(" gamma, oppo ch.: %e, %e \n",GammaOp,GammaOper);
  //       Double_t GammaSa = (QPQPG[z]+QNQNG[z])/(2.*pow(TMath::Abs(V2),0.5));
  //       Double_t GammaSaer = pow(QPQPGer[z]/pow(TMath::Abs(V2),0.5),2.) + pow(QPQPG[z]*V2er/(2.*pow(TMath::Abs(V2),1.5)),2.)
  //       + pow(QNQNGer[z]/pow(TMath::Abs(V2),0.5),2.) + pow(QNQNG[z]*V2er/(2.*pow(TMath::Abs(V2),1.5)),2.);
  //       GammaSaer = pow(GammaSaer,0.5)/2.;
  //       //        printf(" gamma, same ch.: %e, %e \n",GammaSa,GammaSaer);
  //
  //       Double_t GammaDer = pow(QDGer[z]/pow(TMath::Abs(V2),0.5),2.) + pow(QDG[z]*V2er/(2.*pow(TMath::Abs(V2),1.5)),2.);
  //       GammaDer = pow(GammaDer,0.5);
  //       //        printf(" gamma dipole   : %e, %e \n",QDG[z]/pow(TMath::Abs(V2),0.5),GammaDer);
  //       Double_t GammaRer = pow(QRGer[z]/pow(TMath::Abs(V2),0.5),2.) + pow(QRG[z]*V2er/(2.*pow(TMath::Abs(V2),1.5)),2.);
  //       GammaRer = pow(GammaRer,0.5);
  //       //        printf(" gamma random   : %e, %e \n \n",QRG[z]/pow(TMath::Abs(V2),0.5),GammaRer);
  //
  //     }
  //
  //   } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)
  // } // end of for (Int_t h=0; h<fCRCnCen; h++)

  cout << "*************************************" << endl;
  cout << endl;
} // end of void AliFlowAnalysisCRC::FinalizeCMEZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeFlowSPZDC()
{
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating v_n{ZDC}"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  // integrated flow

  for(Int_t hr=0; hr<fFlowNHarmZDC; hr++) {
    for(Int_t j=0; j<fFlowNPro; j++) {

      for(Int_t c=1;c<=100.;c++) {

        Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumWeigCorr=0., SumTwoSq=0., SumWeigSq=0.;
        Double_t stats[6]={0.};

        fFlowSPZDCIntPro[hr][j]->GetXaxis()->SetRange(c,c);
        fFlowSPZDCIntPro[hr][j]->GetStats(stats);
        Double_t sumw   = stats[0];
        Double_t sumw2  = stats[1];
        Double_t sumwx  = stats[4];
        Double_t sumwx2 = stats[5];
        fFlowSPZDCIntPro[hr][j]->GetXaxis()->SetRange(1,100);

        // calculate NUA
//        Double_t cos2Q = fFlowSPZDCIntNUA[0]->GetBinContent(c);
//        Double_t sin2Q = fFlowSPZDCIntNUA[1]->GetBinContent(c);
//        Double_t cosA = fFlowSPZDCIntNUA[2]->GetBinContent(c);
//        Double_t sinA = fFlowSPZDCIntNUA[3]->GetBinContent(c);
//        Double_t cosC = fFlowSPZDCIntNUA[4]->GetBinContent(c);
//        Double_t sinC = fFlowSPZDCIntNUA[5]->GetBinContent(c);
//        Double_t cosAcosC = fFlowSPZDCIntNUA[6]->GetBinContent(c);
//        Double_t sinAsinC = fFlowSPZDCIntNUA[7]->GetBinContent(c);
//        Double_t cosAsinC = fFlowSPZDCIntNUA[8]->GetBinContent(c);
//        Double_t sinAcosC = fFlowSPZDCIntNUA[9]->GetBinContent(c);
//        Double_t cos2AQ = fFlowSPZDCIntNUA[10]->GetBinContent(c);
//        Double_t sin2AQ = fFlowSPZDCIntNUA[11]->GetBinContent(c);
//        Double_t cos2BQ = fFlowSPZDCIntNUA[12]->GetBinContent(c);
//        Double_t sin2BQ = fFlowSPZDCIntNUA[13]->GetBinContent(c);

        // Double_t NUAcorRes=0;
//        if(j==0) NUAcorRes = cos2Q*(cosAcosC-sinAsinC)+sin2Q*(cosAsinC+sinAcosC);
//        if(j==1) NUAcorRes = cosA*cosC+sinA*sinC;
//        // TBI
//        if(j==9) NUAcorRes = cos2AQ*(cosAcosC-sinAsinC)+sin2AQ*(cosAsinC+sinAcosC);
//        if(j==10) NUAcorRes = cos2BQ*(cosAcosC-sinAsinC)+sin2BQ*(cosAsinC+sinAcosC);
//        if(j==11) NUAcorRes = cosA*cosC+sinA*sinC;

        if(sumw>0.) {
          SumTwo    += sumwx;
          SumWeig   += sumw;
          SumTwoSq  += sumwx2;
          SumWeigSq += sumw2;
          SumTwoCorr += sumwx;
          SumWeigCorr += sumw;
        } // end of if(sumw>0.)

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

          // Double_t CorrNoBadRuns = SumTwoCorr/SumWeigCorr;

          if(CorrErr) {
            fFlowSPZDCIntHist[hr][j]->SetBinContent(c,Corr);
            fFlowSPZDCIntHist[hr][j]->SetBinError(c,CorrErr);
          }
        }

      } // end of for(Int_t c=1;c<=100.;c++)
    } // end of for(Int_t j=0; j<fFlowNPro; j++)

    // finalize
    for(Int_t c=1;c<=100.;c++) {

      Double_t q2VAVC    = fFlowSPZDCIntHist[hr][0]->GetBinContent(c);
      Double_t q2VAVCErr = fFlowSPZDCIntHist[hr][0]->GetBinError(c);
      Double_t VAVC      = fFlowSPZDCIntHist[hr][1]->GetBinContent(c);
      Double_t VAVCErr   = fFlowSPZDCIntHist[hr][1]->GetBinError(c);

      if(fabs(VAVC)>0. && fabs(q2VAVC)>0.) {
        Double_t Flow = fabs(q2VAVC/VAVC);
        Double_t FlowE = Flow*sqrt(pow(VAVCErr/VAVC,2.)+pow(q2VAVCErr/q2VAVC,2.)); // TBI
        fFlowSPZDCIntFinalHist[hr][0]->SetBinContent(c,Flow);
        fFlowSPZDCIntFinalHist[hr][0]->SetBinError(c,FlowE);
      }

      Double_t QAV      = fFlowSPZDCIntHist[hr][2]->GetBinContent(c);
      Double_t QAVErr   = fFlowSPZDCIntHist[hr][2]->GetBinError(c);
      Double_t QBV      = fFlowSPZDCIntHist[hr][3]->GetBinContent(c);
      Double_t QBVErr   = fFlowSPZDCIntHist[hr][3]->GetBinError(c);
      Double_t QAQB     = fFlowSPZDCIntHist[hr][4]->GetBinContent(c);
      Double_t QAQBErr  = fFlowSPZDCIntHist[hr][4]->GetBinError(c);

      if(fabs(QAQB)>0. && fabs(QAV)>0. && fabs(QBV)>0.) {
        Double_t Res = QAV*QBV/QAQB;
        Double_t ResE = Res*sqrt(pow(QAVErr/QAV,2.)+pow(QBVErr/QBV,2.)+pow(QAQBErr/QAQB,2.)); // TBI
        if(fabs(Res)>0. && fabs(VAVC)>0.) {
          Double_t Flow = fabs(q2VAVC/Res);
          Double_t FlowE = Flow*sqrt(pow(VAVCErr/VAVC,2.)+pow(ResE/Res,2.)); // TBI
          fFlowSPZDCIntFinalHist[hr][1]->SetBinContent(c,Flow);
          fFlowSPZDCIntFinalHist[hr][1]->SetBinError(c,FlowE);
        }
        fFlowSPZDCIntFinalHist[hr][2]->SetBinContent(c,Res);
        fFlowSPZDCIntFinalHist[hr][2]->SetBinError(c,ResE);
      }

    } // end of for(Int_t c=1;c<=100.;c++)

  } // end of for(Int_t hr=0; hr<fFlowNHarmZDC; hr++)


  // **************************************************************************************************************

  // differential flow

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t hr=0; hr<fFlowNHarmZDC; hr++) {
      for(Int_t j=0; j<fFlowNPro; j++) {

        for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {

          Double_t SumTwo=0., SumWeig=0., SumTwoSq=0., SumWeigSq=0.;
          Double_t stats[6]={0.};

          fFlowSPZDCCorPro[h][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowSPZDCCorPro[h][hr][j]->GetStats(stats);
          Double_t sumw   = stats[0];
          Double_t sumw2  = stats[1];
          Double_t sumwx  = stats[4];
          Double_t sumwx2 = stats[5];

//          // calculate NUA
//          Double_t cos2Q = fFlowSPZDCCorNUA[h][0]->GetBinContent(pt);
//          Double_t sin2Q = fFlowSPZDCCorNUA[h][1]->GetBinContent(pt);
//          Double_t cosAcosC = fFlowSPZDCCorPro[h][hr][0]->GetBinContent(1);
//          Double_t sinAsinC = fFlowSPZDCCorPro[h][hr][0]->GetBinContent(2);
//          Double_t cosAsinC = fFlowSPZDCCorPro[h][hr][0]->GetBinContent(3);
//          Double_t sinAcosC = fFlowSPZDCCorPro[h][hr][0]->GetBinContent(4);
//
//          Double_t NUAcorRes=0;
//          if(j==1) NUAcorRes = cos2Q*cosAcosC;
//          if(j==2) NUAcorRes = cos2Q*sinAsinC;
//          if(j==3) NUAcorRes = sin2Q*cosAsinC;
//          if(j==4) NUAcorRes = sin2Q*sinAcosC;
//
//          if(j==5) NUAcorRes = sin2Q*cosAcosC;
//          if(j==6) NUAcorRes = sin2Q*sinAsinC;
//          if(j==7) NUAcorRes = cos2Q*cosAsinC;
//          if(j==8) NUAcorRes = cos2Q*sinAcosC;

          if(sumw>0.) {
            SumTwo    += sumwx;
            SumWeig   += sumw;
            SumTwoSq  += sumwx2;
            SumWeigSq += sumw2;
          } // end of if(sumw>0.)

          if(SumWeig<=0.) continue;

          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

          if(CorrErr) {
            fFlowSPZDCCorHist[h][hr][j]->SetBinContent(pt,Corr);
            fFlowSPZDCCorHist[h][hr][j]->SetBinError(pt,CorrErr);
          }

        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
        fFlowSPZDCCorPro[h][hr][j]->GetXaxis()->SetRange(1,fPtDiffNBins);
      } // end of for(Int_t j=0; j<3; j++)

      for(Int_t j=1; j<fFlowNPro; j++) {
        for(Int_t pt=1; pt<=fPtDiffNBins; pt++) {

          Double_t VCVA    = fFlowSPZDCCorHist[h][hr][0]->GetBinContent(7);
          Double_t VCVAErr = fFlowSPZDCCorHist[h][hr][0]->GetBinError(7);

          Double_t qpVC    = fFlowSPZDCCorHist[h][hr][j]->GetBinContent(pt);
          Double_t qpVCErr = fFlowSPZDCCorHist[h][hr][j]->GetBinError(pt);

          if(fabs(VCVA)>0.) {
//            Double_t Flow=0., FlowE=0.;
//            if(hr==0) {
//              if(j==1 || j==2) {
//                Flow = 2.*qpVC/VCVA;
//              }
//              if(j==3 || j==4) {
//                VCVA = sqrt(fabs(fFlowSPZDCCorHist[h][hr][0]->GetBinContent(1)*fFlowSPZDCCorHist[h][hr][0]->GetBinContent(2)));
//                Flow = 2.*qpVC/VCVA;
//              }
//              FlowE = 2.*pow(pow(qpVCErr/VCVA,2.)+pow(VCVAErr*qpVC/pow(VCVA,2.),2.),0.5);
//            }
            Double_t Flow = qpVC/VCVA;
            Double_t FlowE = pow(pow(qpVCErr/VCVA,2.)+pow(VCVAErr*qpVC/pow(VCVA,2.),2.),0.5);
            if(FlowE>0.) {
              fFlowSPZDCFinalPtDifHist[h][hr][j]->SetBinContent(pt,Flow);
              fFlowSPZDCFinalPtDifHist[h][hr][j]->SetBinError(pt,FlowE);
            }
          }
        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
      } // end of for(Int_t j=0; j<3; j++)
    } // end of for(Int_t hr=0; hr<fFlowNHarmZDC; hr++)
  } // end of for (Int_t h=0; h<fCRCnCen; h++)

  // v1(eta)
  cout << "*************************************" << endl;

  for (Int_t h=0; h<fCRCnCen; h++) {
    // calculate v1 terms
    for (Int_t k=0; k<fkNHarv1eta; k++) {
      for (Int_t j=0; j<fkNHistv1eta; j++) {
        if(fFlowSPZDCv1etaPro[h][k][j]) {
          for(Int_t c=1;c<=fFlowSPZDCv1etaPro[h][k][j]->GetNbinsX();c++) {

            Double_t SumTwo=0., SumTwoCorr=0., SumWeig=0., SumWeigCorr=0., SumTwoSq=0., SumWeigSq=0.;
            Double_t stats[6]={0.};

            fFlowSPZDCv1etaPro[h][k][j]->GetXaxis()->SetRange(c,c);
            fFlowSPZDCv1etaPro[h][k][j]->GetStats(stats);
            Double_t sumw   = stats[0];
            Double_t sumw2  = stats[1];
            Double_t sumwx  = stats[4];
            Double_t sumwx2 = stats[5];

            if(sumw>0.) {
              SumTwo    += sumwx;
              SumWeig   += sumw;
              SumTwoSq  += sumwx2;
              SumWeigSq += sumw2;
              SumTwoCorr += sumwx;
              SumWeigCorr += sumw;
            } // end of if(sumw>0.)

            if(SumWeig<=0.) continue;

            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

            if(CorrErr) {
              fFlowSPZDCv1etaHist[h][k][j]->SetBinContent(c,Corr);
              fFlowSPZDCv1etaHist[h][k][j]->SetBinError(c,CorrErr);
            }

          } // end of for(Int_t c=1;c<=fFlowSPZDCv1etaPro[h][k][j]->GetNbinsX();c++)
          fFlowSPZDCv1etaPro[h][k][j]->GetXaxis()->SetRange(1,fFlowSPZDCv1etaPro[h][k][j]->GetNbinsX());
        }
      }
    }
    // calculate covariance terms
    Int_t cornum1[] = {0,0,1,3,3,4,5,5,6,3,3,4,4};
    Int_t cornum2[] = {1,2,2,4,2,2,6,2,2,5,6,5,6};
    for (Int_t j=0; j<fkNHistv1etaCov; j++) {
      if(fFlowSPZDCv1etaCovPro[h][j]) {
        for(Int_t pt=1; pt<=fFlowSPZDCv1etaCovPro[h][j]->GetNbinsX(); pt++) {
          // average reduced correlations:
          Double_t two = fFlowSPZDCv1etaHist[h][0][cornum1[j]]->GetBinContent(pt); // <<2>>
          Double_t four = fFlowSPZDCv1etaHist[h][0][cornum2[j]]->GetBinContent(pt); // <<4>>
          // products for differential flow:
          Double_t twoFour = fFlowSPZDCv1etaCovPro[h][j]->GetBinContent(pt); // <<2><4>>
          // sum of weights for reduced correlation:
          Double_t sumOfWeightsForTwo = GetSumPro(fFlowSPZDCv1etaPro[h][0][cornum1[j]],pt); // sum_{i=1}^{N} w_{<2>}
          Double_t sumOfWeightsForFour = GetSumPro(fFlowSPZDCv1etaPro[h][0][cornum2[j]],pt); // sum_{i=1}^{N} w_{<4>}
          // product of weights for reduced correlation:
          Double_t productOfWeightsForTwoFour = GetSumPro(fFlowSPZDCv1etaCovPro[h][j],pt); // sum_{i=1}^{N} w_{<2>}w_{<4>}

          // <2>,<4>:
          Double_t term1 = productOfWeightsForTwoFour;
          Double_t term2 = sumOfWeightsForTwo;
          Double_t term3 = sumOfWeightsForFour;
          if(term2*term3>0.)
          {
            Double_t denominator = 1.-term1/(term2*term3);
            Double_t prefactor = term1/(term2*term3);
            if(TMath::Abs(denominator)>1.e-6)
            {
              Double_t covTwoFour = (twoFour-two*four)/denominator;
              Double_t wCovTwoFour = covTwoFour*prefactor;
              fFlowSPZDCv1etaCovHist[h][j]->SetBinContent(pt,wCovTwoFour);
            }
          }
        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
      }
    }
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t k=0; k<fkNHarv1eta; k++) {
      if(fFlowSPZDCv1etaHist[h][k][0]) {
        if(k==0) {
          for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {

            Double_t v1P = fFlowSPZDCv1etaHist[h][k][0]->GetBinContent(eb+1);
            Double_t v1Per = fFlowSPZDCv1etaHist[h][k][0]->GetBinError(eb+1);
            Double_t v1T = fFlowSPZDCv1etaHist[h][k][1]->GetBinContent(eb+1);
            Double_t v1Ter = fFlowSPZDCv1etaHist[h][k][1]->GetBinError(eb+1);
            Double_t QAQB = fFlowSPZDCv1etaHist[h][k][2]->GetBinContent(eb+1);
            Double_t QAQBer = fFlowSPZDCv1etaHist[h][k][2]->GetBinError(eb+1);

            Double_t QRe = fFlowSPZDCv1etaNUAPro[h][0][0]->GetBinContent(eb+1);
            Double_t QIm = fFlowSPZDCv1etaNUAPro[h][0][1]->GetBinContent(eb+1);
            Double_t ZARe = fFlowSPZDCv1etaNUAPro[h][0][6]->GetBinContent(eb+1);
            Double_t ZAIm = fFlowSPZDCv1etaNUAPro[h][0][7]->GetBinContent(eb+1);
            Double_t ZCRe = fFlowSPZDCv1etaNUAPro[h][0][8]->GetBinContent(eb+1);
            Double_t ZCIm = fFlowSPZDCv1etaNUAPro[h][0][9]->GetBinContent(eb+1);

            if(fNUAforCRC) {
              v1P -= QRe*ZARe+QIm*ZAIm;
              v1T -= QRe*ZCRe+QIm*ZCIm;
            }

            if(fabs(QAQB)>0.) {

              Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
              Double_t den = sqrt(fabs(QAQB));
              Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
              Double_t v1odder = 0.5*sqrt(v1oddSq);

              fFlowSPZDCv1etaHist[h][k][0]->SetBinContent(eb+1,v1odd);
              fFlowSPZDCv1etaHist[h][k][0]->SetBinError(eb+1,v1odder);

              Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
              Double_t v1eveer = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P+v1T)/pow(fabs(QAQB),1.5),2.);
              v1eveer = 0.5*sqrt(v1eveer);
              fFlowSPZDCv1etaHist[h][k][1]->SetBinContent(eb+1,v1eve);
              fFlowSPZDCv1etaHist[h][k][1]->SetBinError(eb+1,v1eveer);

              //positive particles
              v1P = fFlowSPZDCv1etaHist[h][k][3]->GetBinContent(eb+1);
              v1Per = fFlowSPZDCv1etaHist[h][k][3]->GetBinError(eb+1);
              v1T = fFlowSPZDCv1etaHist[h][k][4]->GetBinContent(eb+1);
              v1Ter = fFlowSPZDCv1etaHist[h][k][4]->GetBinError(eb+1);

              Double_t QPRe = fFlowSPZDCv1etaNUAPro[h][0][2]->GetBinContent(eb+1);
              Double_t QPIm = fFlowSPZDCv1etaNUAPro[h][0][3]->GetBinContent(eb+1);

              if(fNUAforCRC) {
                v1P -= QPRe*ZARe+QPIm*ZAIm;
                v1T -= QPRe*ZCRe+QPIm*ZCIm;
              }

              // Double_t v1PA = v1P, v1PAer = v1Per, v1PC = v1T, v1PCer = v1Ter;

              v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
              v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
              v1odder = 0.5*sqrt(v1oddSq);
              fFlowSPZDCv1etaHist[h][k][2]->SetBinContent(eb+1,v1odd);
              fFlowSPZDCv1etaHist[h][k][2]->SetBinError(eb+1,v1odder);

              v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
              v1eveer = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P+v1T)/pow(fabs(QAQB),1.5),2.);
              v1eveer = 0.5*sqrt(v1eveer);
              fFlowSPZDCv1etaHist[h][k][3]->SetBinContent(eb+1,v1eve);
              fFlowSPZDCv1etaHist[h][k][3]->SetBinError(eb+1,v1eveer);

              //negative particles
              v1P = fFlowSPZDCv1etaHist[h][k][5]->GetBinContent(eb+1);
              v1Per = fFlowSPZDCv1etaHist[h][k][5]->GetBinError(eb+1);
              v1T = fFlowSPZDCv1etaHist[h][k][6]->GetBinContent(eb+1);
              v1Ter = fFlowSPZDCv1etaHist[h][k][6]->GetBinError(eb+1);

              Double_t QNRe = fFlowSPZDCv1etaNUAPro[h][0][4]->GetBinContent(eb+1);
              Double_t QNIm = fFlowSPZDCv1etaNUAPro[h][0][5]->GetBinContent(eb+1);

              if(fNUAforCRC) {
                v1P -= QNRe*ZARe+QNIm*ZAIm;
                v1T -= QNRe*ZCRe+QNIm*ZCIm;
              }

              // Double_t v1NA = v1P, v1NAer = v1Per, v1NC = v1T, v1NCer = v1Ter;

              v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
              v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
              v1odder = 0.5*sqrt(v1oddSq);
              fFlowSPZDCv1etaHist[h][k][4]->SetBinContent(eb+1,v1odd);
              fFlowSPZDCv1etaHist[h][k][4]->SetBinError(eb+1,v1odder);

              v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
              v1eveer = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P+v1T)/pow(fabs(QAQB),1.5),2.);
              v1eveer = 0.5*sqrt(v1eveer);
              fFlowSPZDCv1etaHist[h][k][5]->SetBinContent(eb+1,v1eve);
              fFlowSPZDCv1etaHist[h][k][5]->SetBinError(eb+1,v1eveer);

//               //positive minus negative, with covariances
//               Double_t CovPANA = fFlowSPZDCv1etaCovHist[h][9]->GetBinContent(eb+1);
//               Double_t CovPANC = fFlowSPZDCv1etaCovHist[h][10]->GetBinContent(eb+1);
//               Double_t CovPCNA = fFlowSPZDCv1etaCovHist[h][11]->GetBinContent(eb+1);
//               Double_t CovPCNC = fFlowSPZDCv1etaCovHist[h][12]->GetBinContent(eb+1);
//               Double_t CovPAD = fFlowSPZDCv1etaCovHist[h][4]->GetBinContent(eb+1);
//               Double_t CovPCD = fFlowSPZDCv1etaCovHist[h][5]->GetBinContent(eb+1);
//               Double_t CovNAD = fFlowSPZDCv1etaCovHist[h][7]->GetBinContent(eb+1);
//               Double_t CovNCD = fFlowSPZDCv1etaCovHist[h][8]->GetBinContent(eb+1);
//
//               Double_t Deltav1odd = (v1PA-v1PC-v1NA+v1NC)/(sqrt(fabs(QAQB))*2.);
//               Double_t densq = fabs(QAQB);
//               Double_t densqsq = 2.*pow(fabs(QAQB),2.);
//               if(densqsq>0.) {
//                 Double_t Deltav1oddErrSq = pow(v1PAer/den,2.) + pow(v1PCer/den,2.) + pow(v1NAer/den,2.) + pow(v1NCer/den,2.) + pow(QAQBer*0.5*(v1PA-v1PC-v1NA+v1NC)/pow(fabs(QAQB),1.5),2.);
//                 Double_t CovCorrSq = 2.*( - CovPANA/densq + CovPANC/densq + CovPCNA/densq - CovPCNC/densq - (v1PA-v1PC-v1NA+v1NC)*CovPAD/densqsq + (v1PA-v1PC-v1NA+v1NC)*CovPCD/densqsq + (v1PA-v1PC-v1NA+v1NC)*CovNAD/densqsq - (v1PA-v1PC-v1NA+v1NC)*CovNCD/densqsq);
//
//                 if(Deltav1oddErrSq+CovCorrSq>0.) {
//                   Double_t Deltav1oddErr = 0.5*sqrt(Deltav1oddErrSq+CovCorrSq);
//                   fFlowSPZDCv1etaHist[h][k][12]->SetBinContent(eb+1,Deltav1odd);
//                   fFlowSPZDCv1etaHist[h][k][12]->SetBinError(eb+1,Deltav1oddErr);
//                 }
//
//                 Double_t Deltav1eve = (v1PA+v1PC-v1NA-v1NC)/(sqrt(fabs(QAQB))*2.);
//                 Double_t Deltav1eveErrSq = pow(v1PAer/den,2.) + pow(v1PCer/den,2.) + pow(v1NAer/den,2.) + pow(v1NCer/den,2.) + pow(QAQBer*0.5*(v1PA+v1PC-v1NA-v1NC)/pow(fabs(QAQB),1.5),2.);
//                 CovCorrSq = 2.*( - CovPANA/densq - CovPANC/densq - CovPCNA/densq + CovPCNC/densq - (v1PA+v1PC-v1NA-v1NC)*CovPAD/densqsq - (v1PA+v1PC-v1NA-v1NC)*CovPCD/densqsq + (v1PA+v1PC-v1NA-v1NC)*CovNAD/densqsq + (v1PA+v1PC-v1NA-v1NC)*CovNCD/densqsq);
//
//                 if(Deltav1eveErrSq+CovCorrSq>0.) {
//                   Double_t Deltav1eveErr = 0.5*sqrt(Deltav1eveErrSq+CovCorrSq);
//                   fFlowSPZDCv1etaHist[h][k][13]->SetBinContent(eb+1,Deltav1eve);
//                   fFlowSPZDCv1etaHist[h][k][13]->SetBinError(eb+1,Deltav1eveErr);
//                 }
//               }
            }
          }
        }
        if(k==1) {

          // real part: 0,1,12,2,3,4,5
          for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {

            Double_t v1P = fFlowSPZDCv1etaHist[h][k][0]->GetBinContent(eb+1);
            Double_t v1Per = fFlowSPZDCv1etaHist[h][k][0]->GetBinError(eb+1);
            Double_t v1T = fFlowSPZDCv1etaHist[h][k][1]->GetBinContent(eb+1);
            Double_t v1Ter = fFlowSPZDCv1etaHist[h][k][1]->GetBinError(eb+1);
            Double_t QAQB = fFlowSPZDCv1etaHist[h][k][12]->GetBinContent(eb+1);
            Double_t QAQBer = fFlowSPZDCv1etaHist[h][k][12]->GetBinError(eb+1);

            if(fabs(QAQB)<=0.) continue;

            Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t den = sqrt(fabs(QAQB));
            Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            Double_t v1odder = 0.5*sqrt(v1oddSq);

            fFlowSPZDCv1etaHist[h][k][0]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][0]->SetBinError(eb+1,v1odder);

            Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t v1eveer = v1odder;
            fFlowSPZDCv1etaHist[h][k][1]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][1]->SetBinError(eb+1,v1eveer);

            //positive particles
            v1P = fFlowSPZDCv1etaHist[h][k][2]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][2]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][3]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][3]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][2]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][2]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][3]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][3]->SetBinError(eb+1,v1eveer);

            //negative particles
            v1P = fFlowSPZDCv1etaHist[h][k][4]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][4]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][5]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][5]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][4]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][4]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][5]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][5]->SetBinError(eb+1,v1eveer);

          }

          // imaginary part: 6,7,13,8,9,10,11
          for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {

            Double_t v1P = fFlowSPZDCv1etaHist[h][k][6]->GetBinContent(eb+1);
            Double_t v1Per = fFlowSPZDCv1etaHist[h][k][6]->GetBinError(eb+1);
            Double_t v1T = fFlowSPZDCv1etaHist[h][k][7]->GetBinContent(eb+1);
            Double_t v1Ter = fFlowSPZDCv1etaHist[h][k][7]->GetBinError(eb+1);
            Double_t QAQB = fFlowSPZDCv1etaHist[h][k][13]->GetBinContent(eb+1);
            Double_t QAQBer = fFlowSPZDCv1etaHist[h][k][13]->GetBinError(eb+1);

            if(fabs(QAQB)<=0.) continue;

            Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t den = sqrt(fabs(QAQB));
            Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            Double_t v1odder = 0.5*sqrt(v1oddSq);

            fFlowSPZDCv1etaHist[h][k][6]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][6]->SetBinError(eb+1,v1odder);

            Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t v1eveer = v1odder;
            fFlowSPZDCv1etaHist[h][k][7]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][7]->SetBinError(eb+1,v1eveer);

            //positive particles
            v1P = fFlowSPZDCv1etaHist[h][k][8]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][8]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][9]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][9]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][8]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][8]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][9]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][9]->SetBinError(eb+1,v1eveer);

            //negative particles
            v1P = fFlowSPZDCv1etaHist[h][k][10]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][10]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][11]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][11]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][10]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][10]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][11]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][11]->SetBinError(eb+1,v1eveer);

          }

        }
        if(k==2) {

          // magnetic field: pos
          for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {

            Double_t v1P = fFlowSPZDCv1etaHist[h][k][0]->GetBinContent(eb+1);
            Double_t v1Per = fFlowSPZDCv1etaHist[h][k][0]->GetBinError(eb+1);
            Double_t v1T = fFlowSPZDCv1etaHist[h][k][1]->GetBinContent(eb+1);
            Double_t v1Ter = fFlowSPZDCv1etaHist[h][k][1]->GetBinError(eb+1);
            Double_t QAQB = fFlowSPZDCv1etaHist[h][k][2]->GetBinContent(eb+1);
            Double_t QAQBer = fFlowSPZDCv1etaHist[h][k][2]->GetBinError(eb+1);

            if(fabs(QAQB)<=0.) continue;

            Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t den = sqrt(fabs(QAQB));
            Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            Double_t v1odder = 0.5*sqrt(v1oddSq);

            fFlowSPZDCv1etaHist[h][k][0]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][0]->SetBinError(eb+1,v1odder);

            Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t v1eveer = v1odder;
            fFlowSPZDCv1etaHist[h][k][1]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][1]->SetBinError(eb+1,v1eveer);

            //positive particles
            v1P = fFlowSPZDCv1etaHist[h][k][3]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][3]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][4]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][4]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][2]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][2]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][3]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][3]->SetBinError(eb+1,v1eveer);

            //negative particles
            v1P = fFlowSPZDCv1etaHist[h][k][5]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][5]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][6]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][6]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][4]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][4]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][5]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][5]->SetBinError(eb+1,v1eveer);

          }

          // magnetic field: neg
          for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {

            Double_t v1P = fFlowSPZDCv1etaHist[h][k][7]->GetBinContent(eb+1);
            Double_t v1Per = fFlowSPZDCv1etaHist[h][k][7]->GetBinError(eb+1);
            Double_t v1T = fFlowSPZDCv1etaHist[h][k][8]->GetBinContent(eb+1);
            Double_t v1Ter = fFlowSPZDCv1etaHist[h][k][8]->GetBinError(eb+1);
            Double_t QAQB = fFlowSPZDCv1etaHist[h][k][9]->GetBinContent(eb+1);
            Double_t QAQBer = fFlowSPZDCv1etaHist[h][k][9]->GetBinError(eb+1);

            if(fabs(QAQB)<=0.) continue;

            Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t den = sqrt(fabs(QAQB));
            Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            Double_t v1odder = 0.5*sqrt(v1oddSq);

            fFlowSPZDCv1etaHist[h][k][6]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][6]->SetBinError(eb+1,v1odder);

            Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            Double_t v1eveer = v1odder;
            fFlowSPZDCv1etaHist[h][k][7]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][7]->SetBinError(eb+1,v1eveer);

            //positive particles
            v1P = fFlowSPZDCv1etaHist[h][k][10]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][10]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][11]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][11]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][8]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][8]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][9]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][9]->SetBinError(eb+1,v1eveer);

            //negative particles
            v1P = fFlowSPZDCv1etaHist[h][k][12]->GetBinContent(eb+1);
            v1Per = fFlowSPZDCv1etaHist[h][k][12]->GetBinError(eb+1);
            v1T = fFlowSPZDCv1etaHist[h][k][13]->GetBinContent(eb+1);
            v1Ter = fFlowSPZDCv1etaHist[h][k][13]->GetBinError(eb+1);

            v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
            v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
            v1odder = 0.5*sqrt(v1oddSq);
            fFlowSPZDCv1etaHist[h][k][10]->SetBinContent(eb+1,v1odd);
            fFlowSPZDCv1etaHist[h][k][10]->SetBinError(eb+1,v1odder);

            v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
            v1eveer = v1odder; // TBI
            fFlowSPZDCv1etaHist[h][k][11]->SetBinContent(eb+1,v1eve);
            fFlowSPZDCv1etaHist[h][k][11]->SetBinError(eb+1,v1eveer);

          }

        }
      }
    }
  }

  // v1(eta,pT)
  cout << "*************************************" << endl;

  for (Int_t h=0; h<fCRCnCen; h++) {

    for (Int_t eb=0; eb<fkEtaDiffNBins; eb++) {
      for (Int_t pt=0; pt<fZDCPtDiffNBins; pt++) {

        Double_t v1P = fFlowSPZDCv1etaPtPro[h][0]->GetBinContent(eb+1,pt+1);
        Double_t v1Per = fFlowSPZDCv1etaPtPro[h][0]->GetBinError(eb+1,pt+1);
        Double_t v1T = fFlowSPZDCv1etaPtPro[h][1]->GetBinContent(eb+1,pt+1);
        Double_t v1Ter = fFlowSPZDCv1etaPtPro[h][1]->GetBinError(eb+1,pt+1);
        Double_t QAQB = fFlowSPZDCv1etaPro[h][0][2]->GetBinContent(eb+1);
        Double_t QAQBer = fFlowSPZDCv1etaPro[h][0][2]->GetBinError(eb+1);

        if(fabs(QAQB)<=0.) continue;

        Double_t v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
        Double_t den = sqrt(fabs(QAQB));
        Double_t v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
        Double_t v1odder = 0.5*sqrt(v1oddSq);

        fFlowSPZDCv1etaPtHist[h][0]->SetBinContent(eb+1,pt+1,v1odd);
        fFlowSPZDCv1etaPtHist[h][0]->SetBinError(eb+1,pt+1,v1odder);

        Double_t v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
        Double_t v1eveer = v1odder;
        fFlowSPZDCv1etaPtHist[h][1]->SetBinContent(eb+1,pt+1,v1eve);
        fFlowSPZDCv1etaPtHist[h][1]->SetBinError(eb+1,pt+1,v1eveer);

        //positive particles
        v1P = fFlowSPZDCv1etaPtPro[h][2]->GetBinContent(eb+1,pt+1);
        v1Per = fFlowSPZDCv1etaPtPro[h][2]->GetBinError(eb+1,pt+1);
        v1T = fFlowSPZDCv1etaPtPro[h][3]->GetBinContent(eb+1,pt+1);
        v1Ter = fFlowSPZDCv1etaPtPro[h][3]->GetBinError(eb+1,pt+1);

        v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
        v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
        v1odder = 0.5*sqrt(v1oddSq);
        fFlowSPZDCv1etaPtHist[h][2]->SetBinContent(eb+1,pt+1,v1odd);
        fFlowSPZDCv1etaPtHist[h][2]->SetBinError(eb+1,pt+1,v1odder);

        v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
        v1eveer = v1odder; // TBI
        fFlowSPZDCv1etaPtHist[h][3]->SetBinContent(eb+1,pt+1,v1eve);
        fFlowSPZDCv1etaPtHist[h][3]->SetBinError(eb+1,pt+1,v1eveer);

        //negative particles
        v1P = fFlowSPZDCv1etaPtPro[h][4]->GetBinContent(eb+1,pt+1);
        v1Per = fFlowSPZDCv1etaPtPro[h][4]->GetBinError(eb+1,pt+1);
        v1T = fFlowSPZDCv1etaPtPro[h][5]->GetBinContent(eb+1,pt+1);
        v1Ter = fFlowSPZDCv1etaPtPro[h][5]->GetBinError(eb+1,pt+1);

        v1odd = (v1P-v1T)/(sqrt(fabs(QAQB))*2.);
        v1oddSq = pow(v1Per/den,2.) + pow(v1Ter/den,2.) + pow(QAQBer*0.5*(v1P-v1T)/pow(fabs(QAQB),1.5),2.);
        v1odder = 0.5*sqrt(v1oddSq);
        fFlowSPZDCv1etaPtHist[h][4]->SetBinContent(eb+1,pt+1,v1odd);
        fFlowSPZDCv1etaPtHist[h][4]->SetBinError(eb+1,pt+1,v1odder);

        v1eve = (v1P+v1T)/(sqrt(fabs(QAQB))*2.);
        v1eveer = v1odder; // TBI
        fFlowSPZDCv1etaPtHist[h][5]->SetBinContent(eb+1,pt+1,v1eve);
        fFlowSPZDCv1etaPtHist[h][5]->SetBinError(eb+1,pt+1,v1eveer);

      }
    }
  }

  cout << "*************************************" << endl;
  cout << endl;

} // end of void AliFlowAnalysisCRC::FinalizeFlowSPZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeFlowQC()
{
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating v_n{QC,4}"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for(Int_t hr=0; hr<fFlowNHarm; hr++) {

    // Pt-INTEGRATED

    // STORE IN HISTOGRAMS

    // 2- and 4-particle cumulants
    for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
      for(Int_t pt=1;pt<=fFlowQCIntCorPro[hr][j]->GetNbinsX();pt++) {
        Double_t stats[6]={0.};
        fFlowQCIntCorPro[hr][j]->GetXaxis()->SetRange(pt,pt);
        fFlowQCIntCorPro[hr][j]->GetStats(stats);
        LongDouble_t SumWeig   = stats[0];
        LongDouble_t SumWeigSq  = stats[1];
        LongDouble_t SumTwo  = stats[4];
        LongDouble_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          LongDouble_t Corr = SumTwo/SumWeig;
          LongDouble_t SqCorr = SumTwoSq/SumWeig;
          LongDouble_t Weig = SumWeig;
          LongDouble_t SqWeig = SumWeigSq;
          LongDouble_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          LongDouble_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowQCIntCorHist[hr][j]->SetBinContent(pt,Corr);
            fFlowQCIntCorHist[hr][j]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=100;pt++)
      fFlowQCIntCorPro[hr][j]->GetXaxis()->SetRange(1,fFlowQCIntCorPro[hr][j]->GetNbinsX());
    } // end of for(Int_t j=0; j<5; j++)

    for (Int_t j=0; j<6; j++) {
      for(Int_t pt=1;pt<=fFlowQCIntCorNUAPro[hr][j]->GetNbinsX();pt++) {
        Double_t stats[6]={0.};
        fFlowQCIntCorNUAPro[hr][j]->GetXaxis()->SetRange(pt,pt);
        fFlowQCIntCorNUAPro[hr][j]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowQCIntCorNUAHist[hr][j]->SetBinContent(pt,Corr);
            fFlowQCIntCorNUAHist[hr][j]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=100;pt++)
      fFlowQCIntCorNUAPro[hr][j]->GetXaxis()->SetRange(1,fFlowQCIntCorNUAPro[hr][j]->GetNbinsX());
    }

    // 2-particle with Eta Gap
    for(Int_t pt=1;pt<=fFlowQCIntCorProEG[hr]->GetNbinsX();pt++) {
      Double_t stats[6]={0.};
      fFlowQCIntCorProEG[hr]->GetXaxis()->SetRange(pt,pt);
      fFlowQCIntCorProEG[hr]->GetStats(stats);
      Double_t SumWeig   = stats[0];
      Double_t SumWeigSq  = stats[1];
      Double_t SumTwo  = stats[4];
      Double_t SumTwoSq = stats[5];

      if(SumWeig>0.) {
        Double_t Corr = SumTwo/SumWeig;
        Double_t SqCorr = SumTwoSq/SumWeig;
        Double_t Weig = SumWeig;
        Double_t SqWeig = SumWeigSq;
        Double_t spread=0., termA=0., termB=0.;
        if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
        if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
        if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
        Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
        if(CorrErr) {
          fFlowQCIntCorHistEG[hr]->SetBinContent(pt,Corr);
          fFlowQCIntCorHistEG[hr]->SetBinError(pt,CorrErr);
        }
      }
    } // end of for(Int_t pt=1;pt<=100;pt++)
    fFlowQCIntCorProEG[hr]->GetXaxis()->SetRange(1,fFlowQCIntCorProEG[hr]->GetNbinsX());

    for (Int_t j=0; j<4; j++) {
      for(Int_t pt=1;pt<=fFlowQCIntCorNUAProEG[hr][j]->GetNbinsX();pt++) {
        Double_t stats[6]={0.};
        fFlowQCIntCorNUAProEG[hr][j]->GetXaxis()->SetRange(pt,pt);
        fFlowQCIntCorNUAProEG[hr][j]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowQCIntCorNUAHistEG[hr][j]->SetBinContent(pt,Corr);
            fFlowQCIntCorNUAHistEG[hr][j]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=100;pt++)
      fFlowQCIntCorNUAProEG[hr][j]->GetXaxis()->SetRange(1,fFlowQCIntCorNUAProEG[hr][j]->GetNbinsX());
    }
  } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

  // SC intermezzo ***********************************************************

  if (fUseZDC) {

    cout << "SC intermezzo" << endl;

    // pt-integrated

    for(Int_t i=0; i<fSCv2vsZNHarm; i++) {

      for(Int_t bng=0; bng<fkSCNHist; bng++) {
        for(Int_t pt=1;pt<=fFlowSCProdPro[i][bng]->GetNbinsX();pt++) {
          Double_t stats[6]={0.};
          fFlowSCProdPro[i][bng]->GetXaxis()->SetRange(pt,pt);
          fFlowSCProdPro[i][bng]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowSCProdHist[i][bng]->SetBinContent(pt,Corr);
              fFlowSCProdHist[i][bng]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=100;pt++)
        fFlowSCProdPro[i][bng]->GetXaxis()->SetRange(1,fFlowSCProdPro[i][bng]->GetNbinsX());
      } // end of for(Int_t bng=0; bng<3; bng++)

      // check if there is residual pedestal
      TF1* fitped = new TF1("fitped","pol1",0.,10.);
      fFlowSCProdHist[i][4]->Fit(fitped,"RQN","",0.,10.);
      Double_t ExpZN = 2.; // from trento, average between WN,KLN,EKRT; uncertanty .2, few stat
      Double_t ZN0 = fitped->GetParameter(0);
      Double_t Ped = 0.;
      if(ZN0>ExpZN) {
        Ped = ZN0-ExpZN;
      }

      for (Int_t c=0; c<fFlowSCProdHist[0][0]->GetNbinsX(); c++) {

        Double_t vnZN    = fFlowSCProdHist[i][0]->GetBinContent(c+1);
        Double_t vnCen   = fFlowSCProdHist[i][1]->GetBinContent(c+1);
        Double_t ZNCen   = fFlowSCProdHist[i][2]->GetBinContent(c+1);
        Double_t vn      = fFlowSCProdHist[i][3]->GetBinContent(c+1);
        Double_t ZN      = fFlowSCProdHist[i][4]->GetBinContent(c+1);
        Double_t Cen     = fFlowSCProdPro[i][5]->GetBinContent(c+1);
        // Double_t Varvn   = pow(fFlowSCProdPro[i][3]->GetBinError(c+1),2.);
        // Double_t VarZN   = pow(fFlowSCProdPro[i][4]->GetBinError(c+1),2.);
        Double_t VarCen  = pow(fFlowSCProdPro[i][5]->GetXaxis()->GetBinWidth(c+1),2.)/12.;

        Double_t vnZNEr = fFlowSCProdHist[i][0]->GetBinError(c+1);
        Double_t vnCenEr = fFlowSCProdHist[i][1]->GetBinError(c+1);
        Double_t ZNCenEr = fFlowSCProdHist[i][2]->GetBinError(c+1);
        Double_t vnEr = fFlowSCProdHist[i][3]->GetBinError(c+1);
        Double_t ZNEr = fFlowSCProdHist[i][4]->GetBinError(c+1);

        // partial covariance

        Double_t CovvnZN = vnZN - vn*ZN;
        Double_t CovvnCen = vnCen - vn*Cen;
        Double_t CovZNCen = ZNCen - Cen*ZN;

        fFlowSCCovHist[i][0]->SetBinContent(c+1,CovvnZN);
        fFlowSCCovHist[i][0]->SetBinError(c+1,vnZNEr);
        fFlowSCCovHist[i][1]->SetBinContent(c+1,CovvnCen);
        fFlowSCCovHist[i][1]->SetBinError(c+1,vnCenEr);
        fFlowSCCovHist[i][2]->SetBinContent(c+1,CovZNCen);
        fFlowSCCovHist[i][2]->SetBinError(c+1,ZNCenEr);

        Double_t ParCovvnZN = CovvnZN - (CovvnCen*CovZNCen)/VarCen;
        Double_t ParCovvnZNErr = sqrt( pow(vnZNEr,2.) + pow(vn*ZNEr,2.) + pow(ZN*vnEr,2.)); // TBI

        fFlowSCFinalHist[i][0]->SetBinContent(c+1,ParCovvnZN);
        fFlowSCFinalHist[i][0]->SetBinError(c+1,ParCovvnZNErr);

        // normalized partial covariance
        if(vn>0. && ZN>0. && Cen>0.) {

          CovvnZN = (vnZN - vn*ZN)/(vn*ZN);
          CovvnCen = (vnCen - vn*Cen)/(vn*Cen);
          CovZNCen = (ZNCen - Cen*ZN)/(Cen*ZN);

          if(VarCen>0. && Cen>0.) {
            Double_t ParCovvnZN = CovvnZN - (CovvnCen*CovZNCen)/(VarCen/pow(Cen,2.));
            Double_t ParCovvnZNErr = sqrt( pow(vnZNEr,2.) + pow(vn*ZNEr,2.) + pow(ZN*vnEr,2.))/(vn*ZN); // TBI

            fFlowSCFinalHist[i][1]->SetBinContent(c+1,ParCovvnZN);
            fFlowSCFinalHist[i][1]->SetBinError(c+1,ParCovvnZNErr);
          }

        }
        // normalized partial covariance - pedestal subtracted
        if(vn>0. && ZN-Ped>0. && Cen>0.) {

          CovvnZN = (vnZN - vn*ZN)/(vn*(ZN-Ped));
          CovvnCen = (vnCen - vn*Cen)/(vn*Cen);
          CovZNCen = (ZNCen - Cen*ZN)/(Cen*(ZN-Ped));

          fFlowSCCovHist[i][3]->SetBinContent(c+1,CovvnZN);
          fFlowSCCovHist[i][3]->SetBinError(c+1,vnZNEr/(vn*(ZN-Ped)));
          fFlowSCCovHist[i][4]->SetBinContent(c+1,CovvnCen);
          fFlowSCCovHist[i][4]->SetBinError(c+1,vnCenEr/(vn*Cen));
          fFlowSCCovHist[i][5]->SetBinContent(c+1,CovZNCen);
          fFlowSCCovHist[i][5]->SetBinError(c+1,ZNCenEr/(Cen*(ZN-Ped)));

          if(VarCen>0. && Cen>0.) {
            Double_t ParCovvnZN = CovvnZN - (CovvnCen*CovZNCen)/(VarCen/pow(Cen,2.));
            Double_t ParCovvnZNErr = sqrt( pow(vnZNEr,2.) + pow(vn*ZNEr,2.) + pow(ZN*vnEr,2.))/(vn*(ZN-Ped)); // TBI

            fFlowSCFinalHist[i][2]->SetBinContent(c+1,ParCovvnZN);
            fFlowSCFinalHist[i][2]->SetBinError(c+1,ParCovvnZNErr);
          }

        }
      }

      // test with cross products

      //    Double_t ArrVar[fkFlowSCNvar] = {IQC2EG,Nspe,AvPt,QAM+QBM};

      for (Int_t c=0; c<fFlowSCCrossProdPro[0][0][0]->GetNbinsX(); c++) {

        Double_t Aver[fkFlowSCNvar] = {0.};
        Double_t Prod[fkFlowSCNvar][fkFlowSCNvar] = {{0.}};
        Double_t Cov[fkFlowSCNvar][fkFlowSCNvar] = {{0.}};
        Double_t NorCov[fkFlowSCNvar][fkFlowSCNvar] = {{0.}};
        Double_t Var[fkFlowSCNvar] = {0.};
        Double_t NorVar[fkFlowSCNvar] = {0.};

        for (Int_t k=0; k<fkFlowSCNvar; k++) {
          Aver[k] = fFlowSCCrossProdPro[i][k][k]->GetBinContent(c+1);
          Var[k]  = fFlowSCCrossProdPro[i][k][k]->GetBinError(c+1);
          for (Int_t z=0; z<fkFlowSCNvar; z++) {
            Prod[k][z] = fFlowSCCrossProdPro[i][k][z]->GetBinContent(c+1);
          }
        }
        for (Int_t k=0; k<fkFlowSCNvar; k++) {
          if(Aver[k]>0.) NorVar[k] = Var[k]/pow(Aver[k],2.);
          for (Int_t z=0; z<fkFlowSCNvar; z++) {
            Cov[k][z] = Prod[k][z] - Aver[k]*Aver[z];
            if(Aver[k]>0. && Aver[z]>0.) NorCov[k][z] = (Prod[k][z] - Aver[k]*Aver[z])/(Aver[k]*Aver[z]);
          }
        }

        //0,1 TMatrixD* ProdMat = new TMatrixD(fkFlowSCNvar,fkFlowSCNvar); (*ProdMat)(k,z)

        if(fabs(Var[2]*Var[3]-Cov[2][3]*Cov[2][3])>0.) {
          Double_t ParCov = Cov[0][1] - ( Cov[0][2]*Var[2]*Cov[2][1] + Cov[0][3]*Var[3]*Cov[3][1] - Cov[2][3]*(Cov[0][2]*Cov[3][1] + Cov[0][3]*Cov[2][1]) ) / (Var[2]*Var[3]-Cov[2][3]*Cov[2][3]);

          fFlowSCFinalHist[i][3]->SetBinContent(c+1,ParCov);
          fFlowSCFinalHist[i][3]->SetBinError(c+1,ParCov/4.);
        }

        if(fabs(NorVar[2]*NorVar[3]-NorCov[2][3]*NorCov[2][3])>0.) {
          Double_t ParNorCov = NorCov[0][1] - ( NorCov[0][2]*NorVar[2]*NorCov[2][1]*(pow(Aver[2],2.)/pow(Aver[3],2.)) + NorCov[0][3]*NorVar[3]*NorCov[3][1]*(pow(Aver[3],2.)/pow(Aver[2],2.)) - NorCov[2][3]*(NorCov[0][2]*NorCov[3][1] + NorCov[0][3]*NorCov[2][1]) ) / (NorVar[2]*NorVar[3]-NorCov[2][3]*NorCov[2][3]);

          fFlowSCFinalHist[i][4]->SetBinContent(c+1,ParNorCov);
          fFlowSCFinalHist[i][4]->SetBinError(c+1,ParNorCov/4.);
        }

      }

    } // end of for(Int_t i=0; i<fSCv2vsZNHarm; i++)

  } // end of if (fUseZDC)

  // *************************************************************************

  // FINALISE (calculate flow)

  for(Int_t hr=0; hr<fFlowNHarm; hr++) {
    // calculate covariance
    for(Int_t pt=1; pt<=fFlowQCIntCorHist[hr][0]->GetNbinsX(); pt++) {
      // average reduced correlations:
      Double_t two = fFlowQCIntCorHist[hr][0]->GetBinContent(pt); // <<2>>
      Double_t four = fFlowQCIntCorHist[hr][1]->GetBinContent(pt); // <<4>>
      // sum of weights for reduced correlation:
      Double_t sumOfWeightsForTwo = GetSumPro(fFlowQCIntCorPro[hr][0],pt); // sum_{i=1}^{N} w_{<2>}
      Double_t sumOfWeightsForFour = GetSumPro(fFlowQCIntCorPro[hr][1],pt); // sum_{i=1}^{N} w_{<4>}
      // product of weights for reduced correlation:
      Double_t productOfWeightsForTwoFour = GetSumPro(fFlowQCIntCorPro[hr][2],pt); // sum_{i=1}^{N} w_{<2>}w_{<4>}
      // products for differential flow:
      Double_t twoFour = fFlowQCIntCorHist[hr][2]->GetBinContent(pt); // <<2><4>>

      // <2>,<4>:
      Double_t term1 = productOfWeightsForTwoFour;
      Double_t term2 = sumOfWeightsForTwo;
      Double_t term3 = sumOfWeightsForFour;
      if(term2*term3>0.)
      {
        Double_t denominator = 1.-term1/(term2*term3);
        Double_t prefactor = term1/(term2*term3);
        if(TMath::Abs(denominator)>1.e-6)
        {
          Double_t covTwoFour = (twoFour-two*four)/denominator;
          Double_t wCovTwoFour = covTwoFour*prefactor;
          fFlowQCIntCorHist[hr][2]->SetBinContent(pt,wCovTwoFour);
        }
      }
    } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)

    // 2- and 4-particle cumulants
    for(Int_t pt=1; pt<=fFlowQCIntCorHist[hr][0]->GetNbinsX(); pt++) {
      Double_t QC2    = fFlowQCIntCorHist[hr][0]->GetBinContent(pt);
      Double_t QC2E   = fFlowQCIntCorHist[hr][0]->GetBinError(pt);
      Double_t QC4    = fFlowQCIntCorHist[hr][1]->GetBinContent(pt);
      Double_t QC4E   = fFlowQCIntCorHist[hr][1]->GetBinError(pt);
      Double_t wCov24 = fFlowQCIntCorHist[hr][2]->GetBinContent(pt);
      Double_t Cn2 = QC2;
      Double_t Cn2E = QC2E;
      Double_t Cn4 = QC4-2.*QC2*QC2;
      Double_t Cn4Esq = 16.*pow(QC2,2.)*pow(QC2E,2) + pow(QC4E,2.) - 8.*QC2*wCov24;

      if(fNUAforCRC) {
        Double_t Cos1 = fFlowQCIntCorNUAHist[hr][0]->GetBinContent(pt);
        Double_t Sin1 = fFlowQCIntCorNUAHist[hr][1]->GetBinContent(pt);
        Cn2 = Cn2 - Cos1*Cos1 - Sin1*Sin1;
        Double_t Sin1P2 = fFlowQCIntCorNUAHist[hr][2]->GetBinContent(pt);
        Double_t Cos1P2 = fFlowQCIntCorNUAHist[hr][3]->GetBinContent(pt);
        Double_t Sin1M2M3 = fFlowQCIntCorNUAHist[hr][4]->GetBinContent(pt);
        Double_t Cos1M2M3 = fFlowQCIntCorNUAHist[hr][5]->GetBinContent(pt);
        Cn4 = Cn4 - 4.*Cos1*Cos1M2M3 + 4.*Sin1*Sin1M2M3 - Cos1P2*Cos1P2 - Sin1P2*Sin1P2
        + 4.*Cos1P2*(Cos1*Cos1 - Sin1*Sin1) + 8.*Sin1P2*Sin1*Cos1
        + 8.*QC2*(Cos1*Cos1 + Sin1*Sin1) - 6.*pow(Cos1*Cos1 + Sin1*Sin1,2.);
      }

      fFlowQCIntCumHist[hr][0]->SetBinContent(pt,Cn2);
      fFlowQCIntCumHist[hr][0]->SetBinError(pt,Cn2E);

      if(Cn4Esq>0.) {
        Double_t Cn4E = pow(Cn4Esq,0.5);
        fFlowQCIntCumHist[hr][1]->SetBinContent(pt,Cn4);
        fFlowQCIntCumHist[hr][1]->SetBinError(pt,Cn4E);
        if (Cn4<0.) {
          Double_t Flow4 = pow(fabs(Cn4),0.25);
          Double_t Flow4E = fabs(Flow4/(4.*Cn4))*Cn4E;
          fFlowQCIntCorHist[hr][2]->SetBinContent(pt,Flow4);
          fFlowQCIntCorHist[hr][2]->SetBinError(pt,Flow4E);
        } else {
          fFlowQCIntCorHist[hr][2]->SetBinContent(pt,0.);
          fFlowQCIntCorHist[hr][2]->SetBinError(pt,0.);
        }
      }
    }

    // 2-particle with Eta Gap
    if(fFlowQCIntCorProEG[hr]->GetEntries()>0) {
      for(Int_t pt=1; pt<=fFlowQCIntCorHistEG[hr]->GetNbinsX(); pt++) {
        Double_t QC2    = fFlowQCIntCorHistEG[hr]->GetBinContent(pt);
        Double_t QC2Err = fFlowQCIntCorHistEG[hr]->GetBinError(pt);
        if(fNUAforCRC) {
          Double_t QARe = fFlowQCIntCorNUAHistEG[hr][0]->GetBinContent(pt);
          Double_t QAIm = fFlowQCIntCorNUAHistEG[hr][1]->GetBinContent(pt);
          Double_t QBRe = fFlowQCIntCorNUAHistEG[hr][2]->GetBinContent(pt);
          Double_t QBIm = fFlowQCIntCorNUAHistEG[hr][3]->GetBinContent(pt);
          QC2 = QC2-QARe*QBRe-QAIm*QBIm;
        }
        fFlowQCIntCumHist[hr][2]->SetBinContent(pt,QC2);
        fFlowQCIntCumHist[hr][2]->SetBinError(pt,QC2Err);
        if(QC2>0.) {
          Double_t Flow2 = pow(fabs(QC2),0.5);
          Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
          fFlowQCIntCorHistEG[hr]->SetBinContent(pt,Flow2);
          fFlowQCIntCorHistEG[hr]->SetBinError(pt,Flow2E);
        }
      }
      for(Int_t pt=1; pt<=fFlowQCIntCorHist[hr][0]->GetNbinsX(); pt++) {
        Double_t QC2    = fFlowQCIntCorHist[hr][3]->GetBinContent(pt);
        Double_t QC2Err = fFlowQCIntCorHist[hr][3]->GetBinError(pt);

        fFlowQCIntCumHist[hr][3]->SetBinContent(pt,QC2);
        fFlowQCIntCumHist[hr][3]->SetBinError(pt,QC2Err);

        if(QC2>0.) {
          Double_t Flow2 = pow(fabs(QC2),0.5);
          Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
          fFlowQCIntCorHist[hr][3]->SetBinContent(pt,Flow2);
          fFlowQCIntCorHist[hr][3]->SetBinError(pt,Flow2E);
        }
      }
      for(Int_t pt=1; pt<=fFlowQCIntCorHist[hr][0]->GetNbinsX(); pt++) {
        Double_t QC2    = fFlowQCIntCorHist[hr][4]->GetBinContent(pt);
        Double_t QC2Err   = fFlowQCIntCorHist[hr][4]->GetBinError(pt);

        fFlowQCIntCumHist[hr][4]->SetBinContent(pt,QC2);
        fFlowQCIntCumHist[hr][4]->SetBinError(pt,QC2Err);

        if(QC2>0.) {
          Double_t Flow2 = pow(fabs(QC2),0.5);
          Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
          fFlowQCIntCorHist[hr][4]->SetBinContent(pt,Flow2);
          fFlowQCIntCorHist[hr][4]->SetBinError(pt,Flow2E);
        }
      }
    }

    // *************************************************************************
    // *************************************************************************

    // Pt-DIFFERENTIAL

    for(Int_t j=0; j<fFlowQCNRef; j++) {
      for(Int_t pt=1;pt<=fFlowQCRefCorPro[hr][j]->GetNbinsX();pt++) {
        Double_t stats[6]={0.};
        fFlowQCRefCorPro[hr][j]->GetXaxis()->SetRange(pt,pt);
        fFlowQCRefCorPro[hr][j]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowQCRefCorHist[hr][j]->SetBinContent(pt,Corr);
            fFlowQCRefCorHist[hr][j]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=100;pt++)
      fFlowQCRefCorPro[hr][j]->GetXaxis()->SetRange(1,fFlowQCRefCorPro[hr][j]->GetNbinsX());
    } // end of for(Int_t j=0; j<5; j++)

    for (Int_t h=0; h<fCRCnCen; h++) {

      // STORE IN HISTOGRAMS

      for(Int_t j=0; j<fFlowQCNPro; j++) {
        for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {

          Double_t stats[6]={0.};
          fFlowQCCorPro[h][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowQCCorPro[h][hr][j]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowQCCorHist[h][hr][j]->SetBinContent(pt,Corr);
              fFlowQCCorHist[h][hr][j]->SetBinError(pt,CorrErr);
            }
          }

        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
        fFlowQCCorPro[h][hr][j]->GetXaxis()->SetRange(1,fPtDiffNBins);
      } // end of for(Int_t j=0; j<fFlowQCNPro; j++)
      for(Int_t j=0; j<fFlowQCNNUA; j++) {
        for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {

          Double_t stats[6]={0.};
          fFlowQCCorNUAPro[h][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowQCCorNUAPro[h][hr][j]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowQCCorNUAHist[h][hr][j]->SetBinContent(pt,Corr);
              fFlowQCCorNUAHist[h][hr][j]->SetBinError(pt,CorrErr);
            }
          }

        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
        fFlowQCCorNUAPro[h][hr][j]->GetXaxis()->SetRange(1,fPtDiffNBins);
      } // end of for(Int_t j=0; j<fFlowQCNNUA; j++)

      // calculate covariances

      // average correlations:
      Double_t two = fFlowQCRefCorHist[hr][0]->GetBinContent(h+1); // <<2>>
      Double_t four = fFlowQCRefCorHist[hr][1]->GetBinContent(h+1); // <<4>>
      Double_t twoEG = fFlowQCRefCorHist[hr][2]->GetBinContent(h+1); // <<2>> EG
      // sum of weights for correlation:
      Double_t sumOfWeightsForTwo = GetSumPro(fFlowQCRefCorPro[hr][0],h+1);
      Double_t sumOfWeightsForFour = GetSumPro(fFlowQCRefCorPro[hr][1],h+1);
      Double_t sumOfWeightsForTwoEG = GetSumPro(fFlowQCRefCorPro[hr][2],h+1);
      // product of weights for correlation:
      Double_t productOfWeightsForTwoFour = GetSumPro(fFlowQCRefCorPro[hr][13],h+1); // sum_{i=1}^{N} w_{<2>}w_{<4>}
      // products for differential flow:
      Double_t twoFour = fFlowQCRefCorHist[hr][13]->GetBinContent(h+1); // <<2><4>>
      // denominators in the expressions for the unbiased estimators for covariances:
      // denominator = 1 - term1/(term2*term3)
      // prefactor = term1/(term2*term3)
      Double_t term1 = 0.;
      Double_t term2 = 0.;
      Double_t term3 = 0.;
      Double_t denominator = 0.;
      Double_t prefactor = 0.;
      // <2>,<4>:
      term1 = productOfWeightsForTwoFour;
      term2 = sumOfWeightsForTwo;
      term3 = sumOfWeightsForFour;
      if(term2*term3>0.)
      {
        denominator = 1.-term1/(term2*term3);
        prefactor = term1/(term2*term3);
        if(TMath::Abs(denominator)>1.e-6)
        {
          Double_t covTwoFour = (twoFour-two*four)/denominator;
          Double_t wCovTwoFour = covTwoFour*prefactor;
          fFlowQCRefCorHist[hr][13]->SetBinContent(h+1,wCovTwoFour);
        }
      }

      for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {
        // average reduced correlations:
        Double_t twoReduced = fFlowQCCorHist[h][hr][1]->GetBinContent(pt); // <<2'>>
        Double_t fourReduced = fFlowQCCorHist[h][hr][2]->GetBinContent(pt); // <<4'>>
        Double_t twoReducedEG = fFlowQCCorHist[h][hr][3]->GetBinContent(pt); // <<2'>> EG
        Double_t twoReducedEGB = fFlowQCCorHist[h][hr][0]->GetBinContent(pt); // <<2'>> EG reversed

        // sum of weights for reduced correlation:
        Double_t sumOfWeightsForTwoReduced = GetSumPro(fFlowQCCorPro[h][hr][1],pt); // sum_{i=1}^{N} w_{<2'>}
        Double_t sumOfWeightsForFourReduced = GetSumPro(fFlowQCCorPro[h][hr][2],pt); // sum_{i=1}^{N} w_{<4'>}
        Double_t sumOfWeightsForTwoReducedEG = GetSumPro(fFlowQCCorPro[h][hr][3],pt); // sum_{i=1}^{N} w_{<2'>} EG
        Double_t sumOfWeightsForTwoReducedEGB = GetSumPro(fFlowQCCorPro[h][hr][0],pt); // sum_{i=1}^{N} w_{<2'>} EG reversed

        // product of weights for reduced correlation:
        Double_t productOfWeightsForTwoTwoReduced = GetSumPro(fFlowQCCorCovPro[h][hr][0],pt); // sum_{i=1}^{N} w_{<2>}w_{<2'>}
        Double_t productOfWeightsForTwoFourReduced = GetSumPro(fFlowQCCorCovPro[h][hr][2],pt); // sum_{i=1}^{N} w_{<2>}w_{<4'>}
        Double_t productOfWeightsForFourTwoReduced = GetSumPro(fFlowQCCorCovPro[h][hr][1],pt); // sum_{i=1}^{N} w_{<4>}w_{<2'>}
        Double_t productOfWeightsForFourFourReduced = GetSumPro(fFlowQCCorCovPro[h][hr][4],pt); // sum_{i=1}^{N} w_{<4>}w_{<4'>}
        Double_t productOfWeightsForTwoReducedFourReduced = GetSumPro(fFlowQCCorCovPro[h][hr][3],pt); // sum_{i=1}^{N} w_{<2'>}w_{<4'>}
        Double_t productOfWeightsForTwoTwoReducedEG = GetSumPro(fFlowQCCorCovPro[h][hr][5],pt); // sum_{i=1}^{N} w_{<2>}w_{<2'>} EG
        Double_t productOfWeightsForTwoTwoReducedEGB = GetSumPro(fFlowQCCorCovPro[h][hr][6],pt); // sum_{i=1}^{N} w_{<2>}w_{<2'>} EG reversed
        Double_t productOfWeightsForTwoReducedEGTwoReducedEGB = GetSumPro(fFlowQCCorCovPro[h][hr][7],pt); // sum_{i=1}^{N} w_{<2'>}w_{<2'>} EG reversed

        // products for differential flow:
        Double_t twoTwoReduced = fFlowQCCorCovPro[h][hr][0]->GetBinContent(pt); // <<2><2'>>
        Double_t twoFourReduced = fFlowQCCorCovPro[h][hr][2]->GetBinContent(pt); // <<2><4'>>
        Double_t fourTwoReduced = fFlowQCCorCovPro[h][hr][1]->GetBinContent(pt); // <<4><2'>>
        Double_t fourFourReduced = fFlowQCCorCovPro[h][hr][4]->GetBinContent(pt); // <<4><4'>>
        Double_t twoReducedFourReduced = fFlowQCCorCovPro[h][hr][3]->GetBinContent(pt); // <<2'><4'>>
        Double_t twoTwoReducedEG = fFlowQCCorCovPro[h][hr][5]->GetBinContent(pt); // <<2><2'>> EG
        Double_t twoTwoReducedEGB = fFlowQCCorCovPro[h][hr][6]->GetBinContent(pt); // <<2><2'>> EG reversed
        Double_t twoReducedEGTwoReducedEGB = fFlowQCCorCovPro[h][hr][7]->GetBinContent(pt); // <<2><2'>> EG reversed

        // unbiased estimators for covariances for differential flow:
        Double_t covTwoTwoReduced = 0.; // Cov(<2>,<2'>)
        Double_t wCovTwoTwoReduced = 0.; // Cov(<2>,<2'>) * prefactor(w_{<2>},w_{<2'>})
        Double_t covTwoFourReduced = 0.; // Cov(<2>,<4'>)
        Double_t wCovTwoFourReduced = 0.; // Cov(<2>,<4'>) * prefactor(w_{<2>},w_{<4'>})
        Double_t covFourTwoReduced = 0.; // Cov(<4>,<2'>)
        Double_t wCovFourTwoReduced = 0.; // Cov(<4>,<2'>) * prefactor(w_{<4>},w_{<2'>})
        Double_t covFourFourReduced = 0.; // Cov(<4>,<4'>)
        Double_t wCovFourFourReduced = 0.; // Cov(<4>,<4'>) * prefactor(w_{<4>},w_{<4'>})
        Double_t covTwoReducedFourReduced = 0.; // Cov(<2'>,<4'>)
        Double_t wCovTwoReducedFourReduced = 0.; // Cov(<2'>,<4'>) * prefactor(w_{<2'>},w_{<4'>})

        // <2>,<2'>:
        term1 = productOfWeightsForTwoTwoReduced;
        term2 = sumOfWeightsForTwo;
        term3 = sumOfWeightsForTwoReduced;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoTwoReduced = (twoTwoReduced-two*twoReduced)/denominator;
            wCovTwoTwoReduced = covTwoTwoReduced*prefactor;
            fFlowQCCorCovHist[h][hr][0]->SetBinContent(pt,wCovTwoTwoReduced);
          }
        }
        // <2>,<4'>:
        term1 = productOfWeightsForTwoFourReduced;
        term2 = sumOfWeightsForTwo;
        term3 = sumOfWeightsForFourReduced;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoFourReduced = (twoFourReduced-two*fourReduced)/denominator;
            wCovTwoFourReduced = covTwoFourReduced*prefactor;
            fFlowQCCorCovHist[h][hr][1]->SetBinContent(pt,wCovTwoFourReduced);
          }
        }
        // <4>,<2'>:
        term1 = productOfWeightsForFourTwoReduced;
        term2 = sumOfWeightsForFour;
        term3 = sumOfWeightsForTwoReduced;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covFourTwoReduced = (fourTwoReduced-four*twoReduced)/denominator;
            wCovFourTwoReduced = covFourTwoReduced*prefactor;
            fFlowQCCorCovHist[h][hr][2]->SetBinContent(pt,wCovFourTwoReduced);
          }
        }
        // <4>,<4'>:
        term1 = productOfWeightsForFourFourReduced;
        term2 = sumOfWeightsForFour;
        term3 = sumOfWeightsForFourReduced;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covFourFourReduced = (fourFourReduced-four*fourReduced)/denominator;
            wCovFourFourReduced = covFourFourReduced*prefactor;
            fFlowQCCorCovHist[h][hr][3]->SetBinContent(pt,wCovFourFourReduced);
          }
        }
        // <2'>,<4'>:
        term1 = productOfWeightsForTwoReducedFourReduced;
        term2 = sumOfWeightsForTwoReduced;
        term3 = sumOfWeightsForFourReduced;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoReducedFourReduced = (twoReducedFourReduced-twoReduced*fourReduced)/denominator;
            wCovTwoReducedFourReduced = covTwoReducedFourReduced*prefactor;
            fFlowQCCorCovHist[h][hr][4]->SetBinContent(pt,wCovTwoReducedFourReduced);
          }
        }
        // <2>,<2'> EG:
        term1 = productOfWeightsForTwoTwoReducedEG;
        term2 = sumOfWeightsForTwoEG;
        term3 = sumOfWeightsForTwoReducedEG;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoTwoReduced = (twoTwoReducedEG-twoEG*twoReducedEG)/denominator;
            wCovTwoTwoReduced = covTwoTwoReduced*prefactor;
            fFlowQCCorCovHist[h][hr][5]->SetBinContent(pt,wCovTwoTwoReduced);
          }
        }
        // <2>,<2'> EG reversed:
        term1 = productOfWeightsForTwoTwoReducedEGB;
        term2 = sumOfWeightsForTwoEG;
        term3 = sumOfWeightsForTwoReducedEGB;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoTwoReduced = (twoTwoReducedEGB-twoEG*twoReducedEGB)/denominator;
            wCovTwoTwoReduced = covTwoTwoReduced*prefactor;
            fFlowQCCorCovHist[h][hr][6]->SetBinContent(pt,wCovTwoTwoReduced);
          }
        }
        // <2'>,<2'> EG reversed:
        term1 = productOfWeightsForTwoReducedEGTwoReducedEGB;
        term2 = sumOfWeightsForTwoReducedEG;
        term3 = sumOfWeightsForTwoReducedEGB;
        if(term2*term3>0.)
        {
          denominator = 1.-term1/(term2*term3);
          prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            covTwoTwoReduced = (twoReducedEGTwoReducedEGB-twoReducedEG*twoReducedEGB)/denominator;
            wCovTwoTwoReduced = covTwoTwoReduced*prefactor;
            fFlowQCCorCovHist[h][hr][7]->SetBinContent(pt,wCovTwoTwoReduced);
          }
        }
      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)

      // FINALISE (calculate flow)

      // reference flow
      // 2- and 4-particle cumulants
      Double_t QC2    = fFlowQCRefCorHist[hr][0]->GetBinContent(h+1);
      Double_t QC2E = fFlowQCRefCorHist[hr][0]->GetBinError(h+1);
      Double_t QC4    = fFlowQCRefCorHist[hr][1]->GetBinContent(h+1);
      Double_t QC4E = fFlowQCRefCorHist[hr][1]->GetBinError(h+1);
      Double_t Cn2 = QC2;
      Double_t Cn2E = QC2E;
      Double_t wCov24 = fFlowQCRefCorHist[hr][13]->GetBinContent(h+1);
      Double_t Cn4 = QC4-2.*QC2*QC2;
      Double_t Cn4Esq = 16.*pow(QC2,2.)*pow(QC2E,2) + pow(QC4E,2.) - 8.*QC2*wCov24;

      Double_t Cos1 = fFlowQCRefCorHist[hr][3]->GetBinContent(h+1); // <<cos(n*phi1)>>
      Double_t Sin1 = fFlowQCRefCorHist[hr][4]->GetBinContent(h+1); // <<sin(n*phi1)>>
      Double_t Sin1P2 = fFlowQCRefCorHist[hr][5]->GetBinContent(h+1);
      Double_t Cos1P2 = fFlowQCRefCorHist[hr][6]->GetBinContent(h+1);
      Double_t Sin1M2M3 = fFlowQCRefCorHist[hr][7]->GetBinContent(h+1);
      Double_t Cos1M2M3 = fFlowQCRefCorHist[hr][8]->GetBinContent(h+1);
      // change vocabulary, to be changed
      Double_t cosP1nPhi = fFlowQCRefCorHist[hr][3]->GetBinContent(h+1); // <<cos(n*phi1)>>
      Double_t sinP1nPhi = fFlowQCRefCorHist[hr][4]->GetBinContent(h+1); // <<sin(n*phi1)>>
      Double_t sinP1nPhi1P1nPhi2 = fFlowQCRefCorHist[hr][5]->GetBinContent(h+1); //sin(n*(phi1+phi2))
      Double_t cosP1nPhi1P1nPhi2 = fFlowQCRefCorHist[hr][6]->GetBinContent(h+1);  //cos(n*(phi1+phi2))
      Double_t sinP1nPhi1M1nPhi2M1nPhi3 = fFlowQCRefCorHist[hr][7]->GetBinContent(h+1);  //sin(n*(phi1-phi2-phi3))
      Double_t cosP1nPhi1M1nPhi2M1nPhi3 = fFlowQCRefCorHist[hr][8]->GetBinContent(h+1); //cos(n*(phi1-phi2-phi3))
      if(fNUAforCRC) {
        Cn2 = Cn2 - Cos1*Cos1 - Sin1*Sin1;
        Cn4 = Cn4 - 4.*Cos1*Cos1M2M3 + 4.*Sin1*Sin1M2M3 - Cos1P2*Cos1P2 - Sin1P2*Sin1P2
        + 4.*Cos1P2*(Cos1*Cos1 - Sin1*Sin1) + 8.*Sin1P2*Sin1*Cos1
        + 8.*QC2*(Cos1*Cos1 + Sin1*Sin1) - 6.*pow(Cos1*Cos1 + Sin1*Sin1,2.);
      }
      fFlowQCRefCorFinal[hr][0]->SetBinContent(h+1,Cn2);
      fFlowQCRefCorFinal[hr][0]->SetBinError(h+1,Cn2E);

      if(Cn4Esq>0.) {
        Double_t Cn4E = pow(Cn4Esq,0.5);
        fFlowQCRefCorFinal[hr][3]->SetBinContent(h+1,Cn4);
        fFlowQCRefCorFinal[hr][3]->SetBinError(h+1,Cn4E);
        if(Cn4<0.) {
          Double_t Flow4 = pow(fabs(Cn4),0.25);
          Double_t Flow4E = fabs(Flow4/(4.*Cn4))*Cn4E;
          fFlowQCRefCorFinal[hr][1]->SetBinContent(h+1,Flow4);
          fFlowQCRefCorFinal[hr][1]->SetBinError(h+1,Flow4E);
        }
      }

      // 2-particle with Eta Gap
      Double_t QC2EG  = fFlowQCRefCorHist[hr][2]->GetBinContent(h+1);
      Double_t QC2EGE = fFlowQCRefCorHist[hr][2]->GetBinError(h+1);
      Double_t Cn2EG = QC2EG;
      Double_t Cn2EGE = QC2EGE;
      Double_t CosA = fFlowQCRefCorHist[hr][9]->GetBinContent(h+1);
      Double_t SinA = fFlowQCRefCorHist[hr][10]->GetBinContent(h+1);
      Double_t CosB = fFlowQCRefCorHist[hr][11]->GetBinContent(h+1);
      Double_t SinB = fFlowQCRefCorHist[hr][12]->GetBinContent(h+1);
      if(fNUAforCRC) {
        Cn2EG = Cn2EG - CosA*CosB - SinA*SinB;
      }
      if(fFlowQCIntCorProEG[hr]->GetEntries()>0) {
        Double_t Flow2 = pow(fabs(Cn2EG),0.5);
        Double_t Flow2E = fabs(Flow2/(2.*Cn2EG))*Cn2EGE;
        fFlowQCRefCorFinal[hr][2]->SetBinContent(h+1,Flow2);
        fFlowQCRefCorFinal[hr][2]->SetBinError(h+1,Flow2E);
      }

      // pt-differential
      for(Int_t pt=1; pt<=fPtDiffNBins; pt++) {

        Double_t qp2    = fFlowQCCorHist[h][hr][1]->GetBinContent(pt);
        Double_t qp2E = fFlowQCCorHist[h][hr][1]->GetBinError(pt);
        Double_t qp4    = fFlowQCCorHist[h][hr][2]->GetBinContent(pt);
        Double_t qp4E = fFlowQCCorHist[h][hr][2]->GetBinError(pt);
        Double_t Dn2 = qp2;
        Double_t Dn2E = qp2E;
        Double_t Dn4 = qp4-2.*qp2*QC2;
        Double_t wCovTwoFourReduced = fFlowQCCorCovHist[h][hr][1]->GetBinContent(pt);
        Double_t wCovTwoReducedFourReduced = fFlowQCCorCovHist[h][hr][4]->GetBinContent(pt);
        Double_t Dn4Esq = 4.*pow(QC2,2.)*pow(qp2E,2) + 4.*pow(qp2,2.)*pow(QC2E,2) + pow(qp4E,2.) - 4.*qp2*wCovTwoFourReduced - 4.*QC2*wCovTwoReducedFourReduced;

        if(fNUAforCRC) {
          Double_t Cosq = fFlowQCCorNUAHist[h][hr][1]->GetBinContent(pt);
          Double_t Sinq = fFlowQCCorNUAHist[h][hr][0]->GetBinContent(pt);
          Dn2 = Dn2 - Cosq*Cos1 - Sinq*Sin1;
          Double_t sinP1nPsi = fFlowQCCorNUAHist[h][hr][0]->GetBinContent(pt); // <<sin n(Psi)>>
          Double_t cosP1nPsi = fFlowQCCorNUAHist[h][hr][1]->GetBinContent(pt); // <<cos n(Psi)>>
          Double_t sinP1nPsi1P1nPhi2 = fFlowQCCorNUAHist[h][hr][2]->GetBinContent(pt); // <<sin n(psi1+phi2)>>
          Double_t cosP1nPsi1P1nPhi2 = fFlowQCCorNUAHist[h][hr][3]->GetBinContent(pt); // <<cos n(psi1+phi2)>>
          Double_t sinP1nPsi1P1nPhi2M1nPhi3 = fFlowQCCorNUAHist[h][hr][4]->GetBinContent(pt); // <<sin n(psi1+phi2-phi3)>>
          Double_t cosP1nPsi1P1nPhi2M1nPhi3 = fFlowQCCorNUAHist[h][hr][5]->GetBinContent(pt); // <<cos n(psi1+phi2-phi3)>>
          Double_t sinP1nPsi1M1nPhi2M1nPhi3 = fFlowQCCorNUAHist[h][hr][6]->GetBinContent(pt); // <<sin n(psi1-phi2-phi3)>>
          Double_t cosP1nPsi1M1nPhi2M1nPhi3 = fFlowQCCorNUAHist[h][hr][7]->GetBinContent(pt); // <<cos n(psi1-phi2-phi3)>>
          Dn4 = Dn4 - cosP1nPsi*cosP1nPhi1M1nPhi2M1nPhi3
              + sinP1nPsi*sinP1nPhi1M1nPhi2M1nPhi3
              - cosP1nPhi*cosP1nPsi1M1nPhi2M1nPhi3
              + sinP1nPhi*sinP1nPsi1M1nPhi2M1nPhi3
              - 2.*cosP1nPhi*cosP1nPsi1P1nPhi2M1nPhi3
              - 2.*sinP1nPhi*sinP1nPsi1P1nPhi2M1nPhi3
              - cosP1nPsi1P1nPhi2*cosP1nPhi1P1nPhi2
              - sinP1nPsi1P1nPhi2*sinP1nPhi1P1nPhi2
              + 2.*cosP1nPhi1P1nPhi2*(cosP1nPsi*cosP1nPhi-sinP1nPsi*sinP1nPhi)
              + 2.*sinP1nPhi1P1nPhi2*(cosP1nPsi*sinP1nPhi+sinP1nPsi*cosP1nPhi)
              + 4.*QC2*(cosP1nPsi*cosP1nPhi+sinP1nPsi*sinP1nPhi)
              + 2.*cosP1nPsi1P1nPhi2*(pow(cosP1nPhi,2.)-pow(sinP1nPhi,2.))
              + 4.*sinP1nPsi1P1nPhi2*cosP1nPhi*sinP1nPhi
              + 4.*qp2*(pow(cosP1nPhi,2.)+pow(sinP1nPhi,2.))
              - 6.*(pow(cosP1nPhi,2.)-pow(sinP1nPhi,2.))
              * (cosP1nPsi*cosP1nPhi-sinP1nPsi*sinP1nPhi)
              - 12.*cosP1nPhi*sinP1nPhi
              * (sinP1nPsi*cosP1nPhi+cosP1nPsi*sinP1nPhi);
        }

       fFlowQCFinalPtDifHist[h][hr][5]->SetBinContent(pt,Dn2);
       fFlowQCFinalPtDifHist[h][hr][5]->SetBinError(pt,Dn2E);

        if(Cn2) {
          Double_t Flow2 = Dn2/sqrt(fabs(Cn2));
          Double_t Flow2E = 0.;
          // change vocabulary, to be changed
          Double_t two = QC2;
          Double_t twoError = QC2E;
          Double_t twoReduced = qp2;
          Double_t twoReducedError = qp2E;
          Double_t wCovTwoTwoReduced = fFlowQCCorCovHist[h][hr][0]->GetBinContent(pt);
          Double_t v2PrimeErrorSquared = (1./4.)*pow(two,-3.)*(pow(twoReduced,2.)*pow(twoError,2.)
                                + 4.*pow(two,2.)*pow(twoReducedError,2.)
                                - 4.*two*twoReduced*wCovTwoTwoReduced);
          if(v2PrimeErrorSquared>0.){Flow2E = pow(v2PrimeErrorSquared,0.5);}

          if(Flow2E>0.) {
            fFlowQCFinalPtDifHist[h][hr][0]->SetBinContent(pt,Flow2);
            fFlowQCFinalPtDifHist[h][hr][0]->SetBinError(pt,Flow2E);
          }
        }

        if(Dn4Esq>0.) {
          Double_t Dn4E = pow(Dn4Esq,0.5);
         fFlowQCFinalPtDifHist[h][hr][6]->SetBinContent(pt,Dn4);
         fFlowQCFinalPtDifHist[h][hr][6]->SetBinError(pt,Dn4E);
        }

        if(Cn4Esq>0.) {
          Double_t Flow4 = - Dn4/pow(fabs(Cn4),0.75);
          Double_t Flow4E = 0.;
          // change vocabulary, to be changed
          Double_t two = QC2;
          Double_t twoError = QC2E;
          Double_t twoReduced = qp2;
          Double_t twoReducedError = qp2E;
          Double_t four = QC4;
          Double_t fourError = QC4E;
          Double_t fourReduced = qp4;
          Double_t fourReducedError = qp4E;
          Double_t wCovTwoTwoReduced = fFlowQCCorCovHist[h][hr][0]->GetBinContent(pt);
          Double_t wCovTwoFourReduced = fFlowQCCorCovHist[h][hr][1]->GetBinContent(pt);
          Double_t wCovFourTwoReduced = fFlowQCCorCovHist[h][hr][2]->GetBinContent(pt);
          Double_t wCovFourFourReduced = fFlowQCCorCovHist[h][hr][3]->GetBinContent(pt);
          Double_t wCovTwoReducedFourReduced = fFlowQCCorCovHist[h][hr][4]->GetBinContent(pt);
          Double_t wCovTwoFour = fFlowQCRefCorHist[hr][13]->GetBinContent(h+1);

          Double_t v4PrimeErrorSquared = 0.;
          if(2.*pow(two,2.)-four>0.) {
            v4PrimeErrorSquared = pow(2.*pow(two,2.)-four,-7./2.)
            * (pow(2.*pow(two,2.)*twoReduced-3.*two*fourReduced+2.*four*twoReduced,2.)*pow(twoError,2.)
            + (9./16.)*pow(2.*two*twoReduced-fourReduced,2.)*pow(fourError,2.)
            + 4.*pow(two,2.)*pow(2.*pow(two,2.)-four,2.)*pow(twoReducedError,2.)
            + pow(2.*pow(two,2.)-four,2.)*pow(fourReducedError,2.)
            - (3./2.)*(2.*two*twoReduced-fourReduced)
            * (2.*pow(two,2.)*twoReduced-3.*two*fourReduced+2.*four*twoReduced)*wCovTwoFour
            - 4.*two*(2.*pow(two,2.)-four)
            * (2.*pow(two,2.)*twoReduced-3.*two*fourReduced+2.*four*twoReduced)*wCovTwoTwoReduced
            + 2.*(2.*pow(two,2.)-four)
            * (2.*pow(two,2.)*twoReduced-3.*two*fourReduced+2.*four*twoReduced)*wCovTwoFourReduced
            + 3.*two*(2.*pow(two,2.)-four)*(2.*two*twoReduced-fourReduced)*wCovFourTwoReduced
            - (3./2.)*(2.*pow(two,2.)-four)*(2.*two*twoReduced-fourReduced)*wCovFourFourReduced
            - 4.*two*pow(2.*pow(two,2.)-four,2.)*wCovTwoReducedFourReduced);
          }
          if(v4PrimeErrorSquared>0.){Flow4E = pow(v4PrimeErrorSquared,0.5);}

          if(Flow4E>0.) {
            fFlowQCFinalPtDifHist[h][hr][1]->SetBinContent(pt,Flow4);
            fFlowQCFinalPtDifHist[h][hr][1]->SetBinError(pt,Flow4E);
          }
        }

        // 2-particle with Eta Gap
        if(fFlowQCIntCorProEG[hr]->GetEntries()>0) {
          Double_t qp2EG  = fFlowQCCorHist[h][hr][3]->GetBinContent(pt);
          Double_t qp2EGE = fFlowQCCorHist[h][hr][3]->GetBinError(pt);
          Double_t Dn2EG = qp2EG;
          Double_t Dn2EGE = qp2EGE;

          if(fNUAforCRC) {
            Double_t Cosq = fFlowQCCorNUAHist[h][hr][8]->GetBinContent(pt);
            Double_t Sinq = fFlowQCCorNUAHist[h][hr][9]->GetBinContent(pt);
            Dn2EG = Dn2EG - Cosq*CosB - Sinq*SinB;
          }

          fFlowQCFinalPtDifHist[h][hr][7]->SetBinContent(pt,Dn2EG);
          fFlowQCFinalPtDifHist[h][hr][7]->SetBinError(pt,Dn2EGE);

          if(Cn2EG>0.) {
            Double_t Flow2EG = Dn2EG/sqrt(Cn2EG);
            Double_t Flow2EGE = 0.;
            // change vocabulary, to be changed
            Double_t two = Cn2EG;
            Double_t twoError = Cn2EGE;
            Double_t twoReduced = qp2EG;
            Double_t twoReducedError = qp2EGE;
            Double_t wCovTwoTwoReduced = fFlowQCCorCovHist[h][hr][5]->GetBinContent(pt);
            Double_t v2PrimeErrorSquared = (1./4.)*pow(two,-3.)*(pow(twoReduced,2.)*pow(twoError,2.)
            + 4.*pow(two,2.)*pow(twoReducedError,2.)
            - 4.*two*twoReduced*wCovTwoTwoReduced);
            if(v2PrimeErrorSquared>0.){Flow2EGE = pow(v2PrimeErrorSquared,0.5);}

            if(Flow2EGE>0.) {
              fFlowQCFinalPtDifHist[h][hr][2]->SetBinContent(pt,Flow2EG);
              fFlowQCFinalPtDifHist[h][hr][2]->SetBinError(pt,Flow2EGE);
            }
          }

          // 2-particle with Eta Gap, reverse
          Double_t qp2EGB  = fFlowQCCorHist[h][hr][0]->GetBinContent(pt);
          Double_t qp2EGBE = fFlowQCCorHist[h][hr][0]->GetBinError(pt);
          Double_t Dn2EGB = qp2EGB;

          if(fNUAforCRC) {
            Double_t Cosq = fFlowQCCorNUAHist[h][hr][10]->GetBinContent(pt);
            Double_t Sinq = fFlowQCCorNUAHist[h][hr][11]->GetBinContent(pt);
            Dn2EGB = Dn2EGB - Cosq*CosA - Sinq*SinA;
          }

          //        fFlowQCFinalPtDifHist[h][hr][5]->SetBinContent(pt,Dn2EG);
          //        fFlowQCFinalPtDifHist[h][hr][5]->SetBinError(pt,Dn2EGE);

          if(Cn2EG>0.) {
            Double_t Flow2EG = Dn2EGB/sqrt(Cn2EG);
            Double_t Flow2EGE = 0.;
            // change vocabulary, to be changed
            Double_t two = Cn2EG;
            Double_t twoError = Cn2EGE;
            Double_t twoReduced = qp2EGB;
            Double_t twoReducedError = qp2EGBE;
            Double_t wCovTwoTwoReduced = fFlowQCCorCovHist[h][hr][6]->GetBinContent(pt);
            Double_t v2PrimeErrorSquared = (1./4.)*pow(two,-3.)*(pow(twoReduced,2.)*pow(twoError,2.)
            + 4.*pow(two,2.)*pow(twoReducedError,2.)
            - 4.*two*twoReduced*wCovTwoTwoReduced);
            if(v2PrimeErrorSquared>0.){Flow2EGE = pow(v2PrimeErrorSquared,0.5);}

            if(Flow2EGE>0.) {
              fFlowQCFinalPtDifHist[h][hr][3]->SetBinContent(pt,Flow2EG);
              fFlowQCFinalPtDifHist[h][hr][3]->SetBinError(pt,Flow2EGE);
            }
          }

          // 2-particle with Eta Gap, combo
          if(Cn2EG>0.) {
            Double_t Flow2EG = Dn2EGB/sqrt(Cn2EG);
            Double_t Flow2EGE = 0.;
            // change vocabulary, to be changed
            Double_t two = Cn2EG;
            Double_t twoError = Cn2EGE;
            Double_t twoReduced = qp2EGB;
            Double_t twoReducedError = qp2EGBE;
            Double_t wCovTwoTwoReduced = fFlowQCCorCovHist[h][hr][6]->GetBinContent(pt);
            Double_t v2PrimeErrorSquared = (1./4.)*pow(two,-3.)*(pow(twoReduced,2.)*pow(twoError,2.)
            + 4.*pow(two,2.)*pow(twoReducedError,2.)
            - 4.*two*twoReduced*wCovTwoTwoReduced);
            if(v2PrimeErrorSquared>0.){Flow2EGE = pow(v2PrimeErrorSquared,0.5);}

            if(Flow2EGE>0.) {
              fFlowQCFinalPtDifHist[h][hr][4]->SetBinContent(pt,Flow2EG);
              fFlowQCFinalPtDifHist[h][hr][4]->SetBinError(pt,Flow2EGE);
            }
          }
        }

      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
    } // end of for (Int_t h=0; h<fCRCnCen; h++)

    // *************************************************************************
    // *************************************************************************

    // TEST

    for(Int_t j=0; j<fkFlowQCnIntCorTest; j++) {
      for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++) {
        for(Int_t cb=1;cb<=fFlowQCIntCorProTest[hr][k][j]->GetNbinsX();cb++) {
          for(Int_t pt=1;pt<=fFlowQCIntCorProTest[hr][k][j]->GetNbinsY();pt++) {
            Double_t stats[9]={0.};
            fFlowQCIntCorProTest[hr][k][j]->GetYaxis()->SetRange(pt,pt);
            fFlowQCIntCorProTest[hr][k][j]->GetXaxis()->SetRange(cb,cb);
            fFlowQCIntCorProTest[hr][k][j]->GetStats(stats);
            Double_t SumWeig   = stats[0];
            Double_t SumWeigSq  = stats[1];
            Double_t SumTwo  = stats[7];
            Double_t SumTwoSq = stats[8];

            if(SumWeig>0.) {
              Double_t Corr = SumTwo/SumWeig;
              Double_t SqCorr = SumTwoSq/SumWeig;
              Double_t Weig = SumWeig;
              Double_t SqWeig = SumWeigSq;
              Double_t spread=0., termA=0., termB=0.;
              if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
              if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
              if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
              Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
              if(CorrErr) {
                fFlowQCIntCorHistTest[hr][k][j]->SetBinContent(cb,pt,Corr);
                fFlowQCIntCorHistTest[hr][k][j]->SetBinError(cb,pt,CorrErr);
              }
            }
          } // end of for(Int_t pt=1;pt<=100;pt++)
        }
        fFlowQCIntCorProTest[hr][k][j]->GetXaxis()->SetRange(1,fFlowQCIntCorProTest[hr][k][j]->GetNbinsX());
        fFlowQCIntCorProTest[hr][k][j]->GetYaxis()->SetRange(1,fFlowQCIntCorProTest[hr][k][j]->GetNbinsY());
      }
    } // end of for(Int_t j=0; j<fkFlowQCnIntCorTest; j++)

    // FINALISE (calculate flow)
    //  for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++) {
    Int_t k=0;
      for(Int_t cb=1;cb<=fFlowQCIntCorHistTest[hr][k][0]->GetNbinsX();cb++) {
        for(Int_t pt=1;pt<=fFlowQCIntCorHistTest[hr][k][0]->GetNbinsY();pt++) {

          // pT-integrated

          // 2- and 4-particle cumulants

          Double_t QC2  = fFlowQCIntCorHistTest[hr][0][0]->GetBinContent(cb,pt);
          Double_t QC2E = fFlowQCIntCorHistTest[hr][0][0]->GetBinError(cb,pt);
          Double_t QC4  = fFlowQCIntCorHistTest[hr][1][0]->GetBinContent(cb,pt);
          Double_t QC4E = fFlowQCIntCorHistTest[hr][1][0]->GetBinError(cb,pt);
          Double_t Cn2 = QC2;
          Double_t Cn2E = QC2E;
          Double_t Cn4 = QC4-2.*QC2*QC2;
          Double_t Cn4Esq = 16.*pow(QC2,2.)*pow(QC2E,2) + pow(QC4E,2.);
          Double_t Cn4E = 0.;
          if(Cn4Esq>0.) Cn4E = sqrt(Cn4Esq);

          if(fNUAforCRC) {
            Double_t Cos1 = fFlowQCIntCorNUAProTest[hr][0]->GetBinContent(pt);
            Double_t Sin1 = fFlowQCIntCorNUAProTest[hr][1]->GetBinContent(pt);
            Cn2 = Cn2 - Cos1*Cos1 - Sin1*Sin1;
            Double_t Sin1P2 = fFlowQCIntCorNUAProTest[hr][2]->GetBinContent(pt);
            Double_t Cos1P2 = fFlowQCIntCorNUAProTest[hr][3]->GetBinContent(pt);
            Double_t Sin1M2M3 = fFlowQCIntCorNUAProTest[hr][4]->GetBinContent(pt);
            Double_t Cos1M2M3 = fFlowQCIntCorNUAProTest[hr][5]->GetBinContent(pt);
            Cn4 = Cn4 - 4.*Cos1*Cos1M2M3 + 4.*Sin1*Sin1M2M3 - Cos1P2*Cos1P2 - Sin1P2*Sin1P2
            + 4.*Cos1P2*(Cos1*Cos1 - Sin1*Sin1) + 8.*Sin1P2*Sin1*Cos1
            + 8.*QC2*(Cos1*Cos1 + Sin1*Sin1) - 6.*pow(Cos1*Cos1 + Sin1*Sin1,2.);
          }

          // store cumulants
          fFlowQCIntCumHistTest[hr][0][0]->SetBinContent(cb,pt,Cn2);
          fFlowQCIntCumHistTest[hr][0][0]->SetBinError(cb,pt,Cn2E);
          fFlowQCIntCumHistTest[hr][1][0]->SetBinContent(cb,pt,Cn4);
          fFlowQCIntCumHistTest[hr][1][0]->SetBinError(cb,pt,Cn4E);

          // store flow
          if(Cn2>0.) {
            Double_t Flow2 = pow(Cn2,0.5);
            Double_t Flow2E = Flow2*Cn2E/(2.*Cn2);
            fFlowQCIntFinHistTest[hr][0][0]->SetBinContent(cb,pt,Flow2);
            fFlowQCIntFinHistTest[hr][0][0]->SetBinError(cb,pt,Flow2E);
          }
          if(Cn4<0.) {
            Double_t Flow4 = pow(-Cn4,0.25);
            Double_t Flow4E = Flow4*Cn4E/(4.*Cn4);
            fFlowQCIntFinHistTest[hr][1][0]->SetBinContent(cb,pt,Flow4);
            fFlowQCIntFinHistTest[hr][1][0]->SetBinError(cb,pt,Flow4E);
          }

          // 2-particle with Eta Gap
          if(fFlowQCIntCorProEG[hr]->GetEntries()>0) {
            Double_t QC2EG  = fFlowQCIntCorHistTest[hr][2][0]->GetBinContent(cb,pt);
            Double_t QC2EGE = fFlowQCIntCorHistTest[hr][2][0]->GetBinError(cb,pt);
            Double_t Cn2EG = QC2EG;
            Double_t Cn2EGE = QC2EGE;

            // store cumulants
            fFlowQCIntCumHistTest[hr][2][0]->SetBinContent(cb,pt,Cn2EG);
            fFlowQCIntCumHistTest[hr][2][0]->SetBinError(cb,pt,Cn2EGE);

            // store flow
            if(Cn2EG>0.) {
              Double_t Flow2EG = pow(Cn2EG,0.5);
              Double_t Flow2EGE = Flow2EG*Cn2EGE/(2.*Cn2EG);
              fFlowQCIntFinHistTest[hr][2][0]->SetBinContent(cb,pt,Flow2EG);
              fFlowQCIntFinHistTest[hr][2][0]->SetBinError(cb,pt,Flow2EGE);
            }
          }

        } // end of for(Int_t cb=1;cb<=fFlowQCRefCorPro[hr][j]->GetNbinsX();cb++)
      } // end of for(Int_t pt=1;pt<=fFlowQCRefCorPro[hr][j]->GetNbinsY();pt++)
      //    } // end of for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++)

  } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

  // calculate pt-integrated flow in various pt-ranges *************************
  if(!fFlowQCIntPtRanCorPro[0][0][0]) return;

  for(Int_t ptr=0; ptr<fkFlowQCnPtRanges; ptr++) {
    for(Int_t hr=0; hr<fFlowNHarm; hr++) {

      // STORE IN HISTOGRAMS *******************************

      // 2- and 4-particle cumulants
      for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
        for(Int_t pt=1;pt<=fFlowQCIntPtRanCorPro[ptr][hr][j]->GetNbinsX();pt++) {
          Double_t stats[6]={0.};
          fFlowQCIntPtRanCorPro[ptr][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowQCIntPtRanCorPro[ptr][hr][j]->GetStats(stats);
          LongDouble_t SumWeig   = stats[0];
          LongDouble_t SumWeigSq  = stats[1];
          LongDouble_t SumTwo  = stats[4];
          LongDouble_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            LongDouble_t Corr = SumTwo/SumWeig;
            LongDouble_t SqCorr = SumTwoSq/SumWeig;
            LongDouble_t Weig = SumWeig;
            LongDouble_t SqWeig = SumWeigSq;
            LongDouble_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            LongDouble_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowQCIntPtRanCorHist[ptr][hr][j]->SetBinContent(pt,Corr);
              fFlowQCIntPtRanCorHist[ptr][hr][j]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=100;pt++)
        fFlowQCIntPtRanCorPro[ptr][hr][j]->GetXaxis()->SetRange(1,fFlowQCIntPtRanCorPro[ptr][hr][j]->GetNbinsX());
      } // end of for(Int_t j=0; j<5; j++)

      for (Int_t j=0; j<6; j++) {
        for(Int_t pt=1;pt<=fFlowQCIntPtRanCorNUAPro[ptr][hr][j]->GetNbinsX();pt++) {
          Double_t stats[6]={0.};
          fFlowQCIntPtRanCorNUAPro[ptr][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowQCIntPtRanCorNUAPro[ptr][hr][j]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowQCIntPtRanCorNUAHist[ptr][hr][j]->SetBinContent(pt,Corr);
              fFlowQCIntPtRanCorNUAHist[ptr][hr][j]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=100;pt++)
        fFlowQCIntPtRanCorNUAPro[ptr][hr][j]->GetXaxis()->SetRange(1,fFlowQCIntPtRanCorNUAPro[ptr][hr][j]->GetNbinsX());
      }

      // 2-particle with Eta Gap
      for(Int_t pt=1;pt<=fFlowQCIntPtRanCorProEG[ptr][hr]->GetNbinsX();pt++) {
        Double_t stats[6]={0.};
        fFlowQCIntPtRanCorProEG[ptr][hr]->GetXaxis()->SetRange(pt,pt);
        fFlowQCIntPtRanCorProEG[ptr][hr]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowQCIntPtRanCorHistEG[ptr][hr]->SetBinContent(pt,Corr);
            fFlowQCIntPtRanCorHistEG[ptr][hr]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=100;pt++)
      fFlowQCIntPtRanCorProEG[ptr][hr]->GetXaxis()->SetRange(1,fFlowQCIntPtRanCorProEG[ptr][hr]->GetNbinsX());

      for (Int_t j=0; j<4; j++) {
        for(Int_t pt=1;pt<=fFlowQCIntPtRanCorNUAProEG[ptr][hr][j]->GetNbinsX();pt++) {
          Double_t stats[6]={0.};
          fFlowQCIntPtRanCorNUAProEG[ptr][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowQCIntPtRanCorNUAProEG[ptr][hr][j]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];

          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowQCIntPtRanCorNUAHistEG[ptr][hr][j]->SetBinContent(pt,Corr);
              fFlowQCIntPtRanCorNUAHistEG[ptr][hr][j]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=100;pt++)
        fFlowQCIntPtRanCorNUAProEG[ptr][hr][j]->GetXaxis()->SetRange(1,fFlowQCIntPtRanCorNUAProEG[ptr][hr][j]->GetNbinsX());
      }

      // FINALISE flow **************************************

      // calculate covariance
      for(Int_t pt=1; pt<=fFlowQCIntPtRanCorHist[ptr][hr][0]->GetNbinsX(); pt++) {
        // average reduced correlations:
        Double_t two = fFlowQCIntPtRanCorHist[ptr][hr][0]->GetBinContent(pt); // <<2>>
        Double_t four = fFlowQCIntPtRanCorHist[ptr][hr][1]->GetBinContent(pt); // <<4>>
        // sum of weights for reduced correlation:
        Double_t sumOfWeightsForTwo = GetSumPro(fFlowQCIntPtRanCorPro[ptr][hr][0],pt); // sum_{i=1}^{N} w_{<2>}
        Double_t sumOfWeightsForFour = GetSumPro(fFlowQCIntPtRanCorPro[ptr][hr][1],pt); // sum_{i=1}^{N} w_{<4>}
        // product of weights for reduced correlation:
        Double_t productOfWeightsForTwoFour = GetSumPro(fFlowQCIntPtRanCorPro[ptr][hr][2],pt); // sum_{i=1}^{N} w_{<2>}w_{<4>}
        // products for differential flow:
        Double_t twoFour = fFlowQCIntPtRanCorHist[ptr][hr][2]->GetBinContent(pt); // <<2><4>>

        // <2>,<4>:
        Double_t term1 = productOfWeightsForTwoFour;
        Double_t term2 = sumOfWeightsForTwo;
        Double_t term3 = sumOfWeightsForFour;
        if(term2*term3>0.)
        {
          Double_t denominator = 1.-term1/(term2*term3);
          Double_t prefactor = term1/(term2*term3);
          if(TMath::Abs(denominator)>1.e-6)
          {
            Double_t covTwoFour = (twoFour-two*four)/denominator;
            Double_t wCovTwoFour = covTwoFour*prefactor;
            fFlowQCIntPtRanCorHist[ptr][hr][2]->SetBinContent(pt,wCovTwoFour);
          }
        }
      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)

      // 2- and 4-particle cumulants
      for(Int_t pt=1; pt<=fFlowQCIntPtRanCorHist[ptr][hr][0]->GetNbinsX(); pt++) {
        Double_t QC2    = fFlowQCIntPtRanCorHist[ptr][hr][0]->GetBinContent(pt);
        Double_t QC2E   = fFlowQCIntPtRanCorHist[ptr][hr][0]->GetBinError(pt);
        Double_t QC4    = fFlowQCIntPtRanCorHist[ptr][hr][1]->GetBinContent(pt);
        Double_t QC4E   = fFlowQCIntPtRanCorHist[ptr][hr][1]->GetBinError(pt);
        Double_t wCov24 = fFlowQCIntPtRanCorHist[ptr][hr][2]->GetBinContent(pt);
        Double_t Cn2 = QC2;
        Double_t Cn2E = QC2E;
        Double_t Cn4 = QC4-2.*QC2*QC2;
        Double_t Cn4Esq = 16.*pow(QC2,2.)*pow(QC2E,2) + pow(QC4E,2.) - 8.*QC2*wCov24;

        if(fNUAforCRC) {
          Double_t Cos1 = fFlowQCIntPtRanCorNUAHist[ptr][hr][0]->GetBinContent(pt);
          Double_t Sin1 = fFlowQCIntPtRanCorNUAHist[ptr][hr][1]->GetBinContent(pt);
          Cn2 = Cn2 - Cos1*Cos1 - Sin1*Sin1;
          Double_t Sin1P2 = fFlowQCIntPtRanCorNUAHist[ptr][hr][2]->GetBinContent(pt);
          Double_t Cos1P2 = fFlowQCIntPtRanCorNUAHist[ptr][hr][3]->GetBinContent(pt);
          Double_t Sin1M2M3 = fFlowQCIntPtRanCorNUAHist[ptr][hr][4]->GetBinContent(pt);
          Double_t Cos1M2M3 = fFlowQCIntPtRanCorNUAHist[ptr][hr][5]->GetBinContent(pt);
          Cn4 = Cn4 - 4.*Cos1*Cos1M2M3 + 4.*Sin1*Sin1M2M3 - Cos1P2*Cos1P2 - Sin1P2*Sin1P2
          + 4.*Cos1P2*(Cos1*Cos1 - Sin1*Sin1) + 8.*Sin1P2*Sin1*Cos1
          + 8.*QC2*(Cos1*Cos1 + Sin1*Sin1) - 6.*pow(Cos1*Cos1 + Sin1*Sin1,2.);
        }

        fFlowQCIntPtRanCumHist[ptr][hr][0]->SetBinContent(pt,Cn2);
        fFlowQCIntPtRanCumHist[ptr][hr][0]->SetBinError(pt,Cn2E);

        if(Cn4Esq>0.) {
          Double_t Cn4E = pow(Cn4Esq,0.5);
          fFlowQCIntPtRanCumHist[ptr][hr][1]->SetBinContent(pt,Cn4);
          fFlowQCIntPtRanCumHist[ptr][hr][1]->SetBinError(pt,Cn4E);
          if (Cn4<0.) {
            Double_t Flow4 = pow(fabs(Cn4),0.25);
            Double_t Flow4E = fabs(Flow4/(4.*Cn4))*Cn4E;
            fFlowQCIntPtRanCorHist[ptr][hr][2]->SetBinContent(pt,Flow4);
            fFlowQCIntPtRanCorHist[ptr][hr][2]->SetBinError(pt,Flow4E);
          } else {
            fFlowQCIntPtRanCorHist[ptr][hr][2]->SetBinContent(pt,0.);
            fFlowQCIntPtRanCorHist[ptr][hr][2]->SetBinError(pt,0.);
          }
        }
      }

      // 2-particle with Eta Gap
      if(fFlowQCIntPtRanCorProEG[ptr][hr]->GetEntries()>0) {
        for(Int_t pt=1; pt<=fFlowQCIntPtRanCorHistEG[ptr][hr]->GetNbinsX(); pt++) {
          Double_t QC2    = fFlowQCIntPtRanCorHistEG[ptr][hr]->GetBinContent(pt);
          Double_t QC2Err = fFlowQCIntPtRanCorHistEG[ptr][hr]->GetBinError(pt);
          if(fNUAforCRC) {
            Double_t QARe = fFlowQCIntPtRanCorNUAHistEG[ptr][hr][0]->GetBinContent(pt);
            Double_t QAIm = fFlowQCIntPtRanCorNUAHistEG[ptr][hr][1]->GetBinContent(pt);
            Double_t QBRe = fFlowQCIntPtRanCorNUAHistEG[ptr][hr][2]->GetBinContent(pt);
            Double_t QBIm = fFlowQCIntPtRanCorNUAHistEG[ptr][hr][3]->GetBinContent(pt);
            QC2 = QC2-QARe*QBRe-QAIm*QBIm;
          }
          fFlowQCIntPtRanCumHist[ptr][hr][2]->SetBinContent(pt,QC2);
          fFlowQCIntPtRanCumHist[ptr][hr][2]->SetBinError(pt,QC2Err);
          if(QC2>0.) {
            Double_t Flow2 = pow(fabs(QC2),0.5);
            Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
            fFlowQCIntPtRanCorHistEG[ptr][hr]->SetBinContent(pt,Flow2);
            fFlowQCIntPtRanCorHistEG[ptr][hr]->SetBinError(pt,Flow2E);
          }
        }
        for(Int_t pt=1; pt<=fFlowQCIntPtRanCorHist[ptr][hr][0]->GetNbinsX(); pt++) {
          Double_t QC2    = fFlowQCIntPtRanCorHist[ptr][hr][3]->GetBinContent(pt);
          Double_t QC2Err = fFlowQCIntPtRanCorHist[ptr][hr][3]->GetBinError(pt);

          fFlowQCIntPtRanCumHist[ptr][hr][3]->SetBinContent(pt,QC2);
          fFlowQCIntPtRanCumHist[ptr][hr][3]->SetBinError(pt,QC2Err);

          if(QC2>0.) {
            Double_t Flow2 = pow(fabs(QC2),0.5);
            Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
            fFlowQCIntPtRanCorHist[ptr][hr][3]->SetBinContent(pt,Flow2);
            fFlowQCIntPtRanCorHist[ptr][hr][3]->SetBinError(pt,Flow2E);
          }
        }
        for(Int_t pt=1; pt<=fFlowQCIntPtRanCorHist[ptr][hr][0]->GetNbinsX(); pt++) {
          Double_t QC2    = fFlowQCIntPtRanCorHist[ptr][hr][4]->GetBinContent(pt);
          Double_t QC2Err   = fFlowQCIntPtRanCorHist[ptr][hr][4]->GetBinError(pt);

          fFlowQCIntPtRanCumHist[ptr][hr][4]->SetBinContent(pt,QC2);
          fFlowQCIntPtRanCumHist[ptr][hr][4]->SetBinError(pt,QC2Err);

          if(QC2>0.) {
            Double_t Flow2 = pow(fabs(QC2),0.5);
            Double_t Flow2E = fabs(Flow2/(2.*QC2))*QC2Err;
            fFlowQCIntPtRanCorHist[ptr][hr][4]->SetBinContent(pt,Flow2);
            fFlowQCIntPtRanCorHist[ptr][hr][4]->SetBinError(pt,Flow2E);
          }
        }
      }

    } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)
  } // end of loop over pt ranges

  cout << "*************************************" << endl;
  cout << endl;

} // end of void AliFlowAnalysisCRC::FinalizeFlowQC()

//=======================================================================================================================

Double_t AliFlowAnalysisCRC::GetSumPro(TProfile *pro, Int_t bin)
{
  Double_t stats[6]={0.};
  pro->GetXaxis()->SetRange(bin,bin);
  pro->GetStats(stats);
  pro->GetXaxis()->SetRange(1,pro->GetNbinsX());
  return stats[0];
}

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeFlowGF()
{
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating v_n{m} with Generic Framework";
  cout << endl;
  cout << endl;

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNOrde; i++) {
      for(Int_t pt=1; pt<=fFlowGFIntCorPro[h][i]->GetNbinsX(); pt++) {
        Double_t stats[6]={0.};
        fFlowGFIntCorPro[h][i]->GetXaxis()->SetRange(pt,pt);
        fFlowGFIntCorPro[h][i]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];
        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowGFIntCorHist[h][i]->SetBinContent(pt,Corr);
            fFlowGFIntCorHist[h][i]->SetBinError(pt,CorrErr);
          }
        }
      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
      fFlowGFIntCorPro[h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorPro[h][i]->GetNbinsX());
    } // end of for(Int_t i=0; i<fkFlowGFNOrde; i++)
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNOrde; i++) {
      for(Int_t k=0; k<fkFlowGFNOrde; k++) {
        for(Int_t pt=1; pt<=fFlowGFIntCovPro[h][i][k]->GetNbinsX(); pt++) {
          // correlations:
          Double_t A = fFlowGFIntCorHist[h][i]->GetBinContent(pt); // <<A>>
          Double_t B = fFlowGFIntCorHist[h][k]->GetBinContent(pt); // <<B>>
          // sum of weights for correlation:
          Double_t sumOfWeightsForA = GetSumPro(fFlowGFIntCorPro[h][i],pt); // sum_{i=1}^{N} w_{<A>}
          Double_t sumOfWeightsForB = GetSumPro(fFlowGFIntCorPro[h][k],pt); // sum_{i=1}^{N} w_{<B>}
          // products for correlations:
          Double_t AB = fFlowGFIntCovPro[h][i][k]->GetBinContent(pt); // <<A><B>>
          // sum of weights for product of correlation:
          Double_t productOfWeightsForAB = GetSumPro(fFlowGFIntCovPro[h][i][k],pt); // sum_{i=1}^{N} w_{<A>}w_{<B>}
          // <A>,<B>:
          Double_t term1 = productOfWeightsForAB;
          Double_t term2 = sumOfWeightsForA;
          Double_t term3 = sumOfWeightsForB;
          if(term2*term3>0.)
          {
            Double_t denominator = 1.-term1/(term2*term3);
            Double_t prefactor = term1/(term2*term3);
            if(TMath::Abs(denominator)>1.e-6)
            {
              Double_t covAB = (AB-A*B)/denominator;
              Double_t wCovAB = covAB*prefactor;
              fFlowGFIntCovHist[h][i][k]->SetBinContent(pt,wCovAB);
            }
          }
        } // end of for(Int_t pt=1; pt<=fFlowGFIntCovPro[h][i][k]->GetNbinsX(); pt++)
        fFlowGFIntCovPro[h][i][k]->GetXaxis()->SetRange(1,fFlowGFIntCovPro[h][i][k]->GetNbinsX());
        fFlowGFIntCorPro[h][k]->GetXaxis()->SetRange(1,fFlowGFIntCorPro[h][k]->GetNbinsX());
      } // end of for(Int_t k=0; k<fkFlowGFNOrde; k++)
      fFlowGFIntCorPro[h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorPro[h][i]->GetNbinsX());
    }
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t pt=1; pt<=fFlowGFIntCorHist[h][0]->GetNbinsX(); pt++) {

      // Correlations:
      Double_t two = fFlowGFIntCorHist[h][0]->GetBinContent(pt); // <<2>>
      Double_t four = fFlowGFIntCorHist[h][1]->GetBinContent(pt); // <<4>>
      Double_t six = fFlowGFIntCorHist[h][2]->GetBinContent(pt); // <<6>>
      Double_t eight = fFlowGFIntCorHist[h][3]->GetBinContent(pt); // <<8>>
      // Statistical errors of average 2-, 4-, 6- and 8-particle azimuthal correlations:
      Double_t twoError = fFlowGFIntCorHist[h][0]->GetBinError(pt); // statistical error of <2>
      Double_t fourError = fFlowGFIntCorHist[h][1]->GetBinError(pt); // statistical error of <4>
      Double_t sixError = fFlowGFIntCorHist[h][2]->GetBinError(pt); // statistical error of <6>
      Double_t eightError = fFlowGFIntCorHist[h][3]->GetBinError(pt); // statistical error of <8>

      // Q-cumulants:
      Double_t qc2 = 0.; // QC{2}
      Double_t qc4 = 0.; // QC{4}
      Double_t qc6 = 0.; // QC{6}
      Double_t qc8 = 0.; // QC{8}
      if(TMath::Abs(two) > 0.){qc2 = two;}
      if(TMath::Abs(four) > 0.){qc4 = four-2.*pow(two,2.);}
      if(TMath::Abs(six) > 0.){qc6 = six-9.*two*four+12.*pow(two,3.);}
      if(TMath::Abs(eight) > 0.){qc8 = eight-16.*two*six-18.*pow(four,2.)+144.*pow(two,2.)*four-144.*pow(two,4.);}
      // Statistical errors of Q-cumulants:
      Double_t qc2Error = 0.;
      Double_t qc4Error = 0.;
      Double_t qc6Error = 0.;
      Double_t qc8Error = 0.;
      // Squared statistical errors of Q-cumulants:
      //Double_t qc2ErrorSquared = 0.;
      Double_t qc4ErrorSquared = 0.;
      Double_t qc6ErrorSquared = 0.;
      Double_t qc8ErrorSquared = 0.;
      // covariances:
      Double_t wCov24 = fFlowGFIntCovHist[h][0][1]->GetBinContent(pt);
      Double_t wCov26 = fFlowGFIntCovHist[h][0][2]->GetBinContent(pt);
      Double_t wCov28 = fFlowGFIntCovHist[h][0][3]->GetBinContent(pt);
      Double_t wCov46 = fFlowGFIntCovHist[h][1][2]->GetBinContent(pt);
      Double_t wCov48 = fFlowGFIntCovHist[h][1][3]->GetBinContent(pt);
      Double_t wCov68 = fFlowGFIntCovHist[h][2][3]->GetBinContent(pt);

      // Statistical error of QC{2}:
      qc2Error = twoError;
      // Statistical error of QC{4}:
      qc4ErrorSquared = 16.*pow(two,2.)*pow(twoError,2.)+pow(fourError,2.)
      - 8.*two*wCov24;
      if(qc4ErrorSquared>0.) {
        qc4Error = pow(qc4ErrorSquared,0.5);
      }
      // Statistical error of QC{6}:
      qc6ErrorSquared = 81.*pow(4.*pow(two,2.)-four,2.)*pow(twoError,2.)
      + 81.*pow(two,2.)*pow(fourError,2.)
      + pow(sixError,2.)
      - 162.*two*(4.*pow(two,2.)-four)*wCov24
      + 18.*(4.*pow(two,2.)-four)*wCov26
      - 18.*two*wCov46;
      if(qc6ErrorSquared>0.) {
        qc6Error = pow(qc6ErrorSquared,0.5);
      }
      // Statistical error of QC{8}:
      qc8ErrorSquared = 256.*pow(36.*pow(two,3.)-18.*four*two+six,2.)*pow(twoError,2.)
      + 1296.*pow(4.*pow(two,2.)-four,2.)*pow(fourError,2.)
      + 256.*pow(two,2.)*pow(sixError,2.)
      + pow(eightError,2.)
      - 1152.*(36.*pow(two,3.)-18.*four*two+six)*(4.*pow(two,2.)-four)*wCov24
      + 512.*two*(36.*pow(two,3.)-18.*four*two+six)*wCov26
      - 32.*(36.*pow(two,3.)-18.*four*two+six)*wCov28
      - 1152.*two*(4.*pow(two,2.)-four)*wCov46
      + 72.*(4.*pow(two,2.)-four)*wCov48
      - 32.*two*wCov68;
      if(qc8ErrorSquared>0.) {
        qc8Error = pow(qc8ErrorSquared,0.5);
      }
      // Store the cumulants:
      fFlowGFIntCumHist[h][0]->SetBinContent(pt,qc2);
      fFlowGFIntCumHist[h][0]->SetBinError(pt,qc2Error);
      fFlowGFIntCumHist[h][1]->SetBinContent(pt,qc4);
      fFlowGFIntCumHist[h][1]->SetBinError(pt,qc4Error);
      fFlowGFIntCumHist[h][2]->SetBinContent(pt,qc6);
      fFlowGFIntCumHist[h][2]->SetBinError(pt,qc6Error);
      fFlowGFIntCumHist[h][3]->SetBinContent(pt,qc8);
      fFlowGFIntCumHist[h][3]->SetBinError(pt,qc8Error);

      // Reference flow estimates:
      Double_t v2 = 0.; // v{2,QC}
      Double_t v4 = 0.; // v{4,QC}
      Double_t v6 = 0.; // v{6,QC}
      Double_t v8 = 0.; // v{8,QC}
      // Reference flow statistical errors:
      Double_t v2Error = 0.; // v{2,QC} stat. error
      Double_t v4Error = 0.; // v{4,QC} stat. error
      Double_t v6Error = 0.; // v{6,QC} stat. error
      Double_t v8Error = 0.; // v{8,QC} stat. error
      // calculate flow
      if(qc2>=0.){v2 = pow(qc2,0.5);}
      if(qc4<=0.){v4 = pow(-1.*qc4,1./4.);}
      if(qc6>=0.){v6 = pow((1./4.)*qc6,1./6.);}
      if(qc8<=0.){v8 = pow((-1./33.)*qc8,1./8.);}
      // Calculate stat. error for reference flow estimates from stat. error of Q-cumulants:
      if(qc2>0.){v2Error = (1./2.)*pow(qc2,-0.5)*qc2Error;}
      if(qc4<0.){v4Error = (1./4.)*pow(-qc4,-3./4.)*qc4Error;}
      if(qc6>0.){v6Error = (1./6.)*pow(2.,-1./3.)*pow(qc6,-5./6.)*qc6Error;}
      if(qc8<0.){v8Error = (1./8.)*pow(33.,-1./8.)*pow(-qc8,-7./8.)*qc8Error;}
      // Store the results:
      if(qc2>0.) {
        fFlowGFIntFinalHist[h][0]->SetBinContent(pt,v2);
        fFlowGFIntFinalHist[h][0]->SetBinError(pt,v2Error);
      }
      if(qc4<0.) {
        fFlowGFIntFinalHist[h][1]->SetBinContent(pt,v4);
        fFlowGFIntFinalHist[h][1]->SetBinError(pt,v4Error);
      }
      if(qc6>0.) {
        fFlowGFIntFinalHist[h][2]->SetBinContent(pt,v6);
        fFlowGFIntFinalHist[h][2]->SetBinError(pt,v6Error);
      }
      if(qc8<0.) {
        fFlowGFIntFinalHist[h][3]->SetBinContent(pt,v8);
        fFlowGFIntFinalHist[h][3]->SetBinError(pt,v8Error);
      }

      // from eta gap
      Double_t v2EG = fFlowQCIntCorHistEG[h]->GetBinContent(pt);

      //      // ratios (with correct errors) ******************************************

      Double_t DenTermA=0., DenTermB=0., DenTermC=0.;
      Double_t DerTwo, DerFour, DerSix, DerEight;

      if(qc2>0. && qc4<0. && qc6>0.) {
        // vn6/vn4
        DenTermA = 2.*pow(two,2.)-four;
        DenTermB = 12.*pow(two,3.)-9.*two*four+six;
        if(DenTermA>0. && DenTermB>0.) {
          DerTwo = (3.*pow(four,2.)-2.*two*six)/(2.*pow(2.,1./3.)*pow(DenTermA,5./4.)*pow(DenTermB,5./6.));
          DerFour = (-3.*two*four+six)/(4.*pow(2.,1./3.)*pow(DenTermA,5./4.)*pow(DenTermB,5./6.));
          DerSix = 1./(6.*pow(2.,1./3.)*pow(DenTermA,1./4.)*pow(DenTermB,5./6.));

          Double_t RatioErrSquared = pow(DerTwo*twoError,2.)+pow(DerFour*fourError,2.)+pow(DerSix*sixError,2.)+2.*DerTwo*DerFour*wCov24+2.*DerTwo*DerSix*wCov26+2.*DerFour*DerSix*wCov46;

          if(RatioErrSquared>0.) {
            Double_t Ratio = v6/v4;
            Double_t RatioErr = pow(RatioErrSquared,0.5);
            fFlowGFIntExtraHist[h][0]->SetBinContent(pt,Ratio);
            fFlowGFIntExtraHist[h][0]->SetBinError(pt,RatioErr);
          }
        }
      }

      if(qc2>0. && qc4<0. && qc6>0. && qc8<0.) {
        // vn8/vn4
        DenTermA = 2.*pow(two,2.)-four;
        DenTermB = 18.*(8.*pow(two,4.)-8.*two*two*four+four*four)+16.*two*six-eight;
        if(DenTermA>0. && DenTermB>0.) {
          DerTwo = (-12.*two*two*six-2.*four*six+two*(18.*four*four+eight))/(pow(33.,1./8.)*pow(DenTermA,5./4.)*pow(DenTermB,7./8.));
          DerFour = (4.*two*(-9.*two*four+4.*six)-eight)/(4.*pow(33.,1./8.)*pow(DenTermA,5./4.)*pow(DenTermB,7./8.));
          DerSix = (2.*two)/(pow(33.,1./8.)*pow(DenTermA,1./4.)*pow(DenTermB,7./8.));
          DerEight = -1./(8.*pow(33.,1./8.)*pow(DenTermA,1./4.)*pow(DenTermB,7./8.));

          Double_t RatioErrSquared = pow(DerTwo*twoError,2.)+pow(DerFour*fourError,2.)+pow(DerSix*sixError,2.)+pow(DerEight*eightError,2.)+2.*DerTwo*DerFour*wCov24+2.*DerTwo*DerSix*wCov26+2.*DerTwo*DerEight*wCov28+2.*DerFour*DerSix*wCov46+2.*DerFour*DerEight*wCov48+2.*DerSix*DerEight*wCov68;

          if(RatioErrSquared>0.) {
            Double_t Ratio = v8/v4;
            Double_t RatioErr = pow(RatioErrSquared,0.5);
            // set
            fFlowGFIntExtraHist[h][1]->SetBinContent(pt,Ratio);
            fFlowGFIntExtraHist[h][1]->SetBinError(pt,RatioErr);
          }
        }
      }

      if(qc2>0. && qc4<0. && qc6>0. && 2.*two*two-four>0. && 12.*pow(two,3.)-9.*two*four+six>0.) {
        if(two-pow(2.*two*two-four,0.5)>0.) {
          // gamma_1^exp
          DenTermA = 4.*pow(two-pow(2.*two*two-four,0.5),5./2.) * pow(2.*two*two-four,0.5) * pow(12.*pow(two,3.)-9.*two*four+six,5./6.);
          DenTermB = 8.*pow(two-pow(2.*two*two-four,0.5),5./2.) * pow(2.*two*two-four,0.5)*pow(12.*pow(two,3.)-9.*two*four+six,5./6.);
          DenTermC = 6.*pow(2.,1./3.)*pow(two-pow(2.*two*two-four,0.5),3./2.) * pow(12.*pow(two,3.)-9.*two*four+six,5./6.);
          if(TMath::Abs(DenTermA)>0. && TMath::Abs(DenTermB)>0. && TMath::Abs(DenTermC)>0.) {
            DerTwo = (-36.*pow(2.,2./3.)*pow(two,3.)*four + 2.*pow(2.,2./3.)*two*two*six + 2.*pow(2.,2./3.)*two*(12.*four*four - pow(2.*two*two-four,0.5)*six) + 3.*four*(pow(2.,2./3.)*pow(2.*two*two-four,0.5)*four - pow(2.,2./3.)*six + 2.*pow(2.*two*two-four,1./4.)*pow(12.*pow(two,3.)-9.*two*four+six,5./6.)) )
            / DenTermA;
            DerFour = (36.*pow(2.,2./3.)*pow(two,4.) - 24.*pow(2.,2./3.)*pow(two,2.)*four + pow(2.,2./3.)*pow(2.*two*two-four,0.5)*six
            + two*( -3.*pow(2.,2./3.)*pow(2.*two*two-four,1./2.)*four + 2.*pow(2.,2./3.)*six - 6.*pow(2.*two*two-four,1./4.)*pow(12.*pow(two,3.)-9.*two*four+six,5./6.)))
            / DenTermB;
            DerSix = pow(2.*two*two-four,0.5) / DenTermC;

            Double_t GammaErrSquared = pow(DerTwo*twoError,2.)+pow(DerFour*fourError,2.)+pow(DerSix*sixError,2.)+2.*DerTwo*DerFour*wCov24+2.*DerTwo*DerSix*wCov26+2.*DerFour*DerSix*wCov46;

            if(GammaErrSquared>0. && v2EG*v2EG-v4*v4>0.) {
              Double_t Gamma = -6.*sqrt(2.)*pow(v4,2.)*(v4-v6)/pow(v2EG*v2EG-v4*v4,3./2.);
              Double_t GammaErr = 6.*sqrt(2.)*pow(GammaErrSquared,0.5);
              // set
              fFlowGFIntExtraHist[h][2]->SetBinContent(pt,Gamma);
              fFlowGFIntExtraHist[h][2]->SetBinError(pt,GammaErr);
            }
          }
        }
      }

      // differences
      if(qc8<0. && qc6>0.) {
        DenTermC = (48./11.)*pow(two,4.) - (48./11.)*two*two*four + (6./11.)*four*four + (16./33.)*two*six - eight/33.;
        if(DenTermC>0.) {
          DerTwo = (9.*two*two-(9./4.)*four)/(6.*pow(3.*pow(two,3.) - (9./4.)*two*four + six/4,5./6.)) - ((192./11.)*pow(two,3.) - (96./11.)*two*four + (16./33.)*six )/(8.*pow( (48./11.)*pow(two,4.) - (48./11.)*two*two*four + (6./11.)*four*four + (16./33.)*two*six - eight/33.,7./8.));
          DerFour = (-3.*two)/(8.*pow(3.*pow(two,3.) - (9./4.)*two*four + six/4,5./6.)) - ((-48./11.)*two*two + (12./11.)*four)/(8.*pow( (48./11.)*pow(two,4.) - (48./11.)*two*two*four + (6./11.)*four*four + (16./33.)*two*six - eight/33.,7./8.));
          DerSix = 1./(24.*pow(3.*pow(two,3.) - (9./4.)*two*four + six/4,5./6.)) - (2.*two)/(33.*pow( (48./11.)*pow(two,4.) - (48./11.)*two*two*four + (6./11.)*four*four + (16./33.)*two*six - eight/33.,7./8.));
          DerEight = 1./(264.*pow( (48./11.)*pow(two,4.) - (48./11.)*two*two*four + (6./11.)*four*four + (16./33.)*two*six - eight/33.,7./8.));

          Double_t DiffErrSquared = pow(DerTwo*twoError,2.)+pow(DerFour*fourError,2.)+pow(DerSix*sixError,2.)+pow(DerEight*eightError,2.)+2.*DerTwo*DerFour*wCov24+2.*DerTwo*DerSix*wCov26+2.*DerTwo*DerEight*wCov28+2.*DerFour*DerSix*wCov46+2.*DerFour*DerEight*wCov48+2.*DerSix*DerEight*wCov68;

          if(DiffErrSquared>0.) {
            Double_t Diff = v6-v8;
            Double_t DiffErr = pow(DiffErrSquared,0.5);
            // set
            fFlowGFIntExtraHist[h][3]->SetBinContent(pt,Diff);
            fFlowGFIntExtraHist[h][3]->SetBinError(pt,DiffErr);
          }
        }
      }

      if(qc4<0. && qc6>0.) {
        DenTermC = 12.*pow(two,2.)-9.*two*four+six;
        if(DenTermC>0. && 2.*pow(two,2.)-four>0.) {
          DerTwo = 3.*four / ( 2.*pow(2.,1./3.)*pow(DenTermC,5./6.) );
          DerFour = -1./(4.*pow(2.*pow(two,2.)-four,3./4.)) + 3.*two / ( 8.*pow(DenTermC/4.,5./6.) );
          DerSix = -1. / ( 6.*pow(2.,1./3.)*pow(DenTermC,5./6.) );

          Double_t DiffErrSquared = pow(DerTwo*twoError,2.)+pow(DerFour*fourError,2.)+pow(DerSix*sixError,2.)+2.*DerTwo*DerFour*wCov24+2.*DerTwo*DerSix*wCov26+2.*DerFour*DerSix*wCov46;

          if(fFlowGFIntExtraHist[h][4] && DiffErrSquared>0.) {
            Double_t Diff = (v4-v6)/11.;
            Double_t DiffErr = pow(DiffErrSquared,0.5)/11.;
            // set
            fFlowGFIntExtraHist[h][4]->SetBinContent(pt,Diff);
            fFlowGFIntExtraHist[h][4]->SetBinError(pt,DiffErr);
          }
        }
      }

    }
  }

  // sub-sampling (if enabled)

  for(Int_t s=0; s<fkFlowGFNSubSampling; s++) {

    if(!fFlowGFIntCorProSS[0][0][0]) continue;

    for (Int_t h=0; h<fkFlowGFNHarm; h++) {
      for(Int_t i=0; i<fkFlowGFNOrde; i++) {
        for(Int_t pt=1; pt<=fFlowGFIntCorProSS[s][h][i]->GetNbinsX(); pt++) {
          Double_t stats[6]={0.};
          fFlowGFIntCorProSS[s][h][i]->GetXaxis()->SetRange(pt,pt);
          fFlowGFIntCorProSS[s][h][i]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];
          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowGFIntCorHistSS[s][h][i]->SetBinContent(pt,Corr);
              fFlowGFIntCorHistSS[s][h][i]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
        fFlowGFIntCorProSS[s][h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorProSS[s][h][i]->GetNbinsX());
      } // end of for(Int_t i=0; i<fkFlowGFNOrde; i++)
    }

    for (Int_t h=0; h<fkFlowGFNHarm; h++) {
      for(Int_t i=0; i<fkFlowGFNOrde; i++) {
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          for(Int_t pt=1; pt<=fFlowGFIntCovProSS[s][h][i][k]->GetNbinsX(); pt++) {
            // correlations:
            Double_t A = fFlowGFIntCorHistSS[s][h][i]->GetBinContent(pt); // <<A>>
            Double_t B = fFlowGFIntCorHistSS[s][h][k]->GetBinContent(pt); // <<B>>
            // sum of weights for correlation:
            Double_t sumOfWeightsForA = GetSumPro(fFlowGFIntCorProSS[s][h][i],pt); // sum_{i=1}^{N} w_{<A>}
            Double_t sumOfWeightsForB = GetSumPro(fFlowGFIntCorProSS[s][h][k],pt); // sum_{i=1}^{N} w_{<B>}
            // products for correlations:
            Double_t AB = fFlowGFIntCovProSS[s][h][i][k]->GetBinContent(pt); // <<A><B>>
            // sum of weights for product of correlation:
            Double_t productOfWeightsForAB = GetSumPro(fFlowGFIntCovProSS[s][h][i][k],pt); // sum_{i=1}^{N} w_{<A>}w_{<B>}
            // <A>,<B>:
            Double_t term1 = productOfWeightsForAB;
            Double_t term2 = sumOfWeightsForA;
            Double_t term3 = sumOfWeightsForB;
            if(term2*term3>0.)
            {
              Double_t denominator = 1.-term1/(term2*term3);
              Double_t prefactor = term1/(term2*term3);
              if(TMath::Abs(denominator)>1.e-6)
              {
                Double_t covAB = (AB-A*B)/denominator;
                Double_t wCovAB = covAB*prefactor;
                fFlowGFIntCovHistSS[s][h][i][k]->SetBinContent(pt,wCovAB);
              }
            }
          } // end of for(Int_t pt=1; pt<=fFlowGFIntCovProSS[s][h][i][k]->GetNbinsX(); pt++)
          fFlowGFIntCovProSS[s][h][i][k]->GetXaxis()->SetRange(1,fFlowGFIntCovProSS[s][h][i][k]->GetNbinsX());
          fFlowGFIntCorProSS[s][h][k]->GetXaxis()->SetRange(1,fFlowGFIntCorProSS[s][h][k]->GetNbinsX());
        } // end of for(Int_t k=0; k<fkFlowGFNOrde; k++)
        fFlowGFIntCorProSS[s][h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorProSS[s][h][i]->GetNbinsX());
      }
    }
  }

  // MIXED HARMONICS ***********************************************************

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNHarm; i++) {

      for(Int_t pt=1; pt<=fFlowGFMixedCorPro[h][i]->GetNbinsX(); pt++) {

        Double_t stats[6]={0.};
        fFlowGFMixedCorPro[h][i]->GetXaxis()->SetRange(pt,pt);
        fFlowGFMixedCorPro[h][i]->GetStats(stats);
        Double_t SumWeig   = stats[0];
        Double_t SumWeigSq  = stats[1];
        Double_t SumTwo  = stats[4];
        Double_t SumTwoSq = stats[5];

        if(SumWeig>0.) {
          Double_t Corr = SumTwo/SumWeig;
          Double_t SqCorr = SumTwoSq/SumWeig;
          Double_t Weig = SumWeig;
          Double_t SqWeig = SumWeigSq;
          Double_t spread=0., termA=0., termB=0.;
          if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
          if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
          if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
          Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
          if(CorrErr) {
            fFlowGFMixedCorHist[h][i]->SetBinContent(pt,Corr);
            fFlowGFMixedCorHist[h][i]->SetBinError(pt,CorrErr);
          }
        }

      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
      fFlowGFMixedCorPro[h][i]->GetXaxis()->SetRange(1,fFlowGFMixedCorPro[h][i]->GetNbinsX());
    }
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNHarm; i++) {

      for(Int_t pt=1; pt<=fFlowGFIntCorHist[h][0]->GetNbinsX(); pt++) {
        // Correlations:
        Double_t twoA = fFlowGFIntCumHist[h][0]->GetBinContent(pt); // <<2A>>
        Double_t twoB = fFlowGFIntCumHist[i][0]->GetBinContent(pt); // <<2B>>
        Double_t four = fFlowGFMixedCorHist[h][i]->GetBinContent(pt); // <<4>>
        // Statistical errors:
        Double_t twoAError = fFlowGFIntCumHist[h][0]->GetBinError(pt); // statistical error of <2A>
        Double_t twoBError = fFlowGFIntCumHist[i][0]->GetBinError(pt); // statistical error of <2B>
        Double_t fourError = fFlowGFMixedCorHist[h][i]->GetBinError(pt); // statistical error of <4>
        // Symmetric Cumulants:
        Double_t SC = four - twoA*twoB;
        Double_t SCErrorSquared = pow(fourError,2.) + pow(twoA*twoBError,2.) + pow(twoB*twoAError,2.); // TBI
        // Store the results:
        if(SCErrorSquared>0.) {
          fFlowGFMixedFinalHist[h][i]->SetBinContent(pt,SC);
          fFlowGFMixedFinalHist[h][i]->SetBinError(pt,pow(SCErrorSquared,0.5));
        }
      }  // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)

    }
  }

  // in wide pt bins
  for(Int_t s=0; s<fkGFPtB; s++) {

    if(!fFlowGFIntCorProPtB[0][0][0]) continue;

    for (Int_t h=0; h<fkFlowGFNHarm; h++) {
      for(Int_t i=0; i<fkFlowGFNOrde; i++) {
        for(Int_t pt=1; pt<=fFlowGFIntCorProPtB[s][h][i]->GetNbinsX(); pt++) {
          Double_t stats[6]={0.};
          fFlowGFIntCorProPtB[s][h][i]->GetXaxis()->SetRange(pt,pt);
          fFlowGFIntCorProPtB[s][h][i]->GetStats(stats);
          Double_t SumWeig   = stats[0];
          Double_t SumWeigSq  = stats[1];
          Double_t SumTwo  = stats[4];
          Double_t SumTwoSq = stats[5];
          if(SumWeig>0.) {
            Double_t Corr = SumTwo/SumWeig;
            Double_t SqCorr = SumTwoSq/SumWeig;
            Double_t Weig = SumWeig;
            Double_t SqWeig = SumWeigSq;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)
            if(CorrErr) {
              fFlowGFIntCorHistPtB[s][h][i]->SetBinContent(pt,Corr);
              fFlowGFIntCorHistPtB[s][h][i]->SetBinError(pt,CorrErr);
            }
          }
        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
        fFlowGFIntCorProPtB[s][h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorProPtB[s][h][i]->GetNbinsX());
      } // end of for(Int_t i=0; i<fkFlowGFNOrde; i++)
    }

    for (Int_t h=0; h<fkFlowGFNHarm; h++) {
      for(Int_t i=0; i<fkFlowGFNOrde; i++) {
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          for(Int_t pt=1; pt<=fFlowGFIntCovProPtB[s][h][i][k]->GetNbinsX(); pt++) {
            // correlations:
            Double_t A = fFlowGFIntCorHistPtB[s][h][i]->GetBinContent(pt); // <<A>>
            Double_t B = fFlowGFIntCorHistPtB[s][h][k]->GetBinContent(pt); // <<B>>
            // sum of weights for correlation:
            Double_t sumOfWeightsForA = GetSumPro(fFlowGFIntCorProPtB[s][h][i],pt); // sum_{i=1}^{N} w_{<A>}
            Double_t sumOfWeightsForB = GetSumPro(fFlowGFIntCorProPtB[s][h][k],pt); // sum_{i=1}^{N} w_{<B>}
            // products for correlations:
            Double_t AB = fFlowGFIntCovProPtB[s][h][i][k]->GetBinContent(pt); // <<A><B>>
            // sum of weights for product of correlation:
            Double_t productOfWeightsForAB = GetSumPro(fFlowGFIntCovProPtB[s][h][i][k],pt); // sum_{i=1}^{N} w_{<A>}w_{<B>}
            // <A>,<B>:
            Double_t term1 = productOfWeightsForAB;
            Double_t term2 = sumOfWeightsForA;
            Double_t term3 = sumOfWeightsForB;
            if(term2*term3>0.)
            {
              Double_t denominator = 1.-term1/(term2*term3);
              Double_t prefactor = term1/(term2*term3);
              if(TMath::Abs(denominator)>1.e-6)
              {
                Double_t covAB = (AB-A*B)/denominator;
                Double_t wCovAB = covAB*prefactor;
                fFlowGFIntCovHistPtB[s][h][i][k]->SetBinContent(pt,wCovAB);
              }
            }
          } // end of for(Int_t pt=1; pt<=fFlowGFIntCovProPtB[s][h][i][k]->GetNbinsX(); pt++)
          fFlowGFIntCovProPtB[s][h][i][k]->GetXaxis()->SetRange(1,fFlowGFIntCovProPtB[s][h][i][k]->GetNbinsX());
          fFlowGFIntCorProPtB[s][h][k]->GetXaxis()->SetRange(1,fFlowGFIntCorProPtB[s][h][k]->GetNbinsX());
        } // end of for(Int_t k=0; k<fkFlowGFNOrde; k++)
        fFlowGFIntCorProPtB[s][h][i]->GetXaxis()->SetRange(1,fFlowGFIntCorProPtB[s][h][i]->GetNbinsX());
      }
    }
  }

  cout << "*************************************" << endl;
  cout << endl;

} // end of void AliFlowAnalysisCRC::FinalizeFlowGF()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeFlowSPVZ()
{
  cout << "*************************************" << endl;
  cout << endl;
  cout << "calculating v_n{VZE}(pt)"; if(fNUAforCRC) { cout << " (corrected for NUA)";}
  cout << endl;
  cout << endl;

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t hr=0; hr<fCRCnHar; hr++) {
      for(Int_t j=0; j<fkFlowSPVZnHist; j++) {

        for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {

          Double_t stats[6]={0.};
          fFlowSPVZCorPro[h][hr][j]->GetXaxis()->SetRange(pt,pt);
          fFlowSPVZCorPro[h][hr][j]->GetStats(stats);
          Double_t sumw   = stats[0];
          Double_t sumw2  = stats[1];
          Double_t sumwx  = stats[4];
          Double_t sumwx2 = stats[5];
          if(sumw>0.) {
            Double_t Corr = sumwx/sumw;
            Double_t SqCorr = sumwx2/sumw;
            Double_t Weig = sumw;
            Double_t SqWeig = sumw2;
            Double_t spread=0., termA=0., termB=0.;
            if(SqCorr-pow(Corr,2.)>=0.) { spread = pow(SqCorr-pow(Corr,2.),0.5); }
            if(TMath::Abs(Weig)>0.) { termA = (pow(SqWeig,0.5)/Weig); }
            if(1.-pow(termA,2.)>0.) { termB = 1./pow(1.-pow(termA,2.),0.5); }
            Double_t CorrErr = termA*spread*termB; // final error (unbiased estimator for standard deviation)

            fFlowSPVZCorHist[h][hr][j]->SetBinContent(pt,Corr);
            fFlowSPVZCorHist[h][hr][j]->SetBinError(pt,CorrErr);
          } // end of if(sumw>0.)

        } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
      }
    } // end of for(Int_t i=0; i<4; i++)

    for(Int_t hr=0; hr<fCRCnHar; hr++) {

      Double_t cosVC = fFlowSPVZNUAPro[h][hr][0]->GetBinContent(1);
      Double_t cosVA = fFlowSPVZNUAPro[h][hr][0]->GetBinContent(2);
      Double_t sinVC = fFlowSPVZNUAPro[h][hr][0]->GetBinContent(3);
      Double_t sinVA = fFlowSPVZNUAPro[h][hr][0]->GetBinContent(4);

      Double_t VCVA    = fFlowSPVZCorHist[h][hr][0]->GetBinContent(1);
      Double_t VCVAErr = fFlowSPVZCorHist[h][hr][0]->GetBinError(1);
      if(fNUAforCRC) {
        VCVA -= cosVC*cosVA + sinVC*sinVA;
      }

      for(Int_t pt=1;pt<=fPtDiffNBins;pt++) {
        // Double_t AvPtBin = fFlowSPVZCorHist[h][hr][0]->GetBinCenter(pt);

        //    Double_t QVC    = fFlowSPVZCorHist[h][hr][0]->GetBinContent(2);
        //    Double_t QVCErr = fFlowSPVZCorHist[h][hr][0]->GetBinError(2);
        //    Double_t QVA    = fFlowSPVZCorHist[h][hr][0]->GetBinContent(3);
        //    Double_t QVAErr = fFlowSPVZCorHist[h][hr][0]->GetBinError(3);

        Double_t qpVC    = fFlowSPVZCorHist[h][hr][1]->GetBinContent(pt);
        Double_t qpVCErr = fFlowSPVZCorHist[h][hr][1]->GetBinError(pt);
        Double_t qpVA    = fFlowSPVZCorHist[h][hr][2]->GetBinContent(pt);
        Double_t qpVAErr = fFlowSPVZCorHist[h][hr][2]->GetBinError(pt);

        Double_t cosqp = fFlowSPVZNUAPro[h][hr][1]->GetBinContent(pt);
        Double_t sinqp = fFlowSPVZNUAPro[h][hr][2]->GetBinContent(pt);
        if(fNUAforCRC) {
          qpVC -= cosVC*cosqp + sinVC*sinqp;
          qpVA -= cosqp*cosVA + sinqp*sinVA;
        }

        if(TMath::Abs(VCVA)>0.) {
          Double_t Flow = pow(TMath::Abs(qpVA*qpVC/VCVA),0.5);
          Double_t FlowRE = pow(pow(qpVAErr*qpVC/VCVA,2.)+pow(qpVCErr*qpVA/VCVA,2.)+pow(VCVAErr*qpVA*qpVC/pow(VCVA,2.),2.),0.5);
          Double_t FlowE = FlowRE/(2.*Flow);
          fFlowSPVZCorHist[h][hr][3]->SetBinContent(pt,Flow);
          fFlowSPVZCorHist[h][hr][3]->SetBinError(pt,FlowE);
        }

      } // end of for(Int_t pt=1;pt<=fPtDiffNBins;pt++)
    } // end of for(Int_t hr=0; hr<fFlowNHarm; hr++)

  } // end of for (Int_t h=0; h<fCRCnCen; h++)

  cout << "*************************************" << endl;
  cout << endl;

} // end of void AliFlowAnalysisCRC::FinalizeFlowSPVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCRCPtCorr()
{

} // end of void AliFlowAnalysisCRC::FinalizeCRCPtCorr()

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeVarious()
{

} // void AliFlowAnalysisCRC::FinalizeVarious()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowProductOfCorrelations(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCovariances(TString type, TString ptOrEta) // to be improved (reimplemented)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlow(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::Calculate2DDiffFlow(TString type)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreIntFlowFlags()
{
  // a) Store all flags for integrated flow in profile fIntFlowFlags.

  if(!fIntFlowFlags)
  {
    cout<<"WARNING: fIntFlowFlags is NULL in AFAWQC::SFFIF() !!!!"<<endl;
    exit(0);
  }

  // particle weights used or not:
  fIntFlowFlags->Fill(0.5,(Int_t)fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights);
  // which event weights were used:
  if(fMultiplicityWeight->Contains("combinations"))
  {
    fIntFlowFlags->Fill(1.5,0); // 0 = "combinations" (default)
  } else if(fMultiplicityWeight->Contains("unit"))
  {
    fIntFlowFlags->Fill(1.5,1); // 1 = "unit"
  } else if(fMultiplicityWeight->Contains("multiplicity"))
  {
    fIntFlowFlags->Fill(1.5,2); // 2 = "multiplicity"
  }
  fIntFlowFlags->Fill(2.5,(Int_t)fApplyCorrectionForNUA);
  fIntFlowFlags->Fill(3.5,(Int_t)fPrintFinalResults[0]);
  fIntFlowFlags->Fill(4.5,(Int_t)fPrintFinalResults[1]);
  fIntFlowFlags->Fill(5.5,(Int_t)fPrintFinalResults[2]);
  fIntFlowFlags->Fill(6.5,(Int_t)fPrintFinalResults[3]);
  fIntFlowFlags->Fill(7.5,(Int_t)fApplyCorrectionForNUAVsM);
  fIntFlowFlags->Fill(8.5,(Int_t)fPropagateErrorAlsoFromNIT);
  fIntFlowFlags->Fill(9.5,(Int_t)fCalculateCumulantsVsM);
  fIntFlowFlags->Fill(10.5,(Int_t)fMinimumBiasReferenceFlow);
  fIntFlowFlags->Fill(11.5,(Int_t)fForgetAboutCovariances);
  fIntFlowFlags->Fill(12.5,(Int_t)fStoreVarious);
  fIntFlowFlags->Fill(13.5,(Int_t)fFillMultipleControlHistograms);
  fIntFlowFlags->Fill(14.5,(Int_t)fCalculateAllCorrelationsVsM);
  // which multiplicity was used:
  if(fMultiplicityIs==AliFlowCommonConstants::kRP) // # of Reference Particles
  {
    fIntFlowFlags->Fill(15.5,0); // 0 = # of Reference Particles
  } else if(fMultiplicityIs==AliFlowCommonConstants::kExternal)
  {
    fIntFlowFlags->Fill(15.5,1); // 1 = ref. mult. from ESD
  } else if(fMultiplicityIs==AliFlowCommonConstants::kPOI)
  {
    fIntFlowFlags->Fill(15.5,2); // 2 = # of Particles of Interest
  }
  fIntFlowFlags->Fill(16.5,(Int_t)fExactNoRPs);
  fIntFlowFlags->Fill(17.5,(Int_t)fUse2DHistograms);
  fIntFlowFlags->Fill(18.5,(Int_t)fFillProfilesVsMUsingWeights);
  fIntFlowFlags->Fill(19.5,(Int_t)fUseQvectorTerms);

} // end of void AliFlowAnalysisCRC::StoreIntFlowFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreDiffFlowFlags()
{
  // Store all flags for differential flow in the profile fDiffFlowFlags.

  if(!fDiffFlowFlags)
  {
    printf("\n WARNING (QC): fDiffFlowFlags is NULL in AFAWQC::SDFF() !!!!\n\n");
    exit(0);
  }

  fDiffFlowFlags->Fill(0.5,fCalculateDiffFlow); // calculate differential flow
  fDiffFlowFlags->Fill(1.5,fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights); // particle weights used or not?
  //fDiffFlowFlags->Fill(2.5,""); // which event weight was used? ("combinations", "unit" or "multiplicity") to be improved - finalized
  fDiffFlowFlags->Fill(3.5,fApplyCorrectionForNUA); // corrected for non-uniform acceptance or not
  fDiffFlowFlags->Fill(4.5,fCalculate2DDiffFlow); // calculate also 2D differential flow vs (pt,eta)
  fDiffFlowFlags->Fill(5.5,fCalculateDiffFlowVsEta); // if you set kFALSE only differential flow vs pt is calculated

} // end of void AliFlowAnalysisCRC::StoreDiffFlowFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreMixedHarmonicsFlags()
{
  // Store all flags for mixed harmonics in profile fMixedHarmonicsFlags.

  if(!fMixedHarmonicsFlags)
  {
    cout<<"WARNING: fMixedHarmonicsFlags is NULL in AFAWQC::SMHF() !!!!"<<endl;
    exit(0);
  }

  fMixedHarmonicsFlags->Fill(0.5,(Int_t)fCalculateMixedHarmonics);
  fMixedHarmonicsFlags->Fill(1.5,(Int_t)fHarmonic);
  fMixedHarmonicsFlags->Fill(2.5,(Int_t)fCalculateMixedHarmonicsVsM);
  // Which multiplicity weight was used?:

  if(fMultiplicityWeight->Contains("combinations"))
  {
    fMixedHarmonicsFlags->Fill(3.5,0); // 0 = "combinations" (default)
  } else if(fMultiplicityWeight->Contains("unit"))
  {
    fMixedHarmonicsFlags->Fill(3.5,1); // 1 = "unit"
  } else if(fMultiplicityWeight->Contains("multiplicity"))
  {
    fMixedHarmonicsFlags->Fill(3.5,2); // 2 = "multiplicity"
  }

} // end of void AliFlowAnalysisCRC::StoreMixedHarmonicsFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreControlHistogramsFlags()
{
  // Store all flags for control histograms in profile fControlHistogramsFlags.

  if(!fControlHistogramsFlags)
  {
    cout<<"WARNING: fControlHistogramsFlags is NULL in AFAWQC::SCHF() !!!!"<<endl;
    exit(0);
  }

  fControlHistogramsFlags->Fill(0.5,(Int_t)fStoreControlHistograms);
  fControlHistogramsFlags->Fill(1.5,(Int_t)fUseQvectorTerms);

} // end of void AliFlowAnalysisCRC::StoreControlHistogramsFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreBootstrapFlags()
{
  // Store all flags for bootstrap in TProfile fBootstrapFlags.

  if(!fBootstrapFlags)
  {
    cout<<"WARNING: fBootstrapFlags is NULL in AFAWQC::SBF() !!!!"<<endl;
    exit(0);
  }

  fBootstrapFlags->Fill(0.5,(Int_t)fUseBootstrap);
  fBootstrapFlags->Fill(1.5,(Int_t)fUseBootstrapVsM);
  fBootstrapFlags->Fill(2.5,(Int_t)fnSubsamples);

} // end of void AliFlowAnalysisCRC::StoreBootstrapFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreCRCFlags()
{
  // Store all flags for CRC in TProfile fCRCFlags.

  if(!fCRCFlags) {
    cout<<"WARNING: fCRCFlags is NULL in AFAWQC::SCRCF() !!!!"<<endl;
    exit(0);
  }

  fCRCFlags->Fill(0.5,(Int_t)fHarmonic);
  fCRCFlags->Fill(1.5,(Int_t)fCalculateCRCPt);
  fCRCFlags->Fill(2.5,(Int_t)fUseVZERO);
  fCRCFlags->Fill(3.5,(Int_t)fNUAforCRC);
  fCRCFlags->Fill(4.5,(Int_t)fUseCRCRecenter);
  fCRCFlags->Fill(5.5,(Int_t)fUseZDC);
  fCRCFlags->Fill(6.5,(Int_t)fRecenterZDC);
  fCRCFlags->Fill(7.5,(Int_t)fDivSigma);
  fCRCFlags->Fill(8.5,(Int_t)fInvertZDC);
  fCRCFlags->Fill(9.5,(Int_t)fCalculateCRCInt);
  fCRCFlags->Fill(10.5,(Int_t)fCalculateCRC2);
  fCRCFlags->Fill(11.5,(Int_t)fCalculateCRCVZ);
  fCRCFlags->Fill(12.5,(Int_t)fCalculateCRCZDC);
  fCRCFlags->Fill(13.5,(Int_t)fCalculateFlowQC);
  fCRCFlags->Fill(14.5,(Int_t)fCalculateFlowZDC);
  fCRCFlags->Fill(15.5,(Int_t)fCalculateFlowVZ);
  fCRCFlags->Fill(16.5,(Int_t)fUsePhiEtaCuts);
  fCRCFlags->Fill(17.5,(Int_t)fCalculateCME);   //@Shi

} // end of void AliFlowAnalysisCRC::StoreCRCFlags()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCommonHistograms()
{
  // Access all pointers to common control and common result histograms and profiles.

  TString sCommonConstantsName = "fCommonConstants";
  sCommonConstantsName += fAnalysisLabel->Data();
  fCommonConstants = dynamic_cast<TProfile*>(fHistList->FindObject(sCommonConstantsName.Data()));
  if(!fCommonConstants)
  {
    printf("\n WARNING (QC): fCommonConstants is NULL in AFAWQC::GPFCH() !!!!\n\n");
    exit(0);
  }

  // to be improved - lines bellow can be implemented better.

  TString commonHistsName = "AliFlowCommonHistQC";
  commonHistsName += fAnalysisLabel->Data();
  AliFlowCommonHist *commonHist = dynamic_cast<AliFlowCommonHist*>(fHistList->FindObject(commonHistsName.Data()));
  if(commonHist)
  {
    this->SetCommonHists(commonHist);
    if(fCommonHists->GetHarmonic())
    {
      fHarmonic = (Int_t)(fCommonHists->GetHarmonic())->GetBinContent(1);
    }
  } // end of if(commonHist)
  TString commonHists2ndOrderName = "AliFlowCommonHist2ndOrderQC";
  commonHists2ndOrderName += fAnalysisLabel->Data();
  AliFlowCommonHist *commonHist2nd = dynamic_cast<AliFlowCommonHist*>(fHistList->FindObject(commonHists2ndOrderName.Data()));
  if(commonHist2nd) this->SetCommonHists2nd(commonHist2nd);
  TString commonHists4thOrderName = "AliFlowCommonHist4thOrderQC";
  commonHists4thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHist *commonHist4th = dynamic_cast<AliFlowCommonHist*>(fHistList->FindObject(commonHists4thOrderName.Data()));
  if(commonHist4th) this->SetCommonHists4th(commonHist4th);
  TString commonHists6thOrderName = "AliFlowCommonHist6thOrderQC";
  commonHists6thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHist *commonHist6th = dynamic_cast<AliFlowCommonHist*>(fHistList->FindObject(commonHists6thOrderName.Data()));
  if(commonHist6th) this->SetCommonHists6th(commonHist6th);
  TString commonHists8thOrderName = "AliFlowCommonHist8thOrderQC";
  commonHists8thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHist *commonHist8th = dynamic_cast<AliFlowCommonHist*>(fHistList->FindObject(commonHists8thOrderName.Data()));
  if(commonHist8th) this->SetCommonHists8th(commonHist8th);

  TString commonHistResults2ndOrderName = "AliFlowCommonHistResults2ndOrderQC";
  commonHistResults2ndOrderName += fAnalysisLabel->Data();
  AliFlowCommonHistResults *commonHistRes2nd = dynamic_cast<AliFlowCommonHistResults*>
  (fHistList->FindObject(commonHistResults2ndOrderName.Data()));
  if(commonHistRes2nd) this->SetCommonHistsResults2nd(commonHistRes2nd);
  TString commonHistResults4thOrderName = "AliFlowCommonHistResults4thOrderQC";
  commonHistResults4thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHistResults *commonHistRes4th = dynamic_cast<AliFlowCommonHistResults*>
  (fHistList->FindObject(commonHistResults4thOrderName.Data()));
  if(commonHistRes4th) this->SetCommonHistsResults4th(commonHistRes4th);
  TString commonHistResults6thOrderName = "AliFlowCommonHistResults6thOrderQC";
  commonHistResults6thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHistResults *commonHistRes6th = dynamic_cast<AliFlowCommonHistResults*>
  (fHistList->FindObject(commonHistResults6thOrderName.Data()));
  if(commonHistRes6th) this->SetCommonHistsResults6th(commonHistRes6th);
  TString commonHistResults8thOrderName = "AliFlowCommonHistResults8thOrderQC";
  commonHistResults8thOrderName += fAnalysisLabel->Data();
  AliFlowCommonHistResults *commonHistRes8th = dynamic_cast<AliFlowCommonHistResults*>
  (fHistList->FindObject(commonHistResults8thOrderName.Data()));
  if(commonHistRes8th) this->SetCommonHistsResults8th(commonHistRes8th);

} // end of void AliFlowAnalysisCRC::GetPointersForCommonHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForParticleWeightsHistograms()
{
  // Get pointers for histograms with particle weights.
//  TList *weightsList = dynamic_cast<TList*>(fHistList->FindObject("Weights"));
//  if(!weightsList){printf("\n WARNING (QC): weightsList is NULL in AFAWQC::GPFPWH() !!!!\n");exit(0);}
//  this->SetWeightsList(weightsList);
//  TString fUseParticleWeightsName = "fUseParticleWeightsQC"; // to be improved (hirdwired label QC)
//  fUseParticleWeightsName += fAnalysisLabel->Data();
//  TProfile *useParticleWeights = dynamic_cast<TProfile*>(weightsList->FindObject(fUseParticleWeightsName.Data()));
//  if(useParticleWeights)
//  {
//    this->SetUseParticleWeights(useParticleWeights);
//    fUsePhiWeights = (Int_t)fUseParticleWeights->GetBinContent(1);
//    fUsePtWeights = (Int_t)fUseParticleWeights->GetBinContent(2);
//    fUseEtaWeights = (Int_t)fUseParticleWeights->GetBinContent(3);
//    fUseTrackWeights = (Int_t)fUseParticleWeights->GetBinContent(4);
//    fUsePhiEtaWeights = (Int_t)fUseParticleWeights->GetBinContent(5);
//    fUsePhiEtaWeightsChDep = (Int_t)fUseParticleWeights->GetBinContent(6);
//    fUsePhiEtaWeightsVtxDep = (Int_t)fUseParticleWeights->GetBinContent(7);
//    fUsePhiEtaWeightsChPtDep = (Int_t)fUseParticleWeights->GetBinContent(8);
//  }
} // end of void AliFlowAnalysisCRC::GetPointersForParticleWeightsHistograms();

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForIntFlowHistograms()
{
  // Get pointers for histograms and profiles relevant for integrated flow:
  //  a) Get pointer to base list for integrated flow holding profile fIntFlowFlags and lists fIntFlowProfiles and fIntFlowResults.
  //  b) Get pointer to profile fIntFlowFlags holding all flags for integrated flow.
  //  c) Get pointer to list fIntFlowProfiles and pointers to all objects that she holds.
  //  d) Get pointer to list fIntFlowResults and pointers to all objects that she holds.

  TString sinCosFlag[2] = {"sin","cos"}; // to be improved (should I promote this to data member?)
  TString powerFlag[2] = {"linear","quadratic"}; // to be improved (should I promote this to data member?)
  TString correlationFlag[4] = {"#LT#LT2#GT#GT","#LT#LT4#GT#GT","#LT#LT6#GT#GT","#LT#LT8#GT#GT"}; // to be improved (should I promote this to data member?)
  TString squaredCorrelationFlag[4] = {"#LT#LT2#GT^{2}#GT","#LT#LT4#GT^{2}#GT","#LT#LT6#GT^{2}#GT","#LT#LT8#GT^{2}#GT"}; // to be improved (should I promote this to data member?)

  // a) Get pointer to base list for integrated flow holding profile fIntFlowFlags and lists fIntFlowProfiles and fIntFlowResults:
  TList *intFlowList = NULL;
  intFlowList = dynamic_cast<TList*>(fHistList->FindObject("Integrated Flow"));
  if(!intFlowList)
  {
    cout<<"WARNING: intFlowList is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    exit(0);
  }

  // b) Get pointer to profile fIntFlowFlags holding all flags for integrated flow:
  TString intFlowFlagsName = "fIntFlowFlags";
  intFlowFlagsName += fAnalysisLabel->Data();
  TProfile *intFlowFlags = dynamic_cast<TProfile*>(intFlowList->FindObject(intFlowFlagsName.Data()));
  if(intFlowFlags)
  {
    this->SetIntFlowFlags(intFlowFlags);
    fApplyCorrectionForNUA = (Bool_t)intFlowFlags->GetBinContent(3);
    fApplyCorrectionForNUAVsM = (Bool_t)intFlowFlags->GetBinContent(8);
    fCalculateCumulantsVsM = (Bool_t)intFlowFlags->GetBinContent(10);
  } else
  {
    cout<<"WARNING: intFlowFlags is NULL in FAWQC::GPFIFH() !!!!"<<endl;
  }

  // c) Get pointer to list fIntFlowProfiles and pointers to all objects that she holds:
  TList *intFlowProfiles = NULL;
  intFlowProfiles = dynamic_cast<TList*>(intFlowList->FindObject("Profiles"));
  if(intFlowProfiles)
  {
    // average multiplicities:
    TString avMultiplicityName = "fAvMultiplicity";
    avMultiplicityName += fAnalysisLabel->Data();
    TProfile *avMultiplicity = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(avMultiplicityName.Data()));
    if(avMultiplicity)
    {
      this->SetAvMultiplicity(avMultiplicity);
    } else
    {
      cout<<"WARNING: avMultiplicity is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average correlations <<2>>, <<4>>, <<6>> and <<8>> (with wrong errors!):
    TString intFlowCorrelationsProName = "fIntFlowCorrelationsPro";
    intFlowCorrelationsProName += fAnalysisLabel->Data();
    TProfile *intFlowCorrelationsPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowCorrelationsProName.Data()));
    if(intFlowCorrelationsPro)
    {
      this->SetIntFlowCorrelationsPro(intFlowCorrelationsPro);
    } else
    {
      cout<<"WARNING: intFlowCorrelationsPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average squared correlations <<2>^2>, <<4>^2>, <<6>^2> and <<8^2>>:
    TString intFlowSquaredCorrelationsProName = "fIntFlowSquaredCorrelationsPro";
    intFlowSquaredCorrelationsProName += fAnalysisLabel->Data();
    TProfile *intFlowSquaredCorrelationsPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowSquaredCorrelationsProName.Data()));
    if(intFlowSquaredCorrelationsPro)
    {
      this->SetIntFlowSquaredCorrelationsPro(intFlowSquaredCorrelationsPro);
    } else
    {
      cout<<"WARNING: intFlowSquaredCorrelationsPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    if(fCalculateCumulantsVsM)
    {
      // Average correlations <<2>>, <<4>>, <<6>> and <<8>> versus multiplicity for all events (error is wrong here):
      TString intFlowCorrelationsVsMProName = "fIntFlowCorrelationsVsMPro";
      intFlowCorrelationsVsMProName += fAnalysisLabel->Data();
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        TProfile *intFlowCorrelationsVsMPro = dynamic_cast<TProfile*>
        (intFlowProfiles->FindObject(Form("%s, %s",intFlowCorrelationsVsMProName.Data(),correlationFlag[ci].Data())));
        if(intFlowCorrelationsVsMPro)
        {
          this->SetIntFlowCorrelationsVsMPro(intFlowCorrelationsVsMPro,ci);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowCorrelationsVsMPro[%d]",ci)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
      // Average squared correlations <<2>^2>, <<4>^2>, <<6>^2> and <<8>^2> versus multiplicity for all events:
      TString intFlowSquaredCorrelationsVsMProName = "fIntFlowSquaredCorrelationsVsMPro";
      intFlowSquaredCorrelationsVsMProName += fAnalysisLabel->Data();
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        TProfile *intFlowSquaredCorrelationsVsMPro = dynamic_cast<TProfile*>
        (intFlowProfiles->FindObject(Form("%s, %s",intFlowSquaredCorrelationsVsMProName.Data(),squaredCorrelationFlag[ci].Data())));
        if(intFlowSquaredCorrelationsVsMPro)
        {
          this->SetIntFlowSquaredCorrelationsVsMPro(intFlowSquaredCorrelationsVsMPro,ci);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowSquaredCorrelationsVsMPro[%d]",ci)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of if(fCalculateCumulantsVsM)
    // average all correlations for integrated flow (with wrong errors!):
    TString intFlowCorrelationsAllProName = "fIntFlowCorrelationsAllPro";
    intFlowCorrelationsAllProName += fAnalysisLabel->Data();
    TProfile *intFlowCorrelationsAllPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowCorrelationsAllProName.Data()));
    if(intFlowCorrelationsAllPro)
    {
      this->SetIntFlowCorrelationsAllPro(intFlowCorrelationsAllPro);
    } else
    {
      cout<<"WARNING: intFlowCorrelationsAllPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average extra correlations for integrated flow (which appear only when particle weights are used):
    // (to be improved: Weak point in implementation, I am assuming here that method GetPointersForParticleWeightsHistograms() was called)
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    {
      TString intFlowExtraCorrelationsProName = "fIntFlowExtraCorrelationsPro";
      intFlowExtraCorrelationsProName += fAnalysisLabel->Data();
      TProfile *intFlowExtraCorrelationsPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowExtraCorrelationsProName.Data()));
      if(intFlowExtraCorrelationsPro)
      {
        this->SetIntFlowExtraCorrelationsPro(intFlowExtraCorrelationsPro);
      } else
      {
        cout<<"WARNING: intFlowExtraCorrelationsPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
      }
    } // end of if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    // average products of correlations <2>, <4>, <6> and <8>:
    TString intFlowProductOfCorrelationsProName = "fIntFlowProductOfCorrelationsPro";
    intFlowProductOfCorrelationsProName += fAnalysisLabel->Data();
    TProfile *intFlowProductOfCorrelationsPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowProductOfCorrelationsProName.Data()));
    if(intFlowProductOfCorrelationsPro)
    {
      this->SetIntFlowProductOfCorrelationsPro(intFlowProductOfCorrelationsPro);
    } else
    {
      cout<<"WARNING: intFlowProductOfCorrelationsPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average product of correlations <2>, <4>, <6> and <8> versus multiplicity
    // [0=<<2><4>>,1=<<2><6>>,2=<<2><8>>,3=<<4><6>>,4=<<4><8>>,5=<<6><8>>]
    if(fCalculateCumulantsVsM)
    {
      TString intFlowProductOfCorrelationsVsMProName = "fIntFlowProductOfCorrelationsVsMPro";
      intFlowProductOfCorrelationsVsMProName += fAnalysisLabel->Data();
      TString productFlag[6] = {"#LT#LT2#GT#LT4#GT#GT","#LT#LT2#GT#LT6#GT#GT","#LT#LT2#GT#LT8#GT#GT",
        "#LT#LT4#GT#LT6#GT#GT","#LT#LT4#GT#LT8#GT#GT","#LT#LT6#GT#LT8#GT#GT"};
      for(Int_t pi=0;pi<6;pi++)
      {
        TProfile *intFlowProductOfCorrelationsVsMPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(Form("%s, %s",intFlowProductOfCorrelationsVsMProName.Data(),productFlag[pi].Data())));
        if(intFlowProductOfCorrelationsVsMPro)
        {
          this->SetIntFlowProductOfCorrelationsVsMPro(intFlowProductOfCorrelationsVsMPro,pi);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowProductOfCorrelationsVsMPro[%d]",pi)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t pi=0;pi<6;pi++)
    } // end of if(fCalculateCumulantsVsM)
    // average correction terms for non-uniform acceptance (with wrong errors!):
    for(Int_t sc=0;sc<2;sc++)
    {
      TString intFlowCorrectionTermsForNUAProName = "fIntFlowCorrectionTermsForNUAPro";
      intFlowCorrectionTermsForNUAProName += fAnalysisLabel->Data();
      TProfile *intFlowCorrectionTermsForNUAPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject((Form("%s: %s terms",intFlowCorrectionTermsForNUAProName.Data(),sinCosFlag[sc].Data()))));
      if(intFlowCorrectionTermsForNUAPro)
      {
        this->SetIntFlowCorrectionTermsForNUAPro(intFlowCorrectionTermsForNUAPro,sc);
      } else
      {
        cout<<"WARNING: intFlowCorrectionTermsForNUAPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        cout<<"sc = "<<sc<<endl;
      }
      // versus multiplicity:
      if(fCalculateCumulantsVsM)
      {
        TString correctionTermFlag[4] = {"(n(phi1))","(n(phi1+phi2))","(n(phi1-phi2-phi3))","(n(2phi1-phi2))"}; // to be improved - hardwired 4
        TString intFlowCorrectionTermsForNUAVsMProName = "fIntFlowCorrectionTermsForNUAVsMPro";
        intFlowCorrectionTermsForNUAVsMProName += fAnalysisLabel->Data();
        for(Int_t ci=0;ci<4;ci++) // correction term index (to be improved - hardwired 4)
        {
          TProfile *intFlowCorrectionTermsForNUAVsMPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(Form("%s: #LT#LT%s%s#GT#GT",intFlowCorrectionTermsForNUAVsMProName.Data(),sinCosFlag[sc].Data(),correctionTermFlag[ci].Data())));
          if(intFlowCorrectionTermsForNUAVsMPro)
          {
            this->SetIntFlowCorrectionTermsForNUAVsMPro(intFlowCorrectionTermsForNUAVsMPro,sc,ci);
          } else
          {
            cout<<"WARNING: intFlowCorrectionTermsForNUAVsMPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
            cout<<"sc = "<<sc<<endl;
            cout<<"ci = "<<ci<<endl;
          }
        } // end of for(Int_t ci=0;ci<4;ci++) // correction term index (to be improved - hardwired 4)
      } // end of if(fCalculateCumulantsVsM)
    } // end of for(Int_t sc=0;sc<2;sc++)
    // average products of correction terms for NUA:
    TString intFlowProductOfCorrectionTermsForNUAProName = "fIntFlowProductOfCorrectionTermsForNUAPro";
    intFlowProductOfCorrectionTermsForNUAProName += fAnalysisLabel->Data();
    TProfile *intFlowProductOfCorrectionTermsForNUAPro = dynamic_cast<TProfile*>(intFlowProfiles->FindObject(intFlowProductOfCorrectionTermsForNUAProName.Data()));
    if(intFlowProductOfCorrectionTermsForNUAPro)
    {
      this->SetIntFlowProductOfCorrectionTermsForNUAPro(intFlowProductOfCorrectionTermsForNUAPro);
    } else
    {
      cout<<"WARNING: intFlowProductOfCorrectionTermsForNUAPro is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
  } else // to if(intFlowProfiles)
  {
    cout<<"WARNING: intFlowProfiles is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
  }

  //  d) Get pointer to list fIntFlowResults and pointers to all objects that she holds.
  TList *intFlowResults = NULL;
  intFlowResults = dynamic_cast<TList*>(intFlowList->FindObject("Results"));
  if(intFlowResults)
  {
    // average correlations <<2>>, <<4>>, <<6>> and <<8>> (with correct errors!):
    TString intFlowCorrelationsHistName = "fIntFlowCorrelationsHist";
    intFlowCorrelationsHistName += fAnalysisLabel->Data();
    TH1D *intFlowCorrelationsHist = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowCorrelationsHistName.Data()));
    if(intFlowCorrelationsHist)
    {
      this->SetIntFlowCorrelationsHist(intFlowCorrelationsHist);
    } else
    {
      cout<<"WARNING: intFlowCorrelationsHist is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average correlations <<2>>, <<4>>, <<6>> and <<8>> (with correct errors!) vs M:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowCorrelationsVsMHistName = "fIntFlowCorrelationsVsMHist";
      intFlowCorrelationsVsMHistName += fAnalysisLabel->Data();
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        TH1D *intFlowCorrelationsVsMHist = dynamic_cast<TH1D*>
        (intFlowResults->FindObject(Form("%s, %s",intFlowCorrelationsVsMHistName.Data(),correlationFlag[ci].Data())));
        if(intFlowCorrelationsVsMHist)
        {
          this->SetIntFlowCorrelationsVsMHist(intFlowCorrelationsVsMHist,ci);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowCorrelationsVsMHist[%d]",ci)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of if(fCalculateCumulantsVsM)
    // average all correlations for integrated flow (with correct errors!):
    TString intFlowCorrelationsAllHistName = "fIntFlowCorrelationsAllHist";
    intFlowCorrelationsAllHistName += fAnalysisLabel->Data();
    TH1D *intFlowCorrelationsAllHist = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowCorrelationsAllHistName.Data()));
    if(intFlowCorrelationsAllHist)
    {
      this->SetIntFlowCorrelationsAllHist(intFlowCorrelationsAllHist);
    } else
    {
      cout<<"WARNING: intFlowCorrelationsAllHist is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // average correction terms for non-uniform acceptance (with correct errors!):
    TString intFlowCorrectionTermsForNUAHistName = "fIntFlowCorrectionTermsForNUAHist";
    intFlowCorrectionTermsForNUAHistName += fAnalysisLabel->Data();
    for(Int_t sc=0;sc<2;sc++)
    {
      TH1D *intFlowCorrectionTermsForNUAHist = dynamic_cast<TH1D*>(intFlowResults->FindObject((Form("%s: %s terms",intFlowCorrectionTermsForNUAHistName.Data(),sinCosFlag[sc].Data()))));
      if(intFlowCorrectionTermsForNUAHist)
      {
        this->SetIntFlowCorrectionTermsForNUAHist(intFlowCorrectionTermsForNUAHist,sc);
      } else
      {
        cout<<"WARNING: intFlowCorrectionTermsForNUAHist is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        cout<<"sc = "<<sc<<endl;
      }
    } // end of for(Int_t sc=0;sc<2;sc++)
    // covariances (multiplied with weight dependent prefactor):
    TString intFlowCovariancesName = "fIntFlowCovariances";
    intFlowCovariancesName += fAnalysisLabel->Data();
    TH1D *intFlowCovariances = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowCovariancesName.Data()));
    if(intFlowCovariances)
    {
      this->SetIntFlowCovariances(intFlowCovariances);
    } else
    {
      cout<<"WARNING: intFlowCovariances is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // sum of linear and quadratic event weights for <2>, <4>, <6> and <8>:
    TString intFlowSumOfEventWeightsName = "fIntFlowSumOfEventWeights";
    intFlowSumOfEventWeightsName += fAnalysisLabel->Data();
    for(Int_t power=0;power<2;power++)
    {
      TH1D *intFlowSumOfEventWeights = dynamic_cast<TH1D*>(intFlowResults->FindObject(Form("%s: %s",intFlowSumOfEventWeightsName.Data(),powerFlag[power].Data())));
      if(intFlowSumOfEventWeights)
      {
        this->SetIntFlowSumOfEventWeights(intFlowSumOfEventWeights,power);
      } else
      {
        cout<<"WARNING: intFlowSumOfEventWeights is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        cout<<"power = "<<power<<endl;
      }
    } // end of for(Int_t power=0;power<2;power++)
    // sum of products of event weights for correlations <2>, <4>, <6> and <8>:
    TString intFlowSumOfProductOfEventWeightsName = "fIntFlowSumOfProductOfEventWeights";
    intFlowSumOfProductOfEventWeightsName += fAnalysisLabel->Data();
    TH1D *intFlowSumOfProductOfEventWeights = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowSumOfProductOfEventWeightsName.Data()));
    if(intFlowSumOfProductOfEventWeights)
    {
      this->SetIntFlowSumOfProductOfEventWeights(intFlowSumOfProductOfEventWeights);
    } else
    {
      cout<<"WARNING: intFlowSumOfProductOfEventWeights is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // final result for covariances of correlations (multiplied with weight dependent prefactor) versus M
    // [0=Cov(2,4),1=Cov(2,6),2=Cov(2,8),3=Cov(4,6),4=Cov(4,8),5=Cov(6,8)]:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowCovariancesVsMName = "fIntFlowCovariancesVsM";
      intFlowCovariancesVsMName += fAnalysisLabel->Data();
      TString covarianceFlag[6] = {"Cov(<2>,<4>)","Cov(<2>,<6>)","Cov(<2>,<8>)","Cov(<4>,<6>)","Cov(<4>,<8>)","Cov(<6>,<8>)"};
      for(Int_t ci=0;ci<6;ci++)
      {
        TH1D *intFlowCovariancesVsM = dynamic_cast<TH1D*>(intFlowResults->FindObject(Form("%s, %s",intFlowCovariancesVsMName.Data(),covarianceFlag[ci].Data())));
        if(intFlowCovariancesVsM)
        {
          this->SetIntFlowCovariancesVsM(intFlowCovariancesVsM,ci);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowCovariancesVsM[%d]",ci)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t ci=0;ci<6;ci++)
    } // end of if(fCalculateCumulantsVsM)
    // sum of linear and quadratic event weights for <2>, <4>, <6> and <8> versus multiplicity
    // [0=sum{w_{<2>}},1=sum{w_{<4>}},2=sum{w_{<6>}},3=sum{w_{<8>}}][0=linear 1,1=quadratic]:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowSumOfEventWeightsVsMName = "fIntFlowSumOfEventWeightsVsM";
      intFlowSumOfEventWeightsVsMName += fAnalysisLabel->Data();
      TString sumFlag[2][4] = {{"#sum_{i=1}^{N} w_{<2>}","#sum_{i=1}^{N} w_{<4>}","#sum_{i=1}^{N} w_{<6>}","#sum_{i=1}^{N} w_{<8>}"},
        {"#sum_{i=1}^{N} w_{<2>}^{2}","#sum_{i=1}^{N} w_{<4>}^{2}","#sum_{i=1}^{N} w_{<6>}^{2}","#sum_{i=1}^{N} w_{<8>}^{2}"}};
      for(Int_t si=0;si<4;si++)
      {
        for(Int_t power=0;power<2;power++)
        {
          TH1D *intFlowSumOfEventWeightsVsM = dynamic_cast<TH1D*>(intFlowResults->FindObject(Form("%s, %s",intFlowSumOfEventWeightsVsMName.Data(),sumFlag[power][si].Data())));
          if(intFlowSumOfEventWeightsVsM)
          {
            this->SetIntFlowSumOfEventWeightsVsM(intFlowSumOfEventWeightsVsM,si,power);
          } else
          {
            cout<<"WARNING: "<<Form("intFlowSumOfEventWeightsVsM[%d][%d]",si,power)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
          }
        } // end of for(Int_t power=0;power<2;power++)
      } // end of for(Int_t si=0;si<4;si++)
    } // end of if(fCalculateCumulantsVsM)
    // sum of products of event weights for correlations <2>, <4>, <6> and <8> vs M
    // [0=sum{w_{<2>}w_{<4>}},1=sum{w_{<2>}w_{<6>}},2=sum{w_{<2>}w_{<8>}},
    //  3=sum{w_{<4>}w_{<6>}},4=sum{w_{<4>}w_{<8>}},5=sum{w_{<6>}w_{<8>}}]:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowSumOfProductOfEventWeightsVsMName = "fIntFlowSumOfProductOfEventWeightsVsM";
      intFlowSumOfProductOfEventWeightsVsMName += fAnalysisLabel->Data();
      TString sopowFlag[6] = {"#sum_{i=1}^{N} w_{<2>} w_{<4>}","#sum_{i=1}^{N} w_{<2>} w_{<6>}","#sum_{i=1}^{N} w_{<2>} w_{<8>}",
        "#sum_{i=1}^{N} w_{<4>} w_{<6>}","#sum_{i=1}^{N} w_{<4>} w_{<8>}","#sum_{i=1}^{N} w_{<6>} w_{<8>}"};
      for(Int_t pi=0;pi<6;pi++)
      {
        TH1D *intFlowSumOfProductOfEventWeightsVsM = dynamic_cast<TH1D*>(intFlowResults->FindObject(Form("%s, %s",intFlowSumOfProductOfEventWeightsVsMName.Data(),sopowFlag[pi].Data())));
        if(intFlowSumOfProductOfEventWeightsVsM)
        {
          this->SetIntFlowSumOfProductOfEventWeightsVsM(intFlowSumOfProductOfEventWeightsVsM,pi);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowSumOfProductOfEventWeightsVsM[%d]",pi)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t pi=0;pi<6;pi++)
    } // end of if(fCalculateCumulantsVsM)
    // covariances for NUA (multiplied with weight dependent prefactor):
    TString intFlowCovariancesNUAName = "fIntFlowCovariancesNUA";
    intFlowCovariancesNUAName += fAnalysisLabel->Data();
    TH1D *intFlowCovariancesNUA = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowCovariancesNUAName.Data()));
    if(intFlowCovariancesNUA)
    {
      this->SetIntFlowCovariancesNUA(intFlowCovariancesNUA);
    } else
    {
      cout<<"WARNING: intFlowCovariancesNUA is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // sum of linear and quadratic event weights NUA terms:
    TString intFlowSumOfEventWeightsNUAName = "fIntFlowSumOfEventWeightsNUA";
    intFlowSumOfEventWeightsNUAName += fAnalysisLabel->Data();
    for(Int_t sc=0;sc<2;sc++)
    {
      for(Int_t power=0;power<2;power++)
      {
        TH1D *intFlowSumOfEventWeightsNUA = dynamic_cast<TH1D*>(intFlowResults->FindObject(Form("%s: %s, %s",intFlowSumOfEventWeightsNUAName.Data(),powerFlag[power].Data(),sinCosFlag[sc].Data())));
        if(intFlowSumOfEventWeightsNUA)
        {
          this->SetIntFlowSumOfEventWeightsNUA(intFlowSumOfEventWeightsNUA,sc,power);
        } else
        {
          cout<<"WARNING: intFlowSumOfEventWeightsNUA is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
          cout<<"sc    = "<<sc<<endl;
          cout<<"power = "<<power<<endl;
        }
      } // end of for(Int_t power=0;power<2;power++)
    } // end of for(Int_t sc=0;sc<2;sc++)
    // sum of products of event weights for NUA terms:
    TString intFlowSumOfProductOfEventWeightsNUAName = "fIntFlowSumOfProductOfEventWeightsNUA";
    intFlowSumOfProductOfEventWeightsNUAName += fAnalysisLabel->Data();
    TH1D *intFlowSumOfProductOfEventWeightsNUA = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowSumOfProductOfEventWeightsNUAName.Data()));
    if(intFlowSumOfProductOfEventWeightsNUA)
    {
      this->SetIntFlowSumOfProductOfEventWeightsNUA(intFlowSumOfProductOfEventWeightsNUA);
    } else
    {
      cout<<"WARNING: intFlowSumOfProductOfEventWeightsNUA is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // Final results for reference Q-cumulants:
    TString intFlowQcumulantsName = "fIntFlowQcumulants";
    intFlowQcumulantsName += fAnalysisLabel->Data();
    TH1D *intFlowQcumulants = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowQcumulantsName.Data()));
    if(intFlowQcumulants)
    {
      this->SetIntFlowQcumulants(intFlowQcumulants);
    } else
    {
      cout<<"WARNING: intFlowQcumulants is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // Final results for reference Q-cumulants rebinned in M:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowQcumulantsRebinnedInMName = "fIntFlowQcumulantsRebinnedInM";
      intFlowQcumulantsRebinnedInMName += fAnalysisLabel->Data();
      TH1D *intFlowQcumulantsRebinnedInM = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowQcumulantsRebinnedInMName.Data()));
      if(intFlowQcumulantsRebinnedInM)
      {
        this->SetIntFlowQcumulantsRebinnedInM(intFlowQcumulantsRebinnedInM);
      } else
      {
        cout<<"WARNING: intFlowQcumulantsRebinnedInM is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
      }
    } // end of if(fCalculateCumulantsVsM)
    // Ratio between error squared: with/without non-isotropic terms:
    TString intFlowQcumulantsErrorSquaredRatioName = "fIntFlowQcumulantsErrorSquaredRatio";
    intFlowQcumulantsErrorSquaredRatioName += fAnalysisLabel->Data();
    TH1D *intFlowQcumulantsErrorSquaredRatio = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowQcumulantsErrorSquaredRatioName.Data()));
    if(intFlowQcumulantsErrorSquaredRatio)
    {
      this->SetIntFlowQcumulantsErrorSquaredRatio(intFlowQcumulantsErrorSquaredRatio);
    } else
    {
      cout<<" WARNING: intntFlowQcumulantsErrorSquaredRatio is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // final results for integrated Q-cumulants versus multiplicity:
    TString cumulantFlag[4] = {"QC{2}","QC{4}","QC{6}","QC{8}"};
    if(fCalculateCumulantsVsM)
    {
      TString intFlowQcumulantsVsMName = "fIntFlowQcumulantsVsM";
      intFlowQcumulantsVsMName += fAnalysisLabel->Data();
      for(Int_t co=0;co<4;co++) // cumulant order
      {
        TH1D *intFlowQcumulantsVsM = dynamic_cast<TH1D*>
        (intFlowResults->FindObject(Form("%s, %s",intFlowQcumulantsVsMName.Data(),cumulantFlag[co].Data())));
        if(intFlowQcumulantsVsM)
        {
          this->SetIntFlowQcumulantsVsM(intFlowQcumulantsVsM,co);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowQcumulantsVsM[%d]",co)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t co=0;co<4;co++) // cumulant order
    } // end of if(fCalculateCumulantsVsM)
    // Final reference flow estimates from Q-cumulants:
    TString intFlowName = "fIntFlow";
    intFlowName += fAnalysisLabel->Data();
    TH1D *intFlow = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowName.Data()));
    if(intFlow)
    {
      this->SetIntFlow(intFlow);
    } else
    {
      cout<<"WARNING: intFlow is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // Final reference flow estimates from Q-cumulants vs M rebinned in M:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowRebinnedInMName = "fIntFlowRebinnedInM";
      intFlowRebinnedInMName += fAnalysisLabel->Data();
      TH1D *intFlowRebinnedInM = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowRebinnedInMName.Data()));
      if(intFlowRebinnedInM)
      {
        this->SetIntFlowRebinnedInM(intFlowRebinnedInM);
      } else
      {
        cout<<"WARNING: intFlowRebinnedInM is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
      }
    } // end of if(fCalculateCumulantsVsM)
    // integrated flow from Q-cumulants versus multiplicity:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowVsMName = "fIntFlowVsM";
      intFlowVsMName += fAnalysisLabel->Data();
      TString flowFlag[4] = {Form("v_{%d}{2,QC}",fHarmonic),Form("v_{%d}{4,QC}",fHarmonic),Form("v_{%d}{6,QC}",fHarmonic),Form("v_{%d}{8,QC}",fHarmonic)};
      for(Int_t co=0;co<4;co++) // cumulant order
      {
        TH1D *intFlowVsM = dynamic_cast<TH1D*>
        (intFlowResults->FindObject(Form("%s, %s",intFlowVsMName.Data(),flowFlag[co].Data())));
        if(intFlowVsM)
        {
          this->SetIntFlowVsM(intFlowVsM,co);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowVsM[%d]",co)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t co=0;co<4;co++) // cumulant order
    } // end of if(fCalculateCumulantsVsM)
    // quantifying detector effects effects to correlations:
    TString intFlowDetectorBiasName = "fIntFlowDetectorBias";
    intFlowDetectorBiasName += fAnalysisLabel->Data();
    TH1D *intFlowDetectorBias = dynamic_cast<TH1D*>(intFlowResults->FindObject(intFlowDetectorBiasName.Data()));
    if(intFlowDetectorBias)
    {
      this->SetIntFlowDetectorBias(intFlowDetectorBias);
    } else
    {
      cout<<"WARNING: intFlowDetectorBias is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
    }
    // quantifying detector effects effects to correlations vs multiplicity:
    if(fCalculateCumulantsVsM)
    {
      TString intFlowDetectorBiasVsMName = "fIntFlowDetectorBiasVsM";
      intFlowDetectorBiasVsMName += fAnalysisLabel->Data();
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        TH1D *intFlowDetectorBiasVsM = dynamic_cast<TH1D*>
        (intFlowResults->FindObject(Form("%s for %s",intFlowDetectorBiasVsMName.Data(),cumulantFlag[ci].Data())));
        if(intFlowDetectorBiasVsM)
        {
          this->SetIntFlowDetectorBiasVsM(intFlowDetectorBiasVsM,ci);
        } else
        {
          cout<<"WARNING: "<<Form("intFlowDetectorBiasVsM[%d]",ci)<<" is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        }
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of if(fCalculateCumulantsVsM)
  } else // to if(intFlowResults)
  {
    cout<<"WARNING: intFlowResults is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
  }

} // end of void AliFlowAnalysisCRC::GetPointersForIntFlowHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersFor2DDiffFlowHistograms()
{
  // Get pointers for 2D differential flow histograms.
  //  a) Check pointers used in this method;
  //  b) Get pointers to 2D differential flow lists;
  //  c) Get pointers to 2D differential flow profiles;
  //  d) Get pointers to 2D differential flow histograms.

  // a) Check pointers used in this method:
  if(!fDiffFlowList)
  {
    printf("\n WARNING (QC): fDiffFlowList is NULL in AFAWQC::GPF2DDFH() !!!!\n");
    printf("               Call method GetPointersForDiffFlowHistograms() first.\n\n");
    exit(0);
  }
  if(!fDiffFlowFlags)
  {
    printf("\n WARNING (QC): fDiffFlowFlags is NULL in AFAWQC::GPF2DDFH() !!!!\n\n");
    printf("               Call method GetPointersForDiffFlowHistograms() first.\n\n");
    exit(0);
  }

  // b) Get pointers to 2D differential flow lists:
  this->SetCalculate2DDiffFlow((Bool_t)fDiffFlowFlags->GetBinContent(5)); // to be improved - hardwired 5
  if(!fCalculate2DDiffFlow){return;}
  TString typeFlag[2] = {"RP","POI"};
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"};
  TString differentialCumulantIndex[4] = {"QC{2'}","QC{4'}","QC{6'}","QC{8'}"};
  TString differentialFlowIndex[4] = {"v'{2}","v'{4}","v'{6}","v'{8}"};
  // Base list:
  TString diffFlow2DListName = "2D";
  diffFlow2DListName += fAnalysisLabel->Data();
  fDiffFlow2D = dynamic_cast<TList*>(fDiffFlowList->FindObject(diffFlow2DListName.Data()));
  if(!fDiffFlow2D)
  {
    printf("\n WARNING (QC): fDiffFlow2D is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    exit(0);
  }
  // Lists holding profiles with 2D correlations:
  TString s2DDiffFlowCorrelationsProListName = "Profiles with 2D correlations";
  s2DDiffFlowCorrelationsProListName += fAnalysisLabel->Data(); // to be improved
  for(Int_t t=0;t<2;t++)
  {
    f2DDiffFlowCorrelationsProList[t] = dynamic_cast<TList*>(fDiffFlow2D->FindObject(Form("Profiles with 2D correlations (%s)",typeFlag[t].Data())));
    if(!f2DDiffFlowCorrelationsProList[t])
    {
      printf("\n WARNING (QC): f2DDiffFlowCorrelationsProList[%i] is NULL in AFAWQC::GPF2DFH() !!!!\n\n",t);
      exit(0);
    }
  } // end of for(Int_t t=0;t<2;t++)

  // c) Get pointers to 2D differential flow profiles:
  TString s2DDiffFlowCorrelationsProName = "f2DDiffFlowCorrelationsPro";
  s2DDiffFlowCorrelationsProName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t rci=0;rci<4;rci++) // reduced correlation index
    {
      f2DDiffFlowCorrelationsPro[t][rci] = dynamic_cast<TProfile2D*>(f2DDiffFlowCorrelationsProList[t]->FindObject(Form("%s, %s, %s",s2DDiffFlowCorrelationsProName.Data(),typeFlag[t].Data(),reducedCorrelationIndex[rci].Data())));
      if(!f2DDiffFlowCorrelationsPro[t][rci])
      {
        printf("\n WARNING (QC): f2DDiffFlowCorrelationsPro[%i][%i] is NULL in AFAWQC::GPF2DFH() !!!!\n\n",t,rci);
        exit(0);
      } else
      {
        this->Set2DDiffFlowCorrelationsPro(f2DDiffFlowCorrelationsPro[t][rci],t,rci);
      }
    } // end of for(Int_t rci=0;rci<4;rci++) // reduced correlation index
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

  // d) Get pointers to 2D differential flow histograms:
  TString s2DDiffFlowCumulantsName = "f2DDiffFlowCumulants";
  s2DDiffFlowCumulantsName += fAnalysisLabel->Data();
  TString s2DDiffFlowName = "f2DDiffFlow";
  s2DDiffFlowName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t rci=0;rci<4;rci++) // reduced correlation index
    {
      // 2D differential cumulants:
      f2DDiffFlowCumulants[t][rci] = dynamic_cast<TH2D*>(f2DDiffFlowCorrelationsProList[t]->FindObject(Form("%s, %s, %s",s2DDiffFlowCumulantsName.Data(),typeFlag[t].Data(),differentialCumulantIndex[rci].Data())));
      if(!f2DDiffFlowCumulants[t][rci])
      {
        printf("\n WARNING (QC): f2DDiffFlowCumulants[%i][%i] is NULL in AFAWQC::GPF2DFH() !!!!\n\n",t,rci);
        exit(0);
      } else
      {
        this->Set2DDiffFlowCumulants(f2DDiffFlowCumulants[t][rci],t,rci);
      }
      // 2D differential flow:
      f2DDiffFlow[t][rci] = dynamic_cast<TH2D*>(f2DDiffFlowCorrelationsProList[t]->FindObject(Form("%s, %s, %s",s2DDiffFlowName.Data(),typeFlag[t].Data(),differentialFlowIndex[rci].Data())));
      if(!f2DDiffFlow[t][rci])
      {
        printf("\n WARNING (QC): f2DDiffFlow[%i][%i] is NULL in AFAWQC::GPF2DFH() !!!!\n\n",t,rci);
        exit(0);
      } else
      {
        this->Set2DDiffFlow(f2DDiffFlow[t][rci],t,rci);
      }
    } // end of for(Int_t rci=0;rci<4;rci++) // reduced correlation index
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

} // end of void AliFlowAnalysisCRC::GetPointersFor2DDiffFlowHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForOtherDiffCorrelators()
{
  // Get pointers for other differential correlators.
  //  a) Get pointer to list with other differential correlators;
  //  b) Declare local flags;
  //  c) Get pointers to other differential profiles.

  if(!fCalculateDiffFlow){return;} // TBI: This must eventually be moved somewhere else

  // a) Get pointer to list with other differential correlators:
  fOtherDiffCorrelatorsList = dynamic_cast<TList*>(fHistList->FindObject("Other differential correlators"));
  if(!fOtherDiffCorrelatorsList)
  {
    printf("\n WARNING (QC): fOtherDiffCorrelatorsList is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    exit(0);
  }

  // b) Declare local flags: // (to be improved - promoted to data members)
  TString typeFlag[2] = {"RP","POI"};
  TString ptEtaFlag[2] = {"p_{T}","#eta"};
  TString sinCosFlag[2] = {"sin","cos"};

  // c) Get pointers to other differential profiles:
  TString otherDiffCorrelatorsName = "fOtherDiffCorrelators";
  otherDiffCorrelatorsName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t ci=0;ci<1;ci++) // correlator index
        {
          fOtherDiffCorrelators[t][pe][sc][ci] = dynamic_cast<TProfile*>(fOtherDiffCorrelatorsList->FindObject(Form("%s, %s, %s, %s, ci = %d",otherDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1)));
          if(!fOtherDiffCorrelators[t][pe][sc][ci])
          {
            printf("\n WARNING (QC): fOtherDiffCorrelators[%i][%i][%i][%i] is NULL in AFAWQC::GPFODC() !!!!\n\n",t,pe,sc,ci);
            exit(0);
          } else
          {
            this->SetOtherDiffCorrelators(fOtherDiffCorrelators[t][pe][sc][ci],t,pe,sc,ci);
          }
        } // end of for(Int_t ci=0;ci<1;ci++) // correlator index
      } // end of for(Int_t sc=0;sc<2;sc++) // sin or cos
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)

} // end of void AliFlowAnalysisCRC::GetPointersForOtherDiffCorrelators()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForDiffFlowHistograms()
{
  // Get pointer to all objects relevant for differential flow.
  //  a) Get pointer to base list for differential flow fDiffFlowList;
  //  b) Get pointer to profile fDiffFlowFlags holding all flags for differential flow. Access and set some flags;
  //  c) Get pointers to nested lists fDiffFlowListProfiles and fDiffFlowListResults;
  //  d) Define flags locally (to be improved: should I promote these flags to data members?);
  //  e) Get pointers to all nested lists in fDiffFlowListProfiles and to profiles which they hold;
  //  f) Get pointers to all nested lists in fDiffFlowListResults and to histograms which they hold.

  // a) Get pointer to base list for differential flow fDiffFlowList:
  fDiffFlowList = dynamic_cast<TList*>(fHistList->FindObject("Differential Flow"));
  if(!fDiffFlowList)
  {
    printf("\n WARNING (QC): fDiffFlowList is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    exit(0);
  }

  // b) Get pointer to profile fDiffFlowFlags holding all flags for differential flow. Access and set some flags:
  TString diffFlowFlagsName = "fDiffFlowFlags";
  diffFlowFlagsName += fAnalysisLabel->Data();
  fDiffFlowFlags = dynamic_cast<TProfile*>(fDiffFlowList->FindObject(diffFlowFlagsName.Data()));
  if(fDiffFlowFlags)
  {
    this->SetCalculateDiffFlow((Bool_t)fDiffFlowFlags->GetBinContent(1)); // to be improved - hardwired 1
    this->SetCalculateDiffFlowVsEta((Bool_t)fDiffFlowFlags->GetBinContent(6)); // to be improved - hardwired 6
  } else
  {
    printf("\n WARNING (QC): fDiffFlowFlags is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    printf("\n             Flags in method Finish() are wrong.\n\n");
    exit(0);
  }

  if(!fCalculateDiffFlow){return;} // IMPORTANT: do not move this anywhere above in this method (to be improved)

  // c) Get pointers to nested lists fDiffFlowListProfiles and fDiffFlowListResults:
  //  List holding nested lists holding profiles:
  TList *diffFlowListProfiles = NULL;
  diffFlowListProfiles = dynamic_cast<TList*>(fDiffFlowList->FindObject("Profiles"));
  if(!diffFlowListProfiles)
  {
    printf("\n WARNING (QC): diffFlowListProfiles is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    exit(0);
  }
  //  List holding nested lists holding histograms with final results:
  TList *diffFlowListResults = NULL;
  diffFlowListResults = dynamic_cast<TList*>(fDiffFlowList->FindObject("Results"));
  if(!diffFlowListResults)
  {
    printf("\n WARNING (QC): diffFlowListResults is NULL in AFAWQC::GPFDFH() !!!!\n\n");
    exit(0);
  }

  // d) Define flags locally (to be improved: should I promote these flags to data members?):
  TString typeFlag[2] = {"RP","POI"};
  TString ptEtaFlag[2] = {"p_{T}","#eta"};
  TString powerFlag[2] = {"linear","quadratic"};
  TString sinCosFlag[2] = {"sin","cos"};
  TString differentialCumulantIndex[4] = {"QC{2'}","QC{4'}","QC{6'}","QC{8'}"};
  TString differentialFlowIndex[4] = {"v'{2}","v'{4}","v'{6}","v'{8}"};
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"};
  TString reducedSquaredCorrelationIndex[4] = {"<2'>^{2}","<4'>^{2}","<6'>^{2}","<8'>^{2}"};
  TString mixedCorrelationIndex[8] = {"<2>","<2'>","<4>","<4'>","<6>","<6'>","<8>","<8'>"};
  TString covarianceName[5] = {"Cov(<2>,<2'>)","Cov(<2>,<4'>)","Cov(<4>,<2'>)","Cov(<4>,<4'>)","Cov(<2'>,<4'>)"};

  // e) Get pointers to all nested lists in fDiffFlowListProfiles and to profiles which they hold:
  // correlations:
  TList *diffFlowCorrelationsProList[2][2] = {{NULL}};
  TString diffFlowCorrelationsProName = "fDiffFlowCorrelationsPro";
  diffFlowCorrelationsProName += fAnalysisLabel->Data();
  TProfile *diffFlowCorrelationsPro[2][2][4] = {{{NULL}}};
  // squared correlations:
  TString diffFlowSquaredCorrelationsProName = "fDiffFlowSquaredCorrelationsPro";
  diffFlowSquaredCorrelationsProName += fAnalysisLabel->Data();
  TProfile *diffFlowSquaredCorrelationsPro[2][2][4] = {{{NULL}}};
  // products of correlations:
  TList *diffFlowProductOfCorrelationsProList[2][2] = {{NULL}};
  TString diffFlowProductOfCorrelationsProName = "fDiffFlowProductOfCorrelationsPro";
  diffFlowProductOfCorrelationsProName += fAnalysisLabel->Data();
  TProfile *diffFlowProductOfCorrelationsPro[2][2][8][8] = {{{{NULL}}}};
  // corrections:
  TList *diffFlowCorrectionsProList[2][2] = {{NULL}};
  TString diffFlowCorrectionTermsForNUAProName = "fDiffFlowCorrectionTermsForNUAPro";
  diffFlowCorrectionTermsForNUAProName += fAnalysisLabel->Data();
  TProfile *diffFlowCorrectionTermsForNUAPro[2][2][2][10] = {{{{NULL}}}};
  for(Int_t t=0;t<2;t++)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++)
    {
      diffFlowCorrelationsProList[t][pe] = dynamic_cast<TList*>(diffFlowListProfiles->FindObject(Form("Profiles with correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCorrelationsProList[t][pe])
      {
        cout<<"WARNING: diffFlowCorrelationsProList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t ci=0;ci<4;ci++) // correlation index
      {
        // reduced correlations:
        diffFlowCorrelationsPro[t][pe][ci] = dynamic_cast<TProfile*>(diffFlowCorrelationsProList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[ci].Data())));
        if(diffFlowCorrelationsPro[t][pe][ci])
        {
          this->SetDiffFlowCorrelationsPro(diffFlowCorrelationsPro[t][pe][ci],t,pe,ci);
        } else
        {
          cout<<"WARNING: diffFlowCorrelationsPro[t][pe][ci] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t  = "<<t<<endl;
          cout<<"pe = "<<pe<<endl;
          cout<<"ci = "<<ci<<endl;
        }
        // reduced squared correlations:
        diffFlowSquaredCorrelationsPro[t][pe][ci] = dynamic_cast<TProfile*>(diffFlowCorrelationsProList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowSquaredCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedSquaredCorrelationIndex[ci].Data())));
        if(diffFlowSquaredCorrelationsPro[t][pe][ci])
        {
          this->SetDiffFlowSquaredCorrelationsPro(diffFlowSquaredCorrelationsPro[t][pe][ci],t,pe,ci);
        } else
        {
          cout<<"WARNING: diffFlowSquaredCorrelationsPro[t][pe][ci] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t  = "<<t<<endl;
          cout<<"pe = "<<pe<<endl;
          cout<<"ci = "<<ci<<endl;
        }
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
      // products of correlations:
      diffFlowProductOfCorrelationsProList[t][pe] = dynamic_cast<TList*>(diffFlowListProfiles->FindObject(Form("Profiles with products of correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowProductOfCorrelationsProList[t][pe])
      {
        cout<<"WARNING: ddiffFlowProductOfCorrelationsProList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
        {
          diffFlowProductOfCorrelationsPro[t][pe][mci1][mci2] = dynamic_cast<TProfile*>(diffFlowProductOfCorrelationsProList[t][pe]->FindObject(Form("%s, %s, %s, %s, %s",diffFlowProductOfCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data())));
          if(diffFlowProductOfCorrelationsPro[t][pe][mci1][mci2])
          {
            this->SetDiffFlowProductOfCorrelationsPro(diffFlowProductOfCorrelationsPro[t][pe][mci1][mci2],t,pe,mci1,mci2);
          } else
          {
            cout<<"WARNING: diffFlowProductOfCorrelationsPro[t][pe][ci] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t    = "<<t<<endl;
            cout<<"pe   = "<<pe<<endl;
            cout<<"mci1 = "<<mci1<<endl;
            cout<<"mci2 = "<<mci2<<endl;
          }
          if(mci1%2 == 0) mci2++; // products which DO NOT include reduced correlations are not stored here
        } // end of for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
      } // end of for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      // corrections:
      diffFlowCorrectionsProList[t][pe] = dynamic_cast<TList*>(diffFlowListProfiles->FindObject(Form("Profiles with correction terms for NUA (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCorrectionsProList[t][pe])
      {
        cout<<"WARNING: diffFlowCorrectionsProList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      // correction terms for NUA:
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          diffFlowCorrectionTermsForNUAPro[t][pe][sc][cti] = dynamic_cast<TProfile*>(diffFlowCorrectionsProList[t][pe]->FindObject(Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1)));
          if(diffFlowCorrectionTermsForNUAPro[t][pe][sc][cti])
          {
            this->SetDiffFlowCorrectionTermsForNUAPro(diffFlowCorrectionTermsForNUAPro[t][pe][sc][cti],t,pe,sc,cti);
          } else
          {
            cout<<"WARNING: diffFlowCorrectionTermsForNUAPro[t][pe][sc][cti] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t   = "<<t<<endl;
            cout<<"pe  = "<<pe<<endl;
            cout<<"sc  = "<<sc<<endl;
            cout<<"cti = "<<cti<<endl;
          }
        } // end of for(Int_t cti=0;cti<9;cti++) // correction term index
      } // end of for(Int_t sc=0;sc<2;sc++) // sin or cos
      // ...
    } // end of for(Int_t pe=0;pe<2;pe++)
  } // end of for(Int_t t=0;t<2;t++)

  // f) Get pointers to all nested lists in fDiffFlowListResults and to histograms which they hold:
  // reduced correlations:
  TList *diffFlowCorrelationsHistList[2][2] = {{NULL}};
  TString diffFlowCorrelationsHistName = "fDiffFlowCorrelationsHist";
  diffFlowCorrelationsHistName += fAnalysisLabel->Data();
  TH1D *diffFlowCorrelationsHist[2][2][4] = {{{NULL}}};
  // corrections for NUA:
  TList *diffFlowCorrectionsHistList[2][2] = {{NULL}};
  TString diffFlowCorrectionTermsForNUAHistName = "fDiffFlowCorrectionTermsForNUAHist";
  diffFlowCorrectionTermsForNUAHistName += fAnalysisLabel->Data();
  TH1D *diffFlowCorrectionTermsForNUAHist[2][2][2][10] = {{{{NULL}}}};
  // differential Q-cumulants:
  TList *diffFlowCumulantsHistList[2][2] = {{NULL}};
  TString diffFlowCumulantsName = "fDiffFlowCumulants";
  diffFlowCumulantsName += fAnalysisLabel->Data();
  TH1D *diffFlowCumulants[2][2][4] = {{{NULL}}};
  // detector bias to differential Q-cumulants:
  TList *diffFlowDetectorBiasHistList[2][2] = {{NULL}};
  TString diffFlowDetectorBiasName = "fDiffFlowDetectorBias";
  diffFlowDetectorBiasName += fAnalysisLabel->Data();
  TH1D *diffFlowDetectorBias[2][2][4] = {{{NULL}}};
  // differential flow estimates from Q-cumulants:
  TList *diffFlowHistList[2][2] = {{NULL}};
  TString diffFlowName = "fDiffFlow";
  diffFlowName += fAnalysisLabel->Data();
  TH1D *diffFlow[2][2][4] = {{{NULL}}};
  // differential covariances:
  TList *diffFlowCovariancesHistList[2][2] = {{NULL}};
  TString diffFlowCovariancesName = "fDiffFlowCovariances";
  diffFlowCovariancesName += fAnalysisLabel->Data();
  TH1D *diffFlowCovariances[2][2][5] = {{{NULL}}};

  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      // reduced correlations:
      diffFlowCorrelationsHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCorrelationsHistList[t][pe])
      {
        cout<<"WARNING: diffFlowCorrelationsHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t index=0;index<4;index++)
      {
        diffFlowCorrelationsHist[t][pe][index] = dynamic_cast<TH1D*>(diffFlowCorrelationsHistList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowCorrelationsHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[index].Data())));
        if(diffFlowCorrelationsHist[t][pe][index])
        {
          this->SetDiffFlowCorrelationsHist(diffFlowCorrelationsHist[t][pe][index],t,pe,index);
        } else
        {
          cout<<"WARNING: diffFlowCorrelationsHist[t][pe][index] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t     = "<<t<<endl;
          cout<<"pe    = "<<pe<<endl;
          cout<<"index = "<<index<<endl;
          exit(0);
        }
      } // end of for(Int_t index=0;index<4;index++)
      // corrections:
      diffFlowCorrectionsHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Histograms with correction terms for NUA (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCorrectionsHistList[t][pe])
      {
        cout<<"WARNING: diffFlowCorrectionsHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      // correction terms for NUA:
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          diffFlowCorrectionTermsForNUAHist[t][pe][sc][cti] = dynamic_cast<TH1D*>(diffFlowCorrectionsHistList[t][pe]->FindObject(Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1)));
          if(diffFlowCorrectionTermsForNUAHist[t][pe][sc][cti])
          {
            this->SetDiffFlowCorrectionTermsForNUAHist(diffFlowCorrectionTermsForNUAHist[t][pe][sc][cti],t,pe,sc,cti);
          } else
          {
            cout<<"WARNING: diffFlowCorrectionTermsForNUAHist[t][pe][sc][cti] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t   = "<<t<<endl;
            cout<<"pe  = "<<pe<<endl;
            cout<<"sc  = "<<sc<<endl;
            cout<<"cti = "<<cti<<endl;
          }
        } // end of for(Int_t cti=0;cti<9;cti++) // correction term index
      } // end of for(Int_t sc=0;sc<2;sc++) // sin or cos
      // ...
      // differential Q-cumulants:
      diffFlowCumulantsHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Differential Q-cumulants (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCumulantsHistList[t][pe])
      {
        cout<<"WARNING: diffFlowCumulantsHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t  = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t index=0;index<4;index++)
      {
        diffFlowCumulants[t][pe][index] = dynamic_cast<TH1D*>(diffFlowCumulantsHistList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowCumulantsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data())));
        if(diffFlowCumulants[t][pe][index])
        {
          this->SetDiffFlowCumulants(diffFlowCumulants[t][pe][index],t,pe,index);
        } else
        {
          cout<<"WARNING: diffFlowCumulants[t][pe][index] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t     = "<<t<<endl;
          cout<<"pe    = "<<pe<<endl;
          cout<<"index = "<<index<<endl;
          exit(0);
        }
      } // end of for(Int_t index=0;index<4;index++)
      // Detector bias to differential Q-cumulants:
      diffFlowDetectorBiasHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Detector bias (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowDetectorBiasHistList[t][pe])
      {
        cout<<"WARNING: diffFlowDetectorBiasHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t  = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t index=0;index<4;index++)
      {
        diffFlowDetectorBias[t][pe][index] = dynamic_cast<TH1D*>(diffFlowDetectorBiasHistList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowDetectorBiasName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data())));
        if(diffFlowDetectorBias[t][pe][index])
        {
          this->SetDiffFlowDetectorBias(diffFlowDetectorBias[t][pe][index],t,pe,index);
        } else
        {
          cout<<"WARNING: diffFlowDetectorBias[t][pe][index] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t     = "<<t<<endl;
          cout<<"pe    = "<<pe<<endl;
          cout<<"index = "<<index<<endl;
          exit(0);
        }
      } // end of for(Int_t index=0;index<4;index++)
      // differential flow estimates from Q-cumulants:
      diffFlowHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Differential flow (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowHistList[t][pe])
      {
        cout<<"WARNING: diffFlowHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t  = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t index=0;index<4;index++)
      {
        diffFlow[t][pe][index] = dynamic_cast<TH1D*>(diffFlowHistList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialFlowIndex[index].Data())));
        if(diffFlow[t][pe][index])
        {
          this->SetDiffFlow(diffFlow[t][pe][index],t,pe,index);
        } else
        {
          cout<<"WARNING: diffFlow[t][pe][index] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t     = "<<t<<endl;
          cout<<"pe    = "<<pe<<endl;
          cout<<"index = "<<index<<endl;
          exit(0);
        }
      } // end of for(Int_t index=0;index<4;index++)
      // differential covariances:
      diffFlowCovariancesHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Covariances of correlations (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowCovariancesHistList[t][pe])
      {
        cout<<"WARNING: diffFlowCovariancesHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t  = "<<t<<endl;
        cout<<"pe = "<<pe<<endl;
        exit(0);
      }
      for(Int_t covIndex=0;covIndex<5;covIndex++)
      {
        diffFlowCovariances[t][pe][covIndex] = dynamic_cast<TH1D*>(diffFlowCovariancesHistList[t][pe]->FindObject(Form("%s, %s, %s, %s",diffFlowCovariancesName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),covarianceName[covIndex].Data())));
        if(diffFlowCovariances[t][pe][covIndex])
        {
          this->SetDiffFlowCovariances(diffFlowCovariances[t][pe][covIndex],t,pe,covIndex);
        } else
        {
          cout<<"WARNING: diffFlowCovariances[t][pe][covIndex] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t        = "<<t<<endl;
          cout<<"pe       = "<<pe<<endl;
          cout<<"covIndex = "<<covIndex<<endl;
          exit(0);
        }
      } // end of for(Int_t covIndex=0;covIndex<5;covIndex++) // covariance index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // sum of event weights for reduced correlations:
  TList *diffFlowSumOfEventWeightsHistList[2][2][2] = {{{NULL}}};
  TString diffFlowSumOfEventWeightsName = "fDiffFlowSumOfEventWeights";
  diffFlowSumOfEventWeightsName += fAnalysisLabel->Data();
  TH1D *diffFlowSumOfEventWeights[2][2][2][4] = {{{{NULL}}}};
  for(Int_t t=0;t<2;t++) // type is RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t p=0;p<2;p++) // power of event weights is either 1 or 2
      {
        diffFlowSumOfEventWeightsHistList[t][pe][p] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Sum of %s event weights (%s, %s)",powerFlag[p].Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data())));
        if(!diffFlowSumOfEventWeightsHistList[t][pe][p])
        {
          cout<<"WARNING: diffFlowSumOfEventWeightsHistList[t][pe][p] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
          cout<<"t     = "<<t<<endl;
          cout<<"pe    = "<<pe<<endl;
          cout<<"power = "<<p<<endl;
          exit(0);
        }
        for(Int_t ew=0;ew<4;ew++) // index of reduced correlation
        {
          diffFlowSumOfEventWeights[t][pe][p][ew] = dynamic_cast<TH1D*>(diffFlowSumOfEventWeightsHistList[t][pe][p]->FindObject(Form("%s, %s, %s, %s, %s",diffFlowSumOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),powerFlag[p].Data(),reducedCorrelationIndex[ew].Data())));
          if(diffFlowSumOfEventWeights[t][pe][p][ew])
          {
            this->SetDiffFlowSumOfEventWeights(diffFlowSumOfEventWeights[t][pe][p][ew],t,pe,p,ew);
          } else
          {
            cout<<"WARNING: diffFlowSumOfEventWeights[t][pe][p][ew] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t     = "<<t<<endl;
            cout<<"pe    = "<<pe<<endl;
            cout<<"power = "<<p<<endl;
            cout<<"ew    = "<<ew<<endl;
            exit(0);
          }
        }
      } // end of for(Int_t p=0;p<2;p++) // power of event weights is either 1 or 2
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type is RP or POI
  //
  TList *diffFlowSumOfProductOfEventWeightsHistList[2][2] = {{NULL}};
  TString diffFlowSumOfProductOfEventWeightsName = "fDiffFlowSumOfProductOfEventWeights";
  diffFlowSumOfProductOfEventWeightsName += fAnalysisLabel->Data();
  TH1D *diffFlowSumOfProductOfEventWeights[2][2][8][8] = {{{{NULL}}}};
  for(Int_t t=0;t<2;t++) // type is RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      diffFlowSumOfProductOfEventWeightsHistList[t][pe] = dynamic_cast<TList*>(diffFlowListResults->FindObject(Form("Sum of products of event weights (%s, %s)",typeFlag[t].Data(),ptEtaFlag[pe].Data())));
      if(!diffFlowSumOfProductOfEventWeightsHistList[t][pe])
      {
        cout<<"WARNING: diffFlowSumOfProductOfEventWeightsHistList[t][pe] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
        cout<<"t     = "<<t<<endl;
        cout<<"pe    = "<<pe<<endl;
        exit(0);
      }
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
        {
          diffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2] = dynamic_cast<TH1D*>(diffFlowSumOfProductOfEventWeightsHistList[t][pe]->FindObject(Form("%s, %s, %s, %s, %s",diffFlowSumOfProductOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data())));
          if(diffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2])
          {
            this->SetDiffFlowSumOfProductOfEventWeights(diffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2],t,pe,mci1,mci2);
          } else
          {
            cout<<"WARNING: diffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t    = "<<t<<endl;
            cout<<"pe   = "<<pe<<endl;
            cout<<"mci1 = "<<mci1<<endl;
            cout<<"mci2 = "<<mci2<<endl;
            exit(0);
          }
          if(mci1%2 == 0) mci2++; // products which DO NOT include reduced correlations are not stored here
        } // end of for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
      } // end of for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type is RP or POI

} // end void AliFlowAnalysisCRC::GetPointersForDiffFlowHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCRCVZ()
{
  if(!fCalculateCRCVZ){return;}

  // List
  TList *CRCVZList = dynamic_cast<TList*>(fCRCList->FindObject("VZERO CRC"));
  if (CRCVZList) {
    this->SetCRCVZList(CRCVZList);
  } else {
    cout<<"WARNING: CRCVZList is NULL in AFAWQC::GPFCRCVZ() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t j=0; j<fkNHistCRCVZ; j++) {
      TProfile *FlowSPZDCv1etaPro = dynamic_cast<TProfile*>(fCRCVZList->FindObject(Form("fCRCVZEROetaPro[%d][%d]",h,j)));
      if(FlowSPZDCv1etaPro) { this->SetCRCVZEROetaPro(FlowSPZDCv1etaPro,h,j); }
      else { cout<<"WARNING: fCRCVZEROetaPro is NULL in AFAWQC::GPFCRCVZ() !!!!"<<endl; }
      TH1D *FlowSPZDCv1etaHist = dynamic_cast<TH1D*>(fCRCVZList->FindObject(Form("fCRCVZEROetaHist[%d][%d]",h,j)));
      if(FlowSPZDCv1etaHist) { this->SetCRCVZEROetaHist(FlowSPZDCv1etaHist,h,j); }
      else { cout<<"WARNING: fCRCVZEROetaHist is NULL in AFAWQC::GPFCRCVZ() !!!!"<<endl; }
    }
  }

} // end void AliFlowAnalysisCRC::GetPointersForCRCVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCRCZDC()
{
  if(!fCalculateCRCZDC){return;}

  // List
  TList *CRCZDCList = dynamic_cast<TList*>(fCRCList->FindObject("ZDC CRC"));
  if (CRCZDCList) {
    this->SetCRCZDCList(CRCZDCList);
  } else {
    cout<<"WARNING: CRCZDCList is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl;
    exit(0);
  }

  if(!fCalculateCRC){return;}
  if(!fUseZDC){return;}

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {

      TH1D *CRCZDCCFunHist = dynamic_cast<TH1D*>(fCRCZDCList->FindObject(Form("fCRCZDCCFunHist[%d][%d]",eg,h)));
      if(CRCZDCCFunHist) { this->SetCRCZDCCFunHist(CRCZDCCFunHist,eg,h); }
      else { cout<<"WARNING: CRCZDCCFunHist is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
      TProfile *CRCZDCSpectra = dynamic_cast<TProfile*>(fCRCZDCList->FindObject(Form("fCRCZDCSpectra[%d][%d]",eg,h)));
      if(CRCZDCSpectra) { this->SetCRCZDCSpectra(CRCZDCSpectra,eg,h); }
      else { cout<<"WARNING: CRCZDCSpectra is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }

      for(Int_t c=0;c<2;c++) {
        // EbE Corr:
        TH1D *CRCZDCCorrProdTempHist = dynamic_cast<TH1D*>(fCRCZDCList->FindObject(Form("fCRCZDCCorrProdTempHist[%d][%d][%d]",c,eg,h)));
        if(CRCZDCCorrProdTempHist) { this->SetCRCZDCCorrProdTempHist(CRCZDCCorrProdTempHist,c,eg,h); }
        else { cout<<"WARNING: CRCZDCCorrProdTempHist is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
        // Final Histo:
        TH1D *CRCZDCCorrHist = dynamic_cast<TH1D*>(fCRCZDCList->FindObject(Form("fCRCZDCCorrHist[%d][%d][%d]",c,eg,h)));
        if(CRCZDCCorrHist) { this->SetCRCZDCCorrHist(CRCZDCCorrHist,c,eg,h); }
        else { cout<<"WARNING: CRCZDCCorrHist is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
        // Covariances:
        TH2D *CRCZDCCovHist = dynamic_cast<TH2D*>(fCRCZDCList->FindObject(Form("fCRCZDCCovHist[%d][%d][%d]",c,eg,h)));
        if(CRCZDCCovHist) { this->SetCRCZDCCovHist(CRCZDCCovHist,c,eg,h); }
        else { cout<<"WARNING: CRCZDCCovHist is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
      } // end of for(Int_t c=0;c<2;c++)

    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)

  TList *CRCZDCRbRList = dynamic_cast<TList*>(fCRCZDCList->FindObject("Run-by-Run"));
  if (CRCZDCRbRList) {
    this->SetCRCZDCRbRList(CRCZDCRbRList);
  } else {
    cout<<"WARNING: CRCZDCRbRList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    exit(0);
  }

  for(Int_t r=0;r<fCRCnRun;r++) {

    TList *CRCZDCRunsList = dynamic_cast<TList*>(fCRCZDCRbRList->FindObject(Form("Run %d",fRunList[r])));
    if (CRCZDCRunsList) {
      this->SetCRCZDCRunsList(CRCZDCRunsList,r);
    } else {
      cout<<"WARNING: CRCZDCRunsList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    }

    for(Int_t eg=0;eg<fCRCZDCnEtaBin;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        for(Int_t c=0;c<2;c++) {
          // EbE Corr:
          TProfile *CRCZDCCorrPro = dynamic_cast<TProfile*>(fCRCZDCRunsList[r]->FindObject(Form("fCRCZDCCorrPro[%d][%d][%d][%d]",r,c,eg,h)));
          if(CRCZDCCorrPro) { this->SetCRCZDCCorrPro(CRCZDCCorrPro,r,c,eg,h); }
          else { cout<<"WARNING: CRCZDCCorrPro is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
          TProfile *CRCZDCCorrProd2p2pHist = dynamic_cast<TProfile*>(fCRCZDCRunsList[r]->FindObject(Form("fCRCZDCCorrProd2p2pHist[%d][%d][%d][%d]",r,c,eg,h)));
          if(CRCZDCCorrProd2p2pHist) { this->SetCRCZDCCorrProd2p2pHist(CRCZDCCorrProd2p2pHist,r,c,eg,h); }
          else { cout<<"WARNING: CRCZDCCorrProd2p2pHist is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
        }
        for(Int_t c=0;c<4;c++) {
          TProfile *CRCZDCNUAPro = dynamic_cast<TProfile*>(fCRCZDCRunsList[r]->FindObject(Form("fCRCZDCNUAPro[%d][%d][%d][%d]",r,c,eg,h)));
          if(CRCZDCNUAPro) { this->SetCRCZDCNUAPro(CRCZDCNUAPro,r,c,eg,h); }
          else { cout<<"WARNING: CRCZDCNUAPro is NULL in AFAWQC::GPFCRCZDC() !!!!"<<endl; }
        }
      } // end of for (Int_t h=0;h<fCRCnCen;h++)
    } // end of for(Int_t eg=0;eg<fCRCZDCnEtaBin;eg++)

  } // end of for(Int_t r=0;r<fCRCnRun;r++)
} // end void AliFlowAnalysisCRC::GetPointersForCRCZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCRC()
{
  // List
  TList *CRCList = dynamic_cast<TList*>(fHistList->FindObject("Charge-Rapidity Correlations"));
  if (CRCList) {
    this->SetCRCList(CRCList);
  } else {
    cout<<"WARNING: CRCList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    exit(0);
  }

  if(!fCalculateCRC){return;}

  // Flags
  TProfile *CRCFlags = dynamic_cast<TProfile*>(fCRCList->FindObject("fCRCFlags"));
  if(CRCFlags) {
    this->SetCRCFlags(CRCFlags);
    fHarmonic = (Bool_t)fCRCFlags->GetBinContent(1);
    fCalculateCRCPt = (Bool_t)fCRCFlags->GetBinContent(2);
    fUseVZERO = (Bool_t)fCRCFlags->GetBinContent(3);
    fNUAforCRC = (Bool_t)fCRCFlags->GetBinContent(4);
    fUseCRCRecenter = (Bool_t)fCRCFlags->GetBinContent(5);
    fUseZDC = (Bool_t)fCRCFlags->GetBinContent(6);
    fRecenterZDC = (Bool_t)fCRCFlags->GetBinContent(7);
    fDivSigma = (Bool_t)fCRCFlags->GetBinContent(8);
    fInvertZDC = (Bool_t)fCRCFlags->GetBinContent(9);
    fCalculateCRCInt = (Bool_t)fCRCFlags->GetBinContent(10);
    fCalculateCRC2 = (Bool_t)fCRCFlags->GetBinContent(11);
    fCalculateCRCVZ = (Bool_t)fCRCFlags->GetBinContent(12);
    fCalculateCRCZDC = (Bool_t)fCRCFlags->GetBinContent(13);
    fCalculateFlowQC = (Bool_t)fCRCFlags->GetBinContent(14);
    fCalculateFlowZDC = (Bool_t)fCRCFlags->GetBinContent(15);
    fCalculateFlowVZ = (Bool_t)fCRCFlags->GetBinContent(16);
    fUsePhiEtaCuts = (Bool_t)fCRCFlags->GetBinContent(17);
    fCalculateCME = (Bool_t)fCRCFlags->GetBinContent(18);                    // @Shi missing flag added
  } else {
    cout<<"WARNING: CRCFlags is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    fHarmonic = kFALSE;
    fCalculateCRCPt = kFALSE;
    fUseVZERO = kFALSE;
    fNUAforCRC = kFALSE;
    fUseCRCRecenter = kFALSE;
    fUseZDC = kFALSE;
    fRecenterZDC = kFALSE;
    fDivSigma = kFALSE;
    fInvertZDC = kFALSE;
    fCalculateCRCInt = kFALSE;
    fCalculateCRC2 = kFALSE;
    fCalculateCRCVZ = kFALSE;
    fCalculateCRCZDC = kFALSE;
    fCalculateFlowQC = kFALSE;
    fCalculateFlowZDC = kFALSE;
    fCalculateFlowVZ = kFALSE;
    fUsePhiEtaCuts = kFALSE;
    fCalculateCME = kFALSE;
  }

  if(!fCalculateCRCInt){return;}

  TList *CRCIntList = dynamic_cast<TList*>(fCRCList->FindObject("Integrated CRC"));
  if (CRCIntList) {
    this->SetCRCIntList(CRCIntList);
  } else {
    cout<<"WARNING: CRCIntList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    exit(0);
  }

  for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {

      TH1D *CRCCFunHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCCFunHist[%d][%d]",eg,h)));
      if(CRCCFunHist) { this->SetCRCCFunHist(CRCCFunHist,eg,h); }
      else { cout<<"WARNING: CRCCFunHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
        CRCIntList->ls();
        exit(0);
      }

      for(Int_t c=0;c<fCRCnCorr;c++) {
        // EbE Corr:
        TH1D *CRCCorrProdTempHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCCorrProdTempHist[%d][%d][%d]",c,eg,h)));
        if(CRCCorrProdTempHist) { this->SetCRCCorrProdTempHist(CRCCorrProdTempHist,c,eg,h); }
        else { cout<<"WARNING: CRCCorrProdTempHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        // Final Histo:
        TH1D *CRCCorrHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCCorrHist[%d][%d][%d]",c,eg,h)));
        if(CRCCorrHist) { this->SetCRCCorrHist(CRCCorrHist,c,eg,h); }
        else { cout<<"WARNING: CRCCorrHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        TH1D *CRCCumHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCCumHist[%d][%d][%d]",c,eg,h)));
        if(CRCCumHist) { this->SetCRCCumHist(CRCCumHist,c,eg,h); }
        else { cout<<"WARNING: CRCCumHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }

        // Covariances:
        TProfile *CRCCorrProd2p2pPro = dynamic_cast<TProfile*>(fCRCIntList->FindObject(Form("fCRCCorrProd2p2pPro[%d][%d][%d]",c,eg,h)));
        if(CRCCorrProd2p2pPro) { this->SetCRCCorrProd2p2pPro(CRCCorrProd2p2pPro,c,eg,h); }
        else { cout<<"WARNING: CRCCorrProd2p2pPro is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        TH1D *CRCCovHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCCovHist[%d][%d][%d]",c,eg,h)));
        if(CRCCovHist) { this->SetCRCCovHist(CRCCovHist,c,eg,h); }
        else { cout<<"WARNING: CRCCovHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }

      } // end of for(Int_t c=0;c<2;c++)

      // NUA corrections:
      for(Int_t c=0;c<fCRCnNUA;c++) {
        TH1D *CRCNUATermsHist = dynamic_cast<TH1D*>(fCRCIntList->FindObject(Form("fCRCNUATermsHist[%d][%d][%d]",c,eg,h)));
        if(CRCNUATermsHist) { this->SetCRCNUATermsHist(CRCNUATermsHist,c,eg,h); }
        else { cout<<"WARNING: CRCNUATermsHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
      } // end of for(Int_t c=0;c<4;c++)

    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  TList *CRCIntRbRList = dynamic_cast<TList*>(fCRCIntList->FindObject("Run-by-Run"));
  if (CRCIntRbRList) {
    this->SetCRCIntRbRList(CRCIntRbRList);
  } else {
    cout<<"WARNING: CRCIntRbRList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    exit(0);
  }

  for(Int_t r=0;r<fCRCnRun;r++) {

    TList *CRCIntRunsList = dynamic_cast<TList*>(fCRCIntRbRList->FindObject(Form("Run %d",fRunList[r])));
    if (CRCIntRunsList) {
      this->SetCRCIntRunsList(CRCIntRunsList,r);
    } else {
      cout<<"WARNING: CRCIntRunsList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    }

    for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        for(Int_t c=0;c<fCRCnCorr;c++) {
          // EbE Corr:
          TProfile *CRCCorrPro = dynamic_cast<TProfile*>(fCRCIntRunsList[r]->FindObject(Form("fCRCCorrPro[%d][%d][%d][%d]",fRunList[r],c,eg,h)));
          if(CRCCorrPro) { this->SetCRCCorrPro(CRCCorrPro,r,c,eg,h); }
          else { cout<<"WARNING: CRCCorrPro is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
          TH1D *CRCSumWeigHist = dynamic_cast<TH1D*>(fCRCIntRunsList[r]->FindObject(Form("fCRCSumWeigHist[%d][%d][%d][%d]",fRunList[r],c,eg,h)));
          if(CRCSumWeigHist) { this->SetCRCSumWeigHist(CRCSumWeigHist,r,c,eg,h); }
          else { cout<<"WARNING: CRCSumWeigHist is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        } // end of for(Int_t c=0;c<2;c++)
        // NUA corrections:
        for(Int_t c=0;c<fCRCnNUA;c++) {
          TProfile *CRCNUATermsPro = dynamic_cast<TProfile*>(fCRCIntRunsList[r]->FindObject(Form("fCRCNUATermsPro[%d][%d][%d][%d]",fRunList[r],c,eg,h)));
          if(CRCNUATermsPro) { this->SetCRCNUATermsPro(CRCNUATermsPro,r,c,eg,h); }
          else { cout<<"WARNING: CRCNUATermsPro is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        } // end of for(Int_t c=0;c<4;c++)
      } // end of for (Int_t h=0;h<fCRCnCen;h++)
    } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  } // end of for(Int_t r=0;r<fCRCnRun;r++)

} // end void AliFlowAnalysisCRC::GetPointersForCRC()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCRC2()
{
  if(!fCalculateCRC2){return;}

  // List
  TList *CRC2List = dynamic_cast<TList*>(fCRCList->FindObject("CRC2"));
  if (CRC2List) {
    this->SetCRC2List(CRC2List);
  } else {
    cout<<"WARNING: CRC2List is NULL in AFAWQC::GPFCRC2() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      for(Int_t e=0;e<2;e++) {
        TH1D *CRC2CorHist = dynamic_cast<TH1D*>(fCRC2List->FindObject(Form("fCRC2CorHist[%d][%d][%d]",h,c,e)));
        if(CRC2CorHist) { this->SetCRC2CorHist(CRC2CorHist,h,c,e); }
        else { cout<<"WARNING: CRC2CorHist is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
      } // end of for(Int_t e=0;e<2;e++)
      for(Int_t e=0;e<4;e++) {
        TH1D *CRC2NUAHist = dynamic_cast<TH1D*>(fCRC2List->FindObject(Form("fCRC2NUAHist[%d][%d][%d]",h,c,e)));
        if(CRC2NUAHist) { this->SetCRC2NUAHist(CRC2NUAHist,h,c,e); }
        else { cout<<"WARNING: CRC2NUAHist is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
      } // end of for(Int_t e=0;e<2;e++)
      for(Int_t e=0;e<fkNCorCRC2;e++) {
        TProfile *CRC2CovPro = dynamic_cast<TProfile*>(fCRC2List->FindObject(Form("fCRC2CovPro[%d][%d][%d]",h,c,e)));
        if(CRC2CovPro) { this->SetCRC2CovPro(CRC2CovPro,h,c,e); }
        else { cout<<"WARNING: CRC2CovPro is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
        TH1D *CRC2CovHist = dynamic_cast<TH1D*>(fCRC2List->FindObject(Form("fCRC2CovHist[%d][%d][%d]",h,c,e)));
        if(CRC2CovHist) { this->SetCRC2CovHist(CRC2CovHist,h,c,e); }
        else { cout<<"WARNING: CRC2CovHist is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
      } // end of for(Int_t e=0;e<2;e++)
    } // end of for(Int_t c=0;c<3;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      TProfile *CRC2CorPro = dynamic_cast<TProfile*>(fCRC2List->FindObject(Form("fCRC2CorPro[%d][%d]",h,c)));
      if(CRC2CorPro) { this->SetCRC2CorPro(CRC2CorPro,h,c); }
      else { cout<<"WARNING: CRC2CorPro is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
      for(Int_t e=0;e<4;e++) {
        TProfile *CRC2NUAPro = dynamic_cast<TProfile*>(fCRC2List->FindObject(Form("fCRC2NUAPro[%d][%d][%d]",h,c,e)));
        if(CRC2NUAPro) { this->SetCRC2NUAPro(CRC2NUAPro,h,c,e); }
        else { cout<<"WARNING: CRC2NUAPro is NULL in AFAWQC::GPFCRC2() !!!!"<<endl; }
      } // end of for(Int_t e=0;e<4;e++)
    } // end of for(Int_t c=0;c<3;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

} // end void AliFlowAnalysisCRC::GetPointersForCRC2()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForQVec()
{
  // Q-vectors

  TList *CRCQVecList = dynamic_cast<TList*>(fHistList->FindObject("Q Vectors"));
  if (CRCQVecList) {
    this->SetCRCQVecList(CRCQVecList);
  } else {
    cout<<"WARNING: CRCQVecList is NULL in AFAWQC::GPFCRC() !!!!"<<endl;
    exit(0);
  }

  for(Int_t r=0;r<fCRCnRun;r++) {
    TList *CRCQVecListRun = dynamic_cast<TList*>(fCRCQVecList->FindObject(Form("Run %d",fRunList[r])));
    if (CRCQVecListRun) {
      this->SetCRCQVecListRun(CRCQVecListRun,r);
    } else { cout<<"WARNING: CRCQVecRunList is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }

//    if(fUseCRCRecenter) {
//      for(Int_t h=0;h<fCRCnHar;h++) {
//        TProfile *CRCQnRe = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCQnRe[%d][%d]",fRunList[r],h)));
//        if(CRCQnRe) { this->SetCRCQnReHist(CRCQnRe,r,h); }
//        else { cout<<"WARNING: CRCQn is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//        TProfile *CRCQnIm = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCQnIm[%d][%d]",fRunList[r],h)));
//        if(CRCQnIm) { this->SetCRCQnImHist(CRCQnIm,r,h); }
//        else { cout<<"WARNING: CRCQn is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//        TProfile *CRCQnReCorr = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCQnReCorr[%d][%d]",fRunList[r],h)));
//        if(CRCQnReCorr) { this->SetCRCQnReCorrHist(CRCQnReCorr,r,h); }
//        else { cout<<"WARNING: CRCQnCorr is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//        TProfile *CRCQnImCorr = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCQnImCorr[%d][%d]",fRunList[r],h)));
//        if(CRCQnImCorr) { this->SetCRCQnImCorrHist(CRCQnImCorr,r,h); }
//        else { cout<<"WARNING: CRCQnCorr is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//      }
//    }
  }

  //  if (fUseVZERO) {
  //    for(Int_t r=0;r<fCRCnRun;r++) {
  //      for(Int_t i=0;i<2;i++) {
  //        TProfile *CRCVZQVecA = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCVZQVecA[%d][%d]",fRunList[r],i)));
  //        if(CRCVZQVecA) { this->SetCRCVZQVecAHist(CRCVZQVecA,r,i); }
  //        else { cout<<"WARNING: CRCVZQVecA is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
  //        TProfile *CRCVZQVecC = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCVZQVecC[%d][%d]",fRunList[r],i)));
  //        if(CRCVZQVecC) { this->SetCRCVZQVecCHist(CRCVZQVecC,r,i); }
  //        else { cout<<"WARNING: CRCVZQVecC is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
  //      }
  //    }
  //  } // end of if (fUseVZERO)

  if (fUseZDC && fRecenterZDC) {
    for(Int_t r=0;r<fCRCnRun;r++) {
      for(Int_t i=0;i<2;i++) {
        TProfile *CRCZDCQVecA = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecA[%d][%d]",fRunList[r],i)));
        if(CRCZDCQVecA) { this->SetCRCZDCQVecAHist(CRCZDCQVecA,r,i); }
        else { cout<<"WARNING: CRCZDCQVecA is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        TProfile *CRCZDCQVecC = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecC[%d][%d]",fRunList[r],i)));
        if(CRCZDCQVecC) { this->SetCRCZDCQVecCHist(CRCZDCQVecC,r,i); }
        else { cout<<"WARNING: CRCZDCQVecC is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        TProfile *CRCZDCQVecACorr = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecACorr[%d][%d]",fRunList[r],i)));
        if(CRCZDCQVecACorr) { this->SetCRCZDCQVecACorrHist(CRCZDCQVecACorr,r,i); }
        else { cout<<"WARNING: CRCZDCQVecACorr is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
        TProfile *CRCZDCQVecCCorr = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecCCorr[%d][%d]",fRunList[r],i)));
        if(CRCZDCQVecCCorr) { this->SetCRCZDCQVecCCorrHist(CRCZDCQVecCCorr,r,i); }
        else { cout<<"WARNING: CRCZDCQVecCCorr is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
      }
//      for(Int_t i=0;i<4;i++) {
//        TH2D *CRCZDCQVecEP = dynamic_cast<TH2D*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecEP[%d][%d]",fRunList[r],i)));
//        if(CRCZDCQVecEP) { this->SetCRCZDCQVecEP(CRCZDCQVecEP,r,i); }
//        else { cout<<"WARNING: CRCZDCQVecEP is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//      }
      for(Int_t i=0;i<4;i++) {
        TProfile *CRCZDCQVecRes = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecRes[%d][%d]",fRunList[r],i)));
        if(CRCZDCQVecRes) { this->SetCRCZDCQVecRes(CRCZDCQVecRes,r,i); }
        else { cout<<"WARNING: CRCZDCQVecRes is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
      }
//      for(Int_t i=0;i<fCRCQVecnCov;i++) {
//        TProfile2D *CRCZDCQVecCov = dynamic_cast<TProfile2D*>(fCRCQVecListRun[r]->FindObject(Form("fCRCZDCQVecCov[%d][%d]",fRunList[r],i)));
//        if(CRCZDCQVecCov) { this->SetCRCZDCQVecCov(CRCZDCQVecCov,r,i); }
//        else { cout<<"WARNING: CRCZDCQVecCov is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
//      }
    }
  } // end of if (fUseZDC)

  //  if (fUseVZERO && fUseZDC) {
  //    for(Int_t r=0;r<fCRCnRun;r++) {
  //      for(Int_t i=0;i<16;i++) {
  //        TProfile *CRCVZvsZDCCov = dynamic_cast<TProfile*>(fCRCQVecListRun[r]->FindObject(Form("fCRCVZvsZDCCov[%d][%d]",fRunList[r],i)));
  //        if(CRCVZvsZDCCov) { this->SetCRCVZvsZDCCov(CRCVZvsZDCCov,r,i); }
  //        else { cout<<"WARNING: CRCVZvsZDCCov is NULL in AFAWQC::GPFCRC() !!!!"<<endl; }
  //      }
  //    }
  //  } // end of if (fUseVZERO && fUseZDC)

} // end void AliFlowAnalysisCRC::GetPointersForQVec()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCME()
{
  TList *CMEList = dynamic_cast<TList*>(fHistList->FindObject("CME"));
  if (CMEList) {
    this->SetCMEList(CMEList);
  } else {
    cout<<"WARNING: CMEList is NULL in AFAWQC::GPFCME() !!!!"<<endl;
    exit(0);
  }

  TList *CMETPCList = dynamic_cast<TList*>(fCMEList->FindObject("CME TPC only"));
  if (CMETPCList) {
    this->SetCMETPCList(CMETPCList);
  } else {
    cout<<"WARNING: CMETPCList is NULL in AFAWQC::GPFCME() !!!!"<<endl;
    exit(0);
  }

  TList *CMEZDCList = dynamic_cast<TList*>(fCMEList->FindObject("CME TPC-ZDCs"));
  if (CMEZDCList) {
    this->SetCMEZDCList(CMEZDCList);
  } else {
    cout<<"WARNING: CMEZDCList is NULL in AFAWQC::GPFCME() !!!!"<<endl;
    exit(0);
  }

  if(!fCalculateCME){return;}
  if(!fUseZDC){return;}

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {
      // Correlations:
      TH1D *CMEZDCCorHist = dynamic_cast<TH1D*>(fCMEZDCList->FindObject(Form("fCMEZDCCorHist[%d][%d]",eg,h)));
      if(CMEZDCCorHist) { this->SetCMEZDCCorHist(CMEZDCCorHist,eg,h); }
      else { cout<<"WARNING: CMEZDCCorHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      // Covariances:
      TH2D *CMEZDCCovHist = dynamic_cast<TH2D*>(fCMEZDCList->FindObject(Form("fCMEZDCCovHist[%d][%d]",eg,h)));
      if(CMEZDCCovHist) { this->SetCMEZDCCovHist(CMEZDCCovHist,eg,h); }
      else { cout<<"WARNING: CMEZDCCovHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      // Distributions:
      for (Int_t k=0;k<fCMEZDCnDist;k++) {
        TH1D *CMEZDCDistHist = dynamic_cast<TH1D*>(fCMEZDCList->FindObject(Form("fCMEZDCDistHist[%d][%d][%d]",eg,h,k)));
        if(CMEZDCDistHist) { this->SetCMEZDCDistHist(CMEZDCDistHist,eg,h,k); }
        else { cout<<"WARNING: CMEZDCDistHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      }
    } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t eg=0;eg<fCMEnEtaBin;eg++) {
      // Correlations:
      TProfile *CMEZDCCorPro = dynamic_cast<TProfile*>(fCMEZDCList->FindObject(Form("fCMEZDCCorPro[%d][%d]",eg,h)));
      if(CMEZDCCorPro) { this->SetCMEZDCCorPro(CMEZDCCorPro,eg,h); }
      else { cout<<"WARNING: CMEZDCCorPro is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      // Covariances:
      TProfile *CMEZDCCovPro = dynamic_cast<TProfile*>(fCMEZDCList->FindObject(Form("fCMEZDCCovPro[%d][%d]",eg,h)));
      if(CMEZDCCovPro) { this->SetCMEZDCCovPro(CMEZDCCovPro,eg,h); }
      else { cout<<"WARNING: CMEZDCCovPro is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      // NUA:
      TProfile *CMEZDCNUAPro = dynamic_cast<TProfile*>(fCMEZDCList->FindObject(Form("fCMEZDCNUAPro[%d][%d]",eg,h)));
      if(CMEZDCNUAPro) { this->SetCMEZDCNUAPro(CMEZDCNUAPro,eg,h); }
      else { cout<<"WARNING: CMEZDCNUAPro is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
    } // end of for(Int_t eg=0;eg<fCRCZDCnEtaBin;eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    for (Int_t h=0; h<fCMETPCnHist; h++) {
      // Profiles
      TProfile *CMETPCCorPro = dynamic_cast<TProfile*>(fCMETPCList->FindObject(Form("fCMETPCCorPro[%d][%d]",k,h)));
      if(CMETPCCorPro) { this->SetCMETPCCorPro(CMETPCCorPro,k,h); }
      else { cout<<"WARNING: CMETPCCorPro is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      // Correlations:
      TH1D *CMETPCCorHist = dynamic_cast<TH1D*>(fCMETPCList->FindObject(Form("fCMETPCCorHist[%d][%d]",k,h)));
      if(CMETPCCorHist) { this->SetCMETPCCorHist(CMETPCCorHist,k,h); }
      else { cout<<"WARNING: CMETPCCorHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      TH1D *CMETPCFinalHist = dynamic_cast<TH1D*>(fCMETPCList->FindObject(Form("fCMETPCFinalHist[%d][%d]",k,h)));
      if(CMETPCFinalHist) { this->SetCMETPCFinalHist(CMETPCFinalHist,k,h); }
      else { cout<<"WARNING: CMETPCFinalHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
    }
  }

  for (Int_t i=0; i<fCMETPCnSC; i++) {
    for (Int_t j=0; j<2; j++) {
      TProfile *CMETPCSCPro = dynamic_cast<TProfile*>(fCMETPCList->FindObject(Form("fCMETPCSCPro[%d][%d]",i,j)));
      if(CMETPCSCPro) { this->SetCMETPCSCPro(CMETPCSCPro,i,j); }
      else { cout<<"WARNING: CMETPCSCPro is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
      TH1D *CMETPCSCHist = dynamic_cast<TH1D*>(fCMETPCList->FindObject(Form("fCMETPCSCHist[%d][%d]",i,j)));
      if(CMETPCSCHist) { this->SetCMETPCSCHist(CMETPCSCHist,i,j); }
      else { cout<<"WARNING: CMETPCSCHist is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
    }
  }

  for (Int_t i=0; i<fCMETPCnHist2D; i++) {
    TProfile2D *CMETPCCorPro2D = dynamic_cast<TProfile2D*>(fCMETPCList->FindObject(Form("fCMETPCCorPro2D[%d]",i)));
    if(CMETPCCorPro2D) { this->SetCMETPCCorPro2D(CMETPCCorPro2D,i); }
    else { cout<<"WARNING: CMETPCCorPro2D is NULL in AFAWQC::GPFCME() !!!!"<<endl; }
  }

} // end void AliFlowAnalysisCRC::GetPointersForCME()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForFlowSPZDC()
{
  if(!fCalculateFlowZDC){return;}
  if(!fUseZDC){return;}

  TList *FlowSPZDCList = dynamic_cast<TList*>(fHistList->FindObject("Flow SP ZDC"));
  if (FlowSPZDCList) {
    this->SetFlowSPZDCList(FlowSPZDCList);
  } else {
    cout<<"WARNING: FlowSPZDCList is NULL in AFAWQC::GPFCRCPt() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarmZDC; i++) {
      for(Int_t j=0; j<fFlowNPro; j++) {
        TH1D *FlowSPZDCCorHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCCorHist[%d][%d][%d]",h,i,j)));
        if(FlowSPZDCCorHist) { this->SetFlowSPZDCCorHist(FlowSPZDCCorHist,h,i,j); }
        else { cout<<"WARNING: FlowSPZDCCorHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
        TH1D *FlowSPZDCFinalPtDifHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCFinalPtDifHist[%d][%d][%d]",h,i,j)));
        if(FlowSPZDCFinalPtDifHist) { this->SetFlowSPZDCFinalPtDifHist(FlowSPZDCFinalPtDifHist,h,i,j); }
        else { cout<<"WARNING: FlowSPZDCFinalPtDifHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      }
    }
  }
  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      TH1D *FlowSPZDCIntHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCIntHist[%d][%d]",i,j)));
      if(FlowSPZDCIntHist) { this->SetFlowSPZDCIntHist(FlowSPZDCIntHist,i,j); }
      else { cout<<"WARNING: FlowSPZDCIntHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      TH1D *FlowSPZDCIntFinalHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCIntFinalHist[%d][%d]",i,j)));
      if(FlowSPZDCIntFinalHist) { this->SetFlowSPZDCIntFinalHist(FlowSPZDCIntFinalHist,i,j); }
      else { cout<<"WARNING: FlowSPZDCIntFinalHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
    }
  }

  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      TProfile *FlowSPZDCIntPro = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCIntPro[%d][%d]",i,j)));
      if(FlowSPZDCIntPro) { this->SetFlowSPZDCIntPro(FlowSPZDCIntPro,i,j); }
      else { cout<<"WARNING: FlowSPZDCIntPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      for (Int_t h=0; h<fCRCnCen; h++) {
        TProfile *FlowSPZDCCorPro = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCCorPro[%d][%d][%d]",h,i,j)));
        if(FlowSPZDCCorPro) { this->SetFlowSPZDCCorPro(FlowSPZDCCorPro,h,i,j); }
        else { cout<<"WARNING: FlowSPZDCCorPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      }
    }
  }
  for(Int_t j=0; j<fFlowNNUA; j++) {
    TProfile *FlowSPZDCIntNUA = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCIntNUA[%d]",j)));
    if(FlowSPZDCIntNUA) { this->SetFlowSPZDCIntNUA(FlowSPZDCIntNUA,j); }
    else { cout<<"WARNING: FlowSPZDCIntNUA is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
    for (Int_t h=0; h<fCRCnCen; h++) {
      TProfile *FlowSPZDCCorNUA = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCCorNUA[%d][%d]",h,j)));
      if(FlowSPZDCCorNUA) { this->SetFlowSPZDCCorNUA(FlowSPZDCCorNUA,h,j); }
      else { cout<<"WARNING: FlowSPZDCCorNUA is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
    }
  }

  // v1
  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t k=0; k<fkNHarv1eta; k++) {
      for(Int_t j=0; j<fkNHistv1eta; j++) {
        TProfile *FlowSPZDCv1etaPro = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaPro[%d][%d][%d]",h,k,j)));
        if(FlowSPZDCv1etaPro) { this->SetFlowSPZDCv1etaPro(FlowSPZDCv1etaPro,h,k,j); }
        else { cout<<"WARNING: FlowSPZDCv1etaPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
        TH1D *FlowSPZDCv1etaHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaHist[%d][%d][%d]",h,k,j)));
        if(FlowSPZDCv1etaHist) { this->SetFlowSPZDCv1etaHist(FlowSPZDCv1etaHist,h,k,j); }
        else { cout<<"WARNING: FlowSPZDCv1etaHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
        TProfile *FlowSPZDCv1etaNUAPro = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaNUAPro[%d][%d][%d]",h,k,j)));
        if(FlowSPZDCv1etaNUAPro) { this->SetFlowSPZDCv1etaNUAPro(FlowSPZDCv1etaNUAPro,h,k,j); }
        else { cout<<"WARNING: FlowSPZDCv1etaNUAPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      }
    }
    for (Int_t k=0; k<fkNHistv1etaPt; k++) {
      TProfile2D *FlowSPZDCv1etaPtPro = dynamic_cast<TProfile2D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaPtPro[%d][%d]",h,k)));
      if(FlowSPZDCv1etaPtPro) { this->SetFlowSPZDCv1etaPtPro(FlowSPZDCv1etaPtPro,h,k); }
      else { cout<<"WARNING: FlowSPZDCv1etaPtPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      TH2D *FlowSPZDCv1etaPtHist = dynamic_cast<TH2D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaPtHist[%d][%d]",h,k)));
      if(FlowSPZDCv1etaPtHist) { this->SetFlowSPZDCv1etaPtHist(FlowSPZDCv1etaPtHist,h,k); }
      else { cout<<"WARNING: FlowSPZDCv1etaPtHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
    }
    for(Int_t j=0; j<fkNHistv1etaCov; j++) {
      TProfile *FlowSPZDCv1etaCovPro = dynamic_cast<TProfile*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaCovPro[%d][%d]",h,j)));
      if(FlowSPZDCv1etaCovPro) { this->SetFlowSPZDCv1etaCovPro(FlowSPZDCv1etaCovPro,h,j); }
      else { cout<<"WARNING: FlowSPZDCv1etaCovPro is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
      TH1D *FlowSPZDCv1etaCovHist = dynamic_cast<TH1D*>(fFlowSPZDCList->FindObject(Form("fFlowSPZDCv1etaCovHist[%d][%d]",h,j)));
      if(FlowSPZDCv1etaCovHist) { this->SetFlowSPZDCv1etaCovHist(FlowSPZDCv1etaCovHist,h,j); }
      else { cout<<"WARNING: FlowSPZDCv1etaCovHist is NULL in AFAWQC::GPFFSPZDC() !!!!"<<endl; }
    }
  }

} // end void AliFlowAnalysisCRC::GetPointersForFlowSPZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForFlowQC()
{
  if(!fCalculateFlowQC){return;}

  TList *FlowQCList = dynamic_cast<TList*>(fHistList->FindObject("Flow QC"));
  if (FlowQCList) {
    this->SetFlowQCList(FlowQCList);
  } else {
    cout<<"WARNING: FlowQCList is NULL in AFAWQC::GPFCRCPt() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarm; i++) {
      for(Int_t j=0; j<fFlowQCNPro; j++) {
        TProfile *FlowQCCorPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCCorPro[%d][%d][%d]",h,i,j)));
        if(FlowQCCorPro) { this->SetFlowQCCorPro(FlowQCCorPro,h,i,j); }
        else { cout<<"WARNING: FlowQCCorPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCCorHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCCorHist[%d][%d][%d]",h,i,j)));
        if(FlowQCCorHist) { this->SetFlowQCCorHist(FlowQCCorHist,h,i,j); }
        else { cout<<"WARNING: FlowQCCorHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TProfile *FlowQCCorProPhi = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCCorProPhi[%d][%d][%d]",h,i,j)));
        if(FlowQCCorProPhi) { this->SetFlowQCCorProPhi(FlowQCCorProPhi,h,i,j); }
        else { cout<<"WARNING: FlowQCCorProPhi is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
      for(Int_t k=0; k<fFlowQCNNUA; k++) {
        TProfile *FlowQCCorNUAPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCCorNUAPro[%d][%d][%d]",h,i,k)));
        if(FlowQCCorNUAPro) { this->SetFlowQCCorNUAPro(FlowQCCorNUAPro,h,i,k); }
        else { cout<<"WARNING: FlowQCCorNUAPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCCorNUAHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCCorNUAHist[%d][%d][%d]",h,i,k)));
        if(FlowQCCorNUAHist) { this->SetFlowQCCorNUAHist(FlowQCCorNUAHist,h,i,k); }
        else { cout<<"WARNING: FlowQCCorNUAHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
      for(Int_t k=0; k<fFlowQCNCov; k++) {
        TProfile *FlowQCCorCovPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCCorCovPro[%d][%d][%d]",h,i,k)));
        if(FlowQCCorCovPro) { this->SetFlowQCCorCovPro(FlowQCCorCovPro,h,i,k); }
        else { cout<<"WARNING: FlowQCCorCovPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCCorCovHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCCorCovHist[%d][%d][%d]",h,i,k)));
        if(FlowQCCorCovHist) { this->SetFlowQCCorCovHist(FlowQCCorCovHist,h,i,k); }
        else { cout<<"WARNING: FlowQCCorCovHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCFinalPtDifHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCFinalPtDifHist[%d][%d][%d]",h,i,k)));
        if(FlowQCFinalPtDifHist) { this->SetFlowQCFinalPtDifHist(FlowQCFinalPtDifHist,h,i,k); }
        else { cout<<"WARNING: FlowQCFinalPtDifHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
    }
  }

  TH2D *FlowQCSpectra = dynamic_cast<TH2D*>(fFlowQCList->FindObject(Form("fFlowQCSpectra")));
  if(FlowQCSpectra) { this->SetFlowQCSpectra(FlowQCSpectra); }
  else { cout<<"WARNING: FlowQCSpectra is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }

  // reference flow
  for(Int_t i=0; i<fFlowNHarm; i++) {
    for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
      TProfile *FlowQCIntCorPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntCorPro[%d][%d]",i,j)));
      if(FlowQCIntCorPro) { this->SetFlowQCIntCorPro(FlowQCIntCorPro,i,j); }
      else { cout<<"WARNING: FlowQCIntCorPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCIntCorHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorHist[%d][%d]",i,j)));
      if(FlowQCIntCorHist) { this->SetFlowQCIntCorHist(FlowQCIntCorHist,i,j); }
      else { cout<<"WARNING: FlowQCIntCorHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCIntCumHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntCumHist[%d][%d]",i,j)));
      if(FlowQCIntCumHist) { this->SetFlowQCIntCumHist(FlowQCIntCumHist,i,j); }
      else { cout<<"WARNING: FlowQCIntCumHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }
    for(Int_t j=0; j<6; j++) {
      TProfile *FlowQCIntCorNUAPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntCorNUAPro[%d][%d]",i,j)));
      if(FlowQCIntCorNUAPro) { this->SetFlowQCIntCorNUAPro(FlowQCIntCorNUAPro,i,j); }
      else { cout<<"WARNING: FlowQCIntCorNUAPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCIntCorNUAHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorNUAHist[%d][%d]",i,j)));
      if(FlowQCIntCorNUAHist) { this->SetFlowQCIntCorNUAHist(FlowQCIntCorNUAHist,i,j); }
      else { cout<<"WARNING: FlowQCIntCorNUAHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }
    TProfile *FlowQCIntCorProEG = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntCorProEG[%d]",i)));
    if(FlowQCIntCorProEG) { this->SetFlowQCIntCorProEG(FlowQCIntCorProEG,i); }
    else { cout<<"WARNING: FlowQCIntCorProEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    TH1D *FlowQCIntCorHistEG = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorHistEG[%d]",i)));
    if(FlowQCIntCorHistEG) { this->SetFlowQCIntCorHistEG(FlowQCIntCorHistEG,i); }
    else { cout<<"WARNING: FlowQCIntCorHistEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    for(Int_t j=0; j<4; j++) {
      TProfile *FlowQCIntCorNUAProEG = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntCorNUAProEG[%d][%d]",i,j)));
      if(FlowQCIntCorNUAProEG) { this->SetFlowQCIntCorNUAProEG(FlowQCIntCorNUAProEG,i,j); }
      else { cout<<"WARNING: FlowQCIntCorNUAProEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCIntCorNUAHistEG = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorNUAHistEG[%d][%d]",i,j)));
      if(FlowQCIntCorNUAHistEG) { this->SetFlowQCIntCorNUAHistEG(FlowQCIntCorNUAHistEG,i,j); }
      else { cout<<"WARNING: FlowQCIntCorNUAHistEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }

    for(Int_t pt=0; pt<fkFlowQCnPtRanges; pt++) {
      for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
        TProfile *FlowQCIntPtRanCorPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorPro[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorPro) { this->SetFlowQCIntPtRanCorPro(FlowQCIntPtRanCorPro,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCIntPtRanCorHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorHist[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorHist) { this->SetFlowQCIntPtRanCorHist(FlowQCIntPtRanCorHist,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCIntPtRanCumHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCumHist[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCumHist) { this->SetFlowQCIntPtRanCumHist(FlowQCIntPtRanCumHist,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCumHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
      for(Int_t j=0; j<6; j++) {
        TProfile *FlowQCIntPtRanCorNUAPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorNUAPro[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorNUAPro) { this->SetFlowQCIntPtRanCorNUAPro(FlowQCIntPtRanCorNUAPro,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorNUAPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCIntPtRanCorNUAHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorNUAHist[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorNUAHist) { this->SetFlowQCIntPtRanCorNUAHist(FlowQCIntPtRanCorNUAHist,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorNUAHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
      TProfile *FlowQCIntPtRanCorProEG = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorProEG[%d][%d]",pt,i)));
      if(FlowQCIntPtRanCorProEG) { this->SetFlowQCIntPtRanCorProEG(FlowQCIntPtRanCorProEG,pt,i); }
      else { cout<<"WARNING: FlowQCIntPtRanCorProEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCIntPtRanCorHistEG = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorHistEG[%d][%d]",pt,i)));
      if(FlowQCIntPtRanCorHistEG) { this->SetFlowQCIntPtRanCorHistEG(FlowQCIntPtRanCorHistEG,pt,i); }
      else { cout<<"WARNING: FlowQCIntPtRanCorHistEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      for(Int_t j=0; j<4; j++) {
        TProfile *FlowQCIntPtRanCorNUAProEG = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorNUAProEG[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorNUAProEG) { this->SetFlowQCIntPtRanCorNUAProEG(FlowQCIntPtRanCorNUAProEG,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorNUAProEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowQCIntPtRanCorNUAHistEG = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCIntPtRanCorNUAHistEG[%d][%d][%d]",pt,i,j)));
        if(FlowQCIntPtRanCorNUAHistEG) { this->SetFlowQCIntPtRanCorNUAHistEG(FlowQCIntPtRanCorNUAHistEG,pt,i,j); }
        else { cout<<"WARNING: FlowQCIntPtRanCorNUAHistEG is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
    }

    for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++) {
      for(Int_t j=0; j<fkFlowQCnIntCorTest; j++) {
        TProfile2D *FlowQCIntCorProTest = dynamic_cast<TProfile2D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorProTest[%d][%d][%d]",i,k,j)));
        if(FlowQCIntCorProTest) { this->SetFlowQCIntCorProTest(FlowQCIntCorProTest,i,k,j); }
        else { cout<<"WARNING: FlowQCIntCorProTest is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH2D *FlowQCIntCorHistTest = dynamic_cast<TH2D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorHistTest[%d][%d][%d]",i,k,j)));
        if(FlowQCIntCorHistTest) { this->SetFlowQCIntCorHistTest(FlowQCIntCorHistTest,i,k,j); }
        else { cout<<"WARNING: FlowQCIntCorHistTest is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH2D *FlowQCIntCumHistTest = dynamic_cast<TH2D*>(fFlowQCList->FindObject(Form("fFlowQCIntCumHistTest[%d][%d][%d]",i,k,j)));
        if(FlowQCIntCumHistTest) { this->SetFlowQCIntCumHistTest(FlowQCIntCumHistTest,i,k,j); }
        else { cout<<"WARNING: FlowQCIntCumHistTest is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH2D *FlowQCIntFinHistTest = dynamic_cast<TH2D*>(fFlowQCList->FindObject(Form("fFlowQCIntFinHistTest[%d][%d][%d]",i,k,j)));
        if(FlowQCIntFinHistTest) { this->SetFlowQCIntFinHistTest(FlowQCIntFinHistTest,i,k,j); }
        else { cout<<"WARNING: FlowQCIntFinHistTest is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
    }
    for(Int_t k=0; k<fkFlowQCnNUATest; k++) {
      TProfile2D *FlowQCIntCorNUAProTest = dynamic_cast<TProfile2D*>(fFlowQCList->FindObject(Form("fFlowQCIntCorNUAProTest[%d][%d]",i,k)));
      if(FlowQCIntCorNUAProTest) { this->SetFlowQCIntCorNUAProTest(FlowQCIntCorNUAProTest,i,k); }
      else { cout<<"WARNING: FlowQCIntCorNUAProTest is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }
    for(Int_t j=0; j<fFlowQCNRef; j++) {
      TProfile *FlowQCRefCorPro = dynamic_cast<TProfile*>(fFlowQCList->FindObject(Form("fFlowQCRefCorPro[%d][%d]",i,j)));
      if(FlowQCRefCorPro) { this->SetFlowQCRefCorPro(FlowQCRefCorPro,i,j); }
      else { cout<<"WARNING: FlowQCRefCorPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      TH1D *FlowQCRefCorHist = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCRefCorHist[%d][%d]",i,j)));
      if(FlowQCRefCorHist) { this->SetFlowQCRefCorHist(FlowQCRefCorHist,i,j); }
      else { cout<<"WARNING: FlowQCRefCorHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }
    for(Int_t j=0; j<4; j++) {
      TH1D *FlowQCRefCorFinal = dynamic_cast<TH1D*>(fFlowQCList->FindObject(Form("fFlowQCRefCorFinal[%d][%d]",i,j)));
      if(FlowQCRefCorFinal) { this->SetFlowQCRefCorFinal(FlowQCRefCorFinal,i,j); }
      else { cout<<"WARNING: FlowQCRefCorFinal is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
    }
  }

  TList *FlowQCCorrZDCList = dynamic_cast<TList*>(fFlowQCList->FindObject("Corr ZDC"));
  if (FlowQCCorrZDCList) {
    this->SetFlowQCCorrZDCList(FlowQCCorrZDCList);
    for(Int_t i=0; i<fSCv2vsZNHarm; i++) {
      for(Int_t bng=0; bng<fkSCNHist; bng++) {
        TProfile *FlowSCProdPro = dynamic_cast<TProfile*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCProdPro[%d][%d]",i,bng)));
        if(FlowSCProdPro) { this->SetFlowSCProdPro(FlowSCProdPro,i,bng); }
        else { cout<<"WARNING: FlowSCProdPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowSCProdHist = dynamic_cast<TH1D*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCProdHist[%d][%d]",i,bng)));
        if(FlowSCProdHist) { this->SetFlowSCProdHist(FlowSCProdHist,i,bng); }
        else { cout<<"WARNING: FlowSCProdHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowSCFinalHist = dynamic_cast<TH1D*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCFinalHist[%d][%d]",i,bng)));
        if(FlowSCFinalHist) { this->SetFlowSCFinalHist(FlowSCFinalHist,i,bng); }
        else { cout<<"WARNING: FlowSCFinalHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        TH1D *FlowSCCovHist = dynamic_cast<TH1D*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCCovHist[%d][%d]",i,bng)));
        if(FlowSCCovHist) { this->SetFlowSCCovHist(FlowSCCovHist,i,bng); }
        else { cout<<"WARNING: FlowSCCovHist is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
      }
      for (Int_t k=0; k<fkFlowSCNvar; k++) {
        for (Int_t z=0; z<fkFlowSCNvar; z++) {
          TProfile *FlowSCCrossProdPro = dynamic_cast<TProfile*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCCrossProdPro[%d][%d][%d]",i,k,z)));
          if(FlowSCCrossProdPro) { this->SetFlowSCCrossProdPro(FlowSCCrossProdPro,i,k,z); }
          else { cout<<"WARNING: FlowSCCrossProdPro is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
          TProfile *FlowSCCrossProdProMult = dynamic_cast<TProfile*>(fFlowQCCorrZDCList->FindObject(Form("fFlowSCCrossProdProMult[%d][%d][%d]",i,k,z)));
          if(FlowSCCrossProdProMult) { this->SetFlowSCCrossProdProMult(FlowSCCrossProdProMult,i,k,z); }
          else { cout<<"WARNING: FlowSCCrossProdProMult is NULL in AFAWQC::GPFFQC() !!!!"<<endl; }
        }
      }
    }
  }

} // end void AliFlowAnalysisCRC::GetPointersForFlowQC()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForFlowGF()
{
  if(!fCalculateFlowQC){return;}

  TList *FlowGFList = dynamic_cast<TList*>(fHistList->FindObject("Flow GF"));
  if (FlowGFList) {
    this->SetFlowGFList(FlowGFList);
  } else {
    cout<<"WARNING: FlowGFList is NULL in AFAWQC::GPFFGF() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNOrde; i++) {
      TProfile *FlowGFIntCorPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCorPro[%d][%d]",h,i)));
      if(FlowGFIntCorPro) { this->SetFlowGFIntCorPro(FlowGFIntCorPro,h,i); }
      else { cout<<"WARNING: FlowGFIntCorPro is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      TH1D *FlowGFIntCorHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCorHist[%d][%d]",h,i)));
      if(FlowGFIntCorHist) { this->SetFlowGFIntCorHist(FlowGFIntCorHist,h,i); }
      else { cout<<"WARNING: FlowGFIntCorHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      TH1D *FlowGFIntCumHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCumHist[%d][%d]",h,i)));
      if(FlowGFIntCumHist) { this->SetFlowGFIntCumHist(FlowGFIntCumHist,h,i); }
      else { cout<<"WARNING: FlowGFIntCumHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      TH1D *FlowGFIntFinalHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntFinalHist[%d][%d]",h,i)));
      if(FlowGFIntFinalHist) { this->SetFlowGFIntFinalHist(FlowGFIntFinalHist,h,i); }
      else { cout<<"WARNING: FlowGFIntFinalHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      for(Int_t k=0; k<fkFlowGFNOrde; k++) {
        TProfile *FlowGFIntCovPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCovPro[%d][%d][%d]",h,i,k)));
        if(FlowGFIntCovPro) { this->SetFlowGFIntCovPro(FlowGFIntCovPro,h,i,k); }
        else { cout<<"WARNING: FlowGFIntCovPro is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
        TH1D *FlowGFIntCovHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCovHist[%d][%d][%d]",h,i,k)));
        if(FlowGFIntCovHist) { this->SetFlowGFIntCovHist(FlowGFIntCovHist,h,i,k); }
        else { cout<<"WARNING: FlowGFIntCovHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      }
      // for subsampling
      for(Int_t s=0; s<fkFlowGFNSubSampling; s++) {
        TProfile *FlowGFIntCorPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCorProSS[%d][%d][%d]",s,h,i)));
        if(FlowGFIntCorPro) { this->SetFlowGFIntCorProSS(FlowGFIntCorPro,s,h,i); }
        TH1D *FlowGFIntCorHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCorHistSS[%d][%d][%d]",s,h,i)));
        if(FlowGFIntCorHist) { this->SetFlowGFIntCorHistSS(FlowGFIntCorHist,s,h,i); }
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          TProfile *FlowGFIntCovPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCovProSS[%d][%d][%d][%d]",s,h,i,k)));
          if(FlowGFIntCovPro) { this->SetFlowGFIntCovProSS(FlowGFIntCovPro,s,h,i,k); }
          TH1D *FlowGFIntCovHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCovHistSS[%d][%d][%d][%d]",s,h,i,k)));
          if(FlowGFIntCovHist) { this->SetFlowGFIntCovHistSS(FlowGFIntCovHist,s,h,i,k); }
        }
      }
      // in wide pt bins
      for(Int_t s=0; s<fkGFPtB; s++) {
        TProfile *FlowGFIntCorPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCorProPtB[%d][%d][%d]",s,h,i)));
        if(FlowGFIntCorPro) { this->SetFlowGFIntCorProPtB(FlowGFIntCorPro,s,h,i); }
        TH1D *FlowGFIntCorHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCorHistPtB[%d][%d][%d]",s,h,i)));
        if(FlowGFIntCorHist) { this->SetFlowGFIntCorHistPtB(FlowGFIntCorHist,s,h,i); }
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          TProfile *FlowGFIntCovPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFIntCovProPtB[%d][%d][%d][%d]",s,h,i,k)));
          if(FlowGFIntCovPro) { this->SetFlowGFIntCovProPtB(FlowGFIntCovPro,s,h,i,k); }
          TH1D *FlowGFIntCovHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntCovHistPtB[%d][%d][%d][%d]",s,h,i,k)));
          if(FlowGFIntCovHist) { this->SetFlowGFIntCovHistPtB(FlowGFIntCovHist,s,h,i,k); }
        }
      }
    }
    for(Int_t i=0; i<fkFlowGFNExtra; i++) {
      TH1D *FlowGFIntExtraHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFIntExtraHist[%d][%d]",h,i)));
      if(FlowGFIntExtraHist) { this->SetFlowGFIntExtraHist(FlowGFIntExtraHist,h,i); }
      else { cout<<"WARNING: FlowGFIntExtraHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
    }
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNHarm; i++) {
      TProfile *FlowGFMixedCorPro = dynamic_cast<TProfile*>(fFlowGFList->FindObject(Form("fFlowGFMixedCorPro[%d][%d]",h,i)));
      if(FlowGFMixedCorPro) { this->SetFlowGFMixedCorPro(FlowGFMixedCorPro,h,i); }
      else { cout<<"WARNING: FlowGFMixedCorPro is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      TH1D *FlowGFMixedCorHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFMixedCorHist[%d][%d]",h,i)));
      if(FlowGFMixedCorHist) { this->SetFlowGFMixedCorHist(FlowGFMixedCorHist,h,i); }
      else { cout<<"WARNING: FlowGFMixedCorHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
      TH1D *FlowGFMixedFinalHist = dynamic_cast<TH1D*>(fFlowGFList->FindObject(Form("fFlowGFMixedFinalHist[%d][%d]",h,i)));
      if(FlowGFMixedFinalHist) { this->SetFlowGFMixedFinalHist(FlowGFMixedFinalHist,h,i); }
      else { cout<<"WARNING: FlowGFMixedFinalHist is NULL in AFAWQC::GPFFGF() !!!!"<<endl; }
    }
  }

} // end of AliFlowAnalysisCRC::GetPointersForFlowGF()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForFlowSPVZ()
{
  if(!fCalculateFlowVZ){return;}
  if(!fUseVZERO){return;}

  TList *FlowSPVZList = dynamic_cast<TList*>(fHistList->FindObject("Flow SP VZ"));
  if (FlowSPVZList) {
    this->SetFlowSPVZList(FlowSPVZList);
  } else {
    cout<<"WARNING: FlowSPVZList is NULL in AFAWQC::GPFCRCPt() !!!!"<<endl;
    exit(0);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fCRCnHar; i++) {
      for(Int_t j=0; j<fkFlowSPVZnHist; j++) {
        TProfile *FlowSPVZCorPro = dynamic_cast<TProfile*>(fFlowSPVZList->FindObject(Form("fFlowSPVZCorPro[%d][%d][%d]",h,i,j)));
        if(FlowSPVZCorPro) { this->SetFlowSPVZCorPro(FlowSPVZCorPro,h,i,j); }
        else { cout<<"WARNING: FlowSPVZCorPro is NULL in AFAWQC::GPFFSPVZ() !!!!"<<endl; }
        TH1D *FlowSPVZCorHist = dynamic_cast<TH1D*>(fFlowSPVZList->FindObject(Form("fFlowSPVZCorHist[%d][%d][%d]",h,i,j)));
        if(FlowSPVZCorHist) { this->SetFlowSPVZCorHist(FlowSPVZCorHist,h,i,j); }
        else { cout<<"WARNING: FlowSPVZCorHist is NULL in AFAWQC::GPFFSPVZ() !!!!"<<endl; }
        TProfile *FlowSPVZNUAPro = dynamic_cast<TProfile*>(fFlowSPVZList->FindObject(Form("fFlowSPVZNUAPro[%d][%d][%d]",h,i,j)));
        if(FlowSPVZNUAPro) { this->SetFlowSPVZNUAPro(FlowSPVZNUAPro,h,i,j); }
        else { cout<<"WARNING: FlowSPVZNUAPro is NULL in AFAWQC::GPFFSPVZ() !!!!"<<endl; }
      }
    }
  }

} // end void AliFlowAnalysisCRC::GetPointersForFlowSPVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForEbEFlow()
{
  if(!fCalculateEbEFlow){return;}

  TList *EbEFlowList = dynamic_cast<TList*>(fHistList->FindObject("EbE Flow"));
  if (EbEFlowList) {
    this->SetEbEFlowList(EbEFlowList);
  } else {
    cout<<"WARNING: EbEFlowList is NULL in AFAWQC::GPFEbEF() !!!!"<<endl;
    exit(0);
  }

} // end void AliFlowAnalysisCRC::GetPointersForEbEFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForCRCPt()
{
} // end void AliFlowAnalysisCRC::GetPointersForCRCPt()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForVarious()
{
  // Get VariousList
  TList *VariousList = dynamic_cast<TList*>(fHistList->FindObject("Various"));
  if (VariousList) {
    this->SetVariousList(VariousList);
  } else {
    cout<<"WARNING: VariousList is NULL in AFAWQC::GPFV() !!!!"<<endl;
    exit(0);
  }

  // Get StoreVarious flag
  TList *intFlowList = NULL;
  intFlowList = dynamic_cast<TList*>(fHistList->FindObject("Integrated Flow"));
  if(!intFlowList) {
    cout<<"WARNING: intFlowList is NULL in AFAWQC::GPFV() !!!!"<<endl;
    exit(0);
  }
  TString intFlowFlagsName = "fIntFlowFlags";
  intFlowFlagsName += fAnalysisLabel->Data();
  TProfile *intFlowFlags = dynamic_cast<TProfile*>(intFlowList->FindObject(intFlowFlagsName.Data()));
  if(intFlowFlags) {
    fStoreVarious = (Bool_t)intFlowFlags->GetBinContent(13);
  } else {
    cout<<"WARNING: intFlowFlags is NULL in AFAWQC::GPFV() !!!!"<<endl;
  }

  if(!fStoreVarious){return;}

  TString fUseParticleWeightsName = "fUseParticleWeightsQC"; // to be improved (hirdwired label QC)
  fUseParticleWeightsName += fAnalysisLabel->Data();
  TProfile *useParticleWeights = dynamic_cast<TProfile*>(fVariousList->FindObject(fUseParticleWeightsName.Data()));
  if(useParticleWeights) {
    this->SetUseParticleWeights(useParticleWeights);
  }

  TH1D *MultHist = dynamic_cast<TH1D*>(fVariousList->FindObject("Multiplicity"));
  if(MultHist) {
    this->SetMultHist(MultHist);
  } else {
    cout<<"WARNING: MultHist is NULL in AFAWQC::GPFV() !!!!"<<endl;
  }
  TH1D *CenHist = dynamic_cast<TH1D*>(fVariousList->FindObject("Centrality"));
  if(CenHist) {
    this->SetCenHist(CenHist);
  } else {
    cout<<"WARNING: CenHist is NULL in AFAWQC::GPFV() !!!!"<<endl;
  }
  TH1D *CenWeightsHist = dynamic_cast<TH1D*>(fVariousList->FindObject("CenWeights"));
  if(CenWeightsHist) {
    this->SetCenWeightsHist(CenWeightsHist);
  }

  for(Int_t h=0; h<fCRCnCen; h++) {
    TH2F* ZNCvsZNA = dynamic_cast<TH2F*>(fVariousList->FindObject(Form("fhZNCvsZNA[%d]",h)));
    if(ZNCvsZNA) this->SetZNCvsZNA(ZNCvsZNA,h);
  }
  for (Int_t c=0; c<2; c++) {
    TH2F* ZNvsCen = dynamic_cast<TH2F*>(fVariousList->FindObject(Form("fhZNvsCen[%d]",c)));
    if(ZNvsCen) this->SetZNvsCen(ZNvsCen,c);
    TH2F* ZNvsTCen = dynamic_cast<TH2F*>(fVariousList->FindObject(Form("fhZNvsTCen[%d]",c)));
    if(ZNvsTCen) this->SetZNvsTCen(ZNvsTCen,c);
  }
  for (Int_t c=0; c<fZDCESEnCl+1; c++) {
    TH2F* CenvsMul = dynamic_cast<TH2F*>(fVariousList->FindObject(Form("fhCenvsMul[%d]",c)));
    if(CenvsMul) this->SetCenvsMul(CenvsMul,c);
    TH2F* CenvsSpec = dynamic_cast<TH2F*>(fVariousList->FindObject(Form("fhCenvsSpec[%d]",c)));
    if(CenvsSpec) this->SetCenvsSpec(CenvsSpec,c);
  }

  TH2F* ZNvsMul = dynamic_cast<TH2F*>(fVariousList->FindObject("fhZNvsMul"));
  if(ZNvsMul) this->SetZNvsMul(ZNvsMul);

} // end void AliFlowAnalysisCRC::GetPointersForVarious()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingFor2DDifferentialFlow()
{
  // Book all objects needed for 2D differential flow.
  //  a) Define flags locally (to be improved: should I promote flags to data members?);
  //  b) Book e-b-e quantities;
  //  c) Book 2D profiles;
  //  d) Book 2D histograms.

  if(!fCalculate2DDiffFlow){return;}

  // a) Define flags locally (to be improved: should I promote flags to data members?):
  TString typeFlag[2] = {"RP","POI"};
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"};
  TString differentialCumulantIndex[4] = {"QC{2'}","QC{4'}","QC{6'}","QC{8'}"};
  TString differentialFlowIndex[4] = {"v'{2}","v'{4}","v'{6}","v'{8}"};

  // b) Book e-b-e quantities:
  TProfile2D styleRe("typeMultiplePowerRe","typeMultiplePowerRe",fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax);
  TProfile2D styleIm("typeMultiplePowerIm","typeMultiplePowerIm",fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax);
  for(Int_t t=0;t<3;t++) // typeFlag (0 = RP, 1 = POI, 2 = RP&&POI )
  {
    for(Int_t m=0;m<4;m++)
    {
      for(Int_t k=0;k<9;k++)
      {
        fReRPQ2dEBE[t][m][k] = (TProfile2D*)styleRe.Clone(Form("typeFlag%dmultiple%dpower%dRe",t,m,k));
        fImRPQ2dEBE[t][m][k] = (TProfile2D*)styleIm.Clone(Form("typeFlag%dmultiple%dpower%dIm",t,m,k));
      }
    }
  }
  TProfile2D styleS("typePower","typePower",fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax);
  for(Int_t t=0;t<3;t++) // typeFlag (0 = RP, 1 = POI, 2 = RP&&POI )
  {
    for(Int_t k=0;k<9;k++)
    {
      fs2dEBE[t][k] = (TProfile2D*)styleS.Clone(Form("typeFlag%dpower%d",t,k));
    }
  }

  // c) Book 2D profiles:
  TString s2DDiffFlowCorrelationsProName = "f2DDiffFlowCorrelationsPro";
  s2DDiffFlowCorrelationsProName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t rci=0;rci<4;rci++) // reduced correlation index
    {
      f2DDiffFlowCorrelationsPro[t][rci] = new TProfile2D(Form("%s, %s, %s",s2DDiffFlowCorrelationsProName.Data(),typeFlag[t].Data(),reducedCorrelationIndex[rci].Data()),Form("%s, %s, %s",s2DDiffFlowCorrelationsProName.Data(),typeFlag[t].Data(),reducedCorrelationIndex[rci].Data()),fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax,"");
      f2DDiffFlowCorrelationsPro[t][rci]->Sumw2();
      f2DDiffFlowCorrelationsPro[t][rci]->SetXTitle("p_{t}");
      f2DDiffFlowCorrelationsPro[t][rci]->SetYTitle("#eta");
      f2DDiffFlowCorrelationsProList[t]->Add(f2DDiffFlowCorrelationsPro[t][rci]);
    } // end of for(Int_t rci=0;rci<4;rci++) // correlation index
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POIs

  // d) Book 2D histograms:
  TString s2DDiffFlowCumulantsName = "f2DDiffFlowCumulants";
  s2DDiffFlowCumulantsName += fAnalysisLabel->Data();
  TString s2DDiffFlowName = "f2DDiffFlow";
  s2DDiffFlowName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t rci=0;rci<4;rci++) // reduced correlation index
    {
      // 2D diferential cumulants:
      f2DDiffFlowCumulants[t][rci] = new TH2D(Form("%s, %s, %s",s2DDiffFlowCumulantsName.Data(),typeFlag[t].Data(),differentialCumulantIndex[rci].Data()),Form("%s, %s, %s",s2DDiffFlowCumulantsName.Data(),typeFlag[t].Data(),differentialCumulantIndex[rci].Data()),fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax);
      f2DDiffFlowCumulants[t][rci]->SetXTitle("p_{t}");
      f2DDiffFlowCumulants[t][rci]->SetYTitle("#eta");
      f2DDiffFlowCorrelationsProList[t]->Add(f2DDiffFlowCumulants[t][rci]); //  to be improved - moved to another list
      // 2D differential flow:
      f2DDiffFlow[t][rci] = new TH2D(Form("%s, %s, %s",s2DDiffFlowName.Data(),typeFlag[t].Data(),differentialFlowIndex[rci].Data()),Form("%s, %s, %s",s2DDiffFlowName.Data(),typeFlag[t].Data(),differentialFlowIndex[rci].Data()),fnBinsPt,fPtMin,fPtMax,fnBinsEta,fEtaMin,fEtaMax);
      f2DDiffFlow[t][rci]->SetXTitle("p_{t}");
      f2DDiffFlow[t][rci]->SetYTitle("#eta");
      f2DDiffFlowCorrelationsProList[t]->Add(f2DDiffFlow[t][rci]); //  to be improved - moved to another list
    } // end of for(Int_t rci=0;rci<4;rci++) // correlation index
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POIs

} // void AliFlowAnalysisCRC::BookEverythingFor2DDifferentialFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForDifferentialFlow()
{
  // Book all histograms and profiles needed for differential flow.
  //  a) Book profile to hold all flags for differential flow;
  //  b) Define flags locally (to be improved: should I promote flags to data members?);
  //  c) Book e-b-e quantities;
  //  d) Book profiles;
  //  e) Book histograms holding final results.

  // a) Book profile to hold all flags for differential flow:
  TString diffFlowFlagsName = "fDiffFlowFlags";
  diffFlowFlagsName += fAnalysisLabel->Data();
  fDiffFlowFlags = new TProfile(diffFlowFlagsName.Data(),"Flags for differential flow",6,0,6);
  fDiffFlowFlags->SetTickLength(-0.01,"Y");
  fDiffFlowFlags->SetMarkerStyle(25);
  fDiffFlowFlags->SetLabelSize(0.04,"X");
  fDiffFlowFlags->SetLabelOffset(0.02,"Y");
  fDiffFlowFlags->SetStats(kFALSE);
  fDiffFlowFlags->GetXaxis()->SetBinLabel(1,"Calculate diff. flow");
  fDiffFlowFlags->GetXaxis()->SetBinLabel(2,"Particle weights");
  fDiffFlowFlags->GetXaxis()->SetBinLabel(3,"Event weights");
  fDiffFlowFlags->GetXaxis()->SetBinLabel(4,"Correct for NUA");
  fDiffFlowFlags->GetXaxis()->SetBinLabel(5,"Calculate 2D diff. flow");
  fDiffFlowFlags->GetXaxis()->SetBinLabel(6,"Calculate diff. flow vs eta");
  fDiffFlowList->Add(fDiffFlowFlags);

  if(!fCalculateDiffFlow){return;}

  // b) Define flags locally (to be improved: should I promote flags to data members?):
  TString typeFlag[2] = {"RP","POI"};
  TString ptEtaFlag[2] = {"p_{T}","#eta"};
  TString powerFlag[2] = {"linear","quadratic"};
  TString sinCosFlag[2] = {"sin","cos"};
  TString differentialCumulantIndex[4] = {"QC{2'}","QC{4'}","QC{6'}","QC{8'}"};
  TString differentialFlowIndex[4] = {"v'{2}","v'{4}","v'{6}","v'{8}"};
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"};
  TString reducedSquaredCorrelationIndex[4] = {"<2'>^{2}","<4'>^{2}","<6'>^{2}","<8'>^{2}"};
  TString mixedCorrelationIndex[8] = {"<2>","<2'>","<4>","<4'>","<6>","<6'>","<8>","<8'>"};
  TString covarianceName[5] = {"Cov(<2>,<2'>)","Cov(<2>,<4'>)","Cov(<4>,<2'>)","Cov(<4>,<4'>)","Cov(<2'>,<4'>)"};
  Int_t nBinsPtEta[2] = {fnBinsPt,fnBinsEta};
  Double_t minPtEta[2] = {fPtMin,fEtaMin};
  Double_t maxPtEta[2] = {fPtMax,fEtaMax};

  // c) Book e-b-e quantities:
  // Event-by-event r_{m*n,k}(pt,eta), p_{m*n,k}(pt,eta) and q_{m*n,k}(pt,eta)
  // Explanantion of notation:
  //  1.) n is harmonic, m is multiple of harmonic;
  //  2.) k is power of particle weight;
  //  3.) r_{m*n,k}(pt,eta) = Q-vector evaluated in harmonic m*n for RPs in particular (pt,eta) bin (i-th RP is weighted with w_i^k);
  //  4.) p_{m*n,k}(pt,eta) = Q-vector evaluated in harmonic m*n for POIs in particular (pt,eta) bin
  //                          (if i-th POI is also RP, than it is weighted with w_i^k);
  //  5.) q_{m*n,k}(pt,eta) = Q-vector evaluated in harmonic m*n for particles which are both RPs and POIs in particular (pt,eta) bin
  //                          (i-th RP&&POI is weighted with w_i^k)

  // 1D:
  for(Int_t t=0;t<3;t++) // typeFlag (0 = RP, 1 = POI, 2 = RP && POI )
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t m=0;m<4;m++) // multiple of harmonic
      {
        for(Int_t k=0;k<9;k++) // power of particle weight
        {
          fReRPQ1dEBE[t][pe][m][k] = new TProfile(Form("TypeFlag%dpteta%dmultiple%dpower%dRe",t,pe,m,k),
                                                  Form("TypeFlag%dpteta%dmultiple%dpower%dRe",t,pe,m,k),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fImRPQ1dEBE[t][pe][m][k] = new TProfile(Form("TypeFlag%dpteta%dmultiple%dpower%dIm",t,pe,m,k),
                                                  Form("TypeFlag%dpteta%dmultiple%dpower%dIm",t,pe,m,k),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        }
      }
    }
  }

  // to be improved (add explanation of fs1dEBE[t][pe][k]):
  for(Int_t t=0;t<3;t++) // typeFlag (0 = RP, 1 = POI, 2 = RP&&POI )
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t k=0;k<9;k++) // power of particle weight
      {
        fs1dEBE[t][pe][k] = new TProfile(Form("TypeFlag%dpteta%dmultiple%d",t,pe,k),
                                         Form("TypeFlag%dpteta%dmultiple%d",t,pe,k),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
      }
    }
  }
  // correction terms for nua:
  for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAEBE[t][pe][sc][cti] = new TH1D(Form("typeFlag%d pteta%d sincos%d cti%d",t,pe,sc,cti),
                                                                       Form("typeFlag%d pteta%d sincos%d cti%d",t,pe,sc,cti),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        }
      }
    }
  }
  // reduced correlations e-b-e:
  TString diffFlowCorrelationsEBEName = "fDiffFlowCorrelationsEBE";
  diffFlowCorrelationsEBEName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t rci=0;rci<4;rci++) // reduced correlation index
      {
        fDiffFlowCorrelationsEBE[t][pe][rci] = new TH1D(Form("%s, %s, %s, %s",diffFlowCorrelationsEBEName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),Form("%s, %s, %s, %s",diffFlowCorrelationsEBEName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // event weights for reduced correlations e-b-e:
  TString diffFlowEventWeightsForCorrelationsEBEName = "fDiffFlowEventWeightsForCorrelationsEBE";
  diffFlowEventWeightsForCorrelationsEBEName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t rci=0;rci<4;rci++) // event weight for reduced correlation index
      {
        fDiffFlowEventWeightsForCorrelationsEBE[t][pe][rci] = new TH1D(Form("%s, %s, %s, eW for %s",diffFlowEventWeightsForCorrelationsEBEName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),Form("%s, %s, %s, eW for %s",diffFlowEventWeightsForCorrelationsEBEName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
      } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI

  // d) Book profiles;
  // reduced correlations:
  TString diffFlowCorrelationsProName = "fDiffFlowCorrelationsPro";
  diffFlowCorrelationsProName += fAnalysisLabel->Data();
  // reduced squared correlations:
  TString diffFlowSquaredCorrelationsProName = "fDiffFlowSquaredCorrelationsPro";
  diffFlowSquaredCorrelationsProName += fAnalysisLabel->Data();
  // corrections terms:
  TString diffFlowCorrectionTermsForNUAProName = "fDiffFlowCorrectionTermsForNUAPro";
  diffFlowCorrectionTermsForNUAProName += fAnalysisLabel->Data();
  // reduced correlations:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t rci=0;rci<4;rci++) // reduced correlation index
      {
        fDiffFlowCorrelationsPro[t][pe][rci] = new TProfile(Form("%s, %s, %s, %s",diffFlowCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),Form("%s, %s, %s, %s",diffFlowCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[rci].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe],"s");
        fDiffFlowCorrelationsPro[t][pe][rci]->Sumw2();
        fDiffFlowCorrelationsPro[t][pe][rci]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowCorrelationsProList[t][pe]->Add(fDiffFlowCorrelationsPro[t][pe][rci]); // to be improved (add dedicated list to hold reduced correlations)
      } // end of for(Int_t rci=0;rci<4;rci++) // correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // reduced squared correlations:
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t rci=0;rci<4;rci++) // reduced correlation index
      {
        fDiffFlowSquaredCorrelationsPro[t][pe][rci] = new TProfile(Form("%s, %s, %s, %s",diffFlowSquaredCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedSquaredCorrelationIndex[rci].Data()),Form("%s, %s, %s, %s",diffFlowSquaredCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedSquaredCorrelationIndex[rci].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe],"s");
        fDiffFlowSquaredCorrelationsPro[t][pe][rci]->Sumw2();
        fDiffFlowSquaredCorrelationsPro[t][pe][rci]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowCorrelationsProList[t][pe]->Add(fDiffFlowSquaredCorrelationsPro[t][pe][rci]); // to be improved (add dedicated list to hold reduced correlations)
      } // end of for(Int_t rci=0;rci<4;rci++) // correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // correction terms for nua:
  for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAPro[t][pe][sc][cti] = new TProfile(Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fDiffFlowCorrectionsProList[t][pe]->Add(fDiffFlowCorrectionTermsForNUAPro[t][pe][sc][cti]);
        }
      }
    }
  }
  // Other differential correlators:
  TString otherDiffCorrelatorsName = "fOtherDiffCorrelators";
  otherDiffCorrelatorsName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t ci=0;ci<1;ci++) // correlator index
        {
          fOtherDiffCorrelators[t][pe][sc][ci] = new TProfile(Form("%s, %s, %s, %s, ci = %d",otherDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1),Form("%s, %s, %s, %s, ci = %d",otherDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fOtherDiffCorrelators[t][pe][sc][ci]->Sumw2();
          fOtherDiffCorrelatorsList->Add(fOtherDiffCorrelators[t][pe][sc][ci]);
        }
      }
    }
  }

  // e) Book histograms holding final results.
  // reduced correlations:
  TString diffFlowCorrelationsHistName = "fDiffFlowCorrelationsHist";
  diffFlowCorrelationsHistName += fAnalysisLabel->Data();
  // corrections terms:
  TString diffFlowCorrectionTermsForNUAHistName = "fDiffFlowCorrectionTermsForNUAHist";
  diffFlowCorrectionTermsForNUAHistName += fAnalysisLabel->Data();
  // differential covariances:
  TString diffFlowCovariancesName = "fDiffFlowCovariances";
  diffFlowCovariancesName += fAnalysisLabel->Data();
  // differential Q-cumulants:
  TString diffFlowCumulantsName = "fDiffFlowCumulants";
  diffFlowCumulantsName += fAnalysisLabel->Data();
  // Detector bias to differential Q-cumulants:
  TString diffFlowDetectorBiasName = "fDiffFlowDetectorBias";
  diffFlowDetectorBiasName += fAnalysisLabel->Data();
  // differential flow:
  TString diffFlowName = "fDiffFlow";
  diffFlowName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type: RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t index=0;index<4;index++)
      {
        // reduced correlations:
        fDiffFlowCorrelationsHist[t][pe][index] = new TH1D(Form("%s, %s, %s, %s",diffFlowCorrelationsHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[index].Data()),Form("%s, %s, %s, %s",diffFlowCorrelationsHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[index].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        fDiffFlowCorrelationsHist[t][pe][index]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowCorrelationsHistList[t][pe]->Add(fDiffFlowCorrelationsHist[t][pe][index]);
        // differential Q-cumulants:
        fDiffFlowCumulants[t][pe][index] = new TH1D(Form("%s, %s, %s, %s",diffFlowCumulantsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data()),Form("%s, %s, %s, %s",diffFlowCumulantsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        fDiffFlowCumulants[t][pe][index]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowCumulantsHistList[t][pe]->Add(fDiffFlowCumulants[t][pe][index]);
        // Detector bias to differential Q-cumulants:
        fDiffFlowDetectorBias[t][pe][index] = new TH1D(Form("%s, %s, %s, %s",diffFlowDetectorBiasName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data()),Form("%s, %s, %s, %s",diffFlowDetectorBiasName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialCumulantIndex[index].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        fDiffFlowDetectorBias[t][pe][index]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowDetectorBias[t][pe][index]->SetTitle(Form("#frac{corrected}{measured} %s",differentialCumulantIndex[index].Data()));
        fDiffFlowDetectorBiasHistList[t][pe]->Add(fDiffFlowDetectorBias[t][pe][index]);
        // differential flow estimates from Q-cumulants:
        fDiffFlow[t][pe][index] = new TH1D(Form("%s, %s, %s, %s",diffFlowName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialFlowIndex[index].Data()),Form("%s, %s, %s, %s",diffFlowName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),differentialFlowIndex[index].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        fDiffFlow[t][pe][index]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowHistList[t][pe]->Add(fDiffFlow[t][pe][index]);
      } // end of for(Int_t index=0;index<4;index++)
      for(Int_t covIndex=0;covIndex<5;covIndex++) // covariance index
      {
        // differential covariances:
        fDiffFlowCovariances[t][pe][covIndex] = new TH1D(Form("%s, %s, %s, %s",diffFlowCovariancesName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),covarianceName[covIndex].Data()),Form("%s, %s, %s, %s",diffFlowCovariancesName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),covarianceName[covIndex].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
        fDiffFlowCovariances[t][pe][covIndex]->SetXTitle(ptEtaFlag[pe].Data());
        fDiffFlowCovariancesHistList[t][pe]->Add(fDiffFlowCovariances[t][pe][covIndex]);
      } // end of for(Int_t covIndex=0;covIndex<5;covIndex++) // covariance index
      // products of both types of correlations:
      TString diffFlowProductOfCorrelationsProName = "fDiffFlowProductOfCorrelationsPro";
      diffFlowProductOfCorrelationsProName += fAnalysisLabel->Data();
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
        {
          fDiffFlowProductOfCorrelationsPro[t][pe][mci1][mci2] = new TProfile(Form("%s, %s, %s, %s, %s",diffFlowProductOfCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data()),Form("%s, %s, %s, %s #times %s",diffFlowProductOfCorrelationsProName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fDiffFlowProductOfCorrelationsPro[t][pe][mci1][mci2]->SetXTitle(ptEtaFlag[pe].Data());
          fDiffFlowProductOfCorrelationsProList[t][pe]->Add(fDiffFlowProductOfCorrelationsPro[t][pe][mci1][mci2]);
          if(mci1%2 == 0) mci2++; // products which DO NOT include reduced correlations are not stored here
        } // end of for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
      } // end of for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
    } // end of for(Int_t pe=0;pe<2;pe++) // pt or eta
  } // end of for(Int_t t=0;t<2;t++) // type: RP or POI
  // sums of event weights for reduced correlations:
  TString diffFlowSumOfEventWeightsName = "fDiffFlowSumOfEventWeights";
  diffFlowSumOfEventWeightsName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type is RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t p=0;p<2;p++) // power of weights is either 1 or 2
      {
        for(Int_t ew=0;ew<4;ew++) // index of reduced correlation
        {
          fDiffFlowSumOfEventWeights[t][pe][p][ew] = new TH1D(Form("%s, %s, %s, %s, %s",diffFlowSumOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),powerFlag[p].Data(),reducedCorrelationIndex[ew].Data()),Form("%s, %s, %s, power = %s, %s",diffFlowSumOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),powerFlag[p].Data(),reducedCorrelationIndex[ew].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fDiffFlowSumOfEventWeights[t][pe][p][ew]->SetXTitle(ptEtaFlag[pe].Data());
          fDiffFlowSumOfEventWeightsHistList[t][pe][p]->Add(fDiffFlowSumOfEventWeights[t][pe][p][ew]); // to be improved (add dedicated list to hold all this)
        }
      }
    }
  }
  // sum of products of event weights for both types of correlations:
  TString diffFlowSumOfProductOfEventWeightsName = "fDiffFlowSumOfProductOfEventWeights";
  diffFlowSumOfProductOfEventWeightsName += fAnalysisLabel->Data();
  for(Int_t t=0;t<2;t++) // type is RP or POI
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t mci1=0;mci1<8;mci1++) // mixed correlation index
      {
        for(Int_t mci2=mci1+1;mci2<8;mci2++) // mixed correlation index
        {
          fDiffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2] = new TH1D(Form("%s, %s, %s, %s, %s",diffFlowSumOfProductOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data()),Form("%s, %s, %s, %s #times %s",diffFlowSumOfProductOfEventWeightsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),mixedCorrelationIndex[mci1].Data(),mixedCorrelationIndex[mci2].Data()),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fDiffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2]->SetXTitle(ptEtaFlag[pe].Data());
          fDiffFlowSumOfProductOfEventWeightsHistList[t][pe]->Add(fDiffFlowSumOfProductOfEventWeights[t][pe][mci1][mci2]);
          if(mci1%2 == 0) mci2++; // products which DO NOT include reduced correlations are not stored here
        }
      }
    }
  }
  // correction terms for nua:
  for(Int_t t=0;t<2;t++) // typeFlag (0 = RP, 1 = POI)
  {
    for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
    {
      for(Int_t sc=0;sc<2;sc++) // sin or cos
      {
        for(Int_t cti=0;cti<9;cti++) // correction term index
        {
          fDiffFlowCorrectionTermsForNUAHist[t][pe][sc][cti] = new TH1D(Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),Form("%s, %s, %s, %s, cti = %d",diffFlowCorrectionTermsForNUAHistName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1),nBinsPtEta[pe],minPtEta[pe],maxPtEta[pe]);
          fDiffFlowCorrectionsHistList[t][pe]->Add(fDiffFlowCorrectionTermsForNUAHist[t][pe][sc][cti]);
        }
      }
    }
  }

} // end of AliFlowAnalysisCRC::BookEverythingForDifferentialFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCRCVZ()
{
  if(!fCalculateCRC){return;}
  if(!fCalculateCRCVZ){return;}
  if(!fUseVZERO){return;}

  for (Int_t h=0; h<fCRCnCen; h++) {
      for(Int_t j=0; j<fkNHistCRCVZ; j++) {
        fCRCVZEROetaPro[h][j] = new TProfile(Form("fCRCVZEROetaPro[%d][%d]",h,j),Form("fCRCVZEROetaPro[%d][%d]",h,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
        fCRCVZEROetaPro[h][j]->Sumw2();
        fCRCVZList->Add(fCRCVZEROetaPro[h][j]);
        fCRCVZEROetaHist[h][j] = new TH1D(Form("fCRCVZEROetaHist[%d][%d]",h,j),Form("fCRCVZEROetaHist[%d][%d]",h,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
        fCRCVZEROetaHist[h][j]->Sumw2();
        fCRCVZList->Add(fCRCVZEROetaHist[h][j]);
      }
  }

} // end of AliFlowAnalysisCRC::BookEverythingForCRCVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCRCZDC()
{
  // EbE quantities
  for(Int_t c=0;c<4;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRCZDCQRe[c][h] = new TH1D(Form("fCRCZDCQRe[%d][%d]",c,h),Form("fCRCZDCQRe[%d][%d]",c,h),fCRCZDCnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCZDCQRe[c][h]);
      fCRCZDCQIm[c][h] = new TH1D(Form("fCRCZDCQIm[%d][%d]",c,h),Form("fCRCZDCQIm[%d][%d]",c,h),fCRCZDCnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCZDCQIm[c][h]);
      fCRCZDCMult[c][h] = new TH1D(Form("fCRCZDCMult[%d][%d]",c,h),Form("fCRCZDCMult[%d][%d]",c,h),fCRCZDCnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCZDCMult[c][h]);
    }
  }

  if(!fCalculateCRC){return;}
  if(!fCalculateCRCZDC){return;}
  if(!fUseZDC){return;}

  for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {
      fCRCZDCCFunHist[eg][h] = new TH1D(Form("fCRCZDCCFunHist[%d][%d]",eg,h),Form("fCRCZDCCFunHist[%d][%d]",eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR);
      fCRCZDCCFunHist[eg][h]->Sumw2();
      fCRCZDCList->Add(fCRCZDCCFunHist[eg][h]);
      fCRCZDCSpectra[eg][h] = new TProfile(Form("fCRCZDCSpectra[%d][%d]",eg,h),Form("fCRCZDCSpectra[%d][%d]",eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR,"s");
      fCRCZDCSpectra[eg][h]->Sumw2();
      fCRCZDCList->Add(fCRCZDCSpectra[eg][h]);
      // EbE Corr:
      for(Int_t c=0;c<2;c++) {
        fCRCZDCCorrProdTempHist[c][eg][h] = new TH1D(Form("fCRCZDCCorrProdTempHist[%d][%d][%d]",c,eg,h),
                                                     Form("fCRCZDCCorrProdTempHist[%d][%d][%d]",c,eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR);
        fCRCZDCCorrProdTempHist[c][eg][h]->Sumw2();
        fCRCZDCList->Add(fCRCZDCCorrProdTempHist[c][eg][h]);
        // Final Histo:
        fCRCZDCCorrHist[c][eg][h] = new TH1D(Form("fCRCZDCCorrHist[%d][%d][%d]",c,eg,h),Form("fCRCZDCCorrHist[%d][%d][%d]",c,eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR);
        fCRCZDCCorrHist[c][eg][h]->Sumw2();
        fCRCZDCList->Add(fCRCZDCCorrHist[c][eg][h]);
        // Covariances:
        fCRCZDCCovHist[c][eg][h] = new TH2D(Form("fCRCZDCCovHist[%d][%d][%d]",c,eg,h),Form("fCRCZDCCovHist[%d][%d][%d]",c,eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR,fCRCZDCnCR,0.,1.*fCRCZDCnCR);
        fCRCZDCCovHist[c][eg][h]->Sumw2();
        fCRCZDCList->Add(fCRCZDCCovHist[c][eg][h]);
      } // end of for(Int_t c=0;c<2;c++)

    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0; eg<fCRCZDCnEtaBin; eg++)

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCZDCRunsList[r] = new TList();
    fCRCZDCRunsList[r]->SetName(Form("Run %d",fRunList[r]));
    fCRCZDCRunsList[r]->SetOwner(kTRUE);
    fCRCZDCRbRList->Add(fCRCZDCRunsList[r]);

    for(Int_t eg=0;eg<fCRCZDCnEtaBin;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        // EbE Corr:
        for(Int_t c=0;c<2;c++) {
          fCRCZDCCorrPro[r][c][eg][h] = new TProfile(Form("fCRCZDCCorrPro[%d][%d][%d][%d]",r,c,eg,h),
                                                     Form("fCRCZDCCorrPro[%d][%d][%d][%d]",r,c,eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR,"s");
          fCRCZDCCorrPro[r][c][eg][h]->Sumw2();
          fCRCZDCRunsList[r]->Add(fCRCZDCCorrPro[r][c][eg][h]);
          fCRCZDCCorrProd2p2pHist[r][c][eg][h] = new TProfile(Form("fCRCZDCCorrProd2p2pHist[%d][%d][%d][%d]",r,c,eg,h),
                                                              Form("fCRCZDCCorrProd2p2pHist[%d][%d][%d][%d]",r,c,eg,h),fCRCZDCnCR*fCRCZDCnCR,0.,fCRCZDCnCR*fCRCZDCnCR,"s");
          fCRCZDCCorrProd2p2pHist[r][c][eg][h]->Sumw2();
          fCRCZDCRunsList[r]->Add(fCRCZDCCorrProd2p2pHist[r][c][eg][h]);
        }
        for(Int_t c=0;c<4;c++) {
          fCRCZDCNUAPro[r][c][eg][h] = new TProfile(Form("fCRCZDCNUAPro[%d][%d][%d][%d]",r,c,eg,h),
                                                    Form("fCRCZDCNUAPro[%d][%d][%d][%d]",r,c,eg,h),fCRCZDCnCR,0.,1.*fCRCZDCnCR,"s");
          fCRCZDCNUAPro[r][c][eg][h]->Sumw2();
          fCRCZDCRunsList[r]->Add(fCRCZDCNUAPro[r][c][eg][h]);
        }
      } // end of for (Int_t h=0;h<fCRCnCen;h++)
    } // end of for(Int_t eg=0;eg<fCRCZDCnEtaBin;eg++)
  } // end of for(Int_t r=0;r<fCRCnRun;r++)
} // end of AliFlowAnalysisCRC::BookEverythingForCRCZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCRC()
{
  // Profile to hold flags for CRC;
  fCRCFlags = new TProfile("fCRCFlags","fCRCFlags",17,0.,17.);
  fCRCFlags->SetTickLength(-0.01,"Y");
  fCRCFlags->SetMarkerStyle(25);
  fCRCFlags->SetLabelSize(0.04);
  fCRCFlags->SetLabelOffset(0.02,"Y");
  fCRCFlags->SetStats(kFALSE);
  fCRCFlags->GetXaxis()->SetBinLabel(1,"Harmonic");
  fCRCFlags->GetXaxis()->SetBinLabel(2,"CalculateCRCPt");
  fCRCFlags->GetXaxis()->SetBinLabel(3,"UseVZERO");
  fCRCFlags->GetXaxis()->SetBinLabel(4,"NUAforCRC");
  fCRCFlags->GetXaxis()->SetBinLabel(5,"UseCRCRecenter");
  fCRCFlags->GetXaxis()->SetBinLabel(6,"UseZDC");
  fCRCFlags->GetXaxis()->SetBinLabel(7,"RecenterZDC");
  fCRCFlags->GetXaxis()->SetBinLabel(8,"DivSigma");
  fCRCFlags->GetXaxis()->SetBinLabel(9,"InvertZDC");
  fCRCFlags->GetXaxis()->SetBinLabel(10,"CalculateCRCInt");
  fCRCFlags->GetXaxis()->SetBinLabel(11,"CalculateCRC2");
  fCRCFlags->GetXaxis()->SetBinLabel(12,"CalculateCRCVZ");
  fCRCFlags->GetXaxis()->SetBinLabel(13,"CalculateCRCZDC");
  fCRCFlags->GetXaxis()->SetBinLabel(14,"CalculateFlowQC");
  fCRCFlags->GetXaxis()->SetBinLabel(15,"CalculateFlowZDC");
  fCRCFlags->GetXaxis()->SetBinLabel(16,"CalculateFlowVZ");
  fCRCFlags->GetXaxis()->SetBinLabel(17,"UsePhiEtaCuts"); //@Shi should be "UsePhiEtaCuts"?!
  fCRCFlags->GetXaxis()->SetBinLabel(18,"CalculateCME");  //@Shi add this missing flag
  fCRCList->Add(fCRCFlags);

  // EbE quantities
  for(Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRCQRe[c][h] = new TH1D(Form("fCRCQRe[%d][%d]",c,h),Form("fCRCQRe[%d][%d]",c,h),fCRCnEtaBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCQRe[c][h]);
      fCRCQIm[c][h] = new TH1D(Form("fCRCQIm[%d][%d]",c,h),Form("fCRCQIm[%d][%d]",c,h),fCRCnEtaBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCQIm[c][h]);
      fCRCMult[c][h] = new TH1D(Form("fCRCMult[%d][%d]",c,h),Form("fCRCMult[%d][%d]",c,h),fCRCnEtaBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRCQIm[c][h]);
    }
  }

  if(!fCalculateCRCInt){return;}

  for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
    for (Int_t h=0;h<fCRCnCen;h++) {

      fCRCCFunHist[eg][h] = new TH1D(Form("fCRCCFunHist[%d][%d]",eg,h),Form("fCRCCFunHist[%d][%d]",eg,h),fCRCnCR,0.,1.*fCRCnCR);
      fCRCCFunHist[eg][h]->Sumw2();
      fCRCIntList->Add(fCRCCFunHist[eg][h]);

      for(Int_t c=0;c<fCRCnCorr;c++) {
        fCRCCorrProdTempHist[c][eg][h] = new TH1D(Form("fCRCCorrProdTempHist[%d][%d][%d]",c,eg,h),
                                                  Form("fCRCCorrProdTempHist[%d][%d][%d]",c,eg,h),fCRCnCR,0.,1.*fCRCnCR);
        fCRCCorrProdTempHist[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCCorrProdTempHist[c][eg][h]);
        fCRCCorrHist[c][eg][h] = new TH1D(Form("fCRCCorrHist[%d][%d][%d]",c,eg,h),Form("fCRCCorrHist[%d][%d][%d]",c,eg,h),fCRCnCR,0.,1.*fCRCnCR);
        fCRCCorrHist[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCCorrHist[c][eg][h]);
        fCRCCumHist[c][eg][h] = new TH1D(Form("fCRCCumHist[%d][%d][%d]",c,eg,h),Form("fCRCCumHist[%d][%d][%d]",c,eg,h),fCRCnCR,0.,1.*fCRCnCR);
        fCRCCumHist[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCCumHist[c][eg][h]);

        // Covariances:
        fCRCCorrProd2p2pPro[c][eg][h] = new TProfile(Form("fCRCCorrProd2p2pPro[%d][%d][%d]",c,eg,h),
                                                     Form("fCRCCorrProd2p2pPro[%d][%d][%d]",c,eg,h),fCRCnCR*fCRCnCR,0.,fCRCnCR*fCRCnCR,"s");
        fCRCCorrProd2p2pPro[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCCorrProd2p2pPro[c][eg][h]);
        fCRCCovHist[c][eg][h] = new TH1D(Form("fCRCCovHist[%d][%d][%d]",c,eg,h),Form("fCRCCovHist[%d][%d][%d]",c,eg,h),fCRCnCR*fCRCnCR,0.,fCRCnCR*fCRCnCR);
        fCRCCovHist[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCCovHist[c][eg][h]);

      } // end of for(Int_t c=0;c<2;c++)

      // NUA corrections:
      for(Int_t c=0;c<fCRCnNUA;c++) {
        fCRCNUATermsHist[c][eg][h] = new TH1D(Form("fCRCNUATermsHist[%d][%d][%d]",c,eg,h),Form("fCRCNUATermsHist[%d][%d][%d]",c,eg,h),fCRCnCR,0.,1.*fCRCnCR);
        fCRCNUATermsHist[c][eg][h]->Sumw2();
        fCRCIntList->Add(fCRCNUATermsHist[c][eg][h]);
      } // end of for(Int_t c=0;c<4;c++)
    } // end of for (Int_t h=0;h<fCRCnCen;h++)
  } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCIntRunsList[r] = new TList();
    fCRCIntRunsList[r]->SetName(Form("Run %d",fRunList[r]));
    fCRCIntRunsList[r]->SetOwner(kTRUE);
    fCRCIntRbRList->Add(fCRCIntRunsList[r]);

    for(Int_t eg=0;eg<fCRCnEtaGap;eg++) {
      for (Int_t h=0;h<fCRCnCen;h++) {
        // correlations:
        for(Int_t c=0;c<fCRCnCorr;c++) {
          fCRCCorrPro[r][c][eg][h] = new TProfile(Form("fCRCCorrPro[%d][%d][%d][%d]",fRunList[r],c,eg,h),
                                                  Form("fCRCCorrPro[%d][%d][%d][%d]",fRunList[r],c,eg,h),fCRCnCR,0.,1.*fCRCnCR,"s");
          fCRCCorrPro[r][c][eg][h]->Sumw2();
          fCRCIntRunsList[r]->Add(fCRCCorrPro[r][c][eg][h]);
          fCRCSumWeigHist[r][c][eg][h] = new TH1D(Form("fCRCSumWeigHist[%d][%d][%d][%d]",fRunList[r],c,eg,h),
                                                  Form("fCRCSumWeigHist[%d][%d][%d][%d]",fRunList[r],c,eg,h),fCRCnCR,0.,1.*fCRCnCR);
          fCRCSumWeigHist[r][c][eg][h]->Sumw2();
          fCRCIntRunsList[r]->Add(fCRCSumWeigHist[r][c][eg][h]);
        }
        // NUA:
        for(Int_t c=0;c<fCRCnNUA;c++) {
          fCRCNUATermsPro[r][c][eg][h] = new TProfile(Form("fCRCNUATermsPro[%d][%d][%d][%d]",fRunList[r],c,eg,h),
                                                      Form("fCRCNUATermsPro[%d][%d][%d][%d]",fRunList[r],c,eg,h),fCRCnCR+1,0.,fCRCnCR+1.,"s");
          fCRCNUATermsPro[r][c][eg][h]->Sumw2();
          fCRCIntRunsList[r]->Add(fCRCNUATermsPro[r][c][eg][h]);
        } // end of for(Int_t c=0;c<4;c++)
      } // end of for (Int_t h=0;h<fCRCnCen;h++)
    } // end of for(Int_t eg=0;eg<fCRCnEtaGap;eg++)
  } // end of for(Int_t r=0;r<fCRCnRun;r++)

} // end of AliFlowAnalysisCRC::BookEverythingForCRC()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCRC2()
{
  // EbE quantities
  for(Int_t c=0;c<3;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCRC2QRe[c][h] = new TH1D(Form("fCRC2QRe[%d][%d]",c,h),Form("fCRC2QRe[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRC2QRe[c][h]);
      fCRC2QIm[c][h] = new TH1D(Form("fCRC2QIm[%d][%d]",c,h),Form("fCRC2QIm[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRC2QIm[c][h]);
      fCRC2Mul[c][h] = new TH1D(Form("fCRC2Mul[%d][%d]",c,h),Form("fCRC2Mul[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCRC2Mul[c][h]);
    }
  }

  if(!fCalculateCRC2){return;}

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      for(Int_t e=0;e<2;e++) {
        fCRC2CorHist[h][c][e] = new TH1D(Form("fCRC2CorHist[%d][%d][%d]",h,c,e),Form("fCRC2CorHist[%d][%d][%d]",h,c,e),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax);
        fCRC2CorHist[h][c][e]->Sumw2();
        fCRC2List->Add(fCRC2CorHist[h][c][e]);
      } // end of for(Int_t e=0;e<2;e++)
      for(Int_t e=0;e<4;e++) {
        fCRC2NUAHist[h][c][e] = new TH1D(Form("fCRC2NUAHist[%d][%d][%d]",h,c,e),Form("fCRC2NUAHist[%d][%d][%d]",h,c,e),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax);
        fCRC2NUAHist[h][c][e]->Sumw2();
        fCRC2List->Add(fCRC2NUAHist[h][c][e]);
      } // end of for(Int_t e=0;e<4;e++)
      for(Int_t e=0;e<fkNCorCRC2;e++) {
        fCRC2CovPro[h][c][e] = new TProfile(Form("fCRC2CovPro[%d][%d][%d]",h,c,e),Form("fCRC2CovPro[%d][%d][%d]",h,c,e),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax,"s");
        fCRC2CovPro[h][c][e]->Sumw2();
        fCRC2List->Add(fCRC2CovPro[h][c][e]);
        fCRC2CovHist[h][c][e] = new TH1D(Form("fCRC2CovHist[%d][%d][%d]",h,c,e),Form("fCRC2CovHist[%d][%d][%d]",h,c,e),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax);
        fCRC2CovHist[h][c][e]->Sumw2();
        fCRC2List->Add(fCRC2CovHist[h][c][e]);
      } // end of for(Int_t e=0;e<4;e++)
    } // end of for(Int_t c=0;c<3;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t c=0;c<fkNCorCRC2;c++) {
      fCRC2CorPro[h][c] = new TProfile(Form("fCRC2CorPro[%d][%d]",h,c),
                                       Form("fCRC2CorPro[%d][%d]",h,c),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax);
      fCRC2CorPro[h][c]->Sumw2();
      fCRC2List->Add(fCRC2CorPro[h][c]);
      for(Int_t e=0;e<4;e++) {
        fCRC2NUAPro[h][c][e] = new TProfile(Form("fCRC2NUAPro[%d][%d][%d]",h,c,e),
                                            Form("fCRC2NUAPro[%d][%d][%d]",h,c,e),fCRC2nEtaBins,fCRCEtaMin,fCRCEtaMax);
        fCRC2NUAPro[h][c][e]->Sumw2();
        fCRC2List->Add(fCRC2NUAPro[h][c][e]);
      } // end of for(Int_t e=0;e<4;e++)
    } // end of for(Int_t c=0;c<3;c++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

} // end of AliFlowAnalysisCRC::BookEverythingForCRC2()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForQVec()
{
  for(Int_t h=0; h<fCRCnHar; h++) {
    for(Int_t k=0; k<2; k++) {
      fTPCQHist[h][k] = new TProfile();
      fTempList->Add(fTPCQHist[h][k]);
    }
  }
  for(Int_t k=0; k<12; k++) {
    fZDCQHist[k] = new TProfile();
    fTempList->Add(fZDCQHist[k]);
  }
  for(Int_t k=0; k<fkNZDCResHist; k++) {
    fZDCResHist[k] = new TH1D();
    fTempList->Add(fZDCResHist[k]);
  }
  fZDCQHist2 = new TH2D();
  fTempList->Add(fZDCQHist2);
  fFitPol0EP = new TF1("fFitPol0EP","pol0",-TMath::Pi(),TMath::Pi());
  fTempList->Add(fFitPol0EP);
  for(Int_t k=0; k<4; k++) {
    fZDCVtxHist[k] = new TProfile3D();
    fTempList->Add(fZDCVtxHist[k]);
    fZDCEcomHist[k] = new TProfile2D();
    fTempList->Add(fZDCEcomHist[k]);
    fZDCEcomTotHist[k] = new TProfile2D();
    fTempList->Add(fZDCEcomTotHist[k]);
    fZDCVtxFitHist[k] = new TH3D();
    fTempList->Add(fZDCVtxFitHist[k]);
    for(Int_t i=0; i<3; i++) {
      fZDCVtxFitCenProjHist[k][i] = new TH1D();
      fTempList->Add(fZDCVtxFitCenProjHist[k][i]);
    }
    fZDCVtxFitHist2[k] = new TH3D();
    fTempList->Add(fZDCVtxFitHist2[k]);
    for(Int_t i=0; i<3; i++) {
      fZDCVtxFitCenProjHist2[k][i] = new TH1D();
      fTempList->Add(fZDCVtxFitCenProjHist2[k][i]);
    }
  }
  for(Int_t c=0; c<10; c++) {
    fZDCBinsCenRefMult[c] = new TH3D();
    fTempList->Add(fZDCBinsCenRefMult[c]);
  }
  for(Int_t k=0; k<4; k++) {
    fZDCBinsCenRefMultRbR[k] = new TProfile2D();
    fTempList->Add(fZDCBinsCenRefMultRbR[k]);
    fZDCBinsCenRefMultTot[k] = new TProfile2D();
    fTempList->Add(fZDCBinsCenRefMultTot[k]);
    for(Int_t c=0; c<10; c++) {
      fZDCBinsCenRefMultRbRProf[c][k] = new TProfile();
      fTempList->Add(fZDCBinsCenRefMultRbRProf[c][k]);
      fZDCBinsCenRefMultTotProf[c][k] = new TProfile();
      fTempList->Add(fZDCBinsCenRefMultTotProf[c][k]);
      fZDCBinsCenRefMultRbRProj[c][k] = new TH1D();
      fTempList->Add(fZDCBinsCenRefMultRbRProj[c][k]);
      fZDCBinsCenRefMultTotProj[c][k] = new TH1D();
      fTempList->Add(fZDCBinsCenRefMultTotProj[c][k]);
    }
  }
  for(Int_t i=0; i<3; i++) {
    for(Int_t k=0; k<4; k++) {
      fZDCBinsVtxCenEZDC[i][k] = new TH3D();
      fTempList->Add(fZDCBinsVtxCenEZDC[i][k]);
    }
  }
  for(Int_t i=0; i<10; i++) {
    for(Int_t z=0; z<10; z++) {
      for(Int_t k=0; k<4; k++) {
        fZDCQVecVtxCenEZDC3D[i][z][k] = new TH3D();
        fTempList->Add(fZDCQVecVtxCenEZDC3D[i][z][k]);

      }
    }
  }
  fZDCQVecVtxCenEZDCFit0 = new TH3D();
  fTempList->Add(fZDCQVecVtxCenEZDCFit0);
  fZDCQVecVtxCenEZDCFit1 = new TH3D();
  fTempList->Add(fZDCQVecVtxCenEZDCFit1);

  for(Int_t k=0; k<12; k++) {
    fZDCEcomTotvsVtxHist[k] = new TProfile3D();
    fTempList->Add(fZDCEcomTotvsVtxHist[k]);
  }
  for(Int_t c=0; c<10; c++) {
    for(Int_t k=0; k<4; k++) {
      fZDCVtxCenHist[c][k] = new TProfile3D();
      fTempList->Add(fZDCVtxCenHist[c][k]);
    }
    for(Int_t k=0; k<8; k++) {
      fZDCVtxCenHistMagPol[c][k] = new TProfile3D();
      fTempList->Add(fZDCVtxCenHistMagPol[c][k]);
    }
  }
  for(Int_t k=0; k<3; k++) {
    fVZEROCenHist[k] = new TProfile2D();
    fTempList->Add(fVZEROCenHist[k]);
  }
  for(Int_t k=0; k<4; k++) {
    fZDCFitSec[k] = new TF1(Form("fZDCFitSec[%d]",k),"pol3",0.,100.);
    fTempList->Add(fZDCFitSec[k]);
  }
  if(fCRCZDC2DCutList) {
    for(Int_t i=0; i<2; i++) {
      for(Int_t z=0; z<10; z++) {
        fCRCZDC2DCutZDCC[i][z] = (TH2D*)(fCRCZDC2DCutList->FindObject(Form("CutZDCC_cen%d_magfielpol%d",z,i)));
        fCRCZDC2DCutZDCA[i][z] = (TH2D*)(fCRCZDC2DCutList->FindObject(Form("CutZDCA_cen%d_magfielpol%d",z,i)));
      }
    }
  }
  if(fZDCESEList) {
    fZDCESEMinHist[0] = (TH1D*)(fZDCESEList->FindObject("MinMulHis[0]"));
    fZDCESEMaxHist[0] = (TH1D*)(fZDCESEList->FindObject("MaxMulHis[0]"));
    fZDCESEAvHist[0] = (TH1D*)(fZDCESEList->FindObject("AvMulHis[0]"));
    fZDCESEMinHist[1] = (TH1D*)(fZDCESEList->FindObject("MinMulHis[1]"));
    fZDCESEMaxHist[1] = (TH1D*)(fZDCESEList->FindObject("MaxMulHis[1]"));
    fZDCESEAvHist[1] = (TH1D*)(fZDCESEList->FindObject("AvMulHis[1]"));
    if(fZDCESEMinHist[0]) fTempList->Add(fZDCESEMinHist[0]);
    else printf("WARNING: fZDCESEMinHist not found! \n");
    if(fZDCESEMaxHist[0]) fTempList->Add(fZDCESEMaxHist[0]);
    else printf("WARNING: fZDCESEMaxHist not found! \n");
    if(fZDCESEAvHist[0]) fTempList->Add(fZDCESEAvHist[0]);
    else printf("WARNING: fZDCESEAvHist not found! \n");
    if(fZDCESEMinHist[1]) fTempList->Add(fZDCESEMinHist[1]);
    else printf("WARNING: fZDCESEMinHist not found! \n");
    if(fZDCESEMaxHist[1]) fTempList->Add(fZDCESEMaxHist[1]);
    else printf("WARNING: fZDCESEMaxHist not found! \n");
    if(fZDCESEAvHist[1]) fTempList->Add(fZDCESEAvHist[1]);
    else printf("WARNING: fZDCESEAvHist not found! \n");
    // new metric
    fZDCESEMinMetricHist[0] = (TH1D*)(fZDCESEList->FindObject("MinMetricMulHis[0]"));
    fZDCESEMaxMetricHist[0] = (TH1D*)(fZDCESEList->FindObject("MaxMetricMulHis[0]"));
    fZDCESEMinMetricHist[1] = (TH1D*)(fZDCESEList->FindObject("MinMetricMulHis[1]"));
    fZDCESEMaxMetricHist[1] = (TH1D*)(fZDCESEList->FindObject("MaxMetricMulHis[1]"));
    if(fZDCESEMinMetricHist[0]) fTempList->Add(fZDCESEMinMetricHist[0]);
    else printf("WARNING: fZDCESEMinMetricHist not found! \n");
    if(fZDCESEMaxMetricHist[0]) fTempList->Add(fZDCESEMaxMetricHist[0]);
    else printf("WARNING: fZDCESEMaxMetricHist not found! \n");
    if(fZDCESEMinMetricHist[1]) fTempList->Add(fZDCESEMinMetricHist[1]);
    else printf("WARNING: fZDCESEMinMetricHist not found! \n");
    if(fZDCESEMaxMetricHist[1]) fTempList->Add(fZDCESEMaxMetricHist[1]);
    else printf("WARNING: fZDCESEMaxMetricHist not found! \n");

    // functions
    for (Int_t k=0; k<2; k++) {
      fPolMin[k] = new TF1(Form("fPolMin[%d]",k),"pol9",0.,100.);
      fPolMax[k] = new TF1(Form("fPolMax[%d]",k),"pol9",0.,100.);
      if(fZDCESEMinHist[k] && fZDCESEMaxHist[k]) {
        fZDCESEMinHist[k]->Fit(fPolMin[k],"QRN","",0.,90.);
        fZDCESEMaxHist[k]->Fit(fPolMax[k],"QRN","",0.,90.);
      }
      fTempList->Add(fPolMin[k]);
      fTempList->Add(fPolMax[k]);

      // to calculate new metric
      fPolAv[k] = new TF1(Form("fPolAv[%d]",k),"pol4",5.E3,2.5E4);
      //      fPolDer[k] = new TF1(Form("fPolDer[%d]",k),"pol3",5.E3,2.5E4);
      //      fPolInt[k] = new TF1(Form("fPolInt[%d]",k),"sqrt(1+pol3**2)",5.E3,2.5E4);
      fPolDist[k] = new TF1(Form("fPolDist[%d]",k),"TMath::Abs(pol1(0)-pol1(2))",5.E3,2.5E4);
      if(fZDCESEAvHist[k]) {
        //        fZDCESEAvHist[k]->Fit(fPolAv[k],"QRN","",5.E3,2.1E4);
        //        for (Int_t p=1; p<=fPolAv[k]->GetNpar(); p++) {
        //          fPolDer[k]->SetParameter(p-1,p*fPolAv[k]->GetParameter(p));
        //        }
        //        fPolInt[k]->SetParameters(fPolDer[k]->GetParameters());
        fPolAv[k]->SetParameter(0,4.92958e+01);
        fPolAv[k]->SetParameter(1,-2.28486e-03);
        for (Int_t p=0; p<=fPolAv[k]->GetNpar(); p++) {
          fPolDist[k]->SetParameter(p+2,fPolAv[k]->GetParameter(p));
        }
      }
      fTempList->Add(fPolAv[k]);
      //      fTempList->Add(fPolDer[k]);
      //      fTempList->Add(fPolInt[k]);
      fTempList->Add(fPolDist[k]);

      // cuts on new metric
      //      Double_t Lmax=(k==0?50.:45.);
      //      fPolMinMetric[k] = new TF1(Form("fPolMinMetric[%d]",k),"pol1",0.,Lmax);
      //      fPolMaxMetric[k] = new TF1(Form("fPolMaxMetric[%d]",k),"pol1",0.,Lmax);
      //      if(fZDCESEMinMetricHist[k] && fZDCESEMaxMetricHist[k]) {
      //        fZDCESEMinMetricHist[k]->Fit(fPolMinMetric[k],"QRN","",10.,Lmax); // hardwired, TBI
      //        fZDCESEMaxMetricHist[k]->Fit(fPolMaxMetric[k],"QRN","",10.,Lmax); // hardwired, TBI
      //      }
      //      fTempList->Add(fPolMinMetric[k]);
      //      fTempList->Add(fPolMaxMetric[k]);

      // new cuts on ZDC-ESE
      for(Int_t k=0; k<fZDCESEnPol; k++) {
        fZDCESECutsHist[k] = (TH1D*)(fZDCESEList->FindObject(Form("CutsHis[%d]",k)));
        if(fZDCESECutsHist[k]) fTempList->Add(fZDCESECutsHist[k]);
        else printf("WARNING: fZDCESECutsHist not found! \n");

        fPolCuts[k] = new TF1(Form("fPolCuts[%d]",k),"pol9",0.,100.);
        if(fZDCESECutsHist[k]) {
          fZDCESECutsHist[k]->Fit(fPolCuts[k],"QRN","",0.,90.);
        }
        fTempList->Add(fPolCuts[k]);
      }

      const Int_t nbins = 3410;

      Double_t xd[nbins] = {1.800005e+00, 1.800005e+00, 1.800005e+00, 5.400014e+00, 1.080003e+01, 1.440004e+01, 1.800005e+01, 2.160006e+01, 2.520007e+01, 2.700007e+01, 3.060008e+01, 3.240008e+01, 3.600009e+01, 3.780010e+01, 4.140011e+01, 4.320011e+01, 4.500012e+01, 4.860013e+01, 5.040013e+01, 5.220014e+01, 5.580015e+01, 5.760015e+01, 5.940016e+01, 6.120016e+01, 6.480017e+01, 6.660017e+01, 6.840018e+01, 7.020018e+01, 7.380019e+01, 7.560020e+01, 7.740020e+01, 7.920021e+01, 8.280022e+01, 8.460022e+01, 8.640023e+01, 8.820023e+01, 9.180024e+01, 9.360024e+01, 9.540025e+01, 9.900026e+01, 1.008003e+02, 1.026003e+02, 1.044003e+02, 1.080003e+02, 1.098003e+02, 1.116003e+02, 1.134003e+02, 1.152003e+02, 1.188003e+02, 1.206003e+02, 1.224003e+02, 1.242003e+02, 1.278003e+02, 1.296003e+02, 1.314003e+02, 1.332003e+02, 1.368004e+02, 1.386004e+02, 1.404004e+02, 1.422004e+02, 1.458004e+02, 1.476004e+02, 1.494004e+02, 1.530004e+02, 1.548004e+02, 1.566004e+02, 1.584004e+02, 1.620004e+02, 1.638004e+02, 1.656004e+02, 1.674004e+02, 1.692004e+02, 1.728005e+02, 1.746005e+02, 1.764005e+02, 1.800005e+02, 1.818005e+02, 1.836005e+02, 1.854005e+02, 1.890005e+02, 1.908005e+02, 1.926005e+02, 1.944005e+02, 1.980005e+02, 1.998005e+02, 2.016005e+02, 2.034005e+02, 2.070005e+02, 2.088005e+02, 2.106005e+02, 2.124006e+02, 2.160006e+02, 2.178006e+02, 2.196006e+02, 2.214006e+02, 2.250006e+02, 2.268006e+02, 2.286006e+02, 2.304006e+02, 2.340006e+02, 2.358006e+02, 2.376006e+02, 2.412006e+02, 2.430006e+02, 2.448006e+02, 2.466006e+02, 2.502007e+02, 2.520007e+02, 2.538007e+02, 2.556007e+02, 2.592007e+02, 2.610007e+02, 2.628007e+02, 2.646007e+02, 2.682007e+02, 2.700007e+02, 2.718007e+02, 2.754007e+02, 2.772007e+02, 2.790007e+02, 2.808007e+02, 2.844007e+02, 2.862007e+02, 2.880008e+02, 2.916008e+02, 2.934008e+02, 2.952008e+02, 2.970008e+02, 3.006008e+02, 3.024008e+02, 3.042008e+02, 3.078008e+02, 3.096008e+02, 3.114008e+02, 3.132008e+02, 3.168008e+02, 3.186008e+02, 3.204008e+02, 3.240008e+02, 3.258009e+02, 3.276009e+02, 3.294009e+02, 3.330009e+02, 3.348009e+02, 3.366009e+02, 3.402009e+02, 3.420009e+02, 3.438009e+02, 3.456009e+02, 3.492009e+02, 3.510009e+02, 3.528009e+02, 3.564009e+02, 3.582009e+02, 3.600009e+02, 3.618009e+02, 3.654010e+02, 3.672010e+02, 3.690010e+02, 3.726010e+02, 3.744010e+02, 3.762010e+02, 3.780010e+02, 3.816010e+02, 3.834010e+02, 3.852010e+02, 3.888010e+02, 3.906010e+02, 3.924010e+02, 3.960010e+02, 3.978010e+02, 3.996010e+02, 4.014010e+02, 4.050011e+02, 4.068011e+02, 4.086011e+02, 4.122011e+02, 4.140011e+02, 4.158011e+02, 4.194011e+02, 4.212011e+02, 4.230011e+02, 4.266011e+02, 4.284011e+02, 4.302011e+02, 4.320011e+02, 4.356011e+02, 4.374011e+02, 4.392011e+02, 4.428012e+02, 4.446012e+02, 4.464012e+02, 4.500012e+02, 4.518012e+02, 4.536012e+02, 4.554012e+02, 4.590012e+02, 4.608012e+02, 4.626012e+02, 4.662012e+02, 4.680012e+02, 4.698012e+02, 4.734012e+02, 4.752012e+02, 4.770012e+02, 4.806013e+02, 4.824013e+02, 4.842013e+02, 4.860013e+02, 4.896013e+02, 4.914013e+02, 4.932013e+02, 4.968013e+02, 4.986013e+02, 5.004013e+02, 5.040013e+02, 5.058013e+02, 5.076013e+02, 5.112013e+02, 5.130013e+02, 5.148013e+02, 5.184014e+02, 5.202014e+02, 5.220014e+02, 5.256014e+02, 5.274014e+02, 5.292014e+02, 5.328014e+02, 5.346014e+02, 5.364014e+02, 5.400014e+02, 5.418014e+02, 5.436014e+02, 5.472014e+02, 5.490014e+02, 5.508014e+02, 5.544014e+02, 5.562015e+02, 5.580015e+02, 5.616015e+02, 5.634015e+02, 5.652015e+02, 5.688015e+02, 5.706015e+02, 5.724015e+02, 5.760015e+02, 5.778015e+02, 5.796015e+02, 5.832015e+02, 5.850015e+02, 5.868015e+02, 5.886015e+02, 5.922015e+02, 5.940016e+02, 5.958016e+02, 5.994016e+02, 6.012016e+02, 6.030016e+02, 6.066016e+02, 6.084016e+02, 6.102016e+02, 6.138016e+02, 6.156016e+02, 6.174016e+02, 6.210016e+02, 6.228016e+02, 6.246016e+02, 6.282016e+02, 6.300016e+02, 6.318016e+02, 6.354017e+02, 6.372017e+02, 6.390017e+02, 6.426017e+02, 6.444017e+02, 6.462017e+02, 6.498017e+02, 6.516017e+02, 6.534017e+02, 6.570017e+02, 6.588017e+02, 6.606017e+02, 6.642017e+02, 6.660017e+02, 6.696017e+02, 6.714018e+02, 6.732018e+02, 6.768018e+02, 6.786018e+02, 6.804018e+02, 6.840018e+02, 6.858018e+02, 6.876018e+02, 6.912018e+02, 6.930018e+02, 6.948018e+02, 6.984018e+02, 7.002018e+02, 7.020018e+02, 7.056018e+02, 7.074018e+02, 7.092019e+02, 7.128019e+02, 7.146019e+02, 7.164019e+02, 7.200019e+02, 7.218019e+02, 7.236019e+02, 7.272019e+02, 7.290019e+02, 7.326019e+02, 7.344019e+02, 7.362019e+02, 7.380019e+02, 7.416019e+02, 7.434019e+02, 7.470019e+02, 7.488020e+02, 7.506020e+02, 7.542020e+02, 7.560020e+02, 7.578020e+02, 7.614020e+02, 7.632020e+02, 7.650020e+02, 7.686020e+02, 7.704020e+02, 7.740020e+02, 7.758020e+02, 7.776020e+02, 7.812020e+02, 7.830020e+02, 7.848020e+02, 7.884021e+02, 7.902021e+02, 7.920021e+02, 7.956021e+02, 7.974021e+02, 8.010021e+02, 8.028021e+02, 8.046021e+02, 8.082021e+02, 8.100021e+02, 8.118021e+02, 8.154021e+02, 8.172021e+02, 8.190021e+02, 8.226021e+02, 8.244022e+02, 8.280022e+02, 8.298022e+02, 8.316022e+02, 8.352022e+02, 8.370022e+02, 8.406022e+02, 8.424022e+02, 8.442022e+02, 8.478022e+02, 8.496022e+02, 8.514022e+02, 8.550022e+02, 8.568022e+02, 8.604022e+02, 8.622023e+02, 8.640023e+02, 8.676023e+02, 8.694023e+02, 8.712023e+02, 8.748023e+02, 8.766023e+02, 8.802023e+02, 8.820023e+02, 8.838023e+02, 8.874023e+02, 8.892023e+02, 8.910023e+02, 8.946023e+02, 8.964023e+02, 9.000023e+02, 9.018024e+02, 9.036024e+02, 9.072024e+02, 9.090024e+02, 9.108024e+02, 9.144024e+02, 9.162024e+02, 9.198024e+02, 9.216024e+02, 9.234024e+02, 9.270024e+02, 9.288024e+02, 9.324024e+02, 9.342024e+02, 9.360024e+02, 9.396025e+02, 9.414025e+02, 9.432025e+02, 9.468025e+02, 9.486025e+02, 9.522025e+02, 9.540025e+02, 9.576025e+02, 9.594025e+02, 9.612025e+02, 9.648025e+02, 9.666025e+02, 9.702025e+02, 9.720025e+02, 9.738025e+02, 9.774026e+02, 9.792026e+02, 9.828026e+02, 9.846026e+02, 9.864026e+02, 9.900026e+02, 9.918026e+02, 9.954026e+02, 9.972026e+02, 9.990026e+02, 1.002603e+03, 1.004403e+03, 1.006203e+03, 1.009803e+03, 1.011603e+03, 1.015203e+03, 1.017003e+03, 1.018803e+03, 1.022403e+03, 1.024203e+03, 1.027803e+03, 1.029603e+03, 1.031403e+03, 1.035003e+03, 1.036803e+03, 1.040403e+03, 1.042203e+03, 1.044003e+03, 1.047603e+03, 1.049403e+03, 1.053003e+03, 1.054803e+03, 1.058403e+03, 1.060203e+03, 1.062003e+03, 1.065603e+03, 1.067403e+03, 1.071003e+03, 1.072803e+03, 1.076403e+03, 1.078203e+03, 1.080003e+03, 1.083603e+03, 1.085403e+03, 1.089003e+03, 1.090803e+03, 1.094403e+03, 1.096203e+03, 1.098003e+03, 1.101603e+03, 1.103403e+03, 1.105203e+03, 1.108803e+03, 1.110603e+03, 1.114203e+03, 1.116003e+03, 1.117803e+03, 1.121403e+03, 1.123203e+03, 1.126803e+03, 1.128603e+03, 1.132203e+03, 1.134003e+03, 1.135803e+03, 1.139403e+03, 1.141203e+03, 1.144803e+03, 1.146603e+03, 1.150203e+03, 1.152003e+03, 1.153803e+03, 1.157403e+03, 1.159203e+03, 1.162803e+03, 1.164603e+03, 1.168203e+03, 1.170003e+03, 1.173603e+03, 1.175403e+03, 1.177203e+03, 1.180803e+03, 1.182603e+03, 1.186203e+03, 1.188003e+03, 1.191603e+03, 1.193403e+03, 1.195203e+03, 1.198803e+03, 1.200603e+03, 1.204203e+03, 1.206003e+03, 1.209603e+03, 1.211403e+03, 1.215003e+03, 1.216803e+03, 1.218603e+03, 1.222203e+03, 1.224003e+03, 1.227603e+03, 1.229403e+03, 1.233003e+03, 1.234803e+03, 1.238403e+03, 1.240203e+03, 1.243803e+03, 1.245603e+03, 1.247403e+03, 1.251003e+03, 1.252803e+03, 1.256403e+03, 1.258203e+03, 1.261803e+03, 1.263603e+03, 1.265403e+03, 1.269003e+03, 1.270803e+03, 1.274403e+03, 1.276203e+03, 1.279803e+03, 1.281603e+03, 1.285203e+03, 1.287003e+03, 1.290603e+03, 1.292403e+03, 1.296003e+03, 1.297803e+03, 1.299603e+03, 1.303203e+03, 1.305003e+03, 1.308603e+03, 1.310403e+03, 1.314003e+03, 1.315803e+03, 1.319403e+03, 1.321203e+03, 1.324803e+03, 1.326603e+03, 1.328403e+03, 1.332003e+03, 1.333803e+03, 1.337403e+03, 1.339203e+03, 1.342804e+03, 1.344604e+03, 1.348204e+03, 1.350004e+03, 1.353604e+03, 1.355404e+03, 1.359004e+03, 1.360804e+03, 1.364404e+03, 1.366204e+03, 1.368004e+03, 1.371604e+03, 1.373404e+03, 1.377004e+03, 1.378804e+03, 1.382404e+03, 1.384204e+03, 1.387804e+03, 1.389604e+03, 1.393204e+03, 1.395004e+03, 1.398604e+03, 1.400404e+03, 1.404004e+03, 1.405804e+03, 1.407604e+03, 1.411204e+03, 1.413004e+03, 1.416604e+03, 1.418404e+03, 1.422004e+03, 1.423804e+03, 1.427404e+03, 1.429204e+03, 1.432804e+03, 1.434604e+03, 1.438204e+03, 1.440004e+03, 1.443604e+03, 1.445404e+03, 1.449004e+03, 1.450804e+03, 1.454404e+03, 1.456204e+03, 1.458004e+03, 1.461604e+03, 1.463404e+03, 1.467004e+03, 1.468804e+03, 1.472404e+03, 1.474204e+03, 1.477804e+03, 1.479604e+03, 1.483204e+03, 1.485004e+03, 1.488604e+03, 1.490404e+03, 1.494004e+03, 1.495804e+03, 1.499404e+03, 1.501204e+03, 1.504804e+03, 1.506604e+03, 1.510204e+03, 1.512004e+03, 1.515604e+03, 1.517404e+03, 1.521004e+03, 1.522804e+03, 1.526404e+03, 1.528204e+03, 1.531804e+03, 1.533604e+03, 1.537204e+03, 1.539004e+03, 1.542604e+03, 1.544404e+03, 1.548004e+03, 1.549804e+03, 1.553404e+03, 1.555204e+03, 1.558804e+03, 1.560604e+03, 1.564204e+03, 1.566004e+03, 1.569604e+03, 1.571404e+03, 1.575004e+03, 1.576804e+03, 1.580404e+03, 1.582204e+03, 1.585804e+03, 1.587604e+03, 1.591204e+03, 1.593004e+03, 1.596604e+03, 1.598404e+03, 1.602004e+03, 1.603804e+03, 1.607404e+03, 1.609204e+03, 1.612804e+03, 1.616404e+03, 1.618204e+03, 1.621804e+03, 1.623604e+03, 1.627204e+03, 1.629004e+03, 1.632604e+03, 1.634404e+03, 1.638004e+03, 1.639804e+03, 1.641604e+03, 1.645204e+03, 1.647004e+03, 1.650604e+03, 1.654204e+03, 1.656004e+03, 1.659604e+03, 1.661404e+03, 1.665004e+03, 1.666804e+03, 1.670404e+03, 1.672204e+03, 1.675804e+03, 1.677604e+03, 1.681204e+03, 1.683004e+03, 1.686604e+03, 1.688404e+03, 1.692004e+03, 1.693804e+03, 1.697404e+03, 1.699204e+03, 1.702804e+03, 1.706404e+03, 1.708204e+03, 1.710004e+03, 1.713604e+03, 1.715404e+03, 1.719004e+03, 1.722604e+03, 1.724405e+03, 1.728005e+03, 1.729805e+03, 1.733405e+03, 1.735205e+03, 1.738805e+03, 1.740605e+03, 1.744205e+03, 1.746005e+03, 1.749605e+03, 1.751405e+03, 1.755005e+03, 1.756805e+03, 1.760405e+03, 1.762205e+03, 1.765805e+03, 1.767605e+03, 1.771205e+03, 1.773005e+03, 1.776605e+03, 1.778405e+03, 1.782005e+03, 1.785605e+03, 1.787405e+03, 1.791005e+03, 1.792805e+03, 1.796405e+03, 1.798205e+03, 1.801805e+03, 1.803605e+03, 1.807205e+03, 1.809005e+03, 1.812605e+03, 1.814405e+03, 1.818005e+03, 1.819805e+03, 1.823405e+03, 1.827005e+03, 1.828805e+03, 1.832405e+03, 1.834205e+03, 1.837805e+03, 1.839605e+03, 1.843205e+03, 1.845005e+03, 1.848605e+03, 1.850405e+03, 1.854005e+03, 1.857605e+03, 1.859405e+03, 1.861205e+03, 1.864805e+03, 1.868405e+03, 1.870205e+03, 1.873805e+03, 1.875605e+03, 1.879205e+03, 1.881005e+03, 1.884605e+03, 1.888205e+03, 1.890005e+03, 1.893605e+03, 1.895405e+03, 1.899005e+03, 1.902605e+03, 1.904405e+03, 1.908005e+03, 1.909805e+03, 1.913405e+03, 1.915205e+03, 1.918805e+03, 1.920605e+03, 1.924205e+03, 1.926005e+03, 1.929605e+03, 1.933205e+03, 1.935005e+03, 1.938605e+03, 1.940405e+03, 1.944005e+03, 1.945805e+03, 1.949405e+03, 1.953005e+03, 1.954805e+03, 1.958405e+03, 1.960205e+03, 1.963805e+03, 1.965605e+03, 1.969205e+03, 1.972805e+03, 1.974605e+03, 1.978205e+03, 1.980005e+03, 1.983605e+03, 1.985405e+03, 1.989005e+03, 1.992605e+03, 1.994405e+03, 1.998005e+03, 1.999805e+03, 2.003405e+03, 2.005205e+03, 2.008805e+03, 2.010605e+03, 2.014205e+03, 2.017805e+03, 2.019605e+03, 2.023205e+03, 2.025005e+03, 2.028605e+03, 2.030405e+03, 2.034005e+03, 2.037605e+03, 2.039405e+03, 2.043005e+03, 2.046605e+03, 2.048405e+03, 2.052005e+03, 2.053805e+03, 2.057405e+03, 2.059205e+03, 2.062805e+03, 2.066405e+03, 2.068205e+03, 2.071805e+03, 2.073605e+03, 2.077205e+03, 2.080805e+03, 2.082605e+03, 2.086205e+03, 2.088005e+03, 2.091605e+03, 2.095205e+03, 2.097005e+03, 2.100605e+03, 2.102405e+03, 2.106005e+03, 2.109606e+03, 2.111406e+03, 2.115006e+03, 2.116806e+03, 2.120406e+03, 2.122206e+03, 2.125806e+03, 2.129406e+03, 2.131206e+03, 2.134806e+03, 2.136606e+03, 2.140206e+03, 2.143806e+03, 2.145606e+03, 2.149206e+03, 2.152806e+03, 2.154606e+03, 2.158206e+03, 2.160006e+03, 2.163606e+03, 2.167206e+03, 2.169006e+03, 2.172606e+03, 2.174406e+03, 2.178006e+03, 2.181606e+03, 2.183406e+03, 2.187006e+03, 2.188806e+03, 2.192406e+03, 2.196006e+03, 2.197806e+03, 2.201406e+03, 2.205006e+03, 2.206806e+03, 2.210406e+03, 2.212206e+03, 2.215806e+03, 2.219406e+03, 2.221206e+03, 2.224806e+03, 2.226606e+03, 2.230206e+03, 2.233806e+03, 2.235606e+03, 2.239206e+03, 2.241006e+03, 2.244606e+03, 2.248206e+03, 2.250006e+03, 2.253606e+03, 2.257206e+03, 2.259006e+03, 2.262606e+03, 2.264406e+03, 2.268006e+03, 2.271606e+03, 2.273406e+03, 2.277006e+03, 2.280606e+03, 2.282406e+03, 2.286006e+03, 2.287806e+03, 2.291406e+03, 2.295006e+03, 2.296806e+03, 2.300406e+03, 2.304006e+03, 2.305806e+03, 2.309406e+03, 2.313006e+03, 2.314806e+03, 2.318406e+03, 2.320206e+03, 2.323806e+03, 2.327406e+03, 2.329206e+03, 2.332806e+03, 2.336406e+03, 2.338206e+03, 2.341806e+03, 2.345406e+03, 2.347206e+03, 2.350806e+03, 2.354406e+03, 2.356206e+03, 2.359806e+03, 2.363406e+03, 2.365206e+03, 2.368806e+03, 2.372406e+03, 2.374206e+03, 2.377806e+03, 2.381406e+03, 2.383206e+03, 2.386806e+03, 2.390406e+03, 2.392206e+03, 2.395806e+03, 2.397606e+03, 2.401206e+03, 2.404806e+03, 2.406606e+03, 2.410206e+03, 2.413806e+03, 2.415606e+03, 2.419206e+03, 2.422806e+03, 2.424606e+03, 2.428206e+03, 2.431806e+03, 2.433606e+03, 2.437206e+03, 2.439006e+03, 2.442606e+03, 2.446206e+03, 2.448006e+03, 2.451606e+03, 2.455206e+03, 2.457006e+03, 2.460606e+03, 2.464206e+03, 2.466006e+03, 2.469606e+03, 2.473206e+03, 2.475006e+03, 2.478606e+03, 2.480406e+03, 2.484006e+03, 2.487606e+03, 2.489406e+03, 2.493007e+03, 2.496607e+03, 2.498407e+03, 2.502007e+03, 2.505607e+03, 2.507407e+03, 2.511007e+03, 2.514607e+03, 2.516407e+03, 2.520007e+03, 2.523607e+03, 2.527207e+03, 2.529007e+03, 2.532607e+03, 2.536207e+03, 2.538007e+03, 2.541607e+03, 2.545207e+03, 2.547007e+03, 2.550607e+03, 2.554207e+03, 2.557807e+03, 2.559607e+03, 2.563207e+03, 2.566807e+03, 2.568607e+03, 2.572207e+03, 2.575807e+03, 2.577607e+03, 2.581207e+03, 2.584807e+03, 2.588407e+03, 2.590207e+03, 2.593807e+03, 2.597407e+03, 2.599207e+03, 2.602807e+03, 2.606407e+03, 2.610007e+03, 2.611807e+03, 2.615407e+03, 2.619007e+03, 2.620807e+03, 2.624407e+03, 2.628007e+03, 2.629807e+03, 2.633407e+03, 2.637007e+03, 2.640607e+03, 2.642407e+03, 2.646007e+03, 2.649607e+03, 2.651407e+03, 2.655007e+03, 2.658607e+03, 2.660407e+03, 2.664007e+03, 2.667607e+03, 2.669407e+03, 2.673007e+03, 2.676607e+03, 2.680207e+03, 2.682007e+03, 2.685607e+03, 2.689207e+03, 2.692807e+03, 2.694607e+03, 2.698207e+03, 2.701807e+03, 2.705407e+03, 2.707207e+03, 2.710807e+03, 2.714407e+03, 2.716207e+03, 2.719807e+03, 2.723407e+03, 2.727007e+03, 2.728807e+03, 2.732407e+03, 2.736007e+03, 2.737807e+03, 2.741407e+03, 2.745007e+03, 2.748607e+03, 2.750407e+03, 2.754007e+03, 2.757607e+03, 2.759407e+03, 2.763007e+03, 2.766607e+03, 2.770207e+03, 2.772007e+03, 2.775607e+03, 2.779207e+03, 2.781007e+03, 2.784607e+03, 2.788207e+03, 2.790007e+03, 2.793607e+03, 2.797207e+03, 2.800807e+03, 2.802607e+03, 2.806207e+03, 2.809807e+03, 2.813407e+03, 2.815207e+03, 2.818807e+03, 2.822407e+03, 2.824207e+03, 2.827807e+03, 2.831407e+03, 2.833207e+03, 2.836807e+03, 2.840407e+03, 2.844007e+03, 2.845807e+03, 2.849407e+03, 2.853007e+03, 2.856607e+03, 2.858407e+03, 2.862007e+03, 2.865607e+03, 2.867407e+03, 2.871007e+03, 2.874608e+03, 2.878208e+03, 2.880008e+03, 2.883608e+03, 2.887208e+03, 2.890808e+03, 2.892608e+03, 2.896208e+03, 2.899808e+03, 2.903408e+03, 2.905208e+03, 2.908808e+03, 2.912408e+03, 2.916008e+03, 2.917808e+03, 2.921408e+03, 2.925008e+03, 2.928608e+03, 2.930408e+03, 2.934008e+03, 2.937608e+03, 2.941208e+03, 2.943008e+03, 2.946608e+03, 2.950208e+03, 2.953808e+03, 2.955608e+03, 2.959208e+03, 2.962808e+03, 2.966408e+03, 2.968208e+03, 2.971808e+03, 2.975408e+03, 2.979008e+03, 2.980808e+03, 2.984408e+03, 2.988008e+03, 2.991608e+03, 2.993408e+03, 2.997008e+03, 3.000608e+03, 3.004208e+03, 3.006008e+03, 3.009608e+03, 3.013208e+03, 3.016808e+03, 3.018608e+03, 3.022208e+03, 3.025808e+03, 3.029408e+03, 3.033008e+03, 3.034808e+03, 3.038408e+03, 3.042008e+03, 3.045608e+03, 3.047408e+03, 3.051008e+03, 3.054608e+03, 3.058208e+03, 3.061808e+03, 3.063608e+03, 3.067208e+03, 3.070808e+03, 3.074408e+03, 3.076208e+03, 3.079808e+03, 3.083408e+03, 3.087008e+03, 3.088808e+03, 3.092408e+03, 3.096008e+03, 3.099608e+03, 3.101408e+03, 3.105008e+03, 3.108608e+03, 3.112208e+03, 3.115808e+03, 3.117608e+03, 3.121208e+03, 3.124808e+03, 3.128408e+03, 3.130208e+03, 3.133808e+03, 3.137408e+03, 3.141008e+03, 3.142808e+03, 3.146408e+03, 3.150008e+03, 3.153608e+03, 3.155408e+03, 3.159008e+03, 3.162608e+03, 3.166208e+03, 3.168008e+03, 3.171608e+03, 3.175208e+03, 3.178808e+03, 3.182408e+03, 3.184208e+03, 3.187808e+03, 3.191408e+03, 3.195008e+03, 3.198608e+03, 3.200408e+03, 3.204008e+03, 3.207608e+03, 3.211208e+03, 3.214808e+03, 3.216608e+03, 3.220208e+03, 3.223808e+03, 3.227408e+03, 3.231008e+03, 3.234608e+03, 3.236408e+03, 3.240008e+03, 3.243608e+03, 3.247208e+03, 3.250808e+03, 3.252608e+03, 3.256208e+03, 3.259809e+03, 3.263409e+03, 3.267009e+03, 3.268809e+03, 3.272409e+03, 3.276009e+03, 3.279609e+03, 3.283209e+03, 3.285009e+03, 3.288609e+03, 3.292209e+03, 3.295809e+03, 3.297609e+03, 3.301209e+03, 3.304809e+03, 3.308409e+03, 3.312009e+03, 3.313809e+03, 3.317409e+03, 3.321009e+03, 3.324609e+03, 3.328209e+03, 3.330009e+03, 3.333609e+03, 3.337209e+03, 3.340809e+03, 3.344409e+03, 3.346209e+03, 3.349809e+03, 3.353409e+03, 3.357009e+03, 3.360609e+03, 3.362409e+03, 3.366009e+03, 3.369609e+03, 3.373209e+03, 3.376809e+03, 3.380409e+03, 3.382209e+03, 3.385809e+03, 3.389409e+03, 3.393009e+03, 3.396609e+03, 3.398409e+03, 3.402009e+03, 3.405609e+03, 3.409209e+03, 3.412809e+03, 3.416409e+03, 3.418209e+03, 3.421809e+03, 3.425409e+03, 3.429009e+03, 3.432609e+03, 3.434409e+03, 3.438009e+03, 3.441609e+03, 3.445209e+03, 3.447009e+03, 3.450609e+03, 3.454209e+03, 3.457809e+03, 3.461409e+03, 3.465009e+03, 3.468609e+03, 3.470409e+03, 3.474009e+03, 3.477609e+03, 3.481209e+03, 3.484809e+03, 3.488409e+03, 3.490209e+03, 3.493809e+03, 3.497409e+03, 3.501009e+03, 3.504609e+03, 3.508209e+03, 3.511809e+03, 3.513609e+03, 3.517209e+03, 3.520809e+03, 3.524409e+03, 3.528009e+03, 3.531609e+03, 3.535209e+03, 3.537009e+03, 3.540609e+03, 3.544209e+03, 3.547809e+03, 3.551409e+03, 3.555009e+03, 3.556809e+03, 3.560409e+03, 3.564009e+03, 3.567609e+03, 3.571209e+03, 3.574809e+03, 3.576609e+03, 3.580209e+03, 3.583809e+03, 3.587409e+03, 3.591009e+03, 3.594609e+03, 3.598209e+03, 3.601809e+03, 3.605409e+03, 3.609009e+03, 3.610809e+03, 3.614409e+03, 3.618009e+03, 3.621609e+03, 3.625209e+03, 3.628809e+03, 3.632409e+03, 3.634209e+03, 3.637809e+03, 3.641410e+03, 3.645010e+03, 3.648610e+03, 3.652210e+03, 3.655810e+03, 3.659410e+03, 3.661210e+03, 3.664810e+03, 3.668410e+03, 3.672010e+03, 3.675610e+03, 3.679210e+03, 3.682810e+03, 3.686410e+03, 3.688210e+03, 3.691810e+03, 3.695410e+03, 3.699010e+03, 3.702610e+03, 3.706210e+03, 3.709810e+03, 3.713410e+03, 3.715210e+03, 3.718810e+03, 3.722410e+03, 3.726010e+03, 3.729610e+03, 3.733210e+03, 3.736810e+03, 3.740410e+03, 3.744010e+03, 3.745810e+03, 3.749410e+03, 3.753010e+03, 3.756610e+03, 3.760210e+03, 3.763810e+03, 3.767410e+03, 3.771010e+03, 3.774610e+03, 3.778210e+03, 3.780010e+03, 3.783610e+03, 3.787210e+03, 3.790810e+03, 3.794410e+03, 3.798010e+03, 3.801610e+03, 3.805210e+03, 3.807010e+03, 3.810610e+03, 3.814210e+03, 3.817810e+03, 3.821410e+03, 3.825010e+03, 3.828610e+03, 3.832210e+03, 3.834010e+03, 3.837610e+03, 3.841210e+03, 3.844810e+03, 3.848410e+03, 3.852010e+03, 3.855610e+03, 3.859210e+03, 3.862810e+03, 3.866410e+03, 3.870010e+03, 3.871810e+03, 3.875410e+03, 3.879010e+03, 3.882610e+03, 3.886210e+03, 3.889810e+03, 3.893410e+03, 3.897010e+03, 3.900610e+03, 3.904210e+03, 3.907810e+03, 3.909610e+03, 3.913210e+03, 3.916810e+03, 3.920410e+03, 3.924010e+03, 3.927610e+03, 3.931210e+03, 3.934810e+03, 3.938410e+03, 3.940210e+03, 3.943810e+03, 3.947410e+03, 3.951010e+03, 3.954610e+03, 3.958210e+03, 3.961810e+03, 3.965410e+03, 3.969010e+03, 3.972610e+03, 3.976210e+03, 3.979810e+03, 3.983410e+03, 3.985210e+03, 3.988810e+03, 3.992410e+03, 3.996010e+03, 3.999610e+03, 4.003210e+03, 4.006810e+03, 4.010410e+03, 4.014010e+03, 4.017610e+03, 4.021210e+03, 4.024811e+03, 4.028411e+03, 4.032011e+03, 4.033811e+03, 4.037411e+03, 4.041011e+03, 4.044611e+03, 4.048211e+03, 4.051811e+03, 4.055411e+03, 4.059011e+03, 4.062611e+03, 4.066211e+03, 4.069811e+03, 4.073411e+03, 4.077011e+03, 4.080611e+03, 4.084211e+03, 4.087811e+03, 4.091411e+03, 4.095011e+03, 4.098611e+03, 4.102211e+03, 4.105811e+03, 4.109411e+03, 4.113011e+03, 4.114811e+03, 4.118411e+03, 4.122011e+03, 4.125611e+03, 4.129211e+03, 4.132811e+03, 4.136411e+03, 4.140011e+03, 4.143611e+03, 4.147211e+03, 4.150811e+03, 4.154411e+03, 4.158011e+03, 4.161611e+03, 4.165211e+03, 4.168811e+03, 4.172411e+03, 4.176011e+03, 4.179611e+03, 4.183211e+03, 4.186811e+03, 4.190411e+03, 4.194011e+03, 4.197611e+03, 4.199411e+03, 4.203011e+03, 4.206611e+03, 4.210211e+03, 4.213811e+03, 4.217411e+03, 4.221011e+03, 4.224611e+03, 4.228211e+03, 4.231811e+03, 4.235411e+03, 4.239011e+03, 4.242611e+03, 4.246211e+03, 4.249811e+03, 4.253411e+03, 4.257011e+03, 4.260611e+03, 4.264211e+03, 4.267811e+03, 4.271411e+03, 4.275011e+03, 4.278611e+03, 4.282211e+03, 4.285811e+03, 4.289411e+03, 4.293011e+03, 4.296611e+03, 4.300211e+03, 4.303811e+03, 4.307411e+03, 4.311011e+03, 4.314611e+03, 4.318211e+03, 4.321811e+03, 4.325411e+03, 4.329011e+03, 4.332611e+03, 4.336211e+03, 4.339811e+03, 4.343411e+03, 4.347011e+03, 4.350611e+03, 4.354211e+03, 4.357811e+03, 4.361411e+03, 4.365011e+03, 4.368611e+03, 4.372211e+03, 4.375811e+03, 4.379411e+03, 4.383011e+03, 4.386611e+03, 4.390211e+03, 4.393811e+03, 4.397411e+03, 4.401011e+03, 4.404611e+03, 4.408212e+03, 4.411812e+03, 4.415412e+03, 4.419012e+03, 4.422612e+03, 4.426212e+03, 4.429812e+03, 4.433412e+03, 4.437012e+03, 4.440612e+03, 4.444212e+03, 4.447812e+03, 4.451412e+03, 4.455012e+03, 4.460412e+03, 4.462212e+03, 4.467612e+03, 4.471212e+03, 4.474812e+03, 4.478412e+03, 4.482012e+03, 4.485612e+03, 4.489212e+03, 4.492812e+03, 4.496412e+03, 4.500012e+03, 4.503612e+03, 4.507212e+03, 4.510812e+03, 4.514412e+03, 4.518012e+03, 4.521612e+03, 4.525212e+03, 4.528812e+03, 4.532412e+03, 4.536012e+03, 4.539612e+03, 4.545012e+03, 4.548612e+03, 4.552212e+03, 4.555812e+03, 4.559412e+03, 4.563012e+03, 4.566612e+03, 4.570212e+03, 4.573812e+03, 4.577412e+03, 4.581012e+03, 4.584612e+03, 4.590012e+03, 4.593612e+03, 4.597212e+03, 4.600812e+03, 4.604412e+03, 4.608012e+03, 4.611612e+03, 4.615212e+03, 4.618812e+03, 4.622412e+03, 4.626012e+03, 4.629612e+03, 4.633212e+03, 4.638612e+03, 4.642212e+03, 4.645812e+03, 4.649412e+03, 4.653012e+03, 4.656612e+03, 4.660212e+03, 4.663812e+03, 4.667412e+03, 4.672812e+03, 4.676412e+03, 4.680012e+03, 4.683612e+03, 4.687212e+03, 4.690812e+03, 4.694412e+03, 4.698012e+03, 4.703412e+03, 4.707012e+03, 4.710612e+03, 4.714212e+03, 4.717812e+03, 4.721412e+03, 4.725012e+03, 4.730412e+03, 4.734012e+03, 4.737612e+03, 4.741212e+03, 4.744812e+03, 4.748412e+03, 4.752012e+03, 4.755612e+03, 4.761012e+03, 4.764612e+03, 4.768212e+03, 4.771812e+03, 4.775412e+03, 4.780812e+03, 4.784412e+03, 4.788012e+03, 4.791613e+03, 4.795213e+03, 4.798813e+03, 4.802413e+03, 4.807813e+03, 4.811413e+03, 4.815013e+03, 4.818613e+03, 4.822213e+03, 4.825813e+03, 4.829413e+03, 4.834813e+03, 4.838413e+03, 4.842013e+03, 4.845613e+03, 4.849213e+03, 4.852813e+03, 4.858213e+03, 4.861813e+03, 4.865413e+03, 4.869013e+03, 4.872613e+03, 4.876213e+03, 4.881613e+03, 4.885213e+03, 4.888813e+03, 4.892413e+03, 4.897813e+03, 4.901413e+03, 4.905013e+03, 4.908613e+03, 4.912213e+03, 4.915813e+03, 4.921213e+03, 4.924813e+03, 4.928413e+03, 4.932013e+03, 4.937413e+03, 4.941013e+03, 4.944613e+03, 4.948213e+03, 4.951813e+03, 4.957213e+03, 4.960813e+03, 4.964413e+03, 4.968013e+03, 4.973413e+03, 4.977013e+03, 4.980613e+03, 4.984213e+03, 4.989613e+03, 4.993213e+03, 4.996813e+03, 5.000413e+03, 5.005813e+03, 5.009413e+03, 5.013013e+03, 5.016613e+03, 5.022013e+03, 5.025613e+03, 5.029213e+03, 5.032813e+03, 5.036413e+03, 5.041813e+03, 5.045413e+03, 5.049013e+03, 5.052613e+03, 5.058013e+03, 5.061613e+03, 5.065213e+03, 5.068813e+03, 5.074213e+03, 5.077813e+03, 5.081413e+03, 5.086813e+03, 5.090413e+03, 5.094013e+03, 5.099413e+03, 5.103013e+03, 5.106613e+03, 5.110213e+03, 5.113813e+03, 5.119213e+03, 5.122813e+03, 5.126413e+03, 5.130013e+03, 5.133613e+03, 5.139013e+03, 5.142613e+03, 5.146213e+03, 5.151613e+03, 5.155213e+03, 5.158813e+03, 5.162413e+03, 5.167813e+03, 5.171413e+03, 5.175014e+03, 5.178614e+03, 5.184014e+03, 5.187614e+03, 5.191214e+03, 5.194814e+03, 5.200214e+03, 5.203814e+03, 5.207414e+03, 5.211014e+03, 5.216414e+03, 5.220014e+03, 5.223614e+03, 5.229014e+03, 5.232614e+03, 5.236214e+03, 5.239814e+03, 5.245214e+03, 5.248814e+03, 5.252414e+03, 5.256014e+03, 5.261414e+03, 5.265014e+03, 5.268614e+03, 5.272214e+03, 5.277614e+03, 5.281214e+03, 5.284814e+03, 5.290214e+03, 5.293814e+03, 5.297414e+03, 5.301014e+03, 5.306414e+03, 5.310014e+03, 5.313614e+03, 5.317214e+03, 5.322614e+03, 5.326214e+03, 5.329814e+03, 5.335214e+03, 5.338814e+03, 5.342414e+03, 5.346014e+03, 5.351414e+03, 5.355014e+03, 5.358614e+03, 5.362214e+03, 5.367614e+03, 5.371214e+03, 5.374814e+03, 5.380214e+03, 5.383814e+03, 5.387414e+03, 5.391014e+03, 5.396414e+03, 5.400014e+03, 5.403614e+03, 5.409014e+03, 5.412614e+03, 5.416214e+03, 5.419814e+03, 5.425214e+03, 5.428814e+03, 5.432414e+03, 5.437814e+03, 5.441414e+03, 5.445014e+03, 5.448614e+03, 5.454014e+03, 5.457614e+03, 5.461214e+03, 5.464814e+03, 5.470214e+03, 5.473814e+03, 5.477414e+03, 5.481014e+03, 5.486414e+03, 5.490014e+03, 5.493614e+03, 5.499014e+03, 5.502614e+03, 5.506214e+03, 5.509814e+03, 5.515214e+03, 5.518814e+03, 5.522414e+03, 5.526014e+03, 5.531414e+03, 5.535014e+03, 5.538614e+03, 5.544014e+03, 5.547614e+03, 5.551214e+03, 5.554814e+03, 5.560215e+03, 5.563815e+03, 5.567415e+03, 5.571015e+03, 5.576415e+03, 5.580015e+03, 5.583615e+03, 5.589015e+03, 5.592615e+03, 5.596215e+03, 5.601615e+03, 5.605215e+03, 5.608815e+03, 5.612415e+03, 5.617815e+03, 5.621415e+03, 5.625015e+03, 5.630415e+03, 5.634015e+03, 5.637615e+03, 5.641215e+03, 5.646615e+03, 5.650215e+03, 5.653815e+03, 5.659215e+03, 5.662815e+03, 5.666415e+03, 5.670015e+03, 5.675415e+03, 5.679015e+03, 5.682615e+03, 5.688015e+03, 5.691615e+03, 5.695215e+03, 5.700615e+03, 5.704215e+03, 5.707815e+03, 5.713215e+03, 5.716815e+03, 5.720415e+03, 5.725815e+03, 5.729415e+03, 5.733015e+03, 5.736615e+03, 5.742015e+03, 5.745615e+03, 5.749215e+03, 5.754615e+03, 5.758215e+03, 5.761815e+03, 5.767215e+03, 5.770815e+03, 5.774415e+03, 5.778015e+03, 5.783415e+03, 5.787015e+03, 5.790615e+03, 5.796015e+03, 5.799615e+03, 5.803215e+03, 5.808615e+03, 5.812215e+03, 5.815815e+03, 5.821215e+03, 5.824815e+03, 5.828415e+03, 5.833815e+03, 5.837415e+03, 5.841015e+03, 5.846415e+03, 5.850015e+03, 5.853615e+03, 5.859015e+03, 5.862615e+03, 5.866215e+03, 5.871615e+03, 5.875215e+03, 5.878815e+03, 5.884215e+03, 5.887815e+03, 5.891415e+03, 5.896815e+03, 5.900415e+03, 5.904015e+03, 5.909415e+03, 5.913015e+03, 5.916615e+03, 5.922015e+03, 5.925615e+03, 5.929215e+03, 5.934615e+03, 5.938216e+03, 5.943616e+03, 5.947216e+03, 5.950816e+03, 5.956216e+03, 5.959816e+03, 5.963416e+03, 5.968816e+03, 5.972416e+03, 5.976016e+03, 5.981416e+03, 5.985016e+03, 5.988616e+03, 5.994016e+03, 5.997616e+03, 6.003016e+03, 6.006616e+03, 6.010216e+03, 6.015616e+03, 6.019216e+03, 6.024616e+03, 6.028216e+03, 6.031816e+03, 6.037216e+03, 6.040816e+03, 6.044416e+03, 6.049816e+03, 6.053416e+03, 6.058816e+03, 6.062416e+03, 6.066016e+03, 6.071416e+03, 6.075016e+03, 6.078616e+03, 6.084016e+03, 6.087616e+03, 6.093016e+03, 6.096616e+03, 6.100216e+03, 6.105616e+03, 6.109216e+03, 6.112816e+03, 6.118216e+03, 6.121816e+03, 6.125416e+03, 6.130816e+03, 6.134416e+03, 6.139816e+03, 6.143416e+03, 6.147016e+03, 6.152416e+03, 6.156016e+03, 6.159616e+03, 6.165016e+03, 6.168616e+03, 6.174016e+03, 6.177616e+03, 6.181216e+03, 6.186616e+03, 6.190216e+03, 6.193816e+03, 6.199216e+03, 6.202816e+03, 6.208216e+03, 6.211816e+03, 6.215416e+03, 6.220816e+03, 6.224416e+03, 6.229816e+03, 6.233416e+03, 6.238816e+03, 6.242416e+03, 6.246016e+03, 6.251416e+03, 6.255016e+03, 6.260416e+03, 6.264016e+03, 6.267616e+03, 6.273016e+03, 6.276616e+03, 6.282016e+03, 6.285616e+03, 6.289216e+03, 6.294616e+03, 6.298216e+03, 6.303616e+03, 6.307216e+03, 6.310816e+03, 6.316216e+03, 6.319816e+03, 6.325217e+03, 6.328817e+03, 6.334217e+03, 6.337817e+03, 6.341417e+03, 6.346817e+03, 6.350417e+03, 6.355817e+03, 6.359417e+03, 6.364817e+03, 6.368417e+03, 6.372017e+03, 6.377417e+03, 6.381017e+03, 6.386417e+03, 6.390017e+03, 6.395417e+03, 6.399017e+03, 6.404417e+03, 6.408017e+03, 6.413417e+03, 6.417017e+03, 6.420617e+03, 6.426017e+03, 6.431417e+03, 6.435017e+03, 6.438617e+03, 6.444017e+03, 6.447617e+03, 6.453017e+03, 6.456617e+03, 6.462017e+03, 6.465617e+03, 6.469217e+03, 6.474617e+03, 6.478217e+03, 6.483617e+03, 6.487217e+03, 6.492617e+03, 6.496217e+03, 6.501617e+03, 6.505217e+03, 6.510617e+03, 6.514217e+03, 6.519617e+03, 6.523217e+03, 6.528617e+03, 6.532217e+03, 6.537617e+03, 6.541217e+03, 6.546617e+03, 6.550217e+03, 6.555617e+03, 6.559217e+03, 6.564617e+03, 6.568217e+03, 6.573617e+03, 6.577217e+03, 6.582617e+03, 6.586217e+03, 6.591617e+03, 6.595217e+03, 6.600617e+03, 6.604217e+03, 6.609617e+03, 6.613217e+03, 6.618617e+03, 6.622217e+03, 6.627617e+03, 6.631217e+03, 6.636617e+03, 6.640217e+03, 6.645617e+03, 6.649217e+03, 6.654617e+03, 6.658217e+03, 6.663617e+03, 6.667217e+03, 6.672617e+03, 6.676217e+03, 6.681617e+03, 6.687017e+03, 6.690617e+03, 6.696017e+03, 6.699617e+03, 6.705018e+03, 6.708618e+03, 6.714018e+03, 6.717618e+03, 6.723018e+03, 6.726618e+03, 6.732018e+03, 6.735618e+03, 6.741018e+03, 6.744618e+03, 6.750018e+03, 6.753618e+03, 6.757218e+03, 6.762618e+03, 6.768018e+03, 6.771618e+03, 6.777018e+03, 6.780618e+03, 6.786018e+03, 6.789618e+03, 6.795018e+03, 6.798618e+03, 6.804018e+03, 6.809418e+03, 6.813018e+03, 6.818418e+03, 6.822018e+03, 6.827418e+03, 6.831018e+03, 6.836418e+03, 6.840018e+03, 6.845418e+03, 6.849018e+03, 6.854418e+03, 6.858018e+03, 6.863418e+03, 6.867018e+03, 6.872418e+03, 6.877818e+03, 6.881418e+03, 6.886818e+03, 6.892218e+03, 6.895818e+03, 6.901218e+03, 6.904818e+03, 6.910218e+03, 6.913818e+03, 6.919218e+03, 6.922818e+03, 6.928218e+03, 6.931818e+03, 6.937218e+03, 6.942618e+03, 6.946218e+03, 6.951618e+03, 6.955218e+03, 6.960618e+03, 6.966018e+03, 6.969618e+03, 6.975018e+03, 6.978618e+03, 6.984018e+03, 6.989418e+03, 6.993018e+03, 6.998418e+03, 7.002018e+03, 7.007418e+03, 7.012818e+03, 7.016418e+03, 7.021818e+03, 7.025418e+03, 7.030818e+03, 7.036218e+03, 7.039818e+03, 7.045218e+03, 7.048818e+03, 7.054218e+03, 7.057818e+03, 7.063218e+03, 7.068618e+03, 7.072218e+03, 7.077618e+03, 7.081218e+03, 7.086618e+03, 7.092019e+03, 7.095619e+03, 7.101019e+03, 7.104619e+03, 7.110019e+03, 7.115419e+03, 7.119019e+03, 7.124419e+03, 7.129819e+03, 7.133419e+03, 7.138819e+03, 7.142419e+03, 7.147819e+03, 7.153219e+03, 7.156819e+03, 7.162219e+03, 7.167619e+03, 7.171219e+03, 7.176619e+03, 7.180219e+03, 7.185619e+03, 7.191019e+03, 7.194619e+03, 7.200019e+03, 7.205419e+03, 7.209019e+03, 7.214419e+03, 7.219819e+03, 7.223419e+03, 7.228819e+03, 7.234219e+03, 7.237819e+03, 7.243219e+03, 7.248619e+03, 7.252219e+03, 7.257619e+03, 7.261219e+03, 7.266619e+03, 7.272019e+03, 7.275619e+03, 7.281019e+03, 7.286419e+03, 7.290019e+03, 7.295419e+03, 7.300819e+03, 7.304419e+03, 7.309819e+03, 7.315219e+03, 7.320619e+03, 7.324219e+03, 7.329619e+03, 7.335019e+03, 7.338619e+03, 7.344019e+03, 7.347619e+03, 7.353019e+03, 7.358419e+03, 7.362019e+03, 7.367419e+03, 7.372819e+03, 7.376419e+03, 7.381819e+03, 7.387219e+03, 7.390819e+03, 7.396219e+03, 7.401619e+03, 7.405219e+03, 7.410619e+03, 7.416019e+03, 7.419619e+03, 7.425019e+03, 7.430419e+03, 7.434019e+03, 7.439419e+03, 7.444819e+03, 7.448419e+03, 7.453819e+03, 7.459219e+03, 7.462819e+03, 7.468219e+03, 7.473620e+03, 7.477220e+03, 7.482620e+03, 7.488020e+03, 7.493420e+03, 7.497020e+03, 7.502420e+03, 7.507820e+03, 7.511420e+03, 7.516820e+03, 7.522220e+03, 7.525820e+03, 7.531220e+03, 7.536620e+03, 7.540220e+03, 7.545620e+03, 7.551020e+03, 7.556420e+03, 7.561820e+03, 7.565420e+03, 7.570820e+03, 7.576220e+03, 7.579820e+03, 7.585220e+03, 7.590620e+03, 7.596020e+03, 7.599620e+03, 7.605020e+03, 7.608620e+03, 7.614020e+03, 7.619420e+03, 7.624820e+03, 7.628420e+03, 7.633820e+03, 7.639220e+03, 7.644620e+03, 7.650020e+03, 7.653620e+03, 7.659020e+03, 7.664420e+03, 7.668020e+03, 7.673420e+03, 7.678820e+03, 7.684220e+03, 7.689620e+03, 7.693220e+03, 7.698620e+03, 7.704020e+03, 7.709420e+03, 7.713020e+03, 7.718420e+03, 7.723820e+03, 7.729220e+03, 7.732820e+03, 7.738220e+03, 7.743620e+03, 7.747220e+03, 7.752620e+03, 7.758020e+03, 7.763420e+03, 7.767020e+03, 7.772420e+03, 7.777820e+03, 7.783220e+03, 7.786820e+03, 7.792220e+03, 7.797620e+03, 7.803020e+03, 7.806620e+03, 7.812020e+03, 7.817420e+03, 7.822820e+03, 7.828220e+03, 7.831820e+03, 7.837220e+03, 7.842620e+03, 7.846220e+03, 7.851620e+03, 7.857021e+03, 7.862421e+03, 7.867821e+03, 7.871421e+03, 7.876821e+03, 7.882221e+03, 7.887621e+03, 7.893021e+03, 7.896621e+03, 7.902021e+03, 7.907421e+03, 7.912821e+03, 7.918221e+03, 7.921821e+03, 7.927221e+03, 7.932621e+03, 7.938021e+03, 7.943421e+03, 7.947021e+03, 7.952421e+03, 7.957821e+03, 7.963221e+03, 7.968621e+03, 7.972221e+03, 7.977621e+03, 7.983021e+03, 7.988421e+03, 7.993821e+03, 7.999221e+03, 8.002821e+03, 8.008221e+03, 8.013621e+03, 8.019021e+03, 8.024421e+03, 8.028021e+03, 8.033421e+03, 8.038821e+03, 8.044221e+03, 8.049621e+03, 8.055021e+03, 8.058621e+03, 8.064021e+03, 8.069421e+03, 8.074821e+03, 8.080221e+03, 8.085621e+03, 8.089221e+03, 8.094621e+03, 8.100021e+03, 8.105421e+03, 8.110821e+03, 8.116221e+03, 8.119821e+03, 8.125221e+03, 8.130621e+03, 8.136021e+03, 8.141421e+03, 8.145021e+03, 8.150421e+03, 8.155821e+03, 8.161221e+03, 8.166621e+03, 8.172021e+03, 8.175621e+03, 8.181021e+03, 8.186421e+03, 8.191821e+03, 8.197221e+03, 8.202621e+03, 8.208021e+03, 8.213421e+03, 8.218821e+03, 8.224221e+03, 8.227821e+03, 8.233221e+03, 8.238622e+03, 8.244022e+03, 8.249422e+03, 8.254822e+03, 8.260222e+03, 8.265622e+03, 8.271022e+03, 8.276422e+03, 8.281822e+03, 8.287222e+03, 8.290822e+03, 8.296222e+03, 8.301622e+03, 8.307022e+03, 8.312422e+03, 8.317822e+03, 8.323222e+03, 8.328622e+03, 8.334022e+03, 8.339422e+03, 8.344822e+03, 8.348422e+03, 8.353822e+03, 8.359222e+03, 8.364622e+03, 8.370022e+03, 8.375422e+03, 8.380822e+03, 8.386222e+03, 8.391622e+03, 8.397022e+03, 8.400622e+03, 8.406022e+03, 8.411422e+03, 8.416822e+03, 8.422222e+03, 8.427622e+03, 8.433022e+03, 8.438422e+03, 8.443822e+03, 8.449222e+03, 8.454622e+03, 8.460022e+03, 8.465422e+03, 8.470822e+03, 8.476222e+03, 8.481622e+03, 8.487022e+03, 8.490622e+03, 8.496022e+03, 8.501422e+03, 8.506822e+03, 8.512222e+03, 8.517622e+03, 8.523022e+03, 8.528422e+03, 8.533822e+03, 8.539222e+03, 8.544622e+03, 8.550022e+03, 8.555422e+03, 8.560822e+03, 8.566222e+03, 8.569822e+03, 8.575222e+03, 8.580622e+03, 8.586022e+03, 8.591422e+03, 8.596822e+03, 8.602222e+03, 8.607622e+03, 8.613022e+03, 8.618422e+03, 8.623823e+03, 8.629223e+03, 8.634623e+03, 8.640023e+03, 8.645423e+03, 8.650823e+03, 8.656223e+03, 8.661623e+03, 8.667023e+03, 8.672423e+03, 8.677823e+03, 8.683223e+03, 8.688623e+03, 8.694023e+03, 8.699423e+03, 8.704823e+03, 8.710223e+03, 8.715623e+03, 8.721023e+03, 8.726423e+03, 8.731823e+03, 8.737223e+03, 8.742623e+03, 8.748023e+03, 8.753423e+03, 8.758823e+03, 8.764223e+03, 8.769623e+03, 8.775023e+03, 8.780423e+03, 8.785823e+03, 8.791223e+03, 8.796623e+03, 8.802023e+03, 8.807423e+03, 8.812823e+03, 8.818223e+03, 8.823623e+03, 8.829023e+03, 8.834423e+03, 8.839823e+03, 8.845223e+03, 8.850623e+03, 8.856023e+03, 8.861423e+03, 8.866823e+03, 8.872223e+03, 8.877623e+03, 8.883023e+03, 8.888423e+03, 8.893823e+03, 8.901023e+03, 8.906423e+03, 8.911823e+03, 8.917223e+03, 8.922623e+03, 8.928023e+03, 8.933423e+03, 8.938823e+03, 8.944223e+03, 8.949623e+03, 8.955023e+03, 8.962223e+03, 8.967623e+03, 8.973023e+03, 8.978423e+03, 8.983823e+03, 8.989223e+03, 8.994623e+03, 9.000023e+03, 9.005424e+03, 9.010824e+03, 9.016224e+03, 9.021624e+03, 9.028824e+03, 9.034224e+03, 9.039624e+03, 9.045024e+03, 9.050424e+03, 9.055824e+03, 9.061224e+03, 9.066624e+03, 9.072024e+03, 9.079224e+03, 9.084624e+03, 9.090024e+03, 9.095424e+03, 9.100824e+03, 9.106224e+03, 9.111624e+03, 9.117024e+03, 9.124224e+03, 9.129624e+03, 9.135024e+03, 9.140424e+03, 9.145824e+03, 9.151224e+03, 9.156624e+03, 9.163824e+03, 9.169224e+03, 9.174624e+03, 9.180024e+03, 9.185424e+03, 9.190824e+03, 9.196224e+03, 9.201624e+03, 9.207024e+03, 9.212424e+03, 9.217824e+03, 9.225024e+03, 9.230424e+03, 9.235824e+03, 9.241224e+03, 9.248424e+03, 9.253824e+03, 9.259224e+03, 9.264624e+03, 9.270024e+03, 9.275424e+03, 9.282624e+03, 9.288024e+03, 9.293424e+03, 9.298824e+03, 9.304224e+03, 9.309624e+03, 9.315024e+03, 9.320424e+03, 9.327624e+03, 9.333024e+03, 9.338424e+03, 9.343824e+03, 9.351024e+03, 9.356424e+03, 9.361824e+03, 9.367224e+03, 9.372624e+03, 9.378024e+03, 9.383424e+03, 9.390625e+03, 9.396025e+03, 9.401425e+03, 9.406825e+03, 9.412225e+03, 9.417625e+03, 9.424825e+03, 9.430225e+03, 9.435625e+03, 9.441025e+03, 9.448225e+03, 9.453625e+03, 9.459025e+03, 9.464425e+03, 9.469825e+03, 9.475225e+03, 9.482425e+03, 9.487825e+03, 9.493225e+03, 9.498625e+03, 9.504025e+03, 9.511225e+03, 9.516625e+03, 9.522025e+03, 9.527425e+03, 9.534625e+03, 9.540025e+03, 9.545425e+03, 9.550825e+03, 9.556225e+03, 9.563425e+03, 9.568825e+03, 9.574225e+03, 9.579625e+03, 9.586825e+03, 9.592225e+03, 9.597625e+03, 9.603025e+03, 9.608425e+03, 9.613825e+03, 9.621025e+03, 9.626425e+03, 9.631825e+03, 9.637225e+03, 9.644425e+03, 9.649825e+03, 9.655225e+03, 9.660625e+03, 9.666025e+03, 9.673225e+03, 9.678625e+03, 9.684025e+03, 9.689425e+03, 9.694825e+03, 9.702025e+03, 9.707425e+03, 9.712825e+03, 9.720025e+03, 9.725425e+03, 9.730825e+03, 9.738025e+03, 9.743425e+03, 9.748825e+03, 9.754225e+03, 9.761425e+03, 9.766825e+03, 9.772226e+03, 9.777626e+03, 9.784826e+03, 9.790226e+03, 9.795626e+03, 9.802826e+03, 9.808226e+03, 9.813626e+03, 9.819026e+03, 9.826226e+03, 9.831626e+03, 9.837026e+03, 9.844226e+03, 9.849626e+03, 9.856826e+03, 9.862226e+03, 9.867626e+03, 9.873026e+03, 9.880226e+03, 9.885626e+03, 9.892826e+03, 9.898226e+03, 9.903626e+03, 9.909026e+03, 9.916226e+03, 9.921626e+03, 9.927026e+03, 9.934226e+03, 9.939626e+03, 9.946826e+03, 9.952226e+03, 9.957626e+03, 9.964826e+03, 9.970226e+03, 9.977426e+03, 9.982826e+03, 9.988226e+03, 9.995426e+03, 1.000083e+04, 1.000623e+04, 1.001343e+04, 1.001883e+04, 1.002423e+04, 1.003143e+04, 1.003683e+04, 1.004223e+04, 1.004763e+04, 1.005483e+04, 1.006023e+04, 1.006743e+04, 1.007283e+04, 1.007823e+04, 1.008543e+04, 1.009083e+04, 1.009803e+04, 1.010343e+04, 1.011063e+04, 1.011603e+04, 1.012143e+04, 1.012863e+04, 1.013403e+04, 1.014123e+04, 1.014663e+04, 1.015203e+04, 1.015923e+04, 1.016463e+04, 1.017003e+04, 1.017723e+04, 1.018263e+04, 1.018803e+04, 1.019523e+04, 1.020063e+04, 1.020783e+04, 1.021323e+04, 1.021863e+04, 1.022583e+04, 1.023123e+04, 1.023843e+04, 1.024383e+04, 1.025103e+04, 1.025643e+04, 1.026363e+04, 1.026903e+04, 1.027443e+04, 1.028163e+04, 1.028703e+04, 1.029423e+04, 1.029963e+04, 1.030683e+04, 1.031223e+04, 1.031763e+04, 1.032483e+04, 1.033023e+04, 1.033743e+04, 1.034283e+04, 1.035003e+04, 1.035543e+04, 1.036083e+04, 1.036803e+04, 1.037343e+04, 1.038063e+04, 1.038603e+04, 1.039323e+04, 1.039863e+04, 1.040583e+04, 1.041123e+04, 1.041843e+04, 1.042383e+04, 1.043103e+04, 1.043643e+04, 1.044363e+04, 1.044903e+04, 1.045623e+04, 1.046163e+04, 1.046703e+04, 1.047423e+04, 1.047963e+04, 1.048683e+04, 1.049223e+04, 1.049943e+04, 1.050483e+04, 1.051203e+04, 1.051923e+04, 1.052463e+04, 1.053003e+04, 1.053723e+04, 1.054443e+04, 1.054983e+04, 1.055703e+04, 1.056243e+04, 1.056783e+04, 1.057503e+04, 1.058043e+04, 1.058763e+04, 1.059483e+04, 1.060023e+04, 1.060563e+04, 1.061283e+04, 1.061823e+04, 1.062543e+04, 1.063263e+04, 1.063803e+04, 1.064523e+04, 1.065063e+04, 1.065783e+04, 1.066503e+04, 1.067043e+04, 1.067763e+04, 1.068303e+04, 1.069023e+04, 1.069563e+04, 1.070283e+04, 1.070823e+04, 1.071543e+04, 1.072083e+04, 1.072803e+04, 1.073523e+04, 1.074063e+04, 1.074783e+04, 1.075323e+04, 1.076043e+04, 1.076763e+04, 1.077303e+04, 1.078023e+04, 1.078563e+04, 1.079283e+04, 1.079823e+04, 1.080543e+04, 1.081263e+04, 1.081803e+04, 1.082523e+04, 1.083063e+04, 1.083783e+04, 1.084323e+04, 1.085043e+04, 1.085583e+04, 1.086303e+04, 1.087023e+04, 1.087563e+04, 1.088283e+04, 1.088823e+04, 1.089543e+04, 1.090263e+04, 1.090803e+04, 1.091523e+04, 1.092063e+04, 1.092783e+04, 1.093323e+04, 1.094043e+04, 1.094583e+04, 1.095303e+04, 1.095843e+04, 1.096563e+04, 1.097103e+04, 1.097823e+04, 1.098543e+04, 1.099083e+04, 1.099803e+04, 1.100343e+04, 1.101063e+04, 1.101783e+04, 1.102323e+04, 1.103043e+04, 1.103763e+04, 1.104303e+04, 1.105023e+04, 1.105563e+04, 1.106283e+04, 1.107003e+04, 1.107723e+04, 1.108263e+04, 1.108983e+04, 1.109703e+04, 1.110243e+04, 1.110963e+04, 1.111683e+04, 1.112403e+04, 1.112943e+04, 1.113663e+04, 1.114383e+04, 1.114923e+04, 1.115643e+04, 1.116363e+04, 1.116903e+04, 1.117623e+04, 1.118343e+04, 1.119063e+04, 1.119603e+04, 1.120323e+04, 1.121043e+04, 1.121763e+04, 1.122303e+04, 1.123023e+04, 1.123563e+04, 1.124283e+04, 1.125003e+04, 1.125543e+04, 1.126263e+04, 1.126983e+04, 1.127523e+04, 1.128243e+04, 1.128963e+04, 1.129503e+04, 1.130223e+04, 1.130943e+04, 1.131663e+04, 1.132203e+04, 1.132923e+04, 1.133643e+04, 1.134363e+04, 1.135083e+04, 1.135623e+04, 1.136343e+04, 1.137063e+04, 1.137783e+04, 1.138323e+04, 1.139043e+04, 1.139763e+04, 1.140483e+04, 1.141023e+04, 1.141743e+04, 1.142463e+04, 1.143003e+04, 1.143723e+04, 1.144443e+04, 1.144983e+04, 1.145703e+04, 1.146423e+04, 1.147143e+04, 1.147863e+04, 1.148583e+04, 1.149123e+04, 1.149843e+04, 1.150563e+04, 1.151283e+04, 1.152003e+04, 1.152543e+04, 1.153263e+04, 1.153983e+04, 1.154703e+04, 1.155423e+04, 1.155963e+04, 1.156683e+04, 1.157403e+04, 1.158123e+04, 1.158663e+04, 1.159383e+04, 1.160103e+04, 1.160823e+04, 1.161363e+04, 1.162083e+04, 1.162803e+04, 1.163523e+04, 1.164243e+04, 1.164963e+04, 1.165683e+04, 1.166403e+04, 1.167123e+04, 1.167663e+04, 1.168383e+04, 1.169103e+04, 1.169823e+04, 1.170543e+04, 1.171263e+04, 1.171983e+04, 1.172523e+04, 1.173243e+04, 1.173963e+04, 1.174683e+04, 1.175403e+04, 1.175943e+04, 1.176663e+04, 1.177383e+04, 1.178103e+04, 1.178823e+04, 1.179543e+04, 1.180263e+04, 1.180803e+04, 1.181523e+04, 1.182243e+04, 1.182963e+04, 1.183683e+04, 1.184223e+04, 1.184943e+04, 1.185663e+04, 1.186383e+04, 1.187103e+04, 1.187823e+04, 1.188543e+04, 1.189263e+04, 1.189803e+04, 1.190523e+04, 1.191243e+04, 1.191963e+04, 1.192683e+04, 1.193403e+04, 1.194123e+04, 1.194843e+04, 1.195563e+04, 1.196283e+04, 1.196823e+04, 1.197543e+04, 1.198263e+04, 1.198983e+04, 1.199703e+04, 1.200423e+04, 1.201143e+04, 1.201863e+04, 1.202403e+04, 1.203123e+04, 1.203843e+04, 1.204563e+04, 1.205283e+04, 1.206003e+04, 1.206723e+04, 1.207443e+04, 1.207983e+04, 1.208703e+04, 1.209423e+04, 1.210143e+04, 1.210863e+04, 1.211583e+04, 1.212303e+04, 1.213023e+04, 1.213743e+04, 1.214463e+04, 1.215003e+04, 1.215723e+04, 1.216443e+04, 1.217163e+04, 1.217883e+04, 1.218603e+04, 1.219323e+04, 1.220043e+04, 1.220763e+04, 1.221483e+04, 1.222203e+04, 1.222923e+04, 1.223643e+04, 1.224363e+04, 1.225083e+04, 1.225803e+04, 1.226523e+04, 1.227243e+04, 1.227963e+04, 1.228683e+04, 1.229403e+04, 1.230123e+04, 1.230843e+04, 1.231563e+04, 1.232283e+04, 1.233003e+04, 1.233723e+04, 1.234443e+04, 1.235163e+04, 1.235883e+04, 1.236603e+04, 1.237323e+04, 1.238043e+04, 1.238763e+04, 1.239483e+04, 1.240203e+04, 1.240923e+04, 1.241643e+04, 1.242363e+04, 1.243083e+04, 1.243803e+04, 1.244523e+04, 1.245243e+04, 1.245963e+04, 1.246683e+04, 1.247583e+04, 1.248303e+04, 1.249023e+04, 1.249743e+04, 1.250463e+04, 1.251183e+04, 1.251903e+04, 1.252623e+04, 1.253343e+04, 1.254063e+04, 1.254783e+04, 1.255503e+04, 1.256223e+04, 1.256943e+04, 1.257843e+04, 1.258563e+04, 1.259283e+04, 1.260003e+04, 1.260723e+04, 1.261443e+04, 1.262163e+04, 1.262883e+04, 1.263603e+04, 1.264323e+04, 1.265043e+04, 1.265763e+04, 1.266663e+04, 1.267383e+04, 1.268103e+04, 1.268823e+04, 1.269543e+04, 1.270263e+04, 1.270983e+04, 1.271703e+04, 1.272603e+04, 1.273323e+04, 1.274043e+04, 1.274763e+04, 1.275483e+04, 1.276203e+04, 1.276923e+04, 1.277643e+04, 1.278363e+04, 1.279263e+04, 1.279983e+04, 1.280703e+04, 1.281423e+04, 1.282143e+04, 1.282863e+04, 1.283763e+04, 1.284483e+04, 1.285203e+04, 1.285923e+04, 1.286643e+04, 1.287363e+04, 1.288083e+04, 1.288983e+04, 1.289703e+04, 1.290423e+04, 1.291143e+04, 1.291863e+04, 1.292763e+04, 1.293483e+04, 1.294203e+04, 1.294923e+04, 1.295643e+04, 1.296543e+04, 1.297263e+04, 1.297983e+04, 1.298703e+04, 1.299423e+04, 1.300143e+04, 1.300863e+04, 1.301583e+04, 1.302483e+04, 1.303203e+04, 1.303923e+04, 1.304643e+04, 1.305363e+04, 1.306083e+04, 1.306803e+04, 1.307703e+04, 1.308423e+04, 1.309143e+04, 1.309863e+04, 1.310583e+04, 1.311483e+04, 1.312203e+04, 1.312923e+04, 1.313823e+04, 1.314543e+04, 1.315263e+04, 1.315983e+04, 1.316703e+04, 1.317603e+04, 1.318323e+04, 1.319043e+04, 1.319943e+04, 1.320663e+04, 1.321383e+04, 1.322103e+04, 1.323003e+04, 1.323723e+04, 1.324443e+04, 1.325343e+04, 1.326063e+04, 1.326963e+04, 1.327683e+04, 1.328403e+04, 1.329303e+04, 1.330023e+04, 1.330743e+04, 1.331463e+04, 1.332363e+04, 1.333083e+04, 1.333803e+04, 1.334523e+04, 1.335423e+04, 1.336143e+04, 1.337043e+04, 1.337763e+04, 1.338483e+04, 1.339203e+04, 1.340103e+04, 1.340823e+04, 1.341724e+04, 1.342444e+04, 1.343164e+04, 1.344064e+04, 1.344784e+04, 1.345504e+04, 1.346404e+04, 1.347124e+04, 1.347844e+04, 1.348744e+04, 1.349464e+04, 1.350364e+04, 1.351084e+04, 1.351804e+04, 1.352704e+04, 1.353424e+04, 1.354324e+04, 1.355044e+04, 1.355764e+04, 1.356664e+04, 1.357384e+04, 1.358284e+04, 1.359004e+04, 1.359904e+04, 1.360624e+04, 1.361524e+04, 1.362244e+04, 1.362964e+04, 1.363864e+04, 1.364584e+04, 1.365484e+04, 1.366204e+04, 1.366924e+04, 1.367824e+04, 1.368544e+04, 1.369444e+04, 1.370344e+04, 1.371064e+04, 1.371784e+04, 1.372684e+04, 1.373404e+04, 1.374304e+04, 1.375024e+04, 1.375924e+04, 1.376824e+04, 1.377544e+04, 1.378444e+04, 1.379164e+04, 1.380064e+04, 1.380784e+04, 1.381684e+04, 1.382404e+04, 1.383304e+04, 1.384024e+04, 1.384924e+04, 1.385644e+04, 1.386544e+04, 1.387444e+04, 1.388164e+04, 1.389064e+04, 1.389784e+04, 1.390684e+04, 1.391584e+04, 1.392304e+04, 1.393204e+04, 1.394104e+04, 1.394824e+04, 1.395724e+04, 1.396624e+04, 1.397524e+04, 1.398244e+04, 1.399144e+04, 1.399864e+04, 1.400764e+04, 1.401484e+04, 1.402384e+04, 1.403284e+04, 1.404004e+04, 1.404904e+04, 1.405804e+04, 1.406704e+04, 1.407424e+04, 1.408324e+04, 1.409224e+04, 1.409944e+04, 1.410844e+04, 1.411744e+04, 1.412644e+04, 1.413364e+04, 1.414444e+04, 1.415164e+04, 1.416064e+04, 1.416964e+04, 1.417864e+04, 1.418764e+04, 1.419484e+04, 1.420384e+04, 1.421284e+04, 1.422184e+04, 1.423084e+04, 1.423984e+04, 1.424884e+04, 1.425784e+04, 1.426684e+04, 1.427584e+04, 1.428484e+04, 1.429384e+04, 1.430464e+04, 1.431364e+04, 1.432264e+04, 1.433164e+04, 1.434064e+04, 1.435144e+04, 1.436044e+04, 1.436944e+04, 1.437844e+04, 1.438924e+04, 1.439824e+04, 1.440904e+04, 1.441804e+04, 1.442884e+04, 1.443784e+04, 1.444684e+04, 1.445764e+04, 1.446664e+04, 1.447744e+04, 1.448824e+04, 1.449724e+04, 1.450804e+04, 1.451884e+04, 1.452784e+04, 1.453864e+04, 1.454944e+04, 1.456024e+04, 1.457284e+04, 1.458364e+04, 1.459444e+04, 1.460524e+04, 1.461784e+04, 1.462864e+04, 1.464124e+04, 1.465204e+04, 1.466464e+04, 1.467724e+04, 1.468984e+04, 1.470244e+04, 1.471324e+04, 1.472764e+04, 1.474024e+04, 1.475464e+04, 1.476724e+04, 1.478164e+04, 1.479604e+04, 1.481044e+04, 1.482484e+04, 1.483924e+04, 1.485544e+04, 1.487164e+04, 1.488784e+04, 1.490404e+04, 1.492024e+04, 1.493824e+04, 1.495444e+04, 1.497424e+04, 1.499404e+04, 1.501384e+04, 1.503544e+04, 1.505884e+04, 1.508224e+04, 1.510744e+04, 1.513444e+04, 1.516324e+04, 1.519384e+04, 1.522804e+04, 1.526404e+04, 1.530544e+04, 1.535404e+04, 1.541344e+04, 1.549444e+04, 1.561144e+04};
      Double_t yd[nbins] = {3.409000e+01, 3.408000e+01, 3.407000e+01, 3.406000e+01, 3.405000e+01, 3.404000e+01, 3.403000e+01, 3.402000e+01, 3.401000e+01, 3.400000e+01, 3.399000e+01, 3.398000e+01, 3.397000e+01, 3.396000e+01, 3.395000e+01, 3.394000e+01, 3.393000e+01, 3.392000e+01, 3.391000e+01, 3.390000e+01, 3.389000e+01, 3.388000e+01, 3.387000e+01, 3.386000e+01, 3.385000e+01, 3.384000e+01, 3.383000e+01, 3.382000e+01, 3.381000e+01, 3.380000e+01, 3.379000e+01, 3.378000e+01, 3.377000e+01, 3.376000e+01, 3.375000e+01, 3.374000e+01, 3.373000e+01, 3.372000e+01, 3.371000e+01, 3.370000e+01, 3.369000e+01, 3.368000e+01, 3.367000e+01, 3.366000e+01, 3.365000e+01, 3.364000e+01, 3.363000e+01, 3.362000e+01, 3.361000e+01, 3.360000e+01, 3.359000e+01, 3.358000e+01, 3.357000e+01, 3.356000e+01, 3.355000e+01, 3.354000e+01, 3.353000e+01, 3.352000e+01, 3.351000e+01, 3.350000e+01, 3.349000e+01, 3.348000e+01, 3.347000e+01, 3.346000e+01, 3.345000e+01, 3.344000e+01, 3.343000e+01, 3.342000e+01, 3.341000e+01, 3.340000e+01, 3.339000e+01, 3.338000e+01, 3.337000e+01, 3.336000e+01, 3.335000e+01, 3.334000e+01, 3.333000e+01, 3.332000e+01, 3.331000e+01, 3.330000e+01, 3.329000e+01, 3.328000e+01, 3.327000e+01, 3.326000e+01, 3.325000e+01, 3.324000e+01, 3.323000e+01, 3.322000e+01, 3.321000e+01, 3.320000e+01, 3.319000e+01, 3.318000e+01, 3.317000e+01, 3.316000e+01, 3.315000e+01, 3.314000e+01, 3.313000e+01, 3.312000e+01, 3.311000e+01, 3.310000e+01, 3.309000e+01, 3.308000e+01, 3.307000e+01, 3.306000e+01, 3.305000e+01, 3.304000e+01, 3.303000e+01, 3.302000e+01, 3.301000e+01, 3.300000e+01, 3.299000e+01, 3.298000e+01, 3.297000e+01, 3.296000e+01, 3.295000e+01, 3.294000e+01, 3.293000e+01, 3.292000e+01, 3.291000e+01, 3.290000e+01, 3.289000e+01, 3.288000e+01, 3.287000e+01, 3.286000e+01, 3.285000e+01, 3.284000e+01, 3.283000e+01, 3.282000e+01, 3.281000e+01, 3.280000e+01, 3.279000e+01, 3.278000e+01, 3.277000e+01, 3.276000e+01, 3.275000e+01, 3.274000e+01, 3.273000e+01, 3.272000e+01, 3.271000e+01, 3.270000e+01, 3.269000e+01, 3.268000e+01, 3.267000e+01, 3.266000e+01, 3.265000e+01, 3.264000e+01, 3.263000e+01, 3.262000e+01, 3.261000e+01, 3.260000e+01, 3.259000e+01, 3.258000e+01, 3.257000e+01, 3.256000e+01, 3.255000e+01, 3.254000e+01, 3.253000e+01, 3.252000e+01, 3.251000e+01, 3.250000e+01, 3.249000e+01, 3.248000e+01, 3.247000e+01, 3.246000e+01, 3.245000e+01, 3.244000e+01, 3.243000e+01, 3.242000e+01, 3.241000e+01, 3.240000e+01, 3.239000e+01, 3.238000e+01, 3.237000e+01, 3.236000e+01, 3.235000e+01, 3.234000e+01, 3.233000e+01, 3.232000e+01, 3.231000e+01, 3.230000e+01, 3.229000e+01, 3.228000e+01, 3.227000e+01, 3.226000e+01, 3.225000e+01, 3.224000e+01, 3.223000e+01, 3.222000e+01, 3.221000e+01, 3.220000e+01, 3.219000e+01, 3.218000e+01, 3.217000e+01, 3.216000e+01, 3.215000e+01, 3.214000e+01, 3.213000e+01, 3.212000e+01, 3.211000e+01, 3.210000e+01, 3.209000e+01, 3.208000e+01, 3.207000e+01, 3.206000e+01, 3.205000e+01, 3.204000e+01, 3.203000e+01, 3.202000e+01, 3.201000e+01, 3.200000e+01, 3.199000e+01, 3.198000e+01, 3.197000e+01, 3.196000e+01, 3.195000e+01, 3.194000e+01, 3.193000e+01, 3.192000e+01, 3.191000e+01, 3.190000e+01, 3.189000e+01, 3.188000e+01, 3.187000e+01, 3.186000e+01, 3.185000e+01, 3.184000e+01, 3.183000e+01, 3.182000e+01, 3.181000e+01, 3.180000e+01, 3.179000e+01, 3.178000e+01, 3.177000e+01, 3.176000e+01, 3.175000e+01, 3.174000e+01, 3.173000e+01, 3.172000e+01, 3.171000e+01, 3.170000e+01, 3.169000e+01, 3.168000e+01, 3.167000e+01, 3.166000e+01, 3.165000e+01, 3.164000e+01, 3.163000e+01, 3.162000e+01, 3.161000e+01, 3.160000e+01, 3.159000e+01, 3.158000e+01, 3.157000e+01, 3.156000e+01, 3.155000e+01, 3.154000e+01, 3.153000e+01, 3.152000e+01, 3.151000e+01, 3.150000e+01, 3.149000e+01, 3.148000e+01, 3.147000e+01, 3.146000e+01, 3.145000e+01, 3.144000e+01, 3.143000e+01, 3.142000e+01, 3.141000e+01, 3.140000e+01, 3.139000e+01, 3.138000e+01, 3.137000e+01, 3.136000e+01, 3.135000e+01, 3.134000e+01, 3.133000e+01, 3.132000e+01, 3.131000e+01, 3.130000e+01, 3.129000e+01, 3.128000e+01, 3.127000e+01, 3.126000e+01, 3.125000e+01, 3.124000e+01, 3.123000e+01, 3.122000e+01, 3.121000e+01, 3.120000e+01, 3.119000e+01, 3.118000e+01, 3.117000e+01, 3.116000e+01, 3.115000e+01, 3.114000e+01, 3.113000e+01, 3.112000e+01, 3.111000e+01, 3.110000e+01, 3.109000e+01, 3.108000e+01, 3.107000e+01, 3.106000e+01, 3.105000e+01, 3.104000e+01, 3.103000e+01, 3.102000e+01, 3.101000e+01, 3.100000e+01, 3.099000e+01, 3.098000e+01, 3.097000e+01, 3.096000e+01, 3.095000e+01, 3.094000e+01, 3.093000e+01, 3.092000e+01, 3.091000e+01, 3.090000e+01, 3.089000e+01, 3.088000e+01, 3.087000e+01, 3.086000e+01, 3.085000e+01, 3.084000e+01, 3.083000e+01, 3.082000e+01, 3.081000e+01, 3.080000e+01, 3.079000e+01, 3.078000e+01, 3.077000e+01, 3.076000e+01, 3.075000e+01, 3.074000e+01, 3.073000e+01, 3.072000e+01, 3.071000e+01, 3.070000e+01, 3.069000e+01, 3.068000e+01, 3.067000e+01, 3.066000e+01, 3.065000e+01, 3.064000e+01, 3.063000e+01, 3.062000e+01, 3.061000e+01, 3.060000e+01, 3.059000e+01, 3.058000e+01, 3.057000e+01, 3.056000e+01, 3.055000e+01, 3.054000e+01, 3.053000e+01, 3.052000e+01, 3.051000e+01, 3.050000e+01, 3.049000e+01, 3.048000e+01, 3.047000e+01, 3.046000e+01, 3.045000e+01, 3.044000e+01, 3.043000e+01, 3.042000e+01, 3.041000e+01, 3.040000e+01, 3.039000e+01, 3.038000e+01, 3.037000e+01, 3.036000e+01, 3.035000e+01, 3.034000e+01, 3.033000e+01, 3.032000e+01, 3.031000e+01, 3.030000e+01, 3.029000e+01, 3.028000e+01, 3.027000e+01, 3.026000e+01, 3.025000e+01, 3.024000e+01, 3.023000e+01, 3.022000e+01, 3.021000e+01, 3.020000e+01, 3.019000e+01, 3.018000e+01, 3.017000e+01, 3.016000e+01, 3.015000e+01, 3.014000e+01, 3.013000e+01, 3.012000e+01, 3.011000e+01, 3.010000e+01, 3.009000e+01, 3.008000e+01, 3.007000e+01, 3.006000e+01, 3.005000e+01, 3.004000e+01, 3.003000e+01, 3.002000e+01, 3.001000e+01, 3.000000e+01, 2.999000e+01, 2.998000e+01, 2.997000e+01, 2.996000e+01, 2.995000e+01, 2.994000e+01, 2.993000e+01, 2.992000e+01, 2.991000e+01, 2.990000e+01, 2.989000e+01, 2.988000e+01, 2.987000e+01, 2.986000e+01, 2.985000e+01, 2.984000e+01, 2.983000e+01, 2.982000e+01, 2.981000e+01, 2.980000e+01, 2.979000e+01, 2.978000e+01, 2.977000e+01, 2.976000e+01, 2.975000e+01, 2.974000e+01, 2.973000e+01, 2.972000e+01, 2.971000e+01, 2.970000e+01, 2.969000e+01, 2.968000e+01, 2.967000e+01, 2.966000e+01, 2.965000e+01, 2.964000e+01, 2.963000e+01, 2.962000e+01, 2.961000e+01, 2.960000e+01, 2.959000e+01, 2.958000e+01, 2.957000e+01, 2.956000e+01, 2.955000e+01, 2.954000e+01, 2.953000e+01, 2.952000e+01, 2.951000e+01, 2.950000e+01, 2.949000e+01, 2.948000e+01, 2.947000e+01, 2.946000e+01, 2.945000e+01, 2.944000e+01, 2.943000e+01, 2.942000e+01, 2.941000e+01, 2.940000e+01, 2.939000e+01, 2.938000e+01, 2.937000e+01, 2.936000e+01, 2.935000e+01, 2.934000e+01, 2.933000e+01, 2.932000e+01, 2.931000e+01, 2.930000e+01, 2.929000e+01, 2.928000e+01, 2.927000e+01, 2.926000e+01, 2.925000e+01, 2.924000e+01, 2.923000e+01, 2.922000e+01, 2.921000e+01, 2.920000e+01, 2.919000e+01, 2.918000e+01, 2.917000e+01, 2.916000e+01, 2.915000e+01, 2.914000e+01, 2.913000e+01, 2.912000e+01, 2.911000e+01, 2.910000e+01, 2.909000e+01, 2.908000e+01, 2.907000e+01, 2.906000e+01, 2.905000e+01, 2.904000e+01, 2.903000e+01, 2.902000e+01, 2.901000e+01, 2.900000e+01, 2.899000e+01, 2.898000e+01, 2.897000e+01, 2.896000e+01, 2.895000e+01, 2.894000e+01, 2.893000e+01, 2.892000e+01, 2.891000e+01, 2.890000e+01, 2.889000e+01, 2.888000e+01, 2.887000e+01, 2.886000e+01, 2.885000e+01, 2.884000e+01, 2.883000e+01, 2.882000e+01, 2.881000e+01, 2.880000e+01, 2.879000e+01, 2.878000e+01, 2.877000e+01, 2.876000e+01, 2.875000e+01, 2.874000e+01, 2.873000e+01, 2.872000e+01, 2.871000e+01, 2.870000e+01, 2.869000e+01, 2.868000e+01, 2.867000e+01, 2.866000e+01, 2.865000e+01, 2.864000e+01, 2.863000e+01, 2.862000e+01, 2.861000e+01, 2.860000e+01, 2.859000e+01, 2.858000e+01, 2.857000e+01, 2.856000e+01, 2.855000e+01, 2.854000e+01, 2.853000e+01, 2.852000e+01, 2.851000e+01, 2.850000e+01, 2.849000e+01, 2.848000e+01, 2.847000e+01, 2.846000e+01, 2.845000e+01, 2.844000e+01, 2.843000e+01, 2.842000e+01, 2.841000e+01, 2.840000e+01, 2.839000e+01, 2.838000e+01, 2.837000e+01, 2.836000e+01, 2.835000e+01, 2.834000e+01, 2.833000e+01, 2.832000e+01, 2.831000e+01, 2.830000e+01, 2.829000e+01, 2.828000e+01, 2.827000e+01, 2.826000e+01, 2.825000e+01, 2.824000e+01, 2.823000e+01, 2.822000e+01, 2.821000e+01, 2.820000e+01, 2.819000e+01, 2.818000e+01, 2.817000e+01, 2.816000e+01, 2.815000e+01, 2.814000e+01, 2.813000e+01, 2.812000e+01, 2.811000e+01, 2.810000e+01, 2.809000e+01, 2.808000e+01, 2.807000e+01, 2.806000e+01, 2.805000e+01, 2.804000e+01, 2.803000e+01, 2.802000e+01, 2.801000e+01, 2.800000e+01, 2.799000e+01, 2.798000e+01, 2.797000e+01, 2.796000e+01, 2.795000e+01, 2.794000e+01, 2.793000e+01, 2.792000e+01, 2.791000e+01, 2.790000e+01, 2.789000e+01, 2.788000e+01, 2.787000e+01, 2.786000e+01, 2.785000e+01, 2.784000e+01, 2.783000e+01, 2.782000e+01, 2.781000e+01, 2.780000e+01, 2.779000e+01, 2.778000e+01, 2.777000e+01, 2.776000e+01, 2.775000e+01, 2.774000e+01, 2.773000e+01, 2.772000e+01, 2.771000e+01, 2.770000e+01, 2.769000e+01, 2.768000e+01, 2.767000e+01, 2.766000e+01, 2.765000e+01, 2.764000e+01, 2.763000e+01, 2.762000e+01, 2.761000e+01, 2.760000e+01, 2.759000e+01, 2.758000e+01, 2.757000e+01, 2.756000e+01, 2.755000e+01, 2.754000e+01, 2.753000e+01, 2.752000e+01, 2.751000e+01, 2.750000e+01, 2.749000e+01, 2.748000e+01, 2.747000e+01, 2.746000e+01, 2.745000e+01, 2.744000e+01, 2.743000e+01, 2.742000e+01, 2.741000e+01, 2.740000e+01, 2.739000e+01, 2.738000e+01, 2.737000e+01, 2.736000e+01, 2.735000e+01, 2.734000e+01, 2.733000e+01, 2.732000e+01, 2.731000e+01, 2.730000e+01, 2.729000e+01, 2.728000e+01, 2.727000e+01, 2.726000e+01, 2.725000e+01, 2.724000e+01, 2.723000e+01, 2.722000e+01, 2.721000e+01, 2.720000e+01, 2.719000e+01, 2.718000e+01, 2.717000e+01, 2.716000e+01, 2.715000e+01, 2.714000e+01, 2.713000e+01, 2.712000e+01, 2.711000e+01, 2.710000e+01, 2.709000e+01, 2.708000e+01, 2.707000e+01, 2.706000e+01, 2.705000e+01, 2.704000e+01, 2.703000e+01, 2.702000e+01, 2.701000e+01, 2.700000e+01, 2.699000e+01, 2.698000e+01, 2.697000e+01, 2.696000e+01, 2.695000e+01, 2.694000e+01, 2.693000e+01, 2.692000e+01, 2.691000e+01, 2.690000e+01, 2.689000e+01, 2.688000e+01, 2.687000e+01, 2.686000e+01, 2.685000e+01, 2.684000e+01, 2.683000e+01, 2.682000e+01, 2.681000e+01, 2.680000e+01, 2.679000e+01, 2.678000e+01, 2.677000e+01, 2.676000e+01, 2.675000e+01, 2.674000e+01, 2.673000e+01, 2.672000e+01, 2.671000e+01, 2.670000e+01, 2.669000e+01, 2.668000e+01, 2.667000e+01, 2.666000e+01, 2.665000e+01, 2.664000e+01, 2.663000e+01, 2.662000e+01, 2.661000e+01, 2.660000e+01, 2.659000e+01, 2.658000e+01, 2.657000e+01, 2.656000e+01, 2.655000e+01, 2.654000e+01, 2.653000e+01, 2.652000e+01, 2.651000e+01, 2.650000e+01, 2.649000e+01, 2.648000e+01, 2.647000e+01, 2.646000e+01, 2.645000e+01, 2.644000e+01, 2.643000e+01, 2.642000e+01, 2.641000e+01, 2.640000e+01, 2.639000e+01, 2.638000e+01, 2.637000e+01, 2.636000e+01, 2.635000e+01, 2.634000e+01, 2.633000e+01, 2.632000e+01, 2.631000e+01, 2.630000e+01, 2.629000e+01, 2.628000e+01, 2.627000e+01, 2.626000e+01, 2.625000e+01, 2.624000e+01, 2.623000e+01, 2.622000e+01, 2.621000e+01, 2.620000e+01, 2.619000e+01, 2.618000e+01, 2.617000e+01, 2.616000e+01, 2.615000e+01, 2.614000e+01, 2.613000e+01, 2.612000e+01, 2.611000e+01, 2.610000e+01, 2.609000e+01, 2.608000e+01, 2.607000e+01, 2.606000e+01, 2.605000e+01, 2.604000e+01, 2.603000e+01, 2.602000e+01, 2.601000e+01, 2.600000e+01, 2.599000e+01, 2.598000e+01, 2.597000e+01, 2.596000e+01, 2.595000e+01, 2.594000e+01, 2.593000e+01, 2.592000e+01, 2.591000e+01, 2.590000e+01, 2.589000e+01, 2.588000e+01, 2.587000e+01, 2.586000e+01, 2.585000e+01, 2.584000e+01, 2.583000e+01, 2.582000e+01, 2.581000e+01, 2.580000e+01, 2.579000e+01, 2.578000e+01, 2.577000e+01, 2.576000e+01, 2.575000e+01, 2.574000e+01, 2.573000e+01, 2.572000e+01, 2.571000e+01, 2.570000e+01, 2.569000e+01, 2.568000e+01, 2.567000e+01, 2.566000e+01, 2.565000e+01, 2.564000e+01, 2.563000e+01, 2.562000e+01, 2.561000e+01, 2.560000e+01, 2.559000e+01, 2.558000e+01, 2.557000e+01, 2.556000e+01, 2.555000e+01, 2.554000e+01, 2.553000e+01, 2.552000e+01, 2.551000e+01, 2.550000e+01, 2.549000e+01, 2.548000e+01, 2.547000e+01, 2.546000e+01, 2.545000e+01, 2.544000e+01, 2.543000e+01, 2.542000e+01, 2.541000e+01, 2.540000e+01, 2.539000e+01, 2.538000e+01, 2.537000e+01, 2.536000e+01, 2.535000e+01, 2.534000e+01, 2.533000e+01, 2.532000e+01, 2.531000e+01, 2.530000e+01, 2.529000e+01, 2.528000e+01, 2.527000e+01, 2.526000e+01, 2.525000e+01, 2.524000e+01, 2.523000e+01, 2.522000e+01, 2.521000e+01, 2.520000e+01, 2.519000e+01, 2.518000e+01, 2.517000e+01, 2.516000e+01, 2.515000e+01, 2.514000e+01, 2.513000e+01, 2.512000e+01, 2.511000e+01, 2.510000e+01, 2.509000e+01, 2.508000e+01, 2.507000e+01, 2.506000e+01, 2.505000e+01, 2.504000e+01, 2.503000e+01, 2.502000e+01, 2.501000e+01, 2.500000e+01, 2.499000e+01, 2.498000e+01, 2.497000e+01, 2.496000e+01, 2.495000e+01, 2.494000e+01, 2.493000e+01, 2.492000e+01, 2.491000e+01, 2.490000e+01, 2.489000e+01, 2.488000e+01, 2.487000e+01, 2.486000e+01, 2.485000e+01, 2.484000e+01, 2.483000e+01, 2.482000e+01, 2.481000e+01, 2.480000e+01, 2.479000e+01, 2.478000e+01, 2.477000e+01, 2.476000e+01, 2.475000e+01, 2.474000e+01, 2.473000e+01, 2.472000e+01, 2.471000e+01, 2.470000e+01, 2.469000e+01, 2.468000e+01, 2.467000e+01, 2.466000e+01, 2.465000e+01, 2.464000e+01, 2.463000e+01, 2.462000e+01, 2.461000e+01, 2.460000e+01, 2.459000e+01, 2.458000e+01, 2.457000e+01, 2.456000e+01, 2.455000e+01, 2.454000e+01, 2.453000e+01, 2.452000e+01, 2.451000e+01, 2.450000e+01, 2.449000e+01, 2.448000e+01, 2.447000e+01, 2.446000e+01, 2.445000e+01, 2.444000e+01, 2.443000e+01, 2.442000e+01, 2.441000e+01, 2.440000e+01, 2.439000e+01, 2.438000e+01, 2.437000e+01, 2.436000e+01, 2.435000e+01, 2.434000e+01, 2.433000e+01, 2.432000e+01, 2.431000e+01, 2.430000e+01, 2.429000e+01, 2.428000e+01, 2.427000e+01, 2.426000e+01, 2.425000e+01, 2.424000e+01, 2.423000e+01, 2.422000e+01, 2.421000e+01, 2.420000e+01, 2.419000e+01, 2.418000e+01, 2.417000e+01, 2.416000e+01, 2.415000e+01, 2.414000e+01, 2.413000e+01, 2.412000e+01, 2.411000e+01, 2.410000e+01, 2.409000e+01, 2.408000e+01, 2.407000e+01, 2.406000e+01, 2.405000e+01, 2.404000e+01, 2.403000e+01, 2.402000e+01, 2.401000e+01, 2.400000e+01, 2.399000e+01, 2.398000e+01, 2.397000e+01, 2.396000e+01, 2.395000e+01, 2.394000e+01, 2.393000e+01, 2.392000e+01, 2.391000e+01, 2.390000e+01, 2.389000e+01, 2.388000e+01, 2.387000e+01, 2.386000e+01, 2.385000e+01, 2.384000e+01, 2.383000e+01, 2.382000e+01, 2.381000e+01, 2.380000e+01, 2.379000e+01, 2.378000e+01, 2.377000e+01, 2.376000e+01, 2.375000e+01, 2.374000e+01, 2.373000e+01, 2.372000e+01, 2.371000e+01, 2.370000e+01, 2.369000e+01, 2.368000e+01, 2.367000e+01, 2.366000e+01, 2.365000e+01, 2.364000e+01, 2.363000e+01, 2.362000e+01, 2.361000e+01, 2.360000e+01, 2.359000e+01, 2.358000e+01, 2.357000e+01, 2.356000e+01, 2.355000e+01, 2.354000e+01, 2.353000e+01, 2.352000e+01, 2.351000e+01, 2.350000e+01, 2.349000e+01, 2.348000e+01, 2.347000e+01, 2.346000e+01, 2.345000e+01, 2.344000e+01, 2.343000e+01, 2.342000e+01, 2.341000e+01, 2.340000e+01, 2.339000e+01, 2.338000e+01, 2.337000e+01, 2.336000e+01, 2.335000e+01, 2.334000e+01, 2.333000e+01, 2.332000e+01, 2.331000e+01, 2.330000e+01, 2.329000e+01, 2.328000e+01, 2.327000e+01, 2.326000e+01, 2.325000e+01, 2.324000e+01, 2.323000e+01, 2.322000e+01, 2.321000e+01, 2.320000e+01, 2.319000e+01, 2.318000e+01, 2.317000e+01, 2.316000e+01, 2.315000e+01, 2.314000e+01, 2.313000e+01, 2.312000e+01, 2.311000e+01, 2.310000e+01, 2.309000e+01, 2.308000e+01, 2.307000e+01, 2.306000e+01, 2.305000e+01, 2.304000e+01, 2.303000e+01, 2.302000e+01, 2.301000e+01, 2.300000e+01, 2.299000e+01, 2.298000e+01, 2.297000e+01, 2.296000e+01, 2.295000e+01, 2.294000e+01, 2.293000e+01, 2.292000e+01, 2.291000e+01, 2.290000e+01, 2.289000e+01, 2.288000e+01, 2.287000e+01, 2.286000e+01, 2.285000e+01, 2.284000e+01, 2.283000e+01, 2.282000e+01, 2.281000e+01, 2.280000e+01, 2.279000e+01, 2.278000e+01, 2.277000e+01, 2.276000e+01, 2.275000e+01, 2.274000e+01, 2.273000e+01, 2.272000e+01, 2.271000e+01, 2.270000e+01, 2.269000e+01, 2.268000e+01, 2.267000e+01, 2.266000e+01, 2.265000e+01, 2.264000e+01, 2.263000e+01, 2.262000e+01, 2.261000e+01, 2.260000e+01, 2.259000e+01, 2.258000e+01, 2.257000e+01, 2.256000e+01, 2.255000e+01, 2.254000e+01, 2.253000e+01, 2.252000e+01, 2.251000e+01, 2.250000e+01, 2.249000e+01, 2.248000e+01, 2.247000e+01, 2.246000e+01, 2.245000e+01, 2.244000e+01, 2.243000e+01, 2.242000e+01, 2.241000e+01, 2.240000e+01, 2.239000e+01, 2.238000e+01, 2.237000e+01, 2.236000e+01, 2.235000e+01, 2.234000e+01, 2.233000e+01, 2.232000e+01, 2.231000e+01, 2.230000e+01, 2.229000e+01, 2.228000e+01, 2.227000e+01, 2.226000e+01, 2.225000e+01, 2.224000e+01, 2.223000e+01, 2.222000e+01, 2.221000e+01, 2.220000e+01, 2.219000e+01, 2.218000e+01, 2.217000e+01, 2.216000e+01, 2.215000e+01, 2.214000e+01, 2.213000e+01, 2.212000e+01, 2.211000e+01, 2.210000e+01, 2.209000e+01, 2.208000e+01, 2.207000e+01, 2.206000e+01, 2.205000e+01, 2.204000e+01, 2.203000e+01, 2.202000e+01, 2.201000e+01, 2.200000e+01, 2.199000e+01, 2.198000e+01, 2.197000e+01, 2.196000e+01, 2.195000e+01, 2.194000e+01, 2.193000e+01, 2.192000e+01, 2.191000e+01, 2.190000e+01, 2.189000e+01, 2.188000e+01, 2.187000e+01, 2.186000e+01, 2.185000e+01, 2.184000e+01, 2.183000e+01, 2.182000e+01, 2.181000e+01, 2.180000e+01, 2.179000e+01, 2.178000e+01, 2.177000e+01, 2.176000e+01, 2.175000e+01, 2.174000e+01, 2.173000e+01, 2.172000e+01, 2.171000e+01, 2.170000e+01, 2.169000e+01, 2.168000e+01, 2.167000e+01, 2.166000e+01, 2.165000e+01, 2.164000e+01, 2.163000e+01, 2.162000e+01, 2.161000e+01, 2.160000e+01, 2.159000e+01, 2.158000e+01, 2.157000e+01, 2.156000e+01, 2.155000e+01, 2.154000e+01, 2.153000e+01, 2.152000e+01, 2.151000e+01, 2.150000e+01, 2.149000e+01, 2.148000e+01, 2.147000e+01, 2.146000e+01, 2.145000e+01, 2.144000e+01, 2.143000e+01, 2.142000e+01, 2.141000e+01, 2.140000e+01, 2.139000e+01, 2.138000e+01, 2.137000e+01, 2.136000e+01, 2.135000e+01, 2.134000e+01, 2.133000e+01, 2.132000e+01, 2.131000e+01, 2.130000e+01, 2.129000e+01, 2.128000e+01, 2.127000e+01, 2.126000e+01, 2.125000e+01, 2.124000e+01, 2.123000e+01, 2.122000e+01, 2.121000e+01, 2.120000e+01, 2.119000e+01, 2.118000e+01, 2.117000e+01, 2.116000e+01, 2.115000e+01, 2.114000e+01, 2.113000e+01, 2.112000e+01, 2.111000e+01, 2.110000e+01, 2.109000e+01, 2.108000e+01, 2.107000e+01, 2.106000e+01, 2.105000e+01, 2.104000e+01, 2.103000e+01, 2.102000e+01, 2.101000e+01, 2.100000e+01, 2.099000e+01, 2.098000e+01, 2.097000e+01, 2.096000e+01, 2.095000e+01, 2.094000e+01, 2.093000e+01, 2.092000e+01, 2.091000e+01, 2.090000e+01, 2.089000e+01, 2.088000e+01, 2.087000e+01, 2.086000e+01, 2.085000e+01, 2.084000e+01, 2.083000e+01, 2.082000e+01, 2.081000e+01, 2.080000e+01, 2.079000e+01, 2.078000e+01, 2.077000e+01, 2.076000e+01, 2.075000e+01, 2.074000e+01, 2.073000e+01, 2.072000e+01, 2.071000e+01, 2.070000e+01, 2.069000e+01, 2.068000e+01, 2.067000e+01, 2.066000e+01, 2.065000e+01, 2.064000e+01, 2.063000e+01, 2.062000e+01, 2.061000e+01, 2.060000e+01, 2.059000e+01, 2.058000e+01, 2.057000e+01, 2.056000e+01, 2.055000e+01, 2.054000e+01, 2.053000e+01, 2.052000e+01, 2.051000e+01, 2.050000e+01, 2.049000e+01, 2.048000e+01, 2.047000e+01, 2.046000e+01, 2.045000e+01, 2.044000e+01, 2.043000e+01, 2.042000e+01, 2.041000e+01, 2.040000e+01, 2.039000e+01, 2.038000e+01, 2.037000e+01, 2.036000e+01, 2.035000e+01, 2.034000e+01, 2.033000e+01, 2.032000e+01, 2.031000e+01, 2.030000e+01, 2.029000e+01, 2.028000e+01, 2.027000e+01, 2.026000e+01, 2.025000e+01, 2.024000e+01, 2.023000e+01, 2.022000e+01, 2.021000e+01, 2.020000e+01, 2.019000e+01, 2.018000e+01, 2.017000e+01, 2.016000e+01, 2.015000e+01, 2.014000e+01, 2.013000e+01, 2.012000e+01, 2.011000e+01, 2.010000e+01, 2.009000e+01, 2.008000e+01, 2.007000e+01, 2.006000e+01, 2.005000e+01, 2.004000e+01, 2.003000e+01, 2.002000e+01, 2.001000e+01, 2.000000e+01, 1.999000e+01, 1.998000e+01, 1.997000e+01, 1.996000e+01, 1.995000e+01, 1.994000e+01, 1.993000e+01, 1.992000e+01, 1.991000e+01, 1.990000e+01, 1.989000e+01, 1.988000e+01, 1.987000e+01, 1.986000e+01, 1.985000e+01, 1.984000e+01, 1.983000e+01, 1.982000e+01, 1.981000e+01, 1.980000e+01, 1.979000e+01, 1.978000e+01, 1.977000e+01, 1.976000e+01, 1.975000e+01, 1.974000e+01, 1.973000e+01, 1.972000e+01, 1.971000e+01, 1.970000e+01, 1.969000e+01, 1.968000e+01, 1.967000e+01, 1.966000e+01, 1.965000e+01, 1.964000e+01, 1.963000e+01, 1.962000e+01, 1.961000e+01, 1.960000e+01, 1.959000e+01, 1.958000e+01, 1.957000e+01, 1.956000e+01, 1.955000e+01, 1.954000e+01, 1.953000e+01, 1.952000e+01, 1.951000e+01, 1.950000e+01, 1.949000e+01, 1.948000e+01, 1.947000e+01, 1.946000e+01, 1.945000e+01, 1.944000e+01, 1.943000e+01, 1.942000e+01, 1.941000e+01, 1.940000e+01, 1.939000e+01, 1.938000e+01, 1.937000e+01, 1.936000e+01, 1.935000e+01, 1.934000e+01, 1.933000e+01, 1.932000e+01, 1.931000e+01, 1.930000e+01, 1.929000e+01, 1.928000e+01, 1.927000e+01, 1.926000e+01, 1.925000e+01, 1.924000e+01, 1.923000e+01, 1.922000e+01, 1.921000e+01, 1.920000e+01, 1.919000e+01, 1.918000e+01, 1.917000e+01, 1.916000e+01, 1.915000e+01, 1.914000e+01, 1.913000e+01, 1.912000e+01, 1.911000e+01, 1.910000e+01, 1.909000e+01, 1.908000e+01, 1.907000e+01, 1.906000e+01, 1.905000e+01, 1.904000e+01, 1.903000e+01, 1.902000e+01, 1.901000e+01, 1.900000e+01, 1.899000e+01, 1.898000e+01, 1.897000e+01, 1.896000e+01, 1.895000e+01, 1.894000e+01, 1.893000e+01, 1.892000e+01, 1.891000e+01, 1.890000e+01, 1.889000e+01, 1.888000e+01, 1.887000e+01, 1.886000e+01, 1.885000e+01, 1.884000e+01, 1.883000e+01, 1.882000e+01, 1.881000e+01, 1.880000e+01, 1.879000e+01, 1.878000e+01, 1.877000e+01, 1.876000e+01, 1.875000e+01, 1.874000e+01, 1.873000e+01, 1.872000e+01, 1.871000e+01, 1.870000e+01, 1.869000e+01, 1.868000e+01, 1.867000e+01, 1.866000e+01, 1.865000e+01, 1.864000e+01, 1.863000e+01, 1.862000e+01, 1.861000e+01, 1.860000e+01, 1.859000e+01, 1.858000e+01, 1.857000e+01, 1.856000e+01, 1.855000e+01, 1.854000e+01, 1.853000e+01, 1.852000e+01, 1.851000e+01, 1.850000e+01, 1.849000e+01, 1.848000e+01, 1.847000e+01, 1.846000e+01, 1.845000e+01, 1.844000e+01, 1.843000e+01, 1.842000e+01, 1.841000e+01, 1.840000e+01, 1.839000e+01, 1.838000e+01, 1.837000e+01, 1.836000e+01, 1.835000e+01, 1.834000e+01, 1.833000e+01, 1.832000e+01, 1.831000e+01, 1.830000e+01, 1.829000e+01, 1.828000e+01, 1.827000e+01, 1.826000e+01, 1.825000e+01, 1.824000e+01, 1.823000e+01, 1.822000e+01, 1.821000e+01, 1.820000e+01, 1.819000e+01, 1.818000e+01, 1.817000e+01, 1.816000e+01, 1.815000e+01, 1.814000e+01, 1.813000e+01, 1.812000e+01, 1.811000e+01, 1.810000e+01, 1.809000e+01, 1.808000e+01, 1.807000e+01, 1.806000e+01, 1.805000e+01, 1.804000e+01, 1.803000e+01, 1.802000e+01, 1.801000e+01, 1.800000e+01, 1.799000e+01, 1.798000e+01, 1.797000e+01, 1.796000e+01, 1.795000e+01, 1.794000e+01, 1.793000e+01, 1.792000e+01, 1.791000e+01, 1.790000e+01, 1.789000e+01, 1.788000e+01, 1.787000e+01, 1.786000e+01, 1.785000e+01, 1.784000e+01, 1.783000e+01, 1.782000e+01, 1.781000e+01, 1.780000e+01, 1.779000e+01, 1.778000e+01, 1.777000e+01, 1.776000e+01, 1.775000e+01, 1.774000e+01, 1.773000e+01, 1.772000e+01, 1.771000e+01, 1.770000e+01, 1.769000e+01, 1.768000e+01, 1.767000e+01, 1.766000e+01, 1.765000e+01, 1.764000e+01, 1.763000e+01, 1.762000e+01, 1.761000e+01, 1.760000e+01, 1.759000e+01, 1.758000e+01, 1.757000e+01, 1.756000e+01, 1.755000e+01, 1.754000e+01, 1.753000e+01, 1.752000e+01, 1.751000e+01, 1.750000e+01, 1.749000e+01, 1.748000e+01, 1.747000e+01, 1.746000e+01, 1.745000e+01, 1.744000e+01, 1.743000e+01, 1.742000e+01, 1.741000e+01, 1.740000e+01, 1.739000e+01, 1.738000e+01, 1.737000e+01, 1.736000e+01, 1.735000e+01, 1.734000e+01, 1.733000e+01, 1.732000e+01, 1.731000e+01, 1.730000e+01, 1.729000e+01, 1.728000e+01, 1.727000e+01, 1.726000e+01, 1.725000e+01, 1.724000e+01, 1.723000e+01, 1.722000e+01, 1.721000e+01, 1.720000e+01, 1.719000e+01, 1.718000e+01, 1.717000e+01, 1.716000e+01, 1.715000e+01, 1.714000e+01, 1.713000e+01, 1.712000e+01, 1.711000e+01, 1.710000e+01, 1.709000e+01, 1.708000e+01, 1.707000e+01, 1.706000e+01, 1.705000e+01, 1.704000e+01, 1.703000e+01, 1.702000e+01, 1.701000e+01, 1.700000e+01, 1.699000e+01, 1.698000e+01, 1.697000e+01, 1.696000e+01, 1.695000e+01, 1.694000e+01, 1.693000e+01, 1.692000e+01, 1.691000e+01, 1.690000e+01, 1.689000e+01, 1.688000e+01, 1.687000e+01, 1.686000e+01, 1.685000e+01, 1.684000e+01, 1.683000e+01, 1.682000e+01, 1.681000e+01, 1.680000e+01, 1.679000e+01, 1.678000e+01, 1.677000e+01, 1.676000e+01, 1.675000e+01, 1.674000e+01, 1.673000e+01, 1.672000e+01, 1.671000e+01, 1.670000e+01, 1.669000e+01, 1.668000e+01, 1.667000e+01, 1.666000e+01, 1.665000e+01, 1.664000e+01, 1.663000e+01, 1.662000e+01, 1.661000e+01, 1.660000e+01, 1.659000e+01, 1.658000e+01, 1.657000e+01, 1.656000e+01, 1.655000e+01, 1.654000e+01, 1.653000e+01, 1.652000e+01, 1.651000e+01, 1.650000e+01, 1.649000e+01, 1.648000e+01, 1.647000e+01, 1.646000e+01, 1.645000e+01, 1.644000e+01, 1.643000e+01, 1.642000e+01, 1.641000e+01, 1.640000e+01, 1.639000e+01, 1.638000e+01, 1.637000e+01, 1.636000e+01, 1.635000e+01, 1.634000e+01, 1.633000e+01, 1.632000e+01, 1.631000e+01, 1.630000e+01, 1.629000e+01, 1.628000e+01, 1.627000e+01, 1.626000e+01, 1.625000e+01, 1.624000e+01, 1.623000e+01, 1.622000e+01, 1.621000e+01, 1.620000e+01, 1.619000e+01, 1.618000e+01, 1.617000e+01, 1.616000e+01, 1.615000e+01, 1.614000e+01, 1.613000e+01, 1.612000e+01, 1.611000e+01, 1.610000e+01, 1.609000e+01, 1.608000e+01, 1.607000e+01, 1.606000e+01, 1.605000e+01, 1.604000e+01, 1.603000e+01, 1.602000e+01, 1.601000e+01, 1.600000e+01, 1.599000e+01, 1.598000e+01, 1.597000e+01, 1.596000e+01, 1.595000e+01, 1.594000e+01, 1.593000e+01, 1.592000e+01, 1.591000e+01, 1.590000e+01, 1.589000e+01, 1.588000e+01, 1.587000e+01, 1.586000e+01, 1.585000e+01, 1.584000e+01, 1.583000e+01, 1.582000e+01, 1.581000e+01, 1.580000e+01, 1.579000e+01, 1.578000e+01, 1.577000e+01, 1.576000e+01, 1.575000e+01, 1.574000e+01, 1.573000e+01, 1.572000e+01, 1.571000e+01, 1.570000e+01, 1.569000e+01, 1.568000e+01, 1.567000e+01, 1.566000e+01, 1.565000e+01, 1.564000e+01, 1.563000e+01, 1.562000e+01, 1.561000e+01, 1.560000e+01, 1.559000e+01, 1.558000e+01, 1.557000e+01, 1.556000e+01, 1.555000e+01, 1.554000e+01, 1.553000e+01, 1.552000e+01, 1.551000e+01, 1.550000e+01, 1.549000e+01, 1.548000e+01, 1.547000e+01, 1.546000e+01, 1.545000e+01, 1.544000e+01, 1.543000e+01, 1.542000e+01, 1.541000e+01, 1.540000e+01, 1.539000e+01, 1.538000e+01, 1.537000e+01, 1.536000e+01, 1.535000e+01, 1.534000e+01, 1.533000e+01, 1.532000e+01, 1.531000e+01, 1.530000e+01, 1.529000e+01, 1.528000e+01, 1.527000e+01, 1.526000e+01, 1.525000e+01, 1.524000e+01, 1.523000e+01, 1.522000e+01, 1.521000e+01, 1.520000e+01, 1.519000e+01, 1.518000e+01, 1.517000e+01, 1.516000e+01, 1.515000e+01, 1.514000e+01, 1.513000e+01, 1.512000e+01, 1.511000e+01, 1.510000e+01, 1.509000e+01, 1.508000e+01, 1.507000e+01, 1.506000e+01, 1.505000e+01, 1.504000e+01, 1.503000e+01, 1.502000e+01, 1.501000e+01, 1.500000e+01, 1.499000e+01, 1.498000e+01, 1.497000e+01, 1.496000e+01, 1.495000e+01, 1.494000e+01, 1.493000e+01, 1.492000e+01, 1.491000e+01, 1.490000e+01, 1.489000e+01, 1.488000e+01, 1.487000e+01, 1.486000e+01, 1.485000e+01, 1.484000e+01, 1.483000e+01, 1.482000e+01, 1.481000e+01, 1.480000e+01, 1.479000e+01, 1.478000e+01, 1.477000e+01, 1.476000e+01, 1.475000e+01, 1.474000e+01, 1.473000e+01, 1.472000e+01, 1.471000e+01, 1.470000e+01, 1.469000e+01, 1.468000e+01, 1.467000e+01, 1.466000e+01, 1.465000e+01, 1.464000e+01, 1.463000e+01, 1.462000e+01, 1.461000e+01, 1.460000e+01, 1.459000e+01, 1.458000e+01, 1.457000e+01, 1.456000e+01, 1.455000e+01, 1.454000e+01, 1.453000e+01, 1.452000e+01, 1.451000e+01, 1.450000e+01, 1.449000e+01, 1.448000e+01, 1.447000e+01, 1.446000e+01, 1.445000e+01, 1.444000e+01, 1.443000e+01, 1.442000e+01, 1.441000e+01, 1.440000e+01, 1.439000e+01, 1.438000e+01, 1.437000e+01, 1.436000e+01, 1.435000e+01, 1.434000e+01, 1.433000e+01, 1.432000e+01, 1.431000e+01, 1.430000e+01, 1.429000e+01, 1.428000e+01, 1.427000e+01, 1.426000e+01, 1.425000e+01, 1.424000e+01, 1.423000e+01, 1.422000e+01, 1.421000e+01, 1.420000e+01, 1.419000e+01, 1.418000e+01, 1.417000e+01, 1.416000e+01, 1.415000e+01, 1.414000e+01, 1.413000e+01, 1.412000e+01, 1.411000e+01, 1.410000e+01, 1.409000e+01, 1.408000e+01, 1.407000e+01, 1.406000e+01, 1.405000e+01, 1.404000e+01, 1.403000e+01, 1.402000e+01, 1.401000e+01, 1.400000e+01, 1.399000e+01, 1.398000e+01, 1.397000e+01, 1.396000e+01, 1.395000e+01, 1.394000e+01, 1.393000e+01, 1.392000e+01, 1.391000e+01, 1.390000e+01, 1.389000e+01, 1.388000e+01, 1.387000e+01, 1.386000e+01, 1.385000e+01, 1.384000e+01, 1.383000e+01, 1.382000e+01, 1.381000e+01, 1.380000e+01, 1.379000e+01, 1.378000e+01, 1.377000e+01, 1.376000e+01, 1.375000e+01, 1.374000e+01, 1.373000e+01, 1.372000e+01, 1.371000e+01, 1.370000e+01, 1.369000e+01, 1.368000e+01, 1.367000e+01, 1.366000e+01, 1.365000e+01, 1.364000e+01, 1.363000e+01, 1.362000e+01, 1.361000e+01, 1.360000e+01, 1.359000e+01, 1.358000e+01, 1.357000e+01, 1.356000e+01, 1.355000e+01, 1.354000e+01, 1.353000e+01, 1.352000e+01, 1.351000e+01, 1.350000e+01, 1.349000e+01, 1.348000e+01, 1.347000e+01, 1.346000e+01, 1.345000e+01, 1.344000e+01, 1.343000e+01, 1.342000e+01, 1.341000e+01, 1.340000e+01, 1.339000e+01, 1.338000e+01, 1.337000e+01, 1.336000e+01, 1.335000e+01, 1.334000e+01, 1.333000e+01, 1.332000e+01, 1.331000e+01, 1.330000e+01, 1.329000e+01, 1.328000e+01, 1.327000e+01, 1.326000e+01, 1.325000e+01, 1.324000e+01, 1.323000e+01, 1.322000e+01, 1.321000e+01, 1.320000e+01, 1.319000e+01, 1.318000e+01, 1.317000e+01, 1.316000e+01, 1.315000e+01, 1.314000e+01, 1.313000e+01, 1.312000e+01, 1.311000e+01, 1.310000e+01, 1.309000e+01, 1.308000e+01, 1.307000e+01, 1.306000e+01, 1.305000e+01, 1.304000e+01, 1.303000e+01, 1.302000e+01, 1.301000e+01, 1.300000e+01, 1.299000e+01, 1.298000e+01, 1.297000e+01, 1.296000e+01, 1.295000e+01, 1.294000e+01, 1.293000e+01, 1.292000e+01, 1.291000e+01, 1.290000e+01, 1.289000e+01, 1.288000e+01, 1.287000e+01, 1.286000e+01, 1.285000e+01, 1.284000e+01, 1.283000e+01, 1.282000e+01, 1.281000e+01, 1.280000e+01, 1.279000e+01, 1.278000e+01, 1.277000e+01, 1.276000e+01, 1.275000e+01, 1.274000e+01, 1.273000e+01, 1.272000e+01, 1.271000e+01, 1.270000e+01, 1.269000e+01, 1.268000e+01, 1.267000e+01, 1.266000e+01, 1.265000e+01, 1.264000e+01, 1.263000e+01, 1.262000e+01, 1.261000e+01, 1.260000e+01, 1.259000e+01, 1.258000e+01, 1.257000e+01, 1.256000e+01, 1.255000e+01, 1.254000e+01, 1.253000e+01, 1.252000e+01, 1.251000e+01, 1.250000e+01, 1.249000e+01, 1.248000e+01, 1.247000e+01, 1.246000e+01, 1.245000e+01, 1.244000e+01, 1.243000e+01, 1.242000e+01, 1.241000e+01, 1.240000e+01, 1.239000e+01, 1.238000e+01, 1.237000e+01, 1.236000e+01, 1.235000e+01, 1.234000e+01, 1.233000e+01, 1.232000e+01, 1.231000e+01, 1.230000e+01, 1.229000e+01, 1.228000e+01, 1.227000e+01, 1.226000e+01, 1.225000e+01, 1.224000e+01, 1.223000e+01, 1.222000e+01, 1.221000e+01, 1.220000e+01, 1.219000e+01, 1.218000e+01, 1.217000e+01, 1.216000e+01, 1.215000e+01, 1.214000e+01, 1.213000e+01, 1.212000e+01, 1.211000e+01, 1.210000e+01, 1.209000e+01, 1.208000e+01, 1.207000e+01, 1.206000e+01, 1.205000e+01, 1.204000e+01, 1.203000e+01, 1.202000e+01, 1.201000e+01, 1.200000e+01, 1.199000e+01, 1.198000e+01, 1.197000e+01, 1.196000e+01, 1.195000e+01, 1.194000e+01, 1.193000e+01, 1.192000e+01, 1.191000e+01, 1.190000e+01, 1.189000e+01, 1.188000e+01, 1.187000e+01, 1.186000e+01, 1.185000e+01, 1.184000e+01, 1.183000e+01, 1.182000e+01, 1.181000e+01, 1.180000e+01, 1.179000e+01, 1.178000e+01, 1.177000e+01, 1.176000e+01, 1.175000e+01, 1.174000e+01, 1.173000e+01, 1.172000e+01, 1.171000e+01, 1.170000e+01, 1.169000e+01, 1.168000e+01, 1.167000e+01, 1.166000e+01, 1.165000e+01, 1.164000e+01, 1.163000e+01, 1.162000e+01, 1.161000e+01, 1.160000e+01, 1.159000e+01, 1.158000e+01, 1.157000e+01, 1.156000e+01, 1.155000e+01, 1.154000e+01, 1.153000e+01, 1.152000e+01, 1.151000e+01, 1.150000e+01, 1.149000e+01, 1.148000e+01, 1.147000e+01, 1.146000e+01, 1.145000e+01, 1.144000e+01, 1.143000e+01, 1.142000e+01, 1.141000e+01, 1.140000e+01, 1.139000e+01, 1.138000e+01, 1.137000e+01, 1.136000e+01, 1.135000e+01, 1.134000e+01, 1.133000e+01, 1.132000e+01, 1.131000e+01, 1.130000e+01, 1.129000e+01, 1.128000e+01, 1.127000e+01, 1.126000e+01, 1.125000e+01, 1.124000e+01, 1.123000e+01, 1.122000e+01, 1.121000e+01, 1.120000e+01, 1.119000e+01, 1.118000e+01, 1.117000e+01, 1.116000e+01, 1.115000e+01, 1.114000e+01, 1.113000e+01, 1.112000e+01, 1.111000e+01, 1.110000e+01, 1.109000e+01, 1.108000e+01, 1.107000e+01, 1.106000e+01, 1.105000e+01, 1.104000e+01, 1.103000e+01, 1.102000e+01, 1.101000e+01, 1.100000e+01, 1.099000e+01, 1.098000e+01, 1.097000e+01, 1.096000e+01, 1.095000e+01, 1.094000e+01, 1.093000e+01, 1.092000e+01, 1.091000e+01, 1.090000e+01, 1.089000e+01, 1.088000e+01, 1.087000e+01, 1.086000e+01, 1.085000e+01, 1.084000e+01, 1.083000e+01, 1.082000e+01, 1.081000e+01, 1.080000e+01, 1.079000e+01, 1.078000e+01, 1.077000e+01, 1.076000e+01, 1.075000e+01, 1.074000e+01, 1.073000e+01, 1.072000e+01, 1.071000e+01, 1.070000e+01, 1.069000e+01, 1.068000e+01, 1.067000e+01, 1.066000e+01, 1.065000e+01, 1.064000e+01, 1.063000e+01, 1.062000e+01, 1.061000e+01, 1.060000e+01, 1.059000e+01, 1.058000e+01, 1.057000e+01, 1.056000e+01, 1.055000e+01, 1.054000e+01, 1.053000e+01, 1.052000e+01, 1.051000e+01, 1.050000e+01, 1.049000e+01, 1.048000e+01, 1.047000e+01, 1.046000e+01, 1.045000e+01, 1.044000e+01, 1.043000e+01, 1.042000e+01, 1.041000e+01, 1.040000e+01, 1.039000e+01, 1.038000e+01, 1.037000e+01, 1.036000e+01, 1.035000e+01, 1.034000e+01, 1.033000e+01, 1.032000e+01, 1.031000e+01, 1.030000e+01, 1.029000e+01, 1.028000e+01, 1.027000e+01, 1.026000e+01, 1.025000e+01, 1.024000e+01, 1.023000e+01, 1.022000e+01, 1.021000e+01, 1.020000e+01, 1.019000e+01, 1.018000e+01, 1.017000e+01, 1.016000e+01, 1.015000e+01, 1.014000e+01, 1.013000e+01, 1.012000e+01, 1.011000e+01, 1.010000e+01, 1.009000e+01, 1.008000e+01, 1.007000e+01, 1.006000e+01, 1.005000e+01, 1.004000e+01, 1.003000e+01, 1.002000e+01, 1.001000e+01, 1.000000e+01, 9.990000e+00, 9.980000e+00, 9.970000e+00, 9.960000e+00, 9.950000e+00, 9.940000e+00, 9.930000e+00, 9.920000e+00, 9.910000e+00, 9.900000e+00, 9.890000e+00, 9.880000e+00, 9.870000e+00, 9.860000e+00, 9.850000e+00, 9.840000e+00, 9.830000e+00, 9.820000e+00, 9.810000e+00, 9.800000e+00, 9.790000e+00, 9.780000e+00, 9.770000e+00, 9.760000e+00, 9.750000e+00, 9.740000e+00, 9.730000e+00, 9.720000e+00, 9.710000e+00, 9.700000e+00, 9.690000e+00, 9.680000e+00, 9.670000e+00, 9.660000e+00, 9.650000e+00, 9.640000e+00, 9.630000e+00, 9.620000e+00, 9.610000e+00, 9.600000e+00, 9.590000e+00, 9.580000e+00, 9.570000e+00, 9.560000e+00, 9.550000e+00, 9.540000e+00, 9.530000e+00, 9.520000e+00, 9.510000e+00, 9.500000e+00, 9.490000e+00, 9.480000e+00, 9.470000e+00, 9.460000e+00, 9.450000e+00, 9.440000e+00, 9.430000e+00, 9.420000e+00, 9.410000e+00, 9.400000e+00, 9.390000e+00, 9.380000e+00, 9.370000e+00, 9.360000e+00, 9.350000e+00, 9.340000e+00, 9.330000e+00, 9.320000e+00, 9.310000e+00, 9.300000e+00, 9.290000e+00, 9.280000e+00, 9.270000e+00, 9.260000e+00, 9.250000e+00, 9.240000e+00, 9.230000e+00, 9.220000e+00, 9.210000e+00, 9.200000e+00, 9.190000e+00, 9.180000e+00, 9.170000e+00, 9.160000e+00, 9.150000e+00, 9.140000e+00, 9.130000e+00, 9.120000e+00, 9.110000e+00, 9.100000e+00, 9.090000e+00, 9.080000e+00, 9.070000e+00, 9.060000e+00, 9.050000e+00, 9.040000e+00, 9.030000e+00, 9.020000e+00, 9.010000e+00, 9.000000e+00, 8.990000e+00, 8.980000e+00, 8.970000e+00, 8.960000e+00, 8.950000e+00, 8.940000e+00, 8.930000e+00, 8.920000e+00, 8.910000e+00, 8.900000e+00, 8.890000e+00, 8.880000e+00, 8.870000e+00, 8.860000e+00, 8.850000e+00, 8.840000e+00, 8.830000e+00, 8.820000e+00, 8.810000e+00, 8.800000e+00, 8.790000e+00, 8.780000e+00, 8.770000e+00, 8.760000e+00, 8.750000e+00, 8.740000e+00, 8.730000e+00, 8.720000e+00, 8.710000e+00, 8.700000e+00, 8.690000e+00, 8.680000e+00, 8.670000e+00, 8.660000e+00, 8.650000e+00, 8.640000e+00, 8.630000e+00, 8.620000e+00, 8.610000e+00, 8.600000e+00, 8.590000e+00, 8.580000e+00, 8.570000e+00, 8.560000e+00, 8.550000e+00, 8.540000e+00, 8.530000e+00, 8.520000e+00, 8.510000e+00, 8.500000e+00, 8.490000e+00, 8.480000e+00, 8.470000e+00, 8.460000e+00, 8.450000e+00, 8.440000e+00, 8.430000e+00, 8.420000e+00, 8.410000e+00, 8.400000e+00, 8.390000e+00, 8.380000e+00, 8.370000e+00, 8.360000e+00, 8.350000e+00, 8.340000e+00, 8.330000e+00, 8.320000e+00, 8.310000e+00, 8.300000e+00, 8.290000e+00, 8.280000e+00, 8.270000e+00, 8.260000e+00, 8.250000e+00, 8.240000e+00, 8.230000e+00, 8.220000e+00, 8.210000e+00, 8.200000e+00, 8.190000e+00, 8.180000e+00, 8.170000e+00, 8.160000e+00, 8.150000e+00, 8.140000e+00, 8.130000e+00, 8.120000e+00, 8.110000e+00, 8.100000e+00, 8.090000e+00, 8.080000e+00, 8.070000e+00, 8.060000e+00, 8.050000e+00, 8.040000e+00, 8.030000e+00, 8.020000e+00, 8.010000e+00, 8.000000e+00, 7.990000e+00, 7.980000e+00, 7.970000e+00, 7.960000e+00, 7.950000e+00, 7.940000e+00, 7.930000e+00, 7.920000e+00, 7.910000e+00, 7.900000e+00, 7.890000e+00, 7.880000e+00, 7.870000e+00, 7.860000e+00, 7.850000e+00, 7.840000e+00, 7.830000e+00, 7.820000e+00, 7.810000e+00, 7.800000e+00, 7.790000e+00, 7.780000e+00, 7.770000e+00, 7.760000e+00, 7.750000e+00, 7.740000e+00, 7.730000e+00, 7.720000e+00, 7.710000e+00, 7.700000e+00, 7.690000e+00, 7.680000e+00, 7.670000e+00, 7.660000e+00, 7.650000e+00, 7.640000e+00, 7.630000e+00, 7.620000e+00, 7.610000e+00, 7.600000e+00, 7.590000e+00, 7.580000e+00, 7.570000e+00, 7.560000e+00, 7.550000e+00, 7.540000e+00, 7.530000e+00, 7.520000e+00, 7.510000e+00, 7.500000e+00, 7.490000e+00, 7.480000e+00, 7.470000e+00, 7.460000e+00, 7.450000e+00, 7.440000e+00, 7.430000e+00, 7.420000e+00, 7.410000e+00, 7.400000e+00, 7.390000e+00, 7.380000e+00, 7.370000e+00, 7.360000e+00, 7.350000e+00, 7.340000e+00, 7.330000e+00, 7.320000e+00, 7.310000e+00, 7.300000e+00, 7.290000e+00, 7.280000e+00, 7.270000e+00, 7.260000e+00, 7.250000e+00, 7.240000e+00, 7.230000e+00, 7.220000e+00, 7.210000e+00, 7.200000e+00, 7.190000e+00, 7.180000e+00, 7.170000e+00, 7.160000e+00, 7.150000e+00, 7.140000e+00, 7.130000e+00, 7.120000e+00, 7.110000e+00, 7.100000e+00, 7.090000e+00, 7.080000e+00, 7.070000e+00, 7.060000e+00, 7.050000e+00, 7.040000e+00, 7.030000e+00, 7.020000e+00, 7.010000e+00, 7.000000e+00, 6.990000e+00, 6.980000e+00, 6.970000e+00, 6.960000e+00, 6.950000e+00, 6.940000e+00, 6.930000e+00, 6.920000e+00, 6.910000e+00, 6.900000e+00, 6.890000e+00, 6.880000e+00, 6.870000e+00, 6.860000e+00, 6.850000e+00, 6.840000e+00, 6.830000e+00, 6.820000e+00, 6.810000e+00, 6.800000e+00, 6.790000e+00, 6.780000e+00, 6.770000e+00, 6.760000e+00, 6.750000e+00, 6.740000e+00, 6.730000e+00, 6.720000e+00, 6.710000e+00, 6.700000e+00, 6.690000e+00, 6.680000e+00, 6.670000e+00, 6.660000e+00, 6.650000e+00, 6.640000e+00, 6.630000e+00, 6.620000e+00, 6.610000e+00, 6.600000e+00, 6.590000e+00, 6.580000e+00, 6.570000e+00, 6.560000e+00, 6.550000e+00, 6.540000e+00, 6.530000e+00, 6.520000e+00, 6.510000e+00, 6.500000e+00, 6.490000e+00, 6.480000e+00, 6.470000e+00, 6.460000e+00, 6.450000e+00, 6.440000e+00, 6.430000e+00, 6.420000e+00, 6.410000e+00, 6.400000e+00, 6.390000e+00, 6.380000e+00, 6.370000e+00, 6.360000e+00, 6.350000e+00, 6.340000e+00, 6.330000e+00, 6.320000e+00, 6.310000e+00, 6.300000e+00, 6.290000e+00, 6.280000e+00, 6.270000e+00, 6.260000e+00, 6.250000e+00, 6.240000e+00, 6.230000e+00, 6.220000e+00, 6.210000e+00, 6.200000e+00, 6.190000e+00, 6.180000e+00, 6.170000e+00, 6.160000e+00, 6.150000e+00, 6.140000e+00, 6.130000e+00, 6.120000e+00, 6.110000e+00, 6.100000e+00, 6.090000e+00, 6.080000e+00, 6.070000e+00, 6.060000e+00, 6.050000e+00, 6.040000e+00, 6.030000e+00, 6.020000e+00, 6.010000e+00, 6.000000e+00, 5.990000e+00, 5.980000e+00, 5.970000e+00, 5.960000e+00, 5.950000e+00, 5.940000e+00, 5.930000e+00, 5.920000e+00, 5.910000e+00, 5.900000e+00, 5.890000e+00, 5.880000e+00, 5.870000e+00, 5.860000e+00, 5.850000e+00, 5.840000e+00, 5.830000e+00, 5.820000e+00, 5.810000e+00, 5.800000e+00, 5.790000e+00, 5.780000e+00, 5.770000e+00, 5.760000e+00, 5.750000e+00, 5.740000e+00, 5.730000e+00, 5.720000e+00, 5.710000e+00, 5.700000e+00, 5.690000e+00, 5.680000e+00, 5.670000e+00, 5.660000e+00, 5.650000e+00, 5.640000e+00, 5.630000e+00, 5.620000e+00, 5.610000e+00, 5.600000e+00, 5.590000e+00, 5.580000e+00, 5.570000e+00, 5.560000e+00, 5.550000e+00, 5.540000e+00, 5.530000e+00, 5.520000e+00, 5.510000e+00, 5.500000e+00, 5.490000e+00, 5.480000e+00, 5.470000e+00, 5.460000e+00, 5.450000e+00, 5.440000e+00, 5.430000e+00, 5.420000e+00, 5.410000e+00, 5.400000e+00, 5.390000e+00, 5.380000e+00, 5.370000e+00, 5.360000e+00, 5.350000e+00, 5.340000e+00, 5.330000e+00, 5.320000e+00, 5.310000e+00, 5.300000e+00, 5.290000e+00, 5.280000e+00, 5.270000e+00, 5.260000e+00, 5.250000e+00, 5.240000e+00, 5.230000e+00, 5.220000e+00, 5.210000e+00, 5.200000e+00, 5.190000e+00, 5.180000e+00, 5.170000e+00, 5.160000e+00, 5.150000e+00, 5.140000e+00, 5.130000e+00, 5.120000e+00, 5.110000e+00, 5.100000e+00, 5.090000e+00, 5.080000e+00, 5.070000e+00, 5.060000e+00, 5.050000e+00, 5.040000e+00, 5.030000e+00, 5.020000e+00, 5.010000e+00, 5.000000e+00, 4.990000e+00, 4.980000e+00, 4.970000e+00, 4.960000e+00, 4.950000e+00, 4.940000e+00, 4.930000e+00, 4.920000e+00, 4.910000e+00, 4.900000e+00, 4.890000e+00, 4.880000e+00, 4.870000e+00, 4.860000e+00, 4.850000e+00, 4.840000e+00, 4.830000e+00, 4.820000e+00, 4.810000e+00, 4.800000e+00, 4.790000e+00, 4.780000e+00, 4.770000e+00, 4.760000e+00, 4.750000e+00, 4.740000e+00, 4.730000e+00, 4.720000e+00, 4.710000e+00, 4.700000e+00, 4.690000e+00, 4.680000e+00, 4.670000e+00, 4.660000e+00, 4.650000e+00, 4.640000e+00, 4.630000e+00, 4.620000e+00, 4.610000e+00, 4.600000e+00, 4.590000e+00, 4.580000e+00, 4.570000e+00, 4.560000e+00, 4.550000e+00, 4.540000e+00, 4.530000e+00, 4.520000e+00, 4.510000e+00, 4.500000e+00, 4.490000e+00, 4.480000e+00, 4.470000e+00, 4.460000e+00, 4.450000e+00, 4.440000e+00, 4.430000e+00, 4.420000e+00, 4.410000e+00, 4.400000e+00, 4.390000e+00, 4.380000e+00, 4.370000e+00, 4.360000e+00, 4.350000e+00, 4.340000e+00, 4.330000e+00, 4.320000e+00, 4.310000e+00, 4.300000e+00, 4.290000e+00, 4.280000e+00, 4.270000e+00, 4.260000e+00, 4.250000e+00, 4.240000e+00, 4.230000e+00, 4.220000e+00, 4.210000e+00, 4.200000e+00, 4.190000e+00, 4.180000e+00, 4.170000e+00, 4.160000e+00, 4.150000e+00, 4.140000e+00, 4.130000e+00, 4.120000e+00, 4.110000e+00, 4.100000e+00, 4.090000e+00, 4.080000e+00, 4.070000e+00, 4.060000e+00, 4.050000e+00, 4.040000e+00, 4.030000e+00, 4.020000e+00, 4.010000e+00, 4.000000e+00, 3.990000e+00, 3.980000e+00, 3.970000e+00, 3.960000e+00, 3.950000e+00, 3.940000e+00, 3.930000e+00, 3.920000e+00, 3.910000e+00, 3.900000e+00, 3.890000e+00, 3.880000e+00, 3.870000e+00, 3.860000e+00, 3.850000e+00, 3.840000e+00, 3.830000e+00, 3.820000e+00, 3.810000e+00, 3.800000e+00, 3.790000e+00, 3.780000e+00, 3.770000e+00, 3.760000e+00, 3.750000e+00, 3.740000e+00, 3.730000e+00, 3.720000e+00, 3.710000e+00, 3.700000e+00, 3.690000e+00, 3.680000e+00, 3.670000e+00, 3.660000e+00, 3.650000e+00, 3.640000e+00, 3.630000e+00, 3.620000e+00, 3.610000e+00, 3.600000e+00, 3.590000e+00, 3.580000e+00, 3.570000e+00, 3.560000e+00, 3.550000e+00, 3.540000e+00, 3.530000e+00, 3.520000e+00, 3.510000e+00, 3.500000e+00, 3.490000e+00, 3.480000e+00, 3.470000e+00, 3.460000e+00, 3.450000e+00, 3.440000e+00, 3.430000e+00, 3.420000e+00, 3.410000e+00, 3.400000e+00, 3.390000e+00, 3.380000e+00, 3.370000e+00, 3.360000e+00, 3.350000e+00, 3.340000e+00, 3.330000e+00, 3.320000e+00, 3.310000e+00, 3.300000e+00, 3.290000e+00, 3.280000e+00, 3.270000e+00, 3.260000e+00, 3.250000e+00, 3.240000e+00, 3.230000e+00, 3.220000e+00, 3.210000e+00, 3.200000e+00, 3.190000e+00, 3.180000e+00, 3.170000e+00, 3.160000e+00, 3.150000e+00, 3.140000e+00, 3.130000e+00, 3.120000e+00, 3.110000e+00, 3.100000e+00, 3.090000e+00, 3.080000e+00, 3.070000e+00, 3.060000e+00, 3.050000e+00, 3.040000e+00, 3.030000e+00, 3.020000e+00, 3.010000e+00, 3.000000e+00, 2.990000e+00, 2.980000e+00, 2.970000e+00, 2.960000e+00, 2.950000e+00, 2.940000e+00, 2.930000e+00, 2.920000e+00, 2.910000e+00, 2.900000e+00, 2.890000e+00, 2.880000e+00, 2.870000e+00, 2.860000e+00, 2.850000e+00, 2.840000e+00, 2.830000e+00, 2.820000e+00, 2.810000e+00, 2.800000e+00, 2.790000e+00, 2.780000e+00, 2.770000e+00, 2.760000e+00, 2.750000e+00, 2.740000e+00, 2.730000e+00, 2.720000e+00, 2.710000e+00, 2.700000e+00, 2.690000e+00, 2.680000e+00, 2.670000e+00, 2.660000e+00, 2.650000e+00, 2.640000e+00, 2.630000e+00, 2.620000e+00, 2.610000e+00, 2.600000e+00, 2.590000e+00, 2.580000e+00, 2.570000e+00, 2.560000e+00, 2.550000e+00, 2.540000e+00, 2.530000e+00, 2.520000e+00, 2.510000e+00, 2.500000e+00, 2.490000e+00, 2.480000e+00, 2.470000e+00, 2.460000e+00, 2.450000e+00, 2.440000e+00, 2.430000e+00, 2.420000e+00, 2.410000e+00, 2.400000e+00, 2.390000e+00, 2.380000e+00, 2.370000e+00, 2.360000e+00, 2.350000e+00, 2.340000e+00, 2.330000e+00, 2.320000e+00, 2.310000e+00, 2.300000e+00, 2.290000e+00, 2.280000e+00, 2.270000e+00, 2.260000e+00, 2.250000e+00, 2.240000e+00, 2.230000e+00, 2.220000e+00, 2.210000e+00, 2.200000e+00, 2.190000e+00, 2.180000e+00, 2.170000e+00, 2.160000e+00, 2.150000e+00, 2.140000e+00, 2.130000e+00, 2.120000e+00, 2.110000e+00, 2.100000e+00, 2.090000e+00, 2.080000e+00, 2.070000e+00, 2.060000e+00, 2.050000e+00, 2.040000e+00, 2.030000e+00, 2.020000e+00, 2.010000e+00, 2.000000e+00, 1.990000e+00, 1.980000e+00, 1.970000e+00, 1.960000e+00, 1.950000e+00, 1.940000e+00, 1.930000e+00, 1.920000e+00, 1.910000e+00, 1.900000e+00, 1.890000e+00, 1.880000e+00, 1.870000e+00, 1.860000e+00, 1.850000e+00, 1.840000e+00, 1.830000e+00, 1.820000e+00, 1.810000e+00, 1.800000e+00, 1.790000e+00, 1.780000e+00, 1.770000e+00, 1.760000e+00, 1.750000e+00, 1.740000e+00, 1.730000e+00, 1.720000e+00, 1.710000e+00, 1.700000e+00, 1.690000e+00, 1.680000e+00, 1.670000e+00, 1.660000e+00, 1.650000e+00, 1.640000e+00, 1.630000e+00, 1.620000e+00, 1.610000e+00, 1.600000e+00, 1.590000e+00, 1.580000e+00, 1.570000e+00, 1.560000e+00, 1.550000e+00, 1.540000e+00, 1.530000e+00, 1.520000e+00, 1.510000e+00, 1.500000e+00, 1.490000e+00, 1.480000e+00, 1.470000e+00, 1.460000e+00, 1.450000e+00, 1.440000e+00, 1.430000e+00, 1.420000e+00, 1.410000e+00, 1.400000e+00, 1.390000e+00, 1.380000e+00, 1.370000e+00, 1.360000e+00, 1.350000e+00, 1.340000e+00, 1.330000e+00, 1.320000e+00, 1.310000e+00, 1.300000e+00, 1.290000e+00, 1.280000e+00, 1.270000e+00, 1.260000e+00, 1.250000e+00, 1.240000e+00, 1.230000e+00, 1.220000e+00, 1.210000e+00, 1.200000e+00, 1.190000e+00, 1.180000e+00, 1.170000e+00, 1.160000e+00, 1.150000e+00, 1.140000e+00, 1.130000e+00, 1.120000e+00, 1.110000e+00, 1.100000e+00, 1.090000e+00, 1.080000e+00, 1.070000e+00, 1.060000e+00, 1.050000e+00, 1.040000e+00, 1.030000e+00, 1.020000e+00, 1.010000e+00, 1.000000e+00, 9.900000e-01, 9.800000e-01, 9.700000e-01, 9.600000e-01, 9.500000e-01, 9.400000e-01, 9.300000e-01, 9.200000e-01, 9.100000e-01, 9.000000e-01, 8.900000e-01, 8.800000e-01, 8.700000e-01, 8.600000e-01, 8.500000e-01, 8.400000e-01, 8.300000e-01, 8.200000e-01, 8.100000e-01, 8.000000e-01, 7.900000e-01, 7.800000e-01, 7.700000e-01, 7.600000e-01, 7.500000e-01, 7.400000e-01, 7.300000e-01, 7.200000e-01, 7.100000e-01, 7.000000e-01, 6.900000e-01, 6.800000e-01, 6.700000e-01, 6.600000e-01, 6.500000e-01, 6.400000e-01, 6.300000e-01, 6.200000e-01, 6.100000e-01, 6.000000e-01, 5.900000e-01, 5.800000e-01, 5.700000e-01, 5.600000e-01, 5.500000e-01, 5.400000e-01, 5.300000e-01, 5.200000e-01, 5.100000e-01, 5.000000e-01, 4.900000e-01, 4.800000e-01, 4.700000e-01, 4.600000e-01, 4.500000e-01, 4.400000e-01, 4.300000e-01, 4.200000e-01, 4.100000e-01, 4.000000e-01, 3.900000e-01, 3.800000e-01, 3.700000e-01, 3.600000e-01, 3.500000e-01, 3.400000e-01, 3.300000e-01, 3.200000e-01, 3.100000e-01, 3.000000e-01, 2.900000e-01, 2.800000e-01, 2.700000e-01, 2.600000e-01, 2.500000e-01, 2.400000e-01, 2.300000e-01, 2.200000e-01, 2.100000e-01, 2.000000e-01, 1.900000e-01, 1.800000e-01, 1.700000e-01, 1.600000e-01, 1.500000e-01, 1.400000e-01, 1.300000e-01, 1.200000e-01, 1.100000e-01, 1.000000e-01, 9.000000e-02, 8.000000e-02, 7.000000e-02, 6.000000e-02, 5.000000e-02, 4.000000e-02, 3.000000e-02, 2.000000e-02, 1.000000e-02, 0.000000e+00};

      fCenMetric = new TGraph(nbins,xd,yd);
      fTempList->Add(fCenMetric);

    }

    fPolSlope[0] = new TF1("slopeper","expo",1.E2,1.E4);
    Double_t parper[] = {9.45678e-01,-5.66325e-04};
    fPolSlope[0]->SetParameters(parper);
    fTempList->Add(fPolSlope[0]);

    fPolSlope[1] = new TF1("slopecen","landaun",1.E4,2.5E4);
    Double_t parcen[] = {1.35360e+02,8.35468e+03,2.39137e+03};
    fPolSlope[1]->SetParameters(parcen);
    fTempList->Add(fPolSlope[1]);

  }

  if (fUseZDC) {
    //    for(Int_t c=0;c<8;c++) {
    //      fCRCZDCQ2[c] = new TProfile2D(Form("fCRCZDCQ2[%d]",c),
    //                                    Form("fCRCZDCQ2[%d]",c),fCRCnRun,0.,1.*fCRCnRun,100,0.,100.,"s");
    //      fCRCZDCQ2[c]->Sumw2();
    //      fCRCQVecList->Add(fCRCZDCQ2[c]);
    //    }
    //    fCRCZDCResCenEn = new TProfile2D("fCRCZDCResCenEn","fCRCZDCResCenEn",50,0.,2.5,100,0.,100.);
    //    fCRCQVecList->Add(fCRCZDCResCenEn);
  }

  Double_t dummybins[] = {0.,1.,2.,3.,4.};
  fCRCQVecPtHistMagField = new TH2D("fCRCQVecPtHistMagField","fCRCQVecPtHistMagField",fPtDiffNBins,fCRCPtBins,4,dummybins);
  fCRCQVecPtHistMagField->GetYaxis()->SetBinLabel(1,"pol+;ch+");
  fCRCQVecPtHistMagField->GetYaxis()->SetBinLabel(2,"pol+;ch-");
  fCRCQVecPtHistMagField->GetYaxis()->SetBinLabel(3,"pol-;ch+");
  fCRCQVecPtHistMagField->GetYaxis()->SetBinLabel(4,"pol-;ch-");
  fCRCQVecEtaPhiList->Add(fCRCQVecPtHistMagField);

  Double_t phibinsforphihist[101] = {0.};
  for (Int_t phib=0; phib<101; phib++) {
    phibinsforphihist[phib] = phib*TMath::TwoPi()/100.;
  }
  Double_t harbinsforphihist[] = {0.,1.,2.,3.,4.,5.,6.};
  Double_t cenbinsforphihist[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
  Double_t etabinsforphihist[] = {-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0.,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8};
  Double_t etabinsforrecente[] = {-0.8,-0.64,-0.48,-0.32,-0.16,0.,0.16,0.32,0.48,0.64,0.8};
  fCRCQVecPhiHist = new TH3D("fCRCQVecPhiHist","fCRCQVecPhiHist",10,cenbinsforphihist,100,phibinsforphihist,16,etabinsforphihist);
  fCRCQVecPhiHist->Sumw2();
  fCRCQVecEtaPhiList->Add(fCRCQVecPhiHist);
  for(Int_t r=0;r<2;r++) {
    fCRCQVecPhiHistCh[r] = new TH3D(Form("fCRCQVecPhiHistCh[%d]",r),Form("fCRCQVecPhiHistCh[%d]",r),10,cenbinsforphihist,100,phibinsforphihist,16,etabinsforphihist);
    fCRCQVecPhiHistCh[r]->Sumw2();
    fCRCQVecEtaPhiList->Add(fCRCQVecPhiHistCh[r]);
    fCRCQVecHarCosProCh[r] = new TProfile3D(Form("fCRCQVecHarCosProCh[%d]",r),Form("fCRCQVecHarCosProCh[%d]",r),10,cenbinsforphihist,6,harbinsforphihist,fkEtaDiffMaxNBins,etabinsforrecente);
    fCRCQVecHarCosProCh[r]->Sumw2();
    fCRCQVecEtaPhiList->Add(fCRCQVecHarCosProCh[r]);
    fCRCQVecHarSinProCh[r] = new TProfile3D(Form("fCRCQVecHarSinProCh[%d]",r),Form("fCRCQVecHarSinProCh[%d]",r),10,cenbinsforphihist,6,harbinsforphihist,fkEtaDiffMaxNBins,etabinsforrecente);
    fCRCQVecHarSinProCh[r]->Sumw2();
    fCRCQVecEtaPhiList->Add(fCRCQVecHarSinProCh[r]);
  }
  // Double_t xmin = -8.5e-3;
  // Double_t xmax = 8.5e-3;
  // Double_t ymin = -7.8e-3;
  // Double_t ymax = 7.8e-3;
  Double_t zmin = -10.;
  Double_t zmax = 10.;
  // Double_t vtxbinsx[11] = {0.};
  // Double_t vtxbinsy[11] = {0.};
  Double_t vtxbinsz[11] = {0.};
  for (Int_t v=0; v<11; v++) {
    // vtxbinsx[v]=xmin + v*(xmax-xmin)/10.;
    // vtxbinsy[v]=ymin + v*(ymax-ymin)/10.;
    vtxbinsz[v]=zmin + v*(zmax-zmin)/10.;
  }
  Double_t phibinsforphihist2[51] = {0.};
  for (Int_t phib=0; phib<51; phib++) {
    phibinsforphihist2[phib] = phib*TMath::TwoPi()/50.;
  }

  // dummy bins for refmul in 15o
  Double_t RecRefMulBinMin[10] = {-6.000000e+02, -4.788000e+02, -4.056000e+02, -3.036000e+02, -2.400000e+02, -1.908000e+02, -1.380000e+02, -9.240000e+01, -5.400000e+01, -2.760000e+01};
  Double_t RecRefMulBinMax[10] = {4.872000e+02, 4.212000e+02, 3.456000e+02, 2.868000e+02, 2.244000e+02, 1.788000e+02, 1.380000e+02, 1.020000e+02, 7.080000e+01, 4.440000e+01};
  Double_t RecRefMulBins[10][11] = {{0.}};
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
    for (Int_t i=0; i<11; i++) {
      RecRefMulBins[cb][i] = RecRefMulBinMin[cb] + i*(RecRefMulBinMax[cb]-RecRefMulBinMin[cb])/10.;
    }
    fCRCQVecPhiHistRefMul[cb] = new TH3D(Form("fCRCQVecPhiHistRefMul[%d]",cb),Form("fCRCQVecPhiHistRefMul[%d]",cb),10,RecRefMulBins[cb],50,phibinsforphihist2,16,etabinsforphihist);
    fCRCQVecPhiHistRefMul[cb]->Sumw2();
    fCRCQVecEtaPhiList->Add(fCRCQVecPhiHistRefMul[cb]);
  }
  for (Int_t cb=0; cb<fCRCnCen; cb++) {
      fCRCQVecPhiHistVtxAll[cb] = new TH3D(Form("fCRCQVecPhiHistVtxAll[%d]",cb),Form("fCRCQVecPhiHistVtxAll[%d]",cb),10,vtxbinsz,50,phibinsforphihist2,16,etabinsforphihist);
      fCRCQVecPhiHistVtxAll[cb]->Sumw2();
      fCRCQVecEtaPhiList->Add(fCRCQVecPhiHistVtxAll[cb]);
  }

  if(fVtxRbR) {
    for (Int_t cb=0; cb<fCRCnCen; cb++) {
      for(Int_t r=0;r<fCRCnRun;r++) {
        fCRCQVecPhiHistVtx[cb][r] = new TH3D(Form("fCRCQVecPhiHistVtx[%d][%d]",cb,fRunList[r]),Form("fCRCQVecPhiHistVtx[%d][%d]",cb,fRunList[r]),10,vtxbinsz,50,phibinsforphihist2,16,etabinsforphihist);
        fCRCQVecPhiHistVtx[cb][r]->Sumw2();
        fCRCQVecEtaPhiList->Add(fCRCQVecPhiHistVtx[cb][r]);
      }
    }
  }

  for(Int_t r=0;r<fCRCnRun;r++) {
    fCRCQVecListRun[r] = new TList();
    fCRCQVecListRun[r]->SetName(Form("Run %d",fRunList[r]));
    fCRCQVecListRun[r]->SetOwner(kTRUE);
    fCRCQVecList->Add(fCRCQVecListRun[r]);

    // @shi uncomment following lines for generating RbRphi eta weight
    fCRCQVecPhiRbRHist[r] = new TH3D(Form("fCRCQVecPhiRbRHist[%d]",fRunList[r]),Form("fCRCQVecPhiRbRHist[%d]",fRunList[r]),10,cenbinsforphihist,100,phibinsforphihist,16,etabinsforphihist);
    fCRCQVecPhiRbRHist[r]->Sumw2();
    fCRCQVecListRun[r]->Add(fCRCQVecPhiRbRHist[r]);
    for(Int_t k=0;k<2;k++) {
      fCRCQVecPhiRbRHistCh[r][k] = new TH3D(Form("fCRCQVecPhiRbRHistCh[%d][%d]",fRunList[r],k),Form("fCRCQVecPhiRbRHistCh[%d][%d]",fRunList[r],k),10,cenbinsforphihist,100,phibinsforphihist,16,etabinsforphihist);
      fCRCQVecPhiRbRHistCh[r][k]->Sumw2();
      fCRCQVecListRun[r]->Add(fCRCQVecPhiRbRHistCh[r][k]);
    }

   if(fStoreZDCQVecVtxPos) {
    fFlowQCVtxList[r] = new TList();
    fFlowQCVtxList[r]->SetName("Flow RbR");
    fFlowQCVtxList[r]->SetOwner(kTRUE);
    fCRCQVecListRun[r]->Add(fFlowQCVtxList[r]);
    // Double_t etabinsforcum[17] = {-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0.,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8};
    //  for(Int_t i=0; i<fkFlowQCRbRnHar; i++) {
    //    for(Int_t k=0; k<fkFlowQCRbRnVar; k++) {
    //      for(Int_t j=0; j<fkFlowQCRbRnHist; j++) {
    //        fFlowQCIntRbRProPtEta[r][i][k][j] = new TProfile2D(Form("fFlowQCIntRbRProPtEta[%d][%d][%d][%d]",fRunList[r],i,k,j),Form("fFlowQCIntRbRProPtEta[%d][%d][%d][%d]",fRunList[r],i,k,j),10,cenbinsforphihist,16,etabinsforcum);
    //        fFlowQCIntRbRProPtEta[r][i][k][j]->Sumw2();
    //        fFlowQCVtxList[r]->Add(fFlowQCIntRbRProPtEta[r][i][k][j]);
    //      }
    //    }
    //    for(Int_t k=0; k<fkFlowQCRbRnVar2; k++) {
    //      for(Int_t j=0; j<fkFlowQCRbRnHist2; j++) {
    //        fFlowQCIntRbRPro[r][i][k][j] = new TProfile(Form("fFlowQCIntRbRPro[%d][%d][%d][%d]",fRunList[r],i,k,j),Form("fFlowQCIntRbRPro[%d][%d][%d][%d]",fRunList[r],i,k,j),10,cenbinsforphihist);
    //        fFlowQCIntRbRPro[r][i][k][j]->Sumw2();
    //        fFlowQCVtxList[r]->Add(fFlowQCIntRbRPro[r][i][k][j]);
    //      }
    //    }
    //  }
   }
  }
  // for(Int_t i=0; i<fkFlowQCRbRnHar; i++) {
  //   for(Int_t k=0; k<fkFlowQCRbRnVar2; k++) {
  //     for(Int_t j=0; j<fkFlowQCRbRnHist2; j++) {
  //       fFlowQCIntRbRProTotal[i][k][j] = new TProfile(Form("fFlowQCIntRbRProTotal[%d][%d][%d]",i,k,j),Form("fFlowQCIntRbRProTotal[%d][%d][%d]",i,k,j),100,0.,100.);
  //       fFlowQCIntRbRProTotal[i][k][j]->Sumw2();
  //       fCRCQVecList->Add(fFlowQCIntRbRProTotal[i][k][j]);
  //     }
  //   }
  // }
  Double_t etabinsforcum[17] = {-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0.,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8};
   for(Int_t i=0; i<fkFlowQCRbRnHar; i++) {
     for(Int_t k=0; k<fkFlowQCRbRnVar; k++) {
       for(Int_t j=0; j<fkFlowQCRbRnHist; j++) {
         fFlowQCIntProEta[i][k][j] = new TProfile2D(Form("fFlowQCIntProEta[%d][%d][%d]",i,k,j),Form("fFlowQCIntProEta[%d][%d][%d]",i,k,j),10,cenbinsforphihist,16,etabinsforcum);
         fFlowQCIntProEta[i][k][j]->Sumw2();
         fCRCQVecList->Add(fFlowQCIntProEta[i][k][j]);
       }
     }
   }

  if(fUseCRCRecenter) {
    if(!fCRCQVecWeightsList) {
      cout << " WARNING: no weights provided for TPC-Qn recentering !!! " << endl;
      return;
    }
    for (Int_t c=0; c<2; c++) {
      for (Int_t et=0; et<4; et++) {
        fTPCQVecProTemp[c][et] = (TProfile2D*)(fCRCQVecWeightsList->FindObject(Form("SumPro2TPC[%d][%d]",c,et)));
        if(fTPCQVecProTemp[c][et]) fTempList->Add(fTPCQVecProTemp[c][et]);
        else printf("WARNING: fTPCQVecProTemp[%d][%d] not found !!! \n",c,et);
      }
    }
  }

  //  if (fUseVZERO) {
  //    for(Int_t r=0;r<fCRCnRun;r++) {
  //      for(Int_t i=0;i<2;i++) {
  //        fCRCVZQVecA[r][i] = new TProfile(Form("fCRCVZQVecA[%d][%d]",fRunList[r],i),
  //                                         Form("fCRCVZQVecA[%d][%d]",fRunList[r],i),100,0.,100.,"s");
  //        fCRCVZQVecA[r][i]->Sumw2();
  //        fCRCQVecListRun[r]->Add(fCRCVZQVecA[r][i]);
  //        fCRCVZQVecC[r][i] = new TProfile(Form("fCRCVZQVecC[%d][%d]",fRunList[r],i),
  //                                         Form("fCRCVZQVecC[%d][%d]",fRunList[r],i),100,0.,100.,"s");
  //        fCRCVZQVecC[r][i]->Sumw2();
  //        fCRCQVecListRun[r]->Add(fCRCVZQVecC[r][i]);
  //      }
  //    }
  //  } // end of if (fUseVZERO)

  if (fUseZDC && fRecenterZDC) {
//    fCRCZDCQVecResvsEAsym = new TProfile2D("fCRCZDCQVecResvsEAsym","",100,0.,100.,100,-pow(1.E5,0.395),pow(1.E5,0.395));
//    fCRCZDCQVecResvsEAsym->Sumw2();
//    fCRCQVecList->Add(fCRCZDCQVecResvsEAsym);
//
//    fCRCZDCQVecResvsESum = new TProfile2D("fCRCZDCQVecResvsESum","",100,0.,100.,100,0.,1.5*pow(1867210,0.395));
//    fCRCZDCQVecResvsESum->Sumw2();
//    fCRCQVecList->Add(fCRCZDCQVecResvsESum);
//
//    fCRCZDCQVecResvsETot = new TProfile2D("fCRCZDCQVecResvsETot","",100,0.,100.,100,0.,100.);
//    fCRCZDCQVecResvsETot->Sumw2();
//    fCRCQVecList->Add(fCRCZDCQVecResvsETot);

    for(Int_t r=0;r<fCRCnRun;r++) {

      for(Int_t i=0;i<2;i++) {
        fCRCZDCQVecA[r][i] = new TProfile(Form("fCRCZDCQVecA[%d][%d]",fRunList[r],i),
                                          Form("fCRCZDCQVecA[%d][%d]",fRunList[r],i),100,0.,100.,"s");
        fCRCZDCQVecA[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecA[r][i]);
        fCRCZDCQVecC[r][i] = new TProfile(Form("fCRCZDCQVecC[%d][%d]",fRunList[r],i),
                                          Form("fCRCZDCQVecC[%d][%d]",fRunList[r],i),100,0.,100.,"s");
        fCRCZDCQVecC[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecC[r][i]);

        fCRCZDCQVecACorr[r][i] = new TProfile(Form("fCRCZDCQVecACorr[%d][%d]",fRunList[r],i),
                                              Form("fCRCZDCQVecACorr[%d][%d]",fRunList[r],i),100,0.,100.,"s");
        fCRCZDCQVecACorr[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecACorr[r][i]);
        fCRCZDCQVecCCorr[r][i] = new TProfile(Form("fCRCZDCQVecCCorr[%d][%d]",fRunList[r],i),
                                              Form("fCRCZDCQVecCCorr[%d][%d]",fRunList[r],i),100,0.,100.,"s");
        fCRCZDCQVecCCorr[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecCCorr[r][i]);
      }
//      for(Int_t i=0;i<4;i++) {
//        fCRCZDCQVecEP[r][i] = new TH2D(Form("fCRCZDCQVecEP[%d][%d]",fRunList[r],i),
//                                       Form("fCRCZDCQVecEP[%d][%d]",fRunList[r],i),20,0.,100.,100,-TMath::Pi(),TMath::Pi());
//        fCRCZDCQVecEP[r][i]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCZDCQVecEP[r][i]);
//      }
      for(Int_t i=0;i<4;i++) {
        fCRCZDCQVecRes[r][i] = new TProfile(Form("fCRCZDCQVecRes[%d][%d]",fRunList[r],i),
                                            Form("fCRCZDCQVecRes[%d][%d]",fRunList[r],i),100,0.,100.,"s");
        fCRCZDCQVecRes[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecRes[r][i]);
      }
      for(Int_t i=0;i<7;i++) {
        fCRCZDCQVecTest[r][i] = new TProfile(Form("fCRCZDCQVecTest[%d][%d]",fRunList[r],i),
                                             Form("fCRCZDCQVecTest[%d][%d]",fRunList[r],i),5,-0.8,0.8);
        fCRCZDCQVecTest[r][i]->Sumw2();
        fCRCQVecListRun[r]->Add(fCRCZDCQVecTest[r][i]);
      }
//      for(Int_t i=0;i<fCRCQVecnCov;i++) {
//        Double_t xmin=0.,xmax=0.;
//        if(fDataSet==k2010) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = -0.032; xmax = 0.016;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = 0.146; xmax = 0.21;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin=-10.; xmax=10.;}
//        }if(fDataSet==k2011) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = 0.045; xmax = 0.08;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = 0.258; xmax = 0.292;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin=-10.; xmax=10.;}
//        }if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = -8.5e-3; xmax = 8.5e-3;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = -7.8e-3; xmax = 7.8e-3;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin = -10.; xmax = 10.;}
//        }
//        Double_t vtxbins[11] = {0.};
//        for (Int_t v=0; v<11; v++) {
//          vtxbins[v]=xmin + v*(xmax-xmin)/10.;
//        }
//        Double_t cenbins[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
//        fCRCZDCQVecCov[r][i] = new TProfile2D(Form("fCRCZDCQVecCov[%d][%d]",fRunList[r],i),
//                                              Form("fCRCZDCQVecCov[%d][%d]",fRunList[r],i),10,cenbins,10,vtxbins,"s");
//        fCRCZDCQVecCov[r][i]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCZDCQVecCov[r][i]);
//      }

      // Double_t fracrunbins[51] = {0.};
      // for (Int_t v=0; v<51; v++) {
      //   fracrunbins[v] = v*0.02;
      // }
//      for(Int_t i=0;i<3;i++) {
//        Double_t xmin=0.,xmax=0.;
//        if(fDataSet==k2010) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = -0.032; xmax = 0.016;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = 0.146; xmax = 0.21;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin=-10.; xmax=10.;}
//        }if(fDataSet==k2011) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = 0.045; xmax = 0.08;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = 0.258; xmax = 0.292;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin=-10.; xmax=10.;}
//        }if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
//          if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {xmin = -8.5e-3; xmax = 8.5e-3;}
//          if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {xmin = -7.8e-3; xmax = 7.8e-3;}
//          if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {xmin = -10.; xmax = 10.;}
//        }
//        Double_t vtxbins[11] = {0.};
//        for (Int_t v=0; v<11; v++) {
//          vtxbins[v]=xmin + v*(xmax-xmin)/10.;
//        }
//        for(Int_t j=0;j<4;j++) {
//          fCRCTPCQVecCenVtxTime[r][i][j] = new TProfile2D(Form("fCRCTPCQVecCenVtxTime[%d][%d][%d]",fRunList[r],i,j),
//                                                          Form("fCRCTPCQVecCenVtxTime[%d][%d][%d]",fRunList[r],i,j),50,fracrunbins,10,vtxbins);
//          fCRCTPCQVecCenVtxTime[r][i][j]->Sumw2();
//          fCRCQVecListRun[r]->Add(fCRCTPCQVecCenVtxTime[r][i][j]);
//          fCRCZDCQVecCenVtxTime[r][i][j] = new TProfile2D(Form("fCRCZDCQVecCenVtxTime[%d][%d][%d]",fRunList[r],i,j),
//                                                          Form("fCRCZDCQVecCenVtxTime[%d][%d][%d]",fRunList[r],i,j),50,fracrunbins,10,vtxbins);
//          fCRCZDCQVecCenVtxTime[r][i][j]->Sumw2();
//          fCRCQVecListRun[r]->Add(fCRCZDCQVecCenVtxTime[r][i][j]);
//        }
//      }

      // Double_t finecenbins[91] = {0.};
      // for (Int_t v=0; v<91; v++) {
      //   finecenbins[v] = v*1.;
      // }
      // Double_t cenbins[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
//      Double_t RefMulbins[101] = {0.};
//      for (Int_t i=0; i<101; i++) {
//        RefMulbins[i] = i*30.;
//      }
      // Double_t RefMulbins[101] = {0.};
      // for (Int_t i=0; i<101; i++) {
      //   RefMulbins[i] = -600 + i*12.;
      // }
      // Double_t ZDCEbins[101] = {0.};
      // for (Int_t i=0; i<101; i++) {
      //   ZDCEbins[i] = 100 + i*5.;
      // }
      // Double_t ZDCEbinsRec[21] = {0.};
      // for (Int_t i=0; i<21; i++) {
      //   ZDCEbinsRec[i] = -300. + i*30.;
      // }

      for (Int_t k=0; k<4; k++) {
//        fCRCZDCQVecCenEComTot[r][k] = new TProfile2D(Form("fCRCZDCQVecCenEComTot[%d][%d]",fRunList[r],k),Form("fCRCZDCQVecCenEComTot[%d][%d]",fRunList[r],k),90,finecenbins,100,ZDCEbins);
//        fCRCZDCQVecCenEComTot[r][k]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCZDCQVecCenEComTot[r][k]);
//
//        fCRCTPCQVecCenEComTot[r][k] = new TProfile2D(Form("fCRCTPCQVecCenEComTot[%d][%d]",fRunList[r],k),Form("fCRCTPCQVecCenEComTot[%d][%d]",fRunList[r],k),90,finecenbins,100,ZDCEbins);
//        fCRCTPCQVecCenEComTot[r][k]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCTPCQVecCenEComTot[r][k]);

//        fCRCZDCQVecCenRefMulTot[r][k] = new TProfile2D(Form("fCRCZDCQVecCenRefMulTot[%d][%d]",fRunList[r],k),Form("fCRCZDCQVecCenRefMulTot[%d][%d]",fRunList[r],k),10,cenbins,100,RefMulbins);
//        fCRCZDCQVecCenRefMulTot[r][k]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCZDCQVecCenRefMulTot[r][k]);
//
//        fCRCTPCQVecCenRefMulTot[r][k] = new TProfile2D(Form("fCRCTPCQVecCenRefMulTot[%d][%d]",fRunList[r],k),Form("fCRCTPCQVecCenRefMulTot[%d][%d]",fRunList[r],k),10,cenbins,100,RefMulbins);
//        fCRCTPCQVecCenRefMulTot[r][k]->Sumw2();
//        fCRCQVecListRun[r]->Add(fCRCTPCQVecCenRefMulTot[r][k]);
      }

//      fMulvsCenRbR[r] = new TH2D(Form("fMulvsCenRbR[%d]",fRunList[r]),Form("fMulvsCenRbR[%d]",fRunList[r]),10,cenbins,100,RefMulbins);
//      fCRCQVecListRun[r]->Add(fMulvsCenRbR[r]);

      for(Int_t c=0;c<fkCRCnCQVecVtxPos;c++) {
        // Double_t xmin=0.,xmax=0.,ymin=0.,ymax=0.,zmin=0.,zmax=0.;
        // if(fDataSet==k2010) {
        //   xmin=-0.032;
        //   xmax=0.016;
        //   ymin=0.146;
        //   ymax=0.21;
        //   zmin=-10.;
        //   zmax=10.;
        // }
        // if(fDataSet==k2011) {
        //   xmin=0.045;
        //   xmax=0.08;
        //   ymin=0.258;
        //   ymax=0.292;
        //   zmin=-10.;
        //   zmax=10.;
        // }
        // if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
        //   xmin = -8.5e-3;
        //   xmax = 8.5e-3;
        //   ymin = -7.8e-3;
        //   ymax = 7.8e-3;
        //   zmin = -10.;
        //   zmax = 10.;
        // }
        if(r==0) {
//          for (Int_t cb=0; cb<fCRCnCen; cb++) {
//            fCRCZDCQVecVtxPosCen[cb][c] = new TProfile3D(Form("fCRCZDCQVecVtxPosCen[%d][%d]",cb,c),Form("fCRCZDCQVecVtxPosCen[%d][%d]",cb,c),10,xmin,xmax,10,ymin,ymax,10,zmin,zmax,"s");
//            fCRCZDCQVecVtxPosCen[cb][c]->Sumw2();
//            fCRCQVecList->Add(fCRCZDCQVecVtxPosCen[cb][c]);
//          }

          if(fUseZDC && fRecenterZDC && fStoreZDCQVecVtxPos) {

//            for(Int_t i=0;i<3;i++) {
//              Double_t vmin=0.,vmax=0.;
//              if(fDataSet==k2010) {
//                if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {vmin = -0.032; vmax = 0.016;}
//                if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {vmin = 0.146; vmax = 0.21;}
//                if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {vmin=-10.; vmax=10.;}
//              }if(fDataSet==k2011) {
//                if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {vmin = 0.045; vmax = 0.08;}
//                if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {vmin = 0.258; vmax = 0.292;}
//                if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {vmin=-10.; vmax=10.;}
//              }if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
//                if(i==0 || i==3 || i==6 || i==9 || i==12 || i==15) {vmin = -8.5e-3; vmax = 8.5e-3;}
//                if(i==1 || i==4 || i==7 || i==10 || i==13 || i==16) {vmin = -7.8e-3; vmax = 7.8e-3;}
//                if(i==2 || i==5 || i==8 || i==11 || i==14 || i==17) {vmin = -10.; vmax = 10.;}
//              }
//              Double_t vtxbins[11] = {0.};
//              for (Int_t v=0; v<11; v++) {
//                vtxbins[v]=vmin + v*(vmax-vmin)/10.;
//              }
//              fCRCZDCQVecVtxCenEZDC[i][c] = new TProfile3D(Form("fCRCZDCQVecVtxCenEZDC[%d][%d]",i,c),
//                                                           Form("fCRCZDCQVecVtxCenEZDC[%d][%d]",i,c),10,cenbins,20,ZDCEbinsRec,10,vtxbins);
//              fCRCZDCQVecVtxCenEZDC[i][c]->Sumw2();
//              fCRCQVecList->Add(fCRCZDCQVecVtxCenEZDC[i][c]);
//            }
//            for (Int_t i=0; i<fCRCnCen; i++) {
//              for (Int_t k=0; k<fknEZDCBins; k++) {
//                fCRCZDCQVecVtxCenEZDC3D[i][k][c] = new TProfile3D(Form("fCRCZDCQVecVtxCenEZDC3D[%d][%d][%d]",i,k,c),
//                                                                  Form("fCRCZDCQVecVtxCenEZDC3D[%d][%d][%d]",i,k,c),10,xmin,xmax,10,ymin,ymax,10,zmin,zmax);
//                fCRCZDCQVecVtxCenEZDC3D[i][k][c]->Sumw2();
//                fCRCQVecList->Add(fCRCZDCQVecVtxCenEZDC3D[i][k][c]);
//              }
//            }
          }
        }
      }
    } // end of for(Int_t r=0;r<fCRCnRun;r++)

    if(fUseZDC && fRecenterZDC && fStoreZDCQVecVtxPos) {
      for(Int_t i=0;i<2;i++) {
        for(Int_t c=0;c<fCRCnCen;c++) {
          for (Int_t j=0;j<2;j++) {
            fCRCZDCQVecDis[i][c][j] = new TH2D(Form("fCRCZDCQVecDis[%d][%d][%d]",i,c,j),Form("fCRCZDCQVecDis[%d][%d][%d]",i,c,j),200,-2.,2.,200,-2.,2.);
            fCRCZDCQVecDis[i][c][j]->Sumw2();
            fCRCQVecList->Add(fCRCZDCQVecDis[i][c][j]);
          }
        }
      }
      Double_t cenbins[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
      Double_t phibinsforZDCEP[101] = {0.};
      for (Int_t phib=0; phib<101; phib++) {
        phibinsforZDCEP[phib] = phib*TMath::TwoPi()/100.;
      }
      for(Int_t k=0; k<2; k++) {
        fZDCEPHist[k] = new TH2D(Form("fZDCEPHist[%d]",k),Form("fZDCEPHist[%d]",k),10,cenbins,100,phibinsforZDCEP);
        fCRCQVecList->Add(fZDCEPHist[k]);
      }
    }

//    Double_t DummyEZDCBins[10][11] = {{-3.000000e+02, -4.008000e+01, -2.658000e+01, -1.686000e+01, -8.520000e+00, -7.200000e-01, 7.080000e+00, 1.542000e+01, 2.520000e+01, 3.888000e+01, 3.000000e+02},{-3.000000e+02, -3.690000e+01, -2.436000e+01, -1.530000e+01, -7.560000e+00, -3.000000e-01, 6.960000e+00, 1.476000e+01, 2.388000e+01, 3.666000e+01, 3.000000e+02},{-3.000000e+02, -3.522000e+01, -2.316000e+01, -1.446000e+01, -7.020000e+00, -6.000000e-02, 6.900000e+00, 1.434000e+01, 2.310000e+01, 3.534000e+01, 3.000000e+02},{-3.000000e+02, -3.528000e+01, -2.322000e+01, -1.452000e+01, -7.080000e+00, -1.200000e-01, 6.840000e+00, 1.434000e+01, 2.310000e+01, 3.528000e+01, 3.000000e+02},{-3.000000e+02, -3.666000e+01, -2.412000e+01, -1.506000e+01, -7.320000e+00, -6.000000e-02, 7.200000e+00, 1.500000e+01, 2.412000e+01, 3.684000e+01, 3.000000e+02},{-3.000000e+02, -3.936000e+01, -2.580000e+01, -1.602000e+01, -7.680000e+00, 1.200000e-01, 7.920000e+00, 1.632000e+01, 2.616000e+01, 3.990000e+01, 3.000000e+02},{-3.000000e+02, -4.416000e+01, -2.880000e+01, -1.776000e+01, -8.280000e+00, 5.400000e-01, 9.420000e+00, 1.890000e+01, 3.000000e+01, 4.554000e+01, 3.000000e+02},{-3.000000e+02, -5.262000e+01, -3.384000e+01, -2.028000e+01, -8.700000e+00, 2.100000e+00, 1.296000e+01, 2.454000e+01, 3.816000e+01, 5.712000e+01, 3.000000e+02},{-3.000000e+02, -6.588000e+01, -4.122000e+01, -2.340000e+01, -8.160000e+00, 6.060000e+00, 2.028000e+01, 3.552000e+01, 5.340000e+01, 7.830000e+01, 3.000000e+02},{-3.000000e+02, -8.844000e+01, -5.556000e+01, -3.186000e+01, -1.158000e+01, 7.380000e+00, 2.634000e+01, 4.662000e+01, 7.038000e+01, 1.034400e+02, 3.000000e+02}};
//    for (Int_t i=0; i<fCRCnCen; i++) {
//      fCRCZDCQVecDummyEZDCBins[i] = new TH1D(Form("fCRCZDCQVecDummyEZDCBins[%d]",i),Form("fCRCZDCQVecDummyEZDCBins[%d]",i),10,DummyEZDCBins[i]);
//      fCRCQVecList->Add(fCRCZDCQVecDummyEZDCBins[i]);
//    }

//    Double_t xmin=0.,xmax=0.,ymin=0.,ymax=0.,zmin=0.,zmax=0.;
//    if(fDataSet==k2015 || fDataSet==k2015v6 || fDataSet==k2015pidfix) {
//      xmin = -8.5e-3;
//      xmax = 8.5e-3;
//      ymin = -7.8e-3;
//      ymax = 7.8e-3;
//      zmin = -10.;
//      zmax = 10.;
//    }
//    for(Int_t c=0;c<fkCRCnCQVecEcomPos;c++) {
//      if(c<4) {
//        fCRCZDCQVecEComTot[c] = new TProfile3D(Form("fCRCZDCQVecEComTot[%d]",c),Form("fCRCZDCQVecEComTot[%d]",c),20,0.,100.,20,0.,100.,12,xmin,xmax,"s");
//      } else if(c>=4 && c<8) {
//        fCRCZDCQVecEComTot[c] = new TProfile3D(Form("fCRCZDCQVecEComTot[%d]",c),Form("fCRCZDCQVecEComTot[%d]",c),20,0.,100.,20,0.,100.,12,ymin,ymax,"s");
//      } else if(c>=8) {
//        fCRCZDCQVecEComTot[c] = new TProfile3D(Form("fCRCZDCQVecEComTot[%d]",c),Form("fCRCZDCQVecEComTot[%d]",c),20,0.,100.,20,0.,100.,12,zmin,zmax,"s");
//      }
//      fCRCZDCQVecEComTot[c]->Sumw2();
    //      fCRCQVecList->Add(fCRCZDCQVecEComTot[c]);
    //    }
    for(Int_t c=0;c<4;c++) {
      fCRCZDCQVecCorSteps[c] = new TProfile2D(Form("fCRCZDCQVecCorSteps[%d]",c),Form("fCRCZDCQVecCorSteps[%d]",c),fkNsteps,0.,1.*fkNsteps,20,0.,100.);
      fCRCZDCQVecCorSteps[c]->Sumw2();
      fCRCQVecList->Add(fCRCZDCQVecCorSteps[c]);
    }

  } // end of if (fUseZDC)

  fCRCQVecListTPC = new TList();
  fCRCQVecListTPC->SetName("various");
  fCRCQVecListTPC->SetOwner(kTRUE);
  fCRCQVecList->Add(fCRCQVecListTPC);

  fhAvRefMulRbR = new TProfile2D("fhAvRefMulRbR","AvRefMulRbR;run;centrality(%)",fCRCnRun,0.,1.*fCRCnRun,90,0.,90.);
  for (Int_t r=0; r<fCRCnRun; r++) fhAvRefMulRbR->GetXaxis()->SetBinLabel(r+1,Form("%d",fRunList[r]));
  fCRCQVecListTPC->Add(fhAvRefMulRbR);
  fhAvQMCRbR = new TProfile2D("fhAvQMCRbR","fhAvQMCRbR;run;centrality(%)",fCRCnRun,0.,1.*fCRCnRun,90,0.,90.);
  for (Int_t r=0; r<fCRCnRun; r++) fhAvQMCRbR->GetXaxis()->SetBinLabel(r+1,Form("%d",fRunList[r]));
  fCRCQVecListTPC->Add(fhAvQMCRbR);
  fhAvQMARbR = new TProfile2D("fhAvQMARbR","fhAvQMARbR;run;centrality(%)",fCRCnRun,0.,1.*fCRCnRun,90,0.,90.);
  for (Int_t r=0; r<fCRCnRun; r++) fhAvQMARbR->GetXaxis()->SetBinLabel(r+1,Form("%d",fRunList[r]));
  fCRCQVecListTPC->Add(fhAvQMARbR);

  fhAvAbsOrbit = new TProfile("fhAvAbsOrbit","fhAvAbsOrbit;run",fCRCnRun,0.,1.*fCRCnRun,"s");
  for (Int_t r=0; r<fCRCnRun; r++) fhAvAbsOrbit->GetXaxis()->SetBinLabel(r+1,Form("%d",fRunList[r]));
  fCRCQVecListTPC->Add(fhAvAbsOrbit);

//  for (Int_t c=0; c<2; c++) {
//    for (Int_t k=0; k<4; k++) {
//      fCRCTPCQVecCenEtaRefMulTot[c][k] = new TProfile3D(Form("fCRCTPCQVecCenEtaRefMulTot[%d][%d]",c,k),Form("fCRCTPCQVecCenEtaRefMulTot[%d][%d]",c,k),90,0.,90.,fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax,100,0.,3000.);
//      fCRCQVecListTPC->Add(fCRCTPCQVecCenEtaRefMulTot[c][k]);
//    }
//  }

  // Double_t cenbins[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};

  fEvPlZDCCflat=0.;
  fEvPlDPsiC=0.;
  fEvPlZDCAflat=0.;
  fEvPlDPsiA=0.;

  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhi) {
    if(fWeightsList->FindObject("fCRCQVecPhiHist")) {
      fPhiEtaWeights = (TH3D*)(fWeightsList->FindObject("fCRCQVecPhiHist"));
    } else {
      AliWarning("WARNING: POIExtraWeights (kEtaPhi) not found ! \n");
    }
  }
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiCh) {
    for (Int_t i=0; i<2; i++) {
      if(fWeightsList->FindObject(Form("fCRCQVecPhiHistCh[%d]",i))) {
        fPhiEtaWeightsCh[i] = (TH3D*)(fWeightsList->FindObject(Form("fCRCQVecPhiHistCh[%d]",i)));
      } else {
        AliWarning("WARNING: POIExtraWeights (kEtaPhiCh) not found ! \n");
      }
    }
  }
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiVtx) {
    for (Int_t cb=0; cb<fCRCnCen; cb++) {
      if(fWeightsList->FindObject(Form("fCRCQVecPhiHistVtx[%d]",cb))) {
        fPhiEtaWeightsVtx[cb] = (TH3D*)(fWeightsList->FindObject(Form("fCRCQVecPhiHistVtx[%d]",cb)));
      } else {
        AliWarning("WARNING: POIExtraWeights (kEtaPhiVtx) not found ! \n");
      }
    }
  }
  if(fPOIExtraWeights==AliFlowAnalysisCRC::kEtaPhiChPt) {
    for (Int_t i=0; i<2; i++) {
      for (Int_t j=0; j<3; j++) {
        if(fWeightsList->FindObject(Form("fCRCQVecPhiHistChPt[%d][%d]",i,j))) {
          fPhiEtaWeightsChPt[i][j] = (TH3D*)(fWeightsList->FindObject(Form("fCRCQVecPhiHistChPt[%d][%d]",i,j)));
        } else {
          AliWarning("WARNING: POIExtraWeights (kEtaPhiChPt) not found ! \n");
        }
      }
    }
  }

//  for(Int_t k=0; k<fkNHistQVecCorrv1eta; k++) {
//    fTPCEtaHist[k] = new TProfile2D();
//    fTempList->Add(fTPCEtaHist[k]);
//  }

} // end of AliFlowAnalysisCRC::BookEverythingForQVec()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCME()
{
  // EbE quantities
  for(Int_t c=0;c<4;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      fCMEQRe[c][h] = new TH1D(Form("fCMEQRe[%d][%d]",c,h),Form("fCMEQRe[%d][%d]",c,h),fCMEnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCMEQRe[c][h]);
      fCMEQIm[c][h] = new TH1D(Form("fCMEQIm[%d][%d]",c,h),Form("fCMEQIm[%d][%d]",c,h),fCMEnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCMEQIm[c][h]);
      fCMEMult[c][h] = new TH1D(Form("fCMEMult[%d][%d]",c,h),Form("fCMEMult[%d][%d]",c,h),fCMEnEtaBin,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fCMEMult[c][h]);
    }
  }

  if(!fCalculateCME){return;}
  if(!fUseZDC){return;}

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t eg=0; eg<fCMEnEtaBin; eg++) {
      // Final Histo:
      fCMEZDCCorHist[eg][h] = new TH1D(Form("fCMEZDCCorHist[%d][%d]",eg,h),Form("fCMEZDCCorHist[%d][%d]",eg,h),fCMEZDCnCR,0.,1.*fCMEZDCnCR);
      fCMEZDCCorHist[eg][h]->Sumw2();
      fCMEZDCList->Add(fCMEZDCCorHist[eg][h]);
      // Covariances:
      fCMEZDCCovHist[eg][h] = new TH2D(Form("fCMEZDCCovHist[%d][%d]",eg,h),Form("fCMEZDCCovHist[%d][%d]",eg,h),fCMEZDCnCR,0.,1.*fCMEZDCnCR,fCMEZDCnCR,0.,1.*fCMEZDCnCR);
      fCMEZDCCovHist[eg][h]->Sumw2();
      fCMEZDCList->Add(fCMEZDCCovHist[eg][h]);
      // Distributions:
      fCMEZDCDistHist[eg][h][0] = new TH1D(Form("fCMEZDCDistHist[%d][%d][0]",eg,h),Form("fCMEZDCDistHist[%d][%d][0]",eg,h),1E4,0.,TMath::Pi()/2.);
      fCMEZDCDistHist[eg][h][0]->Sumw2();
      fCMEZDCList->Add(fCMEZDCDistHist[eg][h][0]);
      fCMEZDCDistHist[eg][h][1] = new TH1D(Form("fCMEZDCDistHist[%d][%d][1]",eg,h),Form("fCMEZDCDistHist[%d][%d][1]",eg,h),1E4,0.,TMath::Pi()/2.);
      fCMEZDCDistHist[eg][h][1]->Sumw2();
      fCMEZDCList->Add(fCMEZDCDistHist[eg][h][1]);
      fCMEZDCDistHist[eg][h][2] = new TH1D(Form("fCMEZDCDistHist[%d][%d][2]",eg,h),Form("fCMEZDCDistHist[%d][%d][2]",eg,h),1E4,0.,TMath::Pi()/2.);
      fCMEZDCDistHist[eg][h][2]->Sumw2();
      fCMEZDCList->Add(fCMEZDCDistHist[eg][h][2]);
      fCMEZDCDistHist[eg][h][3] = new TH1D(Form("fCMEZDCDistHist[%d][%d][3]",eg,h),Form("fCMEZDCDistHist[%d][%d][3]",eg,h),1E4,0.,TMath::Pi()/2.);
      fCMEZDCDistHist[eg][h][3]->Sumw2();
      fCMEZDCList->Add(fCMEZDCDistHist[eg][h][3]);
    } // end of for(Int_t eg=0; eg<fCMEnEtaBin; eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t h=0;h<fCRCnCen;h++) {
    for(Int_t eg=0;eg<fCMEnEtaBin;eg++) {
      fCMEZDCCorPro[eg][h] = new TProfile(Form("fCMEZDCCorPro[%d][%d]",eg,h),Form("fCMEZDCCorPro[%d][%d]",eg,h),fCMEZDCnCR,0.,1.*fCMEZDCnCR,"s");
      fCMEZDCCorPro[eg][h]->Sumw2();
      fCMEZDCList->Add(fCMEZDCCorPro[eg][h]);
      fCMEZDCCovPro[eg][h] = new TProfile(Form("fCMEZDCCovPro[%d][%d]",eg,h),Form("fCMEZDCCovPro[%d][%d]",eg,h),fCMEZDCnCR*fCMEZDCnCR,0.,fCMEZDCnCR*fCMEZDCnCR,"s");
      fCMEZDCCovPro[eg][h]->Sumw2();
      fCMEZDCList->Add(fCMEZDCCovPro[eg][h]);
      fCMEZDCNUAPro[eg][h] = new TProfile(Form("fCMEZDCNUAPro[%d][%d]",eg,h),Form("fCMEZDCNUAPro[%d][%d]",eg,h),fCMEZDCnCR,0.,1.*fCMEZDCnCR,"s");
      fCMEZDCNUAPro[eg][h]->Sumw2();
      fCMEZDCList->Add(fCMEZDCNUAPro[eg][h]);
    } // end of for(Int_t eg=0;eg<fCMEnEtaBin;eg++)
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    for (Int_t h=0; h<fCMETPCnHist; h++) {
      // Profiles
      fCMETPCCorPro[k][h] = new TProfile(Form("fCMETPCCorPro[%d][%d]",k,h),Form("fCMETPCCorPro[%d][%d]",k,h),fFlowQCCenBin,0.,100.,"s");
      fCMETPCCorPro[k][h]->Sumw2();
      fCMETPCList->Add(fCMETPCCorPro[k][h]);
      // Correlations:
      // Final Histo:
      fCMETPCCorHist[k][h] = new TH1D(Form("fCMETPCCorHist[%d][%d]",k,h),Form("fCMETPCCorHist[%d][%d]",k,h),fFlowQCCenBin,0.,100.);
      fCMETPCCorHist[k][h]->Sumw2();
      fCMETPCList->Add(fCMETPCCorHist[k][h]);
      fCMETPCFinalHist[k][h] = new TH1D(Form("fCMETPCFinalHist[%d][%d]",k,h),Form("fCMETPCFinalHist[%d][%d]",k,h),fFlowQCCenBin,0.,100.);
      fCMETPCFinalHist[k][h]->Sumw2();
      fCMETPCList->Add(fCMETPCFinalHist[k][h]);
    }
  }

  for (Int_t k=0; k<fCMETPCnSC; k++) {
    for (Int_t h=0; h<2; h++) {
      fCMETPCSCPro[k][h] = new TProfile(Form("fCMETPCSCPro[%d][%d]",k,h),Form("fCMETPCSCPro[%d][%d]",k,h),fFlowQCCenBin,0.,100.,"s");
      fCMETPCSCPro[k][h]->Sumw2();
      fCMETPCList->Add(fCMETPCSCPro[k][h]);
      fCMETPCSCHist[k][h] = new TH1D(Form("fCMETPCSCHist[%d][%d]",k,h),Form("fCMETPCSCHist[%d][%d]",k,h),fFlowQCCenBin,0.,100.);
      fCMETPCSCHist[k][h]->Sumw2();
      fCMETPCList->Add(fCMETPCSCHist[k][h]);
    }
  }

  for (Int_t i=0; i<fCMETPCnHist2D; i++) {
    fCMETPCCorPro2D[i] = new TProfile2D(Form("fCMETPCCorPro2D[%d]",i),Form("fCMETPCCorPro2D[%d]",i),250,0.,25000.,200,0.,200.);
    fCMETPCCorPro2D[i]->Sumw2();
    fCMETPCList->Add(fCMETPCCorPro2D[i]);
  }

} // end of AliFlowAnalysisCRC::BookEverythingForCME()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForFlowSPZDC()
{
  if(!fCalculateFlowZDC){return;}
  if(!fUseZDC){return;}

//  for(Int_t j=0; j<fkNHistv1eta; j++) {
//    fFlowSPZDCv1etaProPhi[j] = new TProfile2D(Form("fFlowSPZDCv1etaProPhi[%d]",j),Form("fFlowSPZDCv1etaProPhi[%d]",j),5,-0.8,0.8,50,0.,TMath::TwoPi());
//    fFlowSPZDCv1etaProPhi[j]->Sumw2();
//    fFlowSPZDCList->Add(fFlowSPZDCv1etaProPhi[j]);
//    fFlowSPZDCv1etaProITS[j] = new TProfile2D(Form("fFlowSPZDCv1etaProITS[%d]",j),Form("fFlowSPZDCv1etaProITS[%d]",j),5,-0.8,0.8,fkNITStypes,0.,1.*fkNITStypes);
//    fFlowSPZDCv1etaProITS[j]->Sumw2();
//    fFlowSPZDCList->Add(fFlowSPZDCv1etaProITS[j]);
//  }
//  for (Int_t k=0; k<2; k++) {
//    for (Int_t i=0; i<fkNITStypes; i++) {
//      fFlowSPZDCv1etaProITSDis[k][i] = new TH2D(Form("fFlowSPZDCv1etaProITSDis[%d][%d]",k,i),Form("fFlowSPZDCv1etaProITSDis[%d][%d]",k,i),10,-0.8,0.8,100,0.,TMath::TwoPi());
//      fFlowSPZDCv1etaProITSDis[k][i]->Sumw2();
//      fFlowSPZDCList->Add(fFlowSPZDCv1etaProITSDis[k][i]);
//    }
//  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarmZDC; i++) {
      for(Int_t j=0; j<fFlowNPro; j++) {
        fFlowSPZDCCorHist[h][i][j] = new TH1D(Form("fFlowSPZDCCorHist[%d][%d][%d]",h,i,j),Form("fFlowSPZDCCorHist[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowSPZDCCorHist[h][i][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCCorHist[h][i][j]);
        fFlowSPZDCFinalPtDifHist[h][i][j] = new TH1D(Form("fFlowSPZDCFinalPtDifHist[%d][%d][%d]",h,i,j),Form("fFlowSPZDCFinalPtDifHist[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowSPZDCFinalPtDifHist[h][i][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCFinalPtDifHist[h][i][j]);
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)
  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      fFlowSPZDCIntHist[i][j] = new TH1D(Form("fFlowSPZDCIntHist[%d][%d]",i,j),Form("fFlowSPZDCIntHist[%d][%d]",i,j),100.,0.,100.);
      fFlowSPZDCIntHist[i][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCIntHist[i][j]);
      fFlowSPZDCIntFinalHist[i][j] = new TH1D(Form("fFlowSPZDCIntFinalHist[%d][%d]",i,j),Form("fFlowSPZDCIntFinalHist[%d][%d]",i,j),100.,0.,100.);
      fFlowSPZDCIntFinalHist[i][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCIntFinalHist[i][j]);
    }
  }
  for(Int_t j=0; j<fkNv1evenCor; j++) {
    Double_t cenbinsforphihist[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
    fFlowSPZDCv1evenCorPro[j] = new TProfile2D(Form("fFlowSPZDCv1evenCorPro[%d]",j),Form("fFlowSPZDCv1evenCorPro[%d]",j),10,cenbinsforphihist,fPtDiffNBins,fCRCPtBins);
    fFlowSPZDCv1evenCorPro[j]->Sumw2();
    fFlowSPZDCList->Add(fFlowSPZDCv1evenCorPro[j]);
  }
  for(Int_t j=0; j<fkNZDCDistPro; j++) {
    Double_t cenbinsforphihist[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.};
    fFlowSPZDCDistPro[j] = new TProfile2D(Form("fFlowSPZDCDistPro[%d]",j),Form("fFlowSPZDCDistPro[%d]",j),10,0.,100.,100,-1.,1.);
    fFlowSPZDCDistPro[j]->Sumw2();
    fFlowSPZDCList->Add(fFlowSPZDCDistPro[j]);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for (Int_t k=0; k<fkNHarv1eta; k++) {
      for(Int_t j=0; j<fkNHistv1eta; j++) {
        fFlowSPZDCv1etaPro[h][k][j] = new TProfile(Form("fFlowSPZDCv1etaPro[%d][%d][%d]",h,k,j),Form("fFlowSPZDCv1etaPro[%d][%d][%d]",h,k,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
        fFlowSPZDCv1etaPro[h][k][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCv1etaPro[h][k][j]);
        fFlowSPZDCv1etaHist[h][k][j] = new TH1D(Form("fFlowSPZDCv1etaHist[%d][%d][%d]",h,k,j),Form("fFlowSPZDCv1etaHist[%d][%d][%d]",h,k,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
        fFlowSPZDCv1etaHist[h][k][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCv1etaHist[h][k][j]);
        fFlowSPZDCv1etaNUAPro[h][k][j] = new TProfile(Form("fFlowSPZDCv1etaNUAPro[%d][%d][%d]",h,k,j),Form("fFlowSPZDCv1etaNUAPro[%d][%d][%d]",h,k,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
        fFlowSPZDCv1etaNUAPro[h][k][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCv1etaNUAPro[h][k][j]);
      }
    }
    for(Int_t j=0; j<fkNHistv1eta; j++) {
      fFlowSPZDCv1etaProImag[h][j] = new TProfile(Form("fFlowSPZDCv1etaProImag[%d][%d]",h,j),Form("fFlowSPZDCv1etaProImag[%d][%d]",h,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
      fFlowSPZDCv1etaProImag[h][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCv1etaProImag[h][j]);
    }
    Double_t etabinsf[] = {-0.8,-0.48,-0.16,0.16,0.48,0.8};
    Double_t ZDCptbins[] = {0.2,0.5,1.,50.};
    for (Int_t k=0; k<fkNHistv1etaPt; k++) {
      fFlowSPZDCv1etaPtPro[h][k] = new TProfile2D(Form("fFlowSPZDCv1etaPtPro[%d][%d]",h,k),Form("fFlowSPZDCv1etaPtPro[%d][%d]",h,k),fkEtaDiffNBins,etabinsf,fZDCPtDiffNBins,ZDCptbins);
      fFlowSPZDCv1etaPtPro[h][k]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCv1etaPtPro[h][k]);
      fFlowSPZDCv1etaPtHist[h][k] = new TH2D(Form("fFlowSPZDCv1etaPtHist[%d][%d]",h,k),Form("fFlowSPZDCv1etaPtHist[%d][%d]",h,k),fkEtaDiffNBins,etabinsf,fZDCPtDiffNBins,ZDCptbins);
      fFlowSPZDCv1etaPtHist[h][k]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCv1etaPtHist[h][k]);
    }
    for(Int_t j=0; j<fkNHistv1etaCov; j++) {
      fFlowSPZDCv1etaCovPro[h][j] = new TProfile(Form("fFlowSPZDCv1etaCovPro[%d][%d]",h,j),Form("fFlowSPZDCv1etaCovPro[%d][%d]",h,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
      fFlowSPZDCv1etaCovPro[h][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCv1etaCovPro[h][j]);
      fFlowSPZDCv1etaCovHist[h][j] = new TH1D(Form("fFlowSPZDCv1etaCovHist[%d][%d]",h,j),Form("fFlowSPZDCv1etaCovHist[%d][%d]",h,j),fkEtaDiffNBins,fCRCEtaMin,fCRCEtaMax);
      fFlowSPZDCv1etaCovHist[h][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCv1etaCovHist[h][j]);
    }
  }

  for(Int_t i=0; i<fFlowNHarmZDC; i++) {
    for(Int_t j=0; j<fFlowNPro; j++) {
      fFlowSPZDCIntPro[i][j] = new TProfile(Form("fFlowSPZDCIntPro[%d][%d]",i,j),Form("fFlowSPZDCIntPro[%d][%d]",i,j),100.,0.,100.,"s");
      fFlowSPZDCIntPro[i][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCIntPro[i][j]);
      for (Int_t h=0; h<fCRCnCen; h++) {
        fFlowSPZDCCorPro[h][i][j] = new TProfile(Form("fFlowSPZDCCorPro[%d][%d][%d]",h,i,j),Form("fFlowSPZDCCorPro[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins,"s");
        fFlowSPZDCCorPro[h][i][j]->Sumw2();
        fFlowSPZDCList->Add(fFlowSPZDCCorPro[h][i][j]);
      }
    }
  }
  for(Int_t j=0; j<fFlowNNUA; j++) {
    fFlowSPZDCIntNUA[j] = new TProfile(Form("fFlowSPZDCIntNUA[%d]",j),Form("fFlowSPZDCIntNUA[%d]",j),100.,0.,100.,"s");
    fFlowSPZDCIntNUA[j]->Sumw2();
    fFlowSPZDCList->Add(fFlowSPZDCIntNUA[j]);
    for (Int_t h=0; h<fCRCnCen; h++) {
      fFlowSPZDCCorNUA[h][j] = new TProfile(Form("fFlowSPZDCCorNUA[%d][%d]",h,j),Form("fFlowSPZDCCorNUA[%d][%d]",h,j),fPtDiffNBins,fCRCPtBins,"s");
      fFlowSPZDCCorNUA[h][j]->Sumw2();
      fFlowSPZDCList->Add(fFlowSPZDCCorNUA[h][j]);
    }
  }

} // end of AliFlowAnalysisCRC::BookEverythingForFlowSPZDC()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForFlowEbE()
{
  // EbE quantities
  for (Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIPtDiffQRe[c][h] = new TH1D(Form("fPOIPtDiffQRe[%d][%d]",c,h),Form("fPOIPtDiffQRe[%d][%d]",c,h),fPtDiffNBins,fCRCPtBins);
      fTempList->Add(fPOIPtDiffQRe[c][h]);
      fPOIPtDiffQIm[c][h] = new TH1D(Form("fPOIPtDiffQIm[%d][%d]",c,h),Form("fPOIPtDiffQIm[%d][%d]",c,h),fPtDiffNBins,fCRCPtBins);
      fTempList->Add(fPOIPtDiffQIm[c][h]);
      fPOIPtDiffMul[c][h] = new TH1D(Form("fPOIPtDiffMul[%d][%d]",c,h),Form("fPOIPtDiffMul[%d][%d]",c,h),fPtDiffNBins,fCRCPtBins);
      fTempList->Add(fPOIPtDiffMul[c][h]);
      for (Int_t k=0; k<2; k++) {
        fPOIPtDiffQReCh[k][c][h] = new TH1D(Form("fPOIPtDiffQRe[%d][%d][%d]",k,c,h),Form("fPOIPtDiffQRe[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffQReCh[k][c][h]);
        fPOIPtDiffQImCh[k][c][h] = new TH1D(Form("fPOIPtDiffQIm[%d][%d][%d]",k,c,h),Form("fPOIPtDiffQIm[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffQImCh[k][c][h]);
        fPOIPtDiffMulCh[k][c][h] = new TH1D(Form("fPOIPtDiffMul[%d][%d][%d]",k,c,h),Form("fPOIPtDiffMul[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffMulCh[k][c][h]);
      }
    }
  }
  for (Int_t k=0; k<2; k++) {
    for (Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        fPOIPtDiffQReEG[k][c][h] = new TH1D(Form("fPOIPtDiffQReEG[%d][%d][%d]",k,c,h),Form("fPOIPtDiffQReEG[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffQReEG[k][c][h]);
        fPOIPtDiffQImEG[k][c][h] = new TH1D(Form("fPOIPtDiffQImEG[%d][%d][%d]",k,c,h),Form("fPOIPtDiffQImEG[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffQImEG[k][c][h]);
        fPOIPtDiffMulEG[k][c][h] = new TH1D(Form("fPOIPtDiffMulEG[%d][%d][%d]",k,c,h),Form("fPOIPtDiffMulEG[%d][%d][%d]",k,c,h),fPtDiffNBins,fCRCPtBins);
        fTempList->Add(fPOIPtDiffMulEG[k][c][h]);
      }
    }
  }
  for (Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIPhiDiffQRe[c][h] = new TH1D(Form("fPOIPhiDiffQRe[%d][%d]",c,h),Form("fPOIPhiDiffQRe[%d][%d]",c,h),100,0.,TMath::TwoPi());
      fTempList->Add(fPOIPhiDiffQRe[c][h]);
      fPOIPhiDiffQIm[c][h] = new TH1D(Form("fPOIPhiDiffQIm[%d][%d]",c,h),Form("fPOIPhiDiffQIm[%d][%d]",c,h),100,0.,TMath::TwoPi());
      fTempList->Add(fPOIPhiDiffQIm[c][h]);
      fPOIPhiDiffMul[c][h] = new TH1D(Form("fPOIPhiDiffMul[%d][%d]",c,h),Form("fPOIPhiDiffMul[%d][%d]",c,h),100,0.,TMath::TwoPi());
      fTempList->Add(fPOIPhiDiffMul[c][h]);
      fPOIPhiEtaDiffQRe[c][h] = new TH2D(Form("fPOIPhiEtaDiffQRe[%d][%d]",c,h),Form("fPOIPhiEtaDiffQRe[%d][%d]",c,h),100,0.,TMath::TwoPi(),16,-0.8,0.8);
      fTempList->Add(fPOIPhiEtaDiffQRe[c][h]);
      fPOIPhiEtaDiffQIm[c][h] = new TH2D(Form("fPOIPhiEtaDiffQIm[%d][%d]",c,h),Form("fPOIPhiEtaDiffQIm[%d][%d]",c,h),100,0.,TMath::TwoPi(),16,-0.8,0.8);
      fTempList->Add(fPOIPhiEtaDiffQIm[c][h]);
      fPOIPhiEtaDiffMul[c][h] = new TH2D(Form("fPOIPhiEtaDiffMul[%d][%d]",c,h),Form("fPOIPhiEtaDiffMul[%d][%d]",c,h),100,0.,TMath::TwoPi(),16,-0.8,0.8);
      fTempList->Add(fPOIPhiEtaDiffMul[c][h]);
    }
  }
  for (Int_t k=0; k<2; k++) {
    for (Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        fPOIPhiDiffQReEG[k][c][h] = new TH1D(Form("fPOIPhiDiffQReEG[%d][%d][%d]",k,c,h),Form("fPOIPhiDiffQReEG[%d][%d][%d]",k,c,h),100,0.,TMath::TwoPi());
        fTempList->Add(fPOIPhiDiffQReEG[k][c][h]);
        fPOIPhiDiffQImEG[k][c][h] = new TH1D(Form("fPOIPhiDiffQImEG[%d][%d][%d]",k,c,h),Form("fPOIPhiDiffQImEG[%d][%d][%d]",k,c,h),100,0.,TMath::TwoPi());
        fTempList->Add(fPOIPhiDiffQImEG[k][c][h]);
        fPOIPhiDiffMulEG[k][c][h] = new TH1D(Form("fPOIPhiDiffMulEG[%d][%d][%d]",k,c,h),Form("fPOIPhiDiffMulEG[%d][%d][%d]",k,c,h),100,0.,TMath::TwoPi());
        fTempList->Add(fPOIPhiDiffMulEG[k][c][h]);
      }
    }
  }
  for (Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fEtaDiffQRe[c][h] = new TH1D(Form("fEtaDiffQRe[%d][%d]",c,h),Form("fEtaDiffQRe[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fEtaDiffQRe[c][h]);
      fEtaDiffQIm[c][h] = new TH1D(Form("fEtaDiffQIm[%d][%d]",c,h),Form("fEtaDiffQIm[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fEtaDiffQIm[c][h]);
      fEtaDiffMul[c][h] = new TH1D(Form("fEtaDiffMul[%d][%d]",c,h),Form("fEtaDiffMul[%d][%d]",c,h),fkEtaDiffMaxNBins,fCRCEtaMin,fCRCEtaMax);
      fTempList->Add(fEtaDiffMul[c][h]);
    }
  }
  Double_t etabinsf[] = {-0.8,-0.64,-0.48,-0.32,-0.16,0.,0.16,0.32,0.48,0.64,0.8};
  Double_t ZDCptbins[] = {0.2,0.5,1.,50.};
  for (Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      fPOIEtaPtQRe[c][h] = new TH2D(Form("fPOIEtaPtQRe[%d][%d]",c,h),Form("fPOIEtaPtQRe[%d][%d]",c,h),fkEtaDiffMaxNBins,etabinsf,fZDCPtDiffNBins,ZDCptbins);
      fTempList->Add(fPOIEtaPtQRe[c][h]);
      fPOIEtaPtQIm[c][h] = new TH2D(Form("fPOIEtaPtQIm[%d][%d]",c,h),Form("fPOIEtaPtQIm[%d][%d]",c,h),fkEtaDiffMaxNBins,etabinsf,fZDCPtDiffNBins,ZDCptbins);
      fTempList->Add(fPOIEtaPtQIm[c][h]);
      fPOIEtaPtMul[c][h] = new TH2D(Form("fPOIEtaPtMul[%d][%d]",c,h),Form("fPOIEtaPtMul[%d][%d]",c,h),fkEtaDiffMaxNBins,etabinsf,fZDCPtDiffNBins,ZDCptbins);
      fTempList->Add(fPOIEtaPtMul[c][h]);
    }
  }
}

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForFlowQC()
{
  if(!fCalculateFlowQC){return;}

  fFlowQCSpectra = new TH2D("fFlowQCSpectra","fFlowQCSpectra",100,0.,100.,fPtDiffNBins,fCRCPtBins);
  fFlowQCSpectra->Sumw2();
  fFlowQCList->Add(fFlowQCSpectra);
  for (Int_t k=0; k<2; k++) {
    fFlowQCSpectraCharge[k] = new TH2D(Form("fFlowQCSpectraCharge[%d]",k),Form("fFlowQCSpectraCharge[%d]",k),100,0.,100.,fPtDiffNBins,fCRCPtBins);
    fFlowQCSpectraCharge[k]->Sumw2();
    fFlowQCList->Add(fFlowQCSpectraCharge[k]);
  }

  Double_t ptpubbins[66] = {1.500000e-01, 2.000000e-01, 2.500000e-01, 3.000000e-01, 3.500000e-01, 4.000000e-01, 4.500000e-01, 5.000000e-01, 5.500000e-01, 6.000000e-01, 6.500000e-01, 7.000000e-01, 7.500000e-01, 8.000000e-01, 8.500000e-01, 9.000000e-01, 9.500000e-01, 1.000000e+00, 1.100000e+00, 1.200000e+00, 1.300000e+00, 1.400000e+00, 1.500000e+00, 1.600000e+00, 1.700000e+00, 1.800000e+00, 1.900000e+00, 2.000000e+00, 2.200000e+00, 2.400000e+00, 2.600000e+00, 2.800000e+00, 3.000000e+00, 3.200000e+00, 3.400000e+00, 3.600000e+00, 3.800000e+00, 4.000000e+00, 4.500000e+00, 5.000000e+00, 5.500000e+00, 6.000000e+00, 6.500000e+00, 7.000000e+00, 8.000000e+00, 9.000000e+00, 1.000000e+01, 1.100000e+01, 1.200000e+01, 1.300000e+01, 1.400000e+01, 1.500000e+01, 1.600000e+01, 1.800000e+01, 2.000000e+01, 2.200000e+01, 2.400000e+01, 2.600000e+01, 2.800000e+01, 3.000000e+01, 3.200000e+01, 3.400000e+01, 3.600000e+01, 4.000000e+01, 4.500000e+01, 5.e+01};

  fFlowQCSpectraPubBin = new TH2D("fFlowQCSpectraPubBin","fFlowQCSpectraPubBin",100,0.,100.,65,ptpubbins);
  fFlowQCSpectraPubBin->Sumw2();
  fFlowQCList->Add(fFlowQCSpectraPubBin);

  for (Int_t k=0; k<fZDCESEnCl; k++) {
    fFlowQCNewCenSpec[k] = new TH2F(Form("fFlowQCNewCenSpec[%d]",k),Form("fFlowQCNewCenSpec[%d]",k),fPtDiffNBins,fCRCPtBins,100,0.,100.);
    fFlowQCNewCenSpec[k]->Sumw2();
    fFlowQCList->Add(fFlowQCNewCenSpec[k]);
    fFlowQCCenSpec[k] = new TH2F(Form("fFlowQCCenSpec[%d]",k),Form("fFlowQCCenSpec[%d]",k),fPtDiffNBins,fCRCPtBins,100,0.,100.);
    fFlowQCCenSpec[k]->Sumw2();
    fFlowQCList->Add(fFlowQCCenSpec[k]);
  }

  Double_t xbins[12] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.,100.};

  // integrated flow
//  for(Int_t i=0; i<fFlowNHarm; i++) {
//    for(Int_t j=0; j<fkNOrdMag; j++) {
//      for(Int_t k=0; k<fkNHistOrdMag; k++) {
//        fFlowQCIntCorHistOrdMag[i][j][k] = new TH1D(Form("fFlowQCIntCorHistOrdMag[%d][%d][%d]",i,j,k),Form("fFlowQCIntCorHistOrdMag[%d][%d][%d]",i,j,k),fFlowQCCenBin,0.,100.);
//        fFlowQCIntCorHistOrdMag[i][j][k]->Sumw2();
//        fFlowQCOrdMagList->Add(fFlowQCIntCorHistOrdMag[i][j][k]);
//      }
//    }
//  }

  Double_t cenbins[101] = {0.};
  for (Int_t i=0; i<101; i++) {
    cenbins[i] = i*1.;
  }
  // Double_t xmin[3] = {-8.5e-3,-7.8e-3,-10.};
  // Double_t xmax[3] = {8.5e-3,7.8e-3,10.};
  // Double_t vtxbins[3][11] = {0.};
  // for (Int_t k=0; k<3; k++) {
  //   for (Int_t v=0; v<11; v++) {
  //     vtxbins[k][v] = xmin[k] + v*(xmax[k]-xmin[k])/10.;
  //   }
  // }
  Double_t RefMulbins[51] = {0.};
  for (Int_t i=0; i<51; i++) {
    RefMulbins[i] = -600 + i*(1200./50.);
  }

  for(Int_t i=0; i<fFlowNHarm; i++) {
    for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
      fFlowQCIntCorPro[i][j] = new TProfile(Form("fFlowQCIntCorPro[%d][%d]",i,j),Form("fFlowQCIntCorPro[%d][%d]",i,j),fFlowQCCenBin,0.,100.,"s");
      fFlowQCIntCorPro[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorPro[i][j]);
      fFlowQCIntCorHist[i][j] = new TH1D(Form("fFlowQCIntCorHist[%d][%d]",i,j),Form("fFlowQCIntCorHist[%d][%d]",i,j),fFlowQCCenBin,0.,100.);
      fFlowQCIntCorHist[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorHist[i][j]);
      fFlowQCIntCumHist[i][j] = new TH1D(Form("fFlowQCIntCumHist[%d][%d]",i,j),Form("fFlowQCIntCumHist[%d][%d]",i,j),fFlowQCCenBin,0.,100.);
      fFlowQCIntCumHist[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCumHist[i][j]);
    }
    for(Int_t j=0; j<6; j++) {
      fFlowQCIntCorNUAPro[i][j] = new TProfile(Form("fFlowQCIntCorNUAPro[%d][%d]",i,j),Form("fFlowQCIntCorNUAPro[%d][%d]",i,j),fFlowQCCenBin,0.,100.,"s");
      fFlowQCIntCorNUAPro[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorNUAPro[i][j]);
      fFlowQCIntCorNUAHist[i][j] = new TH1D(Form("fFlowQCIntCorNUAHist[%d][%d]",i,j),Form("fFlowQCIntCorNUAHist[%d][%d]",i,j),fFlowQCCenBin,0.,100.);
      fFlowQCIntCorNUAHist[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorNUAHist[i][j]);
    }
    fFlowQCIntCorProEG[i] = new TProfile(Form("fFlowQCIntCorProEG[%d]",i),Form("fFlowQCIntCorProEG[%d]",i),fFlowQCCenBin,0.,100.,"s");
    fFlowQCIntCorProEG[i]->Sumw2();
    fFlowQCList->Add(fFlowQCIntCorProEG[i]);
    fFlowQCIntCorHistEG[i] = new TH1D(Form("fFlowQCIntCorHistEG[%d]",i),Form("fFlowQCIntCorHistEG[%d]",i),fFlowQCCenBin,0.,100.);
    fFlowQCIntCorHistEG[i]->Sumw2();
    fFlowQCList->Add(fFlowQCIntCorHistEG[i]);
    for(Int_t j=0; j<4; j++) {
      fFlowQCIntCorNUAProEG[i][j] = new TProfile(Form("fFlowQCIntCorNUAProEG[%d][%d]",i,j),Form("fFlowQCIntCorNUAProEG[%d][%d]",i,j),fFlowQCCenBin,0.,100.,"s");
      fFlowQCIntCorNUAProEG[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorNUAProEG[i][j]);
      fFlowQCIntCorNUAHistEG[i][j] = new TH1D(Form("fFlowQCIntCorNUAHistEG[%d][%d]",i,j),Form("fFlowQCIntCorNUAHistEG[%d][%d]",i,j),fFlowQCCenBin,0.,100.);
      fFlowQCIntCorNUAHistEG[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorNUAHistEG[i][j]);
    }

    for(Int_t pt=0; pt<fkFlowQCnPtRanges; pt++) {
      for(Int_t j=0; j<fkFlowQCnIntCorPro; j++) {
        fFlowQCIntPtRanCorPro[pt][i][j] = new TProfile(Form("fFlowQCIntPtRanCorPro[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorPro[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.,"s");
        fFlowQCIntPtRanCorPro[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorPro[pt][i][j]);
        fFlowQCIntPtRanCorHist[pt][i][j] = new TH1D(Form("fFlowQCIntPtRanCorHist[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorHist[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.);
        fFlowQCIntPtRanCorHist[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorHist[pt][i][j]);
        fFlowQCIntPtRanCumHist[pt][i][j] = new TH1D(Form("fFlowQCIntPtRanCumHist[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCumHist[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.);
        fFlowQCIntPtRanCumHist[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCumHist[pt][i][j]);
      }
      for(Int_t j=0; j<6; j++) {
        fFlowQCIntPtRanCorNUAPro[pt][i][j] = new TProfile(Form("fFlowQCIntPtRanCorNUAPro[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorNUAPro[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.,"s");
        fFlowQCIntPtRanCorNUAPro[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorNUAPro[pt][i][j]);
        fFlowQCIntPtRanCorNUAHist[pt][i][j] = new TH1D(Form("fFlowQCIntPtRanCorNUAHist[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorNUAHist[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.);
        fFlowQCIntPtRanCorNUAHist[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorNUAHist[pt][i][j]);
      }
      fFlowQCIntPtRanCorProEG[pt][i] = new TProfile(Form("fFlowQCIntPtRanCorProEG[%d][%d]",pt,i),Form("fFlowQCIntPtRanCorProEG[%d][%d]",pt,i),fFlowQCCenBin,0.,100.,"s");
      fFlowQCIntPtRanCorProEG[pt][i]->Sumw2();
      fFlowQCList->Add(fFlowQCIntPtRanCorProEG[pt][i]);
      fFlowQCIntPtRanCorHistEG[pt][i] = new TH1D(Form("fFlowQCIntPtRanCorHistEG[%d][%d]",pt,i),Form("fFlowQCIntPtRanCorHistEG[%d][%d]",pt,i),fFlowQCCenBin,0.,100.);
      fFlowQCIntPtRanCorHistEG[pt][i]->Sumw2();
      fFlowQCList->Add(fFlowQCIntPtRanCorHistEG[pt][i]);
      for(Int_t j=0; j<4; j++) {
        fFlowQCIntPtRanCorNUAProEG[pt][i][j] = new TProfile(Form("fFlowQCIntPtRanCorNUAProEG[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorNUAProEG[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.,"s");
        fFlowQCIntPtRanCorNUAProEG[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorNUAProEG[pt][i][j]);
        fFlowQCIntPtRanCorNUAHistEG[pt][i][j] = new TH1D(Form("fFlowQCIntPtRanCorNUAHistEG[%d][%d][%d]",pt,i,j),Form("fFlowQCIntPtRanCorNUAHistEG[%d][%d][%d]",pt,i,j),fFlowQCCenBin,0.,100.);
        fFlowQCIntPtRanCorNUAHistEG[pt][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntPtRanCorNUAHistEG[pt][i][j]);
      }
    }

    for(Int_t k=0; k<fkFlowQCnVtxCorTest; k++) {
      for(Int_t j=0; j<fkFlowQCnIntCorTest; j++) {
        fFlowQCIntCorProTest[i][k][j] = new TProfile2D(Form("fFlowQCIntCorProTest[%d][%d][%d]",i,k,j),Form("fFlowQCIntCorProTest[%d][%d][%d]",i,k,j),100,cenbins,50,RefMulbins);
        fFlowQCIntCorProTest[i][k][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntCorProTest[i][k][j]);
        fFlowQCIntCorHistTest[i][k][j] = new TH2D(Form("fFlowQCIntCorHistTest[%d][%d][%d]",i,k,j),Form("fFlowQCIntCorHistTest[%d][%d][%d]",i,k,j),100,cenbins,50,RefMulbins);
        fFlowQCIntCorHistTest[i][k][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntCorHistTest[i][k][j]);
        fFlowQCIntCumHistTest[i][k][j] = new TH2D(Form("fFlowQCIntCumHistTest[%d][%d][%d]",i,k,j),Form("fFlowQCIntCumHistTest[%d][%d][%d]",i,k,j),100,cenbins,50,RefMulbins);
        fFlowQCIntCumHistTest[i][k][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntCumHistTest[i][k][j]);
        fFlowQCIntFinHistTest[i][k][j] = new TH2D(Form("fFlowQCIntFinHistTest[%d][%d][%d]",i,k,j),Form("fFlowQCIntFinHistTest[%d][%d][%d]",i,k,j),100,cenbins,50,RefMulbins);
        fFlowQCIntFinHistTest[i][k][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntFinHistTest[i][k][j]);
      }
    }
    for(Int_t k=0; k<fkFlowQCnNUATest; k++) {
      fFlowQCIntCorNUAProTest[i][k] = new TProfile2D(Form("fFlowQCIntCorNUAProTest[%d][%d]",i,k),Form("fFlowQCIntCorNUAProTest[%d][%d]",i,k),100,cenbins,50,RefMulbins);
      fFlowQCIntCorNUAProTest[i][k]->Sumw2();
      fFlowQCList->Add(fFlowQCIntCorNUAProTest[i][k]);
    }
  }
  // reference flow
  for(Int_t i=0; i<fFlowNHarm; i++) {
    for(Int_t j=0; j<fFlowQCNRef; j++) {
      fFlowQCRefCorPro[i][j] = new TProfile(Form("fFlowQCRefCorPro[%d][%d]",i,j),Form("fFlowQCRefCorPro[%d][%d]",i,j),11,xbins,"s");
      fFlowQCRefCorPro[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCRefCorPro[i][j]);
      fFlowQCRefCorHist[i][j] = new TH1D(Form("fFlowQCRefCorHist[%d][%d]",i,j),Form("fFlowQCRefCorHist[%d][%d]",i,j),11,xbins);
      fFlowQCRefCorHist[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCRefCorHist[i][j]);
    }
    for(Int_t j=0; j<4; j++) {
      fFlowQCRefCorFinal[i][j] = new TH1D(Form("fFlowQCRefCorFinal[%d][%d]",i,j),Form("fFlowQCRefCorFinal[%d][%d]",i,j),11,xbins);
      fFlowQCRefCorFinal[i][j]->Sumw2();
      fFlowQCList->Add(fFlowQCRefCorFinal[i][j]);
    }
  }

  // differential flow
  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fFlowNHarm; i++) {
      for(Int_t j=0; j<fFlowQCNPro; j++) {
        fFlowQCCorPro[h][i][j] = new TProfile(Form("fFlowQCCorPro[%d][%d][%d]",h,i,j),Form("fFlowQCCorPro[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins,"s");
        fFlowQCCorPro[h][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCCorPro[h][i][j]);
        fFlowQCCorHist[h][i][j] = new TH1D(Form("fFlowQCCorHist[%d][%d][%d]",h,i,j),Form("fFlowQCCorHist[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowQCCorHist[h][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCCorHist[h][i][j]);
        fFlowQCCorProPhi[h][i][j] = new TProfile(Form("fFlowQCCorProPhi[%d][%d][%d]",h,i,j),Form("fFlowQCCorProPhi[%d][%d][%d]",h,i,j),100,0.,TMath::TwoPi());
        fFlowQCCorProPhi[h][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCCorProPhi[h][i][j]);
      }
      for(Int_t j=0; j<fFlowQCNProPhiEta; j++) {
        fFlowQCIntCorProPhiEta[h][i][j] = new TProfile2D(Form("fFlowQCIntCorProPhiEta[%d][%d][%d]",h,i,j),Form("fFlowQCIntCorProPhiEta[%d][%d][%d]",h,i,j),20,0.,TMath::TwoPi(),16,-0.8,0.8);
        fFlowQCIntCorProPhiEta[h][i][j]->Sumw2();
        fFlowQCList->Add(fFlowQCIntCorProPhiEta[h][i][j]);
      }
      // for(Int_t k=0; k<fkNITStypes; k++) {
      //   fFlowQCCorProPhiEtaITSType[h][i][k] = new TProfile2D(Form("fFlowQCCorProPhiEtaITSType[%d][%d][%d]",h,i,k),Form("fFlowQCCorProPhiEtaITSType[%d][%d][%d]",h,i,k),100,0.,TMath::TwoPi(),32,-0.8,0.8);
      //   fFlowQCCorProPhiEtaITSType[h][i][k]->Sumw2();
      //   fFlowQCList->Add(fFlowQCCorProPhiEtaITSType[h][i][k]);
      // }
      for(Int_t k=0; k<fFlowQCNNUA; k++) {
        fFlowQCCorNUAPro[h][i][k] = new TProfile(Form("fFlowQCCorNUAPro[%d][%d][%d]",h,i,k),Form("fFlowQCCorNUAPro[%d][%d][%d]",h,i,k),fPtDiffNBins,fCRCPtBins,"s");
        fFlowQCCorNUAPro[h][i][k]->Sumw2();
        fFlowQCList->Add(fFlowQCCorNUAPro[h][i][k]);
        fFlowQCCorNUAHist[h][i][k] = new TH1D(Form("fFlowQCCorNUAHist[%d][%d][%d]",h,i,k),Form("fFlowQCCorNUAHist[%d][%d][%d]",h,i,k),fPtDiffNBins,fCRCPtBins);
        fFlowQCCorNUAHist[h][i][k]->Sumw2();
        fFlowQCList->Add(fFlowQCCorNUAHist[h][i][k]);
      }
      for(Int_t k=0; k<fFlowQCNCov; k++) {
        fFlowQCCorCovPro[h][i][k] = new TProfile(Form("fFlowQCCorCovPro[%d][%d][%d]",h,i,k),Form("fFlowQCCorCovPro[%d][%d][%d]",h,i,k),fPtDiffNBins,fCRCPtBins,"s");
        fFlowQCCorCovPro[h][i][k]->Sumw2();
        fFlowQCList->Add(fFlowQCCorCovPro[h][i][k]);
        fFlowQCCorCovHist[h][i][k] = new TH1D(Form("fFlowQCCorCovHist[%d][%d][%d]",h,i,k),Form("fFlowQCCorCovHist[%d][%d][%d]",h,i,k),fPtDiffNBins,fCRCPtBins);
        fFlowQCCorCovHist[h][i][k]->Sumw2();
        fFlowQCList->Add(fFlowQCCorCovHist[h][i][k]);
        fFlowQCFinalPtDifHist[h][i][k] = new TH1D(Form("fFlowQCFinalPtDifHist[%d][%d][%d]",h,i,k),Form("fFlowQCFinalPtDifHist[%d][%d][%d]",h,i,k),fPtDiffNBins,fCRCPtBins);
        fFlowQCFinalPtDifHist[h][i][k]->Sumw2();
        fFlowQCList->Add(fFlowQCFinalPtDifHist[h][i][k]);
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

  // symmetric cumulants with ZDCs

  for(Int_t i=0; i<fSCv2vsZNHarm; i++) {
    Int_t nCenBins = 100;
    for(Int_t bng=0; bng<fkSCNHist; bng++) {
      fFlowSCProdPro[i][bng] = new TProfile(Form("fFlowSCProdPro[%d][%d]",i,bng),Form("fFlowSCProdPro[%d][%d]",i,bng),nCenBins,0.,100.,"s");
      fFlowSCProdPro[i][bng]->Sumw2();
      fFlowQCCorrZDCList->Add(fFlowSCProdPro[i][bng]);
      fFlowSCProdHist[i][bng] = new TH1D(Form("fFlowSCProdHist[%d][%d]",i,bng),Form("fFlowSCProdHist[%d][%d]",i,bng),nCenBins,0.,100.);
      fFlowSCProdHist[i][bng]->Sumw2();
      fFlowQCCorrZDCList->Add(fFlowSCProdHist[i][bng]);
      fFlowSCFinalHist[i][bng] = new TH1D(Form("fFlowSCFinalHist[%d][%d]",i,bng),Form("fFlowSCFinalHist[%d][%d]",i,bng),nCenBins,0.,100.);
      fFlowSCFinalHist[i][bng]->Sumw2();
      fFlowQCCorrZDCList->Add(fFlowSCFinalHist[i][bng]);
      fFlowSCCovHist[i][bng] = new TH1D(Form("fFlowSCCovHist[%d][%d]",i,bng),Form("fFlowSCCovHist[%d][%d]",i,bng),nCenBins,0.,100.);
      fFlowSCCovHist[i][bng]->Sumw2();
      fFlowQCCorrZDCList->Add(fFlowSCCovHist[i][bng]);
    }
    for (Int_t k=0; k<fkFlowSCNvar; k++) {
      for (Int_t z=0; z<fkFlowSCNvar; z++) {
        fFlowSCCrossProdPro[i][k][z] = new TProfile(Form("fFlowSCCrossProdPro[%d][%d][%d]",i,k,z),Form("fFlowSCCrossProdPro[%d][%d][%d]",i,k,z),nCenBins,0.,100.,"s");
        fFlowSCCrossProdPro[i][k][z]->Sumw2();
        fFlowQCCorrZDCList->Add(fFlowSCCrossProdPro[i][k][z]);
        fFlowSCCrossProdProMult[i][k][z] = new TProfile(Form("fFlowSCCrossProdProMult[%d][%d][%d]",i,k,z),Form("fFlowSCCrossProdProMult[%d][%d][%d]",i,k,z),100,0.,3000,"s");
        fFlowSCCrossProdProMult[i][k][z]->Sumw2();
        fFlowQCCorrZDCList->Add(fFlowSCCrossProdProMult[i][k][z]);
      }
    }
  }

} // end of AliFlowAnalysisCRC::BookEverythingForFlowQC()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForFlowGF()
{
  if(!fCalculateFlowQC){return;}

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNOrde; i++) {
      fFlowGFIntCorPro[h][i] = new TProfile(Form("fFlowGFIntCorPro[%d][%d]",h,i),Form("fFlowGFIntCorPro[%d][%d]",h,i),fFlowGFCenBin,0.,100.,"s");
      fFlowGFIntCorPro[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFIntCorPro[h][i]);
      fFlowGFIntCorHist[h][i] = new TH1D(Form("fFlowGFIntCorHist[%d][%d]",h,i),Form("fFlowGFIntCorHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFIntCorHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFIntCorHist[h][i]);
      fFlowGFIntCumHist[h][i] = new TH1D(Form("fFlowGFIntCumHist[%d][%d]",h,i),Form("fFlowGFIntCumHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFIntCumHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFIntCumHist[h][i]);
      fFlowGFIntFinalHist[h][i] = new TH1D(Form("fFlowGFIntFinalHist[%d][%d]",h,i),Form("fFlowGFIntFinalHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFIntFinalHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFIntFinalHist[h][i]);
      for(Int_t k=0; k<fkFlowGFNOrde; k++) {
        fFlowGFIntCovPro[h][i][k] = new TProfile(Form("fFlowGFIntCovPro[%d][%d][%d]",h,i,k),Form("fFlowGFIntCovPro[%d][%d][%d]",h,i,k),fFlowGFCenBin,0.,100.,"s");
        fFlowGFIntCovPro[h][i][k]->Sumw2();
        fFlowGFList->Add(fFlowGFIntCovPro[h][i][k]);
        fFlowGFIntCovHist[h][i][k] = new TH1D(Form("fFlowGFIntCovHist[%d][%d][%d]",h,i,k),Form("fFlowGFIntCovHist[%d][%d][%d]",h,i,k),fFlowGFCenBin,0.,100.);
        fFlowGFIntCovHist[h][i][k]->Sumw2();
        fFlowGFList->Add(fFlowGFIntCovHist[h][i][k]);
      }
      if (fStoreExtraHistoForSubSampling) {
        for(Int_t s=0; s<fkFlowGFNSubSampling; s++) {
          fFlowGFIntCorProSS[s][h][i] = new TProfile(Form("fFlowGFIntCorProSS[%d][%d][%d]",s,h,i),Form("fFlowGFIntCorProSS[%d][%d][%d]",s,h,i),fFlowGFCenBin,0.,100.,"s");
          fFlowGFIntCorProSS[s][h][i]->Sumw2();
          fFlowGFList->Add(fFlowGFIntCorProSS[s][h][i]);
          fFlowGFIntCorHistSS[s][h][i] = new TH1D(Form("fFlowGFIntCorHistSS[%d][%d][%d]",s,h,i),Form("fFlowGFIntCorHistSS[%d][%d][%d]",s,h,i),fFlowGFCenBin,0.,100.);
          fFlowGFIntCorHistSS[s][h][i]->Sumw2();
          fFlowGFList->Add(fFlowGFIntCorHistSS[s][h][i]);
          for(Int_t k=0; k<fkFlowGFNOrde; k++) {
            fFlowGFIntCovProSS[s][h][i][k] = new TProfile(Form("fFlowGFIntCovProSS[%d][%d][%d][%d]",s,h,i,k),Form("fFlowGFIntCovProSS[%d][%d][%d][%d]",s,h,i,k),fFlowGFCenBin,0.,100.,"s");
            fFlowGFIntCovProSS[s][h][i][k]->Sumw2();
            fFlowGFList->Add(fFlowGFIntCovProSS[s][h][i][k]);
            fFlowGFIntCovHistSS[s][h][i][k] = new TH1D(Form("fFlowGFIntCovHistSS[%d][%d][%d][%d]",s,h,i,k),Form("fFlowGFIntCovHistSS[%d][%d][%d][%d]",s,h,i,k),fFlowGFCenBin,0.,100.);
            fFlowGFIntCovHistSS[s][h][i][k]->Sumw2();
            fFlowGFList->Add(fFlowGFIntCovHistSS[s][h][i][k]);
          }
        }
      }
      for(Int_t s=0; s<fkGFPtB; s++) {
        fFlowGFIntCorProPtB[s][h][i] = new TProfile(Form("fFlowGFIntCorProPtB[%d][%d][%d]",s,h,i),Form("fFlowGFIntCorProPtB[%d][%d][%d]",s,h,i),fFlowGFCenBin,0.,100.,"s");
        fFlowGFIntCorProPtB[s][h][i]->Sumw2();
        fFlowGFList->Add(fFlowGFIntCorProPtB[s][h][i]);
        fFlowGFIntCorHistPtB[s][h][i] = new TH1D(Form("fFlowGFIntCorHistPtB[%d][%d][%d]",s,h,i),Form("fFlowGFIntCorHistPtB[%d][%d][%d]",s,h,i),fFlowGFCenBin,0.,100.);
        fFlowGFIntCorHistPtB[s][h][i]->Sumw2();
        fFlowGFList->Add(fFlowGFIntCorHistPtB[s][h][i]);
        for(Int_t k=0; k<fkFlowGFNOrde; k++) {
          fFlowGFIntCovProPtB[s][h][i][k] = new TProfile(Form("fFlowGFIntCovProPtB[%d][%d][%d][%d]",s,h,i,k),Form("fFlowGFIntCovProPtB[%d][%d][%d][%d]",s,h,i,k),fFlowGFCenBin,0.,100.,"s");
          fFlowGFIntCovProPtB[s][h][i][k]->Sumw2();
          fFlowGFList->Add(fFlowGFIntCovProPtB[s][h][i][k]);
          fFlowGFIntCovHistPtB[s][h][i][k] = new TH1D(Form("fFlowGFIntCovHistPtB[%d][%d][%d][%d]",s,h,i,k),Form("fFlowGFIntCovHistPtB[%d][%d][%d][%d]",s,h,i,k),fFlowGFCenBin,0.,100.);
          fFlowGFIntCovHistPtB[s][h][i][k]->Sumw2();
          fFlowGFList->Add(fFlowGFIntCovHistPtB[s][h][i][k]);
        }
      }
    }
    for(Int_t i=0; i<fkFlowGFNExtra; i++) {
      fFlowGFIntExtraHist[h][i] = new TH1D(Form("fFlowGFIntExtraHist[%d][%d]",h,i),Form("fFlowGFIntExtraHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFIntExtraHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFIntExtraHist[h][i]);
    }
  }

  for (Int_t h=0; h<fkFlowGFNHarm; h++) {
    for(Int_t i=0; i<fkFlowGFNHarm; i++) {
      fFlowGFMixedCorPro[h][i] = new TProfile(Form("fFlowGFMixedCorPro[%d][%d]",h,i),Form("fFlowGFMixedCorPro[%d][%d]",h,i),fFlowGFCenBin,0.,100.,"s");
      fFlowGFMixedCorPro[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFMixedCorPro[h][i]);
      fFlowGFMixedCorHist[h][i] = new TH1D(Form("fFlowGFMixedCorHist[%d][%d]",h,i),Form("fFlowGFMixedCorHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFMixedCorHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFMixedCorHist[h][i]);
      fFlowGFMixedFinalHist[h][i] = new TH1D(Form("fFlowGFMixedFinalHist[%d][%d]",h,i),Form("fFlowGFMixedFinalHist[%d][%d]",h,i),fFlowGFCenBin,0.,100.);
      fFlowGFMixedFinalHist[h][i]->Sumw2();
      fFlowGFList->Add(fFlowGFMixedFinalHist[h][i]);
    }
  }

} // end of AliFlowAnalysisCRC::BookEverythingForFlowGF()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForFlowSPVZ()
{
  if(!fCalculateFlowVZ){return;}
  if(!fUseVZERO){return;}

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<fCRCnHar; i++) {
      for(Int_t j=0; j<fkFlowSPVZnHist; j++) {
        fFlowSPVZCorPro[h][i][j] = new TProfile(Form("fFlowSPVZCorPro[%d][%d][%d]",h,i,j),Form("fFlowSPVZCorPro[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowSPVZCorPro[h][i][j]->Sumw2();
        fFlowSPVZList->Add(fFlowSPVZCorPro[h][i][j]);
        fFlowSPVZCorHist[h][i][j] = new TH1D(Form("fFlowSPVZCorHist[%d][%d][%d]",h,i,j),Form("fFlowSPVZCorHist[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowSPVZCorHist[h][i][j]->Sumw2();
        fFlowSPVZList->Add(fFlowSPVZCorHist[h][i][j]);
        fFlowSPVZNUAPro[h][i][j] = new TProfile(Form("fFlowSPVZNUAPro[%d][%d][%d]",h,i,j),Form("fFlowSPVZNUAPro[%d][%d][%d]",h,i,j),fPtDiffNBins,fCRCPtBins);
        fFlowSPVZNUAPro[h][i][j]->Sumw2();
        fFlowSPVZList->Add(fFlowSPVZNUAPro[h][i][j]);
      }
    }
  } // end of for (Int_t h=0;h<fCRCnCen;h++)

} // end of AliFlowAnalysisCRC::BookEverythingForFlowSPVZ()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForEbEFlow()
{
  if(!fCalculateEbEFlow){return;}

  for(Int_t k=0; k<26; k++) {
    Int_t nbins = (Int_t)(sqrt((k+1)*100.));
    fEbEFlowAzimDis[k] = new TH1D(Form("fEbEFlowAzimDis[%d]",k),Form("fEbEFlowAzimDis[%d]",k),nbins,0.,TMath::TwoPi());
    fEbEFlowAzimDis[k]->Sumw2();
    fTempList->Add(fEbEFlowAzimDis[k]);
  }

  for(Int_t i=0; i<2; i++) {
    fEBEFlowRChiSqHist[i] = new TH2D(Form("fEBEFlowRChiSqHist[%d]",i),Form("fEBEFlowRChiSqHist[%d]",i),100,0.,100.,100,0.,5.);
    fEbEFlowList->Add(fEBEFlowRChiSqHist[i]);
    fEBEFlowpValueHist[i] = new TH2D(Form("fEBEFlowpValueHist[%d]",i),Form("fEBEFlowpValueHist[%d]",i),100,0.,100.,100,0.,1.);
    fEbEFlowList->Add(fEBEFlowpValueHist[i]);
  }

  for (Int_t h=0; h<fCRCnCen; h++) {
    for(Int_t i=0; i<4; i++) {
      fEBEFlowFlucHis[h][i] = new TH1D(Form("fEBEFlowFlucHis[%d][%d]",h,i),Form("fEBEFlowFlucHis[%d][%d]",h,i),100,-0.1,0.6);
      fEBEFlowFlucHis[h][i]->Sumw2();
      fEbEFlowList->Add(fEBEFlowFlucHis[h][i]);
    }
    for(Int_t i=0; i<2; i++) {
      fEBEFlowCrosPro[h][i] = new TProfile(Form("fEBEFlowCrosPro[%d][%d]",h,i),Form("fEBEFlowCrosPro[%d][%d]",h,i),100,-0.1,0.6);
      fEBEFlowCrosPro[h][i]->Sumw2();
      fEbEFlowList->Add(fEBEFlowCrosPro[h][i]);
    }
  }
  Double_t cent[] = {0.,5.,10.,20.,30.,40.,50.,60.,70.,80.,90.,100};
  for(Int_t h=0; h<fEBEFlowNResPro; h++) {
    fEBEFlowResVZPro[h] = new TProfile(Form("fEBEFlowResVZPro[%d]",h),Form("fEBEFlowResVZPro[%d]",h),11,cent);
    fEBEFlowResVZPro[h]->Sumw2();
    fEbEFlowList->Add(fEBEFlowResVZPro[h]);
  }

  FourierExp = new TF1("FourierExp","[0]*(1 + 2.*[1]*cos(2.*(x-[3])) + 2.*[2]*cos(3.*(x-[4])))",0.,TMath::TwoPi());

} // end of AliFlowAnalysisCRC::BookEverythingForEbEFlow()

//=======================================================================================================================

void AliFlowAnalysisCRC::BookEverythingForCRCPt()
{
} // end of AliFlowAnalysisCRCPt::BookEverythingForCRCPt()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateQcumulantsCorrectedForNUAIntFlow()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FinalizeCorrectionTermsForNUAIntFlow()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForNestedLoopsHistograms()
{
  // Get pointers to all objects relevant for calculations with nested loops.

  TList *nestedLoopsList = dynamic_cast<TList*>(fHistList->FindObject("Nested Loops"));
  if(nestedLoopsList)
  {
    this->SetNestedLoopsList(nestedLoopsList);
  } else
  {
    cout<<"WARNING: nestedLoopsList is NULL in AFAWQC::GPFNLH() !!!!"<<endl;
    exit(0);
  }

  TString sinCosFlag[2] = {"sin","cos"}; // to be improved (should I promote this to data members?)
  TString typeFlag[2] = {"RP","POI"}; // to be improved (should I promote this to data members?)
  TString ptEtaFlag[2] = {"p_{T}","#eta"}; // to be improved (should I promote this to data members?)
  TString reducedCorrelationIndex[4] = {"<2'>","<4'>","<6'>","<8'>"}; // to be improved (should I promote this to data members?)

  TString evaluateNestedLoopsName = "fEvaluateNestedLoops";
  evaluateNestedLoopsName += fAnalysisLabel->Data();
  TProfile *evaluateNestedLoops = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(evaluateNestedLoopsName.Data()));
  Bool_t bEvaluateIntFlowNestedLoops = kFALSE;
  Bool_t bEvaluateDiffFlowNestedLoops = kFALSE;
  if(evaluateNestedLoops)
  {
    this->SetEvaluateNestedLoops(evaluateNestedLoops);
    bEvaluateIntFlowNestedLoops = (Int_t)evaluateNestedLoops->GetBinContent(1);
    bEvaluateDiffFlowNestedLoops = (Int_t)evaluateNestedLoops->GetBinContent(2);
  }
  // nested loops relevant for integrated flow:
  if(bEvaluateIntFlowNestedLoops)
  {
    // correlations:
    TString intFlowDirectCorrelationsName = "fIntFlowDirectCorrelations";
    intFlowDirectCorrelationsName += fAnalysisLabel->Data();
    TProfile *intFlowDirectCorrelations = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(intFlowDirectCorrelationsName.Data()));
    if(intFlowDirectCorrelations)
    {
      this->SetIntFlowDirectCorrelations(intFlowDirectCorrelations);
    } else
    {
      cout<<"WARNING: intFlowDirectCorrelations is NULL in AFAWQC::GPFNLH() !!!!"<<endl;
      exit(0);
    }
    if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    {
      TString intFlowExtraDirectCorrelationsName = "fIntFlowExtraDirectCorrelations";
      intFlowExtraDirectCorrelationsName += fAnalysisLabel->Data();
      TProfile *intFlowExtraDirectCorrelations = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(intFlowExtraDirectCorrelationsName.Data()));
      if(intFlowExtraDirectCorrelations)
      {
        this->SetIntFlowExtraDirectCorrelations(intFlowExtraDirectCorrelations);
      } else
      {
        cout<<"WARNING: intFlowExtraDirectCorrelations is NULL in AFAWQC::GPFNLH() !!!!"<<endl;
        exit(0);
      }
    } // end of if(fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights)
    // correction terms for non-uniform acceptance:
    TString intFlowDirectCorrectionTermsForNUAName = "fIntFlowDirectCorrectionTermsForNUA";
    intFlowDirectCorrectionTermsForNUAName += fAnalysisLabel->Data();
    TProfile *intFlowDirectCorrectionTermsForNUA[2] = {NULL};
    for(Int_t sc=0;sc<2;sc++) // sin or cos terms
    {
      intFlowDirectCorrectionTermsForNUA[sc] = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(Form("%s: %s terms",intFlowDirectCorrectionTermsForNUAName.Data(),sinCosFlag[sc].Data())));
      if(intFlowDirectCorrectionTermsForNUA[sc])
      {
        this->SetIntFlowDirectCorrectionTermsForNUA(intFlowDirectCorrectionTermsForNUA[sc],sc);
      } else
      {
        cout<<"WARNING: intFlowDirectCorrectionTermsForNUA[sc] is NULL in AFAWQC::GPFNLH() !!!!"<<endl;
        cout<<"sc = "<<sc<<endl;
        exit(0);
      }
    } // end of for(Int_t sc=0;sc<2;sc++)
    // Mixed harmonics:
    if(fCalculateMixedHarmonics)
    {
      TString mixedHarmonicsNestedLoopsName = "fMixedHarmonicsNestedLoops";
      mixedHarmonicsNestedLoopsName += fAnalysisLabel->Data();
      TProfile *mixedHarmonicsNestedLoops = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(mixedHarmonicsNestedLoopsName.Data()));
      if(mixedHarmonicsNestedLoops)
      {
        this->SetMixedHarmonicsNestedLoops(mixedHarmonicsNestedLoops);
      } else
      {
        cout<<"WARNING: mixedHarmonicsNestedLoops is NULL in AFAWQC::GPFNLH() !!!!"<<endl;
        exit(0);
      }
    } // end of if(fCalculateMixedHarmonics)
  } // end of if(bEvaluateIntFlowNestedLoops)

  // nested loops relevant for differential flow:
  if(bEvaluateDiffFlowNestedLoops)
  {
    // correlations:
    TString diffFlowDirectCorrelationsName = "fDiffFlowDirectCorrelations";
    diffFlowDirectCorrelationsName += fAnalysisLabel->Data();
    TProfile *diffFlowDirectCorrelations[2][2][4] = {{{NULL}}};
    for(Int_t t=0;t<2;t++)
    {
      for(Int_t pe=0;pe<2;pe++)
      {
        for(Int_t ci=0;ci<4;ci++) // correlation index
        {
          diffFlowDirectCorrelations[t][pe][ci] = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(Form("%s, %s, %s, %s",diffFlowDirectCorrelationsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),reducedCorrelationIndex[ci].Data())));
          if(diffFlowDirectCorrelations[t][pe][ci])
          {
            this->SetDiffFlowDirectCorrelations(diffFlowDirectCorrelations[t][pe][ci],t,pe,ci);
          } else
          {
            cout<<"WARNING: diffFlowDirectCorrelations[t][pe][ci] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
            cout<<"t  = "<<t<<endl;
            cout<<"pe = "<<pe<<endl;
            cout<<"ci = "<<ci<<endl;
          }
        } // end of for(Int_t ci=0;ci<4;ci++) // correlation index
      } // end of for(Int_t pe=0;pe<2;pe++)
    } // end of for(Int_t t=0;t<2;t++)
    // correction terms for non-uniform acceptance:
    TString diffFlowDirectCorrectionTermsForNUAName = "fDiffFlowDirectCorrectionTermsForNUA";
    diffFlowDirectCorrectionTermsForNUAName += fAnalysisLabel->Data();
    TProfile *diffFlowDirectCorrectionTermsForNUA[2][2][2][10] = {{{{NULL}}}};
    for(Int_t t=0;t<2;t++)
    {
      for(Int_t pe=0;pe<2;pe++)
      {
        // correction terms for NUA:
        for(Int_t sc=0;sc<2;sc++) // sin or cos
        {
          for(Int_t cti=0;cti<9;cti++) // correction term index
          {
            diffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti] = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(Form("%s, %s, %s, %s, cti = %d",diffFlowDirectCorrectionTermsForNUAName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),cti+1)));
            if(diffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti])
            {
              this->SetDiffFlowDirectCorrectionTermsForNUA(diffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti],t,pe,sc,cti);
            } else
            {
              cout<<"WARNING: diffFlowDirectCorrectionTermsForNUA[t][pe][sc][cti] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
              cout<<"t   = "<<t<<endl;
              cout<<"pe  = "<<pe<<endl;
              cout<<"sc  = "<<sc<<endl;
              cout<<"cti = "<<cti<<endl;
            }
          } // end of for(Int_t cti=0;cti<9;cti++) // correction term index
        } // end of for(Int_t sc=0;sc<2;sc++) // sin or cos
      } // end of for(Int_t pe=0;pe<2;pe++)
    } // end of for(Int_t t=0;t<2;t++)
    // other differential correlators:
    TString otherDirectDiffCorrelatorsName = "fOtherDirectDiffCorrelators";
    otherDirectDiffCorrelatorsName += fAnalysisLabel->Data();
    TProfile *otherDirectDiffCorrelators[2][2][2][1] = {{{{NULL}}}};
    for(Int_t t=0;t<2;t++)
    {
      for(Int_t pe=0;pe<2;pe++)
      {
        // correction terms for NUA:
        for(Int_t sc=0;sc<2;sc++) // sin or cos
        {
          for(Int_t ci=0;ci<1;ci++) // correlator index
          {
            otherDirectDiffCorrelators[t][pe][sc][ci] = dynamic_cast<TProfile*>(nestedLoopsList->FindObject(Form("%s, %s, %s, %s, ci = %d",otherDirectDiffCorrelatorsName.Data(),typeFlag[t].Data(),ptEtaFlag[pe].Data(),sinCosFlag[sc].Data(),ci+1)));
            if(otherDirectDiffCorrelators[t][pe][sc][ci])
            {
              this->SetOtherDirectDiffCorrelators(otherDirectDiffCorrelators[t][pe][sc][ci],t,pe,sc,ci);
            } else
            {
              cout<<"WARNING: otherDirectDiffCorrelators[t][pe][sc][ci] is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
              cout<<"t   = "<<t<<endl;
              cout<<"pe  = "<<pe<<endl;
              cout<<"sc  = "<<sc<<endl;
              cout<<"ci = "<<ci<<endl;
            }
          } // end of for(Int_t ci=0;ci<9;ci++) // correction term index
        } // end of for(Int_t sc=0;sc<2;sc++) // sin or cos
      } // end of for(Int_t pe=0;pe<2;pe++)
    } // end of for(Int_t t=0;t<2;t++)
    // number of RPs and POIs in selected pt and eta bins for cross-checkings:
    TString noOfParticlesInBinName = "fNoOfParticlesInBin";
    TH1D *noOfParticlesInBin = NULL;
    noOfParticlesInBin = dynamic_cast<TH1D*>(nestedLoopsList->FindObject(noOfParticlesInBinName.Data()));
    if(noOfParticlesInBin)
    {
      this->SetNoOfParticlesInBin(noOfParticlesInBin);
    } else
    {
      cout<<endl;
      cout<<" WARNING (QC): noOfParticlesInBin is NULL in AFAWQC::GPFDFH() !!!!"<<endl;
      cout<<endl;
    }
  } // end of if(bEvaluateDiffFlowNestedLoops)

} // end of void AliFlowAnalysisCRC::GetPointersForNestedLoopsHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForMixedHarmonicsHistograms()
{
  // Get pointers to all objects relevant for mixed harmonics.

  // a) Get pointer to base list for mixed harmonics;
  // b) Get pointer to TProfile fMixedHarmonicsFlags holding all flags for mixed harmonics;
  // c) Get pointer to list fMixedHarmonicsProfiles and pointers to all objects that she holds;
  // d) Get pointer to list fMixedHarmonicsResults and pointers to all objects that she holds;
  // e) Get pointer to list fMixedHarmonicsErrorPropagation and pointers to all objects that she holds.

  // a) Get pointer to base list for mixed harmonics:
  TList *mixedHarmonicsList = dynamic_cast<TList*>(fHistList->FindObject("Mixed Harmonics"));
  if(mixedHarmonicsList)
  {
    this->SetMixedHarmonicsList(mixedHarmonicsList);
  } else
  {
    cout<<"WARNING: mixedHarmonicsList is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  // b) Get pointer to TProfile fMixedHarmonicsFlags holding all flags for mixed harmonics:
  TString mixedHarmonicsFlagsName = "fMixedHarmonicsFlags";
  mixedHarmonicsFlagsName += fAnalysisLabel->Data();
  TProfile *mixedHarmonicsFlags = dynamic_cast<TProfile*>
  (mixedHarmonicsList->FindObject(mixedHarmonicsFlagsName.Data()));
  if(mixedHarmonicsFlags)
  {
    this->SetMixedHarmonicsFlags(mixedHarmonicsFlags);
    fCalculateMixedHarmonics = (Bool_t)mixedHarmonicsFlags->GetBinContent(1);
    fCalculateMixedHarmonicsVsM = (Bool_t)mixedHarmonicsFlags->GetBinContent(3);
  } else
  {
    cout<<"WARNING: mixedHarmonicsFlags is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  if(!fCalculateMixedHarmonics){return;}

  // c) Get pointer to list fMixedHarmonicsProfiles and pointers to all objects that she holds:
  TList *mixedHarmonicsProfiles = NULL;
  mixedHarmonicsProfiles = dynamic_cast<TList*>(mixedHarmonicsList->FindObject("Profiles"));
  if(mixedHarmonicsProfiles)
  {
    // 2p:
    TString s2pCorrelationsName = "f2pCorrelations";
    s2pCorrelationsName += fAnalysisLabel->Data();
    TProfile *p2pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s2pCorrelationsName.Data()));
    if(p2pCorrelations)
    {
      this->Set2pCorrelations(p2pCorrelations);
    } else
    {
      cout<<"WARNING: p2pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 3p:
    TString s3pCorrelationsName = "f3pCorrelations";
    s3pCorrelationsName += fAnalysisLabel->Data();
    TProfile *p3pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s3pCorrelationsName.Data()));
    if(p3pCorrelations)
    {
      this->Set3pCorrelations(p3pCorrelations);
    } else
    {
      cout<<"WARNING: p3pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 4p:
    TString s4pCorrelationsName = "f4pCorrelations";
    s4pCorrelationsName += fAnalysisLabel->Data();
    TProfile *p4pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s4pCorrelationsName.Data()));
    if(p4pCorrelations)
    {
      this->Set4pCorrelations(p4pCorrelations);
    } else
    {
      cout<<"WARNING: p4pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 5p:
    TString s5pCorrelationsName = "f5pCorrelations";
    s5pCorrelationsName += fAnalysisLabel->Data();
    TProfile *p5pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s5pCorrelationsName.Data()));
    if(p5pCorrelations)
    {
      this->Set5pCorrelations(p5pCorrelations);
    } else
    {
      cout<<"WARNING: p5pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    /* TBI not needed for the time being
     // 6p:
     TString s6pCorrelationsName = "f6pCorrelations";
     s6pCorrelationsName += fAnalysisLabel->Data();
     TProfile *p6pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s6pCorrelationsName.Data()));
     if(p6pCorrelations)
     {
     this->Set6pCorrelations(p6pCorrelations);
     } else
     {
     cout<<"WARNING: p6pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
     exit(0);
     }
     // 7p:
     TString s7pCorrelationsName = "f7pCorrelations";
     s7pCorrelationsName += fAnalysisLabel->Data();
     TProfile *p7pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s7pCorrelationsName.Data()));
     if(p7pCorrelations)
     {
     this->Set7pCorrelations(p7pCorrelations);
     } else
     {
     cout<<"WARNING: p7pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
     exit(0);
     }
     // 8p:
     TString s8pCorrelationsName = "f8pCorrelations";
     s8pCorrelationsName += fAnalysisLabel->Data();
     TProfile *p8pCorrelations = dynamic_cast<TProfile*>(mixedHarmonicsProfiles->FindObject(s8pCorrelationsName.Data()));
     if(p8pCorrelations)
     {
     this->Set8pCorrelations(p8pCorrelations);
     } else
     {
     cout<<"WARNING: p8pCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
     exit(0);
     }
     */
  } else // to if(mixedHarmonicsProfiles)
  {
    cout<<"WARNING: mixedHarmonicsProfiles is NULL in FAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  // d) Get pointer to list fMixedHarmonicsResults and pointers to all objects that she holds.
  TList *mixedHarmonicsResults = NULL;
  mixedHarmonicsResults = dynamic_cast<TList*>(mixedHarmonicsList->FindObject("Results"));
  if(mixedHarmonicsResults)
  {
    // 2p:
    TString s2pCumulantsName = "f2pCumulants";
    s2pCumulantsName += fAnalysisLabel->Data();
    TH1D *p2pCumulants = dynamic_cast<TH1D*>(mixedHarmonicsResults->FindObject(s2pCumulantsName.Data()));
    if(p2pCumulants)
    {
      this->Set2pCumulants(p2pCumulants);
    } else
    {
      cout<<"WARNING: p2pCumulants is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 3p:
    TString s3pCumulantsName = "f3pCumulants";
    s3pCumulantsName += fAnalysisLabel->Data();
    TH1D *p3pCumulants = dynamic_cast<TH1D*>(mixedHarmonicsResults->FindObject(s3pCumulantsName.Data()));
    if(p3pCumulants)
    {
      this->Set3pCumulants(p3pCumulants);
    } else
    {
      cout<<"WARNING: p3pCumulants is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 4p:
    TString s4pCumulantsName = "f4pCumulants";
    s4pCumulantsName += fAnalysisLabel->Data();
    TH1D *p4pCumulants = dynamic_cast<TH1D*>(mixedHarmonicsResults->FindObject(s4pCumulantsName.Data()));
    if(p4pCumulants)
    {
      this->Set4pCumulants(p4pCumulants);
    } else
    {
      cout<<"WARNING: p4pCumulants is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    // 5p:
    TString s5pCumulantsName = "f5pCumulants";
    s5pCumulantsName += fAnalysisLabel->Data();
    TH1D *p5pCumulants = dynamic_cast<TH1D*>(mixedHarmonicsResults->FindObject(s5pCumulantsName.Data()));
    if(p5pCumulants)
    {
      this->Set5pCumulants(p5pCumulants);
    } else
    {
      cout<<"WARNING: p5pCumulants is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
  } else // to if(mixedHarmonicsResults)
  {
    cout<<"WARNING: mixedHarmonicsResults is NULL in FAWQC::GPFMHH() !!!!"<<endl;
  }

  // e) Get pointer to list fMixedHarmonicsErrorPropagation and pointers to all objects that she holds:
  TList *mixedHarmonicsErrorPropagation = NULL;
  mixedHarmonicsErrorPropagation = dynamic_cast<TList*>(mixedHarmonicsList->FindObject("Error Propagation"));
  if(mixedHarmonicsErrorPropagation)
  {
    TString sMixedHarmonicEventWeightsName = "fMixedHarmonicEventWeights";
    sMixedHarmonicEventWeightsName += fAnalysisLabel->Data();
    TString powerFlag[2] = {"linear","quadratic"};
    for(Int_t power=0;power<2;power++)
    {
      TH1D *hMixedHarmonicEventWeights = dynamic_cast<TH1D*>(mixedHarmonicsErrorPropagation->FindObject(Form("%s: %s",sMixedHarmonicEventWeightsName.Data(),powerFlag[power].Data())));
      if(hMixedHarmonicEventWeights)
      {
        this->SetMixedHarmonicEventWeights(hMixedHarmonicEventWeights,power);
      } else
      {
        cout<<"WARNING: hMixedHarmonicEventWeights is NULL in AFAWQC::GPFIFH() !!!!"<<endl;
        cout<<"power = "<<power<<endl;
        exit(0);
      }
    } // end of for(Int_t power=0;power<2;power++)
    TString sMixedHarmonicProductOfEventWeightsName = "fMixedHarmonicProductOfEventWeights";
    sMixedHarmonicProductOfEventWeightsName += fAnalysisLabel->Data();
    TH2D *hMixedHarmonicProductOfEventWeights = dynamic_cast<TH2D*>(mixedHarmonicsErrorPropagation->FindObject(sMixedHarmonicProductOfEventWeightsName.Data()));
    if(hMixedHarmonicProductOfEventWeights)
    {
      this->SetMixedHarmonicProductOfEventWeights(hMixedHarmonicProductOfEventWeights);
    } else
    {
      cout<<"WARNING: hMixedHarmonicProductOfEventWeights is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
    TString sMixedHarmonicProductOfCorrelationsName = "fMixedHarmonicProductOfCorrelations";
    sMixedHarmonicProductOfCorrelationsName += fAnalysisLabel->Data();
    TProfile2D *hMixedHarmonicProductOfCorrelations = dynamic_cast<TProfile2D*>(mixedHarmonicsErrorPropagation->FindObject(sMixedHarmonicProductOfCorrelationsName.Data()));
    if(hMixedHarmonicProductOfCorrelations)
    {
      this->SetMixedHarmonicProductOfCorrelations(hMixedHarmonicProductOfCorrelations);
    } else
    {
      cout<<"WARNING: hMixedHarmonicProductOfCorrelations is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
      exit(0);
    }
  } // end of if(mixedHarmonicsErrorPropagation)

} // end of void AliFlowAnalysisCRC::GetPointersForMixedHarmonicsHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForControlHistograms()
{
  // Get pointers to all control histograms.

  // a) Get pointer to base list for control histograms;
  // b) Get pointer to TProfile fControlHistogramsFlags holding all flags for control histograms;
  // c) Get pointers to TH2D *fCorrelation2468VsMult[4], TH2D *fCorrelationProduct2468VsMult[1] and TH2D *fQvectorTermsVsMult[4].

  // a) Get pointer to base list for control histograms:
  TList *controlHistogramsList = dynamic_cast<TList*>(fHistList->FindObject("Control Histograms"));
  if(controlHistogramsList)
  {
    this->SetControlHistogramsList(controlHistogramsList);
  } else
  {
    cout<<"WARNING: controlHistogramsList is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  // b) Get pointer to TProfile fControlHistogramsFlags holding all flags for control histograms:
  TString controlHistogramsFlagsName = "fControlHistogramsFlags";
  controlHistogramsFlagsName += fAnalysisLabel->Data();
  TProfile *controlHistogramsFlags = dynamic_cast<TProfile*>
  (controlHistogramsList->FindObject(controlHistogramsFlagsName.Data()));
  if(controlHistogramsFlags)
  {
    this->SetControlHistogramsFlags(controlHistogramsFlags);
    fStoreControlHistograms = (Bool_t)controlHistogramsFlags->GetBinContent(1);
    fUseQvectorTerms = (Bool_t)controlHistogramsFlags->GetBinContent(2);
  } else
  {
    cout<<"WARNING: controlHistogramsFlags is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  if(!fStoreControlHistograms){return;}

  // c) Get pointers to TH2D *fCorrelation2468VsMult[4], TH2D *fCorrelationProduct2468VsMult[1] and TH2D *fQvectorTermsVsMult[4]:
  TString sCorrelation[4] = {"#LT2#GT","#LT4#GT","#LT6#GT","#LT8#GT"};
  TString sCorrelation2468VsMultName = "fCorrelation2468VsMult";
  sCorrelation2468VsMultName += fAnalysisLabel->Data();
  for(Int_t ci=0;ci<4;ci++)
  {
    TH2D *hCorrelation2468VsMult = dynamic_cast<TH2D*>(controlHistogramsList->FindObject(Form("%s vs M",sCorrelation[ci].Data())));
    if(hCorrelation2468VsMult)
    {
      this->SetCorrelation2468VsMult(hCorrelation2468VsMult,ci);
    } else
    {
      cout<<"WARNING: hCorrelation2468VsMult is NULL in AFAWQC::GPFCH() !!!!"<<endl;
      cout<<"ci = "<<ci<<endl;
      exit(0);
    }
  } // end of for(Int_t ci=0;ci<4;ci++)
  TString sCorrelationProduct[1] = {"#LT2#GT#LT4#GT"}; // TBI: add the other ones when needed first time
  TString sCorrelationProduct2468VsMultName = "fCorrelationProduct2468VsMult";
  sCorrelationProduct2468VsMultName += fAnalysisLabel->Data();
  for(Int_t cpi=0;cpi<1;cpi++) // TBI: hardwired 1
  {
    TH2D *hCorrelationProduct2468VsMult = dynamic_cast<TH2D*>(controlHistogramsList->FindObject(Form("%s vs M",sCorrelationProduct[cpi].Data())));
    if(hCorrelationProduct2468VsMult)
    {
      this->SetCorrelationProduct2468VsMult(hCorrelationProduct2468VsMult,cpi);
    } else
    {
      cout<<"WARNING: hCorrelationProduct2468VsMult is NULL in AFAWQC::GPFCH() !!!!"<<endl;
      cout<<"cpi = "<<cpi<<endl;
      exit(0);
    }
  } // end of for(Int_t cpi=0;cpi<1;cpi++) // TBI: hardwired 1

  if(!fUseQvectorTerms){return;}

  TString sQvectorTerms[4] = {"#frac{|Q_{n}|^{2}}{M}","#frac{|Q_{2n}|^{2}}{M}","#frac{|Q_{n}|^{4}}{M(2M-1)}","#frac{Re[Q_{2n}Q_{n}^{*}Q_{n}^{*}]}{M^{3/2}}"};
  TString sQvectorTermsVsMultName = "fQvectorTermsVsMult";
  sQvectorTermsVsMultName += fAnalysisLabel->Data();
  for(Int_t qwti=0;qwti<4;qwti++) // TBI: hardwired 4
  {
    TH2D *hQvectorTermsVsMult = dynamic_cast<TH2D*>(controlHistogramsList->FindObject(Form("%s vs M",sQvectorTerms[qwti].Data())));
    if(hQvectorTermsVsMult)
    {
      this->SetQvectorTermsVsMult(hQvectorTermsVsMult,qwti);
    } else
    {
      cout<<"WARNING: hQvectorTermsVsMult is NULL in AFAWQC::GPFCH() !!!!"<<endl;
      cout<<"qwti = "<<qwti<<endl;
      exit(0);
    }
  } // end of for(Int_t qwti=0;qwti<1;qwti++) // TBI: hardwired 4

} // end of void AliFlowAnalysisCRC::GetPointersForControlHistograms()

//=======================================================================================================================

void AliFlowAnalysisCRC::GetPointersForBootstrap()
{
  // Get pointers to all bootstrap histograms.

  // a) Get pointer to base list for bootstrap histograms;
  // b) Get pointer to TProfile fBootstrapFlags holding all flags for bootstrap histograms;
  // c) Get pointers to all other lists;
  // d) Get pointers to remaining bootstrap profiles and histograms;
  // e) Get pointers to remaining bootstrap profiles and histograms 'vs M'.

  // a) Get pointer to base list for bootstrap histograms:
  TList *bootstrapList = dynamic_cast<TList*>(fHistList->FindObject("Bootstrap"));
  if(bootstrapList)
  {
    this->SetBootstrapList(bootstrapList);
  } else
  {
    cout<<"WARNING: bootstrapList is NULL in AFAWQC::GPFB() !!!!"<<endl;
    exit(0);
  }

  // b) Get pointer to TProfile fBootstrapFlags holding all flags for bootstrap histograms:
  TString bootstrapFlagsName = "fBootstrapFlags";
  bootstrapFlagsName += fAnalysisLabel->Data();
  TProfile *bootstrapFlags = dynamic_cast<TProfile*>
  (fBootstrapList->FindObject(bootstrapFlagsName.Data()));
  if(bootstrapFlags)
  {
    this->SetBootstrapFlags(bootstrapFlags);
    fUseBootstrap = (Bool_t)fBootstrapFlags->GetBinContent(1);
    fUseBootstrapVsM = (Bool_t)fBootstrapFlags->GetBinContent(2);
    fnSubsamples = (Int_t)fBootstrapFlags->GetBinContent(3);
  } else
  {
    cout<<"WARNING: bootstrapFlags is NULL in AFAWQC::GPFMHH() !!!!"<<endl;
    exit(0);
  }

  // c) Get pointers to all other lists:
  if(fUseBootstrap || fUseBootstrapVsM)
  {
    TList *bootstrapProfilesList = dynamic_cast<TList*>(fBootstrapList->FindObject("Profiles"));
    if(bootstrapProfilesList)
    {
      this->SetBootstrapProfilesList(bootstrapProfilesList);
    } else
    {
      cout<<"WARNING: bootstrapProfilesList is NULL in AFAWQC::GPFB() !!!!"<<endl;
      exit(0);
    }
    TList *bootstrapResultsList = dynamic_cast<TList*>(fBootstrapList->FindObject("Results"));
    if(bootstrapResultsList)
    {
      this->SetBootstrapResultsList(bootstrapResultsList);
    } else
    {
      cout<<"WARNING: bootstrapResultsList is NULL in AFAWQC::GPFB() !!!!"<<endl;
      exit(0);
    }
  } // end of if(fUseBootstrap || fUseBootstrapVsM)


  // d) Get pointers to remaining bootstrap profiles and histograms:
  TString correlationFlag[4] = {"#LT#LT2#GT#GT","#LT#LT4#GT#GT","#LT#LT6#GT#GT","#LT#LT8#GT#GT"};
  TString cumulantFlag[4] = {"QC{2}","QC{4}","QC{6}","QC{8}"};
  if(fUseBootstrap)
  {
    TString bootstrapCorrelationsName = "fBootstrapCorrelations";
    bootstrapCorrelationsName += fAnalysisLabel->Data();
    TProfile2D *pBootstrapCorrelations = dynamic_cast<TProfile2D*>(fBootstrapProfilesList->FindObject(bootstrapCorrelationsName.Data()));
    if(pBootstrapCorrelations)
    {
      this->SetBootstrapCorrelations(pBootstrapCorrelations);
    } else
    {
      cout<<"WARNING: pBootstrapCorrelations is NULL in AFAWQC::GPFB() !!!!"<<endl;
      exit(0);
    }
    TString bootstrapCumulantsName = "fBootstrapCumulants";
    bootstrapCumulantsName += fAnalysisLabel->Data();
    TH2D *pBootstrapCumulants = dynamic_cast<TH2D*>(fBootstrapResultsList->FindObject(bootstrapCumulantsName.Data()));
    if(pBootstrapCumulants)
    {
      this->SetBootstrapCumulants(pBootstrapCumulants);
    } else
    {
      cout<<"WARNING: pBootstrapCumulants is NULL in AFAWQC::GPFB() !!!!"<<endl;
      exit(0);
    }
  } // end of if(fUseBootstrap)

  // e) Get pointers to remaining bootstrap profiles and histograms 'vs M':
  if(fUseBootstrapVsM)
  {
    TString bootstrapCorrelationsVsMName = "fBootstrapCorrelationsVsM";
    bootstrapCorrelationsVsMName += fAnalysisLabel->Data();
    for(Int_t ci=0;ci<4;ci++) // correlation index
    {
      TProfile2D *pBootstrapCorrelationsVsM = dynamic_cast<TProfile2D*>(fBootstrapProfilesList->FindObject(Form("%s, %s",bootstrapCorrelationsVsMName.Data(),correlationFlag[ci].Data())));
      if(pBootstrapCorrelationsVsM)
      {
        this->SetBootstrapCorrelationsVsM(pBootstrapCorrelationsVsM,ci);
      } else
      {
        cout<<"WARNING: pBootstrapCorrelationsVsM is NULL in AFAWQC::GPFB() !!!!"<<endl;
        cout<<"ci = "<<ci<<endl;
        exit(0);
      }
    } // end of for(Int_t ci=0;ci<4;ci++)
    TString bootstrapCumulantsVsMName = "fBootstrapCumulantsVsM";
    bootstrapCumulantsVsMName += fAnalysisLabel->Data();
    for(Int_t co=0;co<4;co++) // correlation index
    {
      TH2D *pBootstrapCumulantsVsM = dynamic_cast<TH2D*>(fBootstrapResultsList->FindObject(Form("%s, %s",bootstrapCumulantsVsMName.Data(),cumulantFlag[co].Data())));
      if(pBootstrapCumulantsVsM)
      {
        this->SetBootstrapCumulantsVsM(pBootstrapCumulantsVsM,co);
      } else
      {
        cout<<"WARNING: pBootstrapCumulantsVsM is NULL in AFAWQC::GPFB() !!!!"<<endl;
        cout<<"co = "<<co<<endl;
        exit(0);
      }
    } // end of for(Int_t co=0;co<4;co++)
  } // end of if(fUseBootstrapVsM)

} // end of void AliFlowAnalysisCRC::GetPointersForBootstrap()

//=======================================================================================================================

void AliFlowAnalysisCRC::StoreHarmonic()
{
  // Store flow harmonic in common control histograms.

  (fCommonHists->GetHarmonic())->Fill(0.5,fHarmonic);
  if(fFillMultipleControlHistograms)
  {
    (fCommonHists2nd->GetHarmonic())->Fill(0.5,fHarmonic);
    (fCommonHists4th->GetHarmonic())->Fill(0.5,fHarmonic);
    (fCommonHists6th->GetHarmonic())->Fill(0.5,fHarmonic);
    (fCommonHists8th->GetHarmonic())->Fill(0.5,fHarmonic);
  }

} // end of void AliFlowAnalysisCRC::StoreHarmonic()

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrelationsUsingParticleWeights(TString type, TString ptOrEta) // type = RP or POI
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::FillCommonControlHistograms(AliFlowEventSimple *anEvent)
{
  // Fill common control histograms.

  Int_t nRP = anEvent->GetNumberOfRPs(); // number of Reference Particles
  fCommonHists->FillControlHistograms(anEvent);
  if(fFillMultipleControlHistograms)
  {
    if(nRP>1)
    {
      fCommonHists2nd->FillControlHistograms(anEvent);
      if(nRP>3)
      {
        fCommonHists4th->FillControlHistograms(anEvent);
        if(nRP>5)
        {
          fCommonHists6th->FillControlHistograms(anEvent);
          if(nRP>7)
          {
            fCommonHists8th->FillControlHistograms(anEvent);
          } // end of if(nRP>7)
        } // end of if(nRP>5)
      } // end of if(nRP>3)
    } // end of if(nRP>1)
  } // end of if(fFillMultipleControlHistograms)

} // end of void AliFlowAnalysisCRC::FillCommonControlHistograms(AliFlowEventSimple *anEvent)

//=======================================================================================================================

void AliFlowAnalysisCRC::FillControlHistograms(AliFlowEventSimple *anEvent)
{
  // Fill common control histograms.

  Int_t nRPs = anEvent->GetNumberOfRPs(); // number of Reference Particles
  Int_t nPOIs = anEvent->GetNumberOfPOIs(); // number of Particles Of Interest
  Int_t nRefMult = anEvent->GetReferenceMultiplicity(); // reference multiplicity for current event (TBI: This call is not really needed here, use fReferenceMultiplicityEBE instead)

  fCorrelationNoRPsVsRefMult->Fill(nRPs,nRefMult);
  fCorrelationNoPOIsVsRefMult->Fill(nPOIs,nRefMult);
  fCorrelationNoRPsVsNoPOIs->Fill(nRPs,nPOIs);

} // end of void AliFlowAnalysisCRC::FillControlHistograms(AliFlowEventSimple *anEvent)

//=======================================================================================================================

void AliFlowAnalysisCRC::ResetEventByEventQuantities()
{
  // Reset all event by event quantities.

  // Reference flow:
  fReQ->Zero();
  fImQ->Zero();
  fSpk->Zero();
  fReQGF->Zero();
  fImQGF->Zero();
  for(Int_t i=0; i<fkGFPtB; i++) {
    fReQGFPt[i]->Zero();
    fImQGFPt[i]->Zero();
  }
  fIntFlowCorrelationsEBE->Reset();
  fIntFlowEventWeightsForCorrelationsEBE->Reset();
  fIntFlowCorrelationsAllEBE->Reset();

  for(Int_t sc=0;sc<2;sc++)
  {
    fIntFlowCorrectionTermsForNUAEBE[sc]->Reset();
    fIntFlowEventWeightForCorrectionTermsForNUAEBE[sc]->Reset();
  }

  // Differential flow:
  if(fCalculateDiffFlow)
  {
    for(Int_t t=0;t<3;t++) // type (RP, POI, POI&&RP)
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // 1D in pt or eta
      {
        for(Int_t m=0;m<4;m++) // multiple of harmonic
        {
          for(Int_t k=0;k<9;k++) // power of weight
          {
            if(fReRPQ1dEBE[t][pe][m][k]) fReRPQ1dEBE[t][pe][m][k]->Reset();
            if(fImRPQ1dEBE[t][pe][m][k]) fImRPQ1dEBE[t][pe][m][k]->Reset();
          }
        }
      }
    }
    for(Int_t t=0;t<3;t++) // type (0 = RP, 1 = POI, 2 = RP&&POI )
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // 1D in pt or eta
      {
        for(Int_t k=0;k<9;k++)
        {
          if(fs1dEBE[t][pe][k]) fs1dEBE[t][pe][k]->Reset();
        }
      }
    }
    // e-b-e reduced correlations:
    for(Int_t t=0;t<2;t++) // type (0 = RP, 1 = POI)
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
      {
        for(Int_t rci=0;rci<4;rci++) // reduced correlation index
        {
          if(fDiffFlowCorrelationsEBE[t][pe][rci]) fDiffFlowCorrelationsEBE[t][pe][rci]->Reset();
          if(fDiffFlowEventWeightsForCorrelationsEBE[t][pe][rci]) fDiffFlowEventWeightsForCorrelationsEBE[t][pe][rci]->Reset();
        }
      }
    }
    // correction terms for NUA:
    for(Int_t t=0;t<2;t++) // type (0 = RP, 1 = POI)
    {
      for(Int_t pe=0;pe<1+(Int_t)fCalculateDiffFlowVsEta;pe++) // pt or eta
      {
        for(Int_t sc=0;sc<2;sc++) // sin or cos
        {
          for(Int_t cti=0;cti<9;cti++) // correction term index
          {
            fDiffFlowCorrectionTermsForNUAEBE[t][pe][sc][cti]->Reset();
          }
        }
      }
    }
  } // end of if(fCalculateDiffFlow)


  // 2D (pt,eta)
  if(fCalculate2DDiffFlow)
  {
    for(Int_t t=0;t<3;t++) // type (RP, POI, POI&&RP)
    {
      for(Int_t m=0;m<4;m++) // multiple of harmonic
      {
        for(Int_t k=0;k<9;k++) // power of weight
        {
          if(fReRPQ2dEBE[t][m][k]){fReRPQ2dEBE[t][m][k]->Reset();}
          if(fImRPQ2dEBE[t][m][k]){fImRPQ2dEBE[t][m][k]->Reset();}
        }
      }
    }
    for(Int_t t=0;t<3;t++) // type (0 = RP, 1 = POI, 2 = RP&&POI )
    {
      for(Int_t k=0;k<9;k++)
      {
        if(fs2dEBE[t][k]){fs2dEBE[t][k]->Reset();}
      }
    }
  } // end of if(fCalculate2DDiffFlow)

  // CRC
  if(fCalculateCRC) {
    for(Int_t c=0;c<2;c++) {
      for (Int_t h=0;h<fCRCnHar;h++) {
        if(fCRCQRe[c][h]) fCRCQRe[c][h]->Reset();
        if(fCRCQIm[c][h]) fCRCQIm[c][h]->Reset();
        if(fCRCMult[c][h]) fCRCMult[c][h]->Reset();
      }
    }
  }
  // ZDC
  for(Int_t c=0;c<4;c++) {
    for (Int_t h=0;h<fCRCnHar;h++) {
      if(fCRCZDCQRe[c][h]) fCRCZDCQRe[c][h]->Reset();
      if(fCRCZDCQIm[c][h]) fCRCZDCQIm[c][h]->Reset();
      if(fCRCZDCMult[c][h]) fCRCZDCMult[c][h]->Reset();
    }
  }
  for(Int_t i=0;i<2;i++) {
    fZDCFlowVect[i].Clear();
    for (Int_t h=0;h<fCRCnHar;h++) {
      fVZFlowVect[i][h].Clear();
    }
  }
  // CME
  if (fCalculateCME) {
    for(Int_t c=0;c<4;c++) {
      for (Int_t h=0;h<fCRCnHar;h++) {
        if(fCMEQRe[c][h]) fCMEQRe[c][h]->Reset();
        if(fCMEQIm[c][h]) fCMEQIm[c][h]->Reset();
        if(fCMEMult[c][h]) fCMEMult[c][h]->Reset();
      }
    }
  }
  // CRC2
  if(fCalculateCRC2) {
    for(Int_t c=0;c<3;c++) {
      for (Int_t h=0;h<fCRCnHar;h++) {
        if(fCRC2QRe[c][h]) fCRC2QRe[c][h]->Reset();
        if(fCRC2QIm[c][h]) fCRC2QIm[c][h]->Reset();
        if(fCRC2Mul[c][h]) fCRC2Mul[c][h]->Reset();
      }
    }
  }
  // FlowSPZDC
  for(Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      if(fPOIPtDiffQRe[c][h]) fPOIPtDiffQRe[c][h]->Reset();
      if(fPOIPtDiffQIm[c][h]) fPOIPtDiffQIm[c][h]->Reset();
      if(fPOIPtDiffMul[c][h]) fPOIPtDiffMul[c][h]->Reset();
      for(Int_t k=0;k<2;k++) {
        if(fPOIPtDiffQReCh[k][c][h]) fPOIPtDiffQReCh[k][c][h]->Reset();
        if(fPOIPtDiffQImCh[k][c][h]) fPOIPtDiffQImCh[k][c][h]->Reset();
        if(fPOIPtDiffMulCh[k][c][h]) fPOIPtDiffMulCh[k][c][h]->Reset();
      }
    }
  }
  for(Int_t k=0;k<2;k++) {
    for(Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        if(fPOIPtDiffQReEG[k][c][h]) fPOIPtDiffQReEG[k][c][h]->Reset();
        if(fPOIPtDiffQImEG[k][c][h]) fPOIPtDiffQImEG[k][c][h]->Reset();
        if(fPOIPtDiffMulEG[k][c][h]) fPOIPtDiffMulEG[k][c][h]->Reset();
      }
    }
  }
  for(Int_t c=0;c<fQVecPower;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      if(fPOIPhiDiffQRe[c][h]) fPOIPhiDiffQRe[c][h]->Reset();
      if(fPOIPhiDiffQIm[c][h]) fPOIPhiDiffQIm[c][h]->Reset();
      if(fPOIPhiDiffMul[c][h]) fPOIPhiDiffMul[c][h]->Reset();
      if(fPOIPhiEtaDiffQRe[c][h]) fPOIPhiEtaDiffQRe[c][h]->Reset();
      if(fPOIPhiEtaDiffQIm[c][h]) fPOIPhiEtaDiffQIm[c][h]->Reset();
      if(fPOIPhiEtaDiffMul[c][h]) fPOIPhiEtaDiffMul[c][h]->Reset();
    }
  }
  for(Int_t k=0;k<2;k++) {
    for(Int_t c=0;c<fQVecPower;c++) {
      for (Int_t h=0;h<fFlowNHarmMax;h++) {
        if(fPOIPhiDiffQReEG[k][c][h]) fPOIPhiDiffQReEG[k][c][h]->Reset();
        if(fPOIPhiDiffQImEG[k][c][h]) fPOIPhiDiffQImEG[k][c][h]->Reset();
        if(fPOIPhiDiffMulEG[k][c][h]) fPOIPhiDiffMulEG[k][c][h]->Reset();
      }
    }
  }
  for (Int_t c=0;c<2;c++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      if(fEtaDiffQRe[c][h]) fEtaDiffQRe[c][h]->Reset();
      if(fEtaDiffQIm[c][h]) fEtaDiffQIm[c][h]->Reset();
      if(fEtaDiffMul[c][h]) fEtaDiffMul[c][h]->Reset();
    }
  }
  for(Int_t k=0;k<2;k++) {
    for (Int_t h=0;h<fFlowNHarmMax;h++) {
      if(fPOIEtaPtQRe[k][h]) fPOIEtaPtQRe[k][h]->Reset();
      if(fPOIEtaPtQIm[k][h]) fPOIEtaPtQIm[k][h]->Reset();
      if(fPOIEtaPtMul[k][h]) fPOIEtaPtMul[k][h]->Reset();
    }
  }

  if(fCalculateEbEFlow) {
    for(Int_t k=0; k<26; k++) {
      fEbEFlowAzimDis[k]->Reset();
    }
  }

} // end of void AliFlowAnalysisCRC::ResetEventByEventQuantities();

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrectionsForNUASinTerms(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrectionsForNUACosTerms(TString type, TString ptOrEta)
{}

//=========================================================================================================================

void AliFlowAnalysisCRC::FinalizeCorrectionTermsForNUADiffFlow(TString type, TString ptOrEta)
{}

//=========================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCumulantsCorrectedForNUA(TString type, TString ptOrEta)
{}

//==================================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrectedForNUA(TString type, TString ptOrEta)
{}

//=========================================================================================================================

void AliFlowAnalysisCRC::EvaluateIntFlowCorrelationsWithNestedLoops(AliFlowEventSimple * const anEvent)
{}

//================================================================================================================

void AliFlowAnalysisCRC::EvaluateMixedHarmonicsWithNestedLoops(AliFlowEventSimple * const anEvent)
{}

//================================================================================================================

void AliFlowAnalysisCRC::CrossCheckIntFlowCorrelations()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckIntFlowCorrectionTermsForNUA()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateIntFlowCorrelationsWithNestedLoopsUsingParticleWeights(AliFlowEventSimple * const anEvent)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckIntFlowExtraCorrelations()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateIntFlowCorrectionsForNUAWithNestedLoops(AliFlowEventSimple * const anEvent)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateDiffFlowCorrelationsWithNestedLoops(AliFlowEventSimple * const anEvent, TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateOtherDiffCorrelatorsWithNestedLoops(AliFlowEventSimple * const anEvent, TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckDiffFlowCorrelations(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckOtherDiffCorrelators(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::PrintNumberOfParticlesInSelectedBin()
{
  // Print on the screen number of RPs and POIs in selected pt and eta bin for cross checkings.

  cout<<endl;
  cout<<"Number of RPs in selected pt bin   = "<<fNoOfParticlesInBin->GetBinContent(1)<<endl;
  cout<<"Number of RPs in selected eta bin  = "<<fNoOfParticlesInBin->GetBinContent(2)<<endl;
  cout<<"Number of POIs in selected pt bin  = "<<fNoOfParticlesInBin->GetBinContent(3)<<endl;
  cout<<"Number of POIs in selected eta bin = "<<fNoOfParticlesInBin->GetBinContent(4)<<endl;

} // end of void AliFlowAnalysisCRC::PrintNumberOfParticlesInSelectedBin()

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateDiffFlowCorrelationsWithNestedLoopsUsingParticleWeights(AliFlowEventSimple * const anEvent, TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoops(AliFlowEventSimple * const anEvent, TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CrossCheckDiffFlowCorrectionTermsForNUA(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrectionsForNUACosTermsUsingParticleWeights()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateIntFlowCorrectionsForNUASinTermsUsingParticleWeights()
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateIntFlowCorrectionsForNUAWithNestedLoopsUsingParticleWeights(AliFlowEventSimple * const anEvent)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrectionsForNUACosTermsUsingParticleWeights(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::CalculateDiffFlowCorrectionsForNUASinTermsUsingParticleWeights(TString type, TString ptOrEta)
{}

//=======================================================================================================================

void AliFlowAnalysisCRC::EvaluateDiffFlowCorrectionTermsForNUAWithNestedLoopsUsingParticleWeights(AliFlowEventSimple * const anEvent, TString type, TString ptOrEta)
{}

//=======================================================================================================================

Double_t AliFlowAnalysisCRC::GetDPhiStar(Float_t phi1, Float_t pt1, Float_t charge1, Float_t phi2, Float_t pt2, Float_t charge2, Float_t radius, Float_t bSign)
{
  // calculates dphistar

  Double_t dphistar = phi1 - phi2 - charge1 * bSign * TMath::ASin(0.07510020733 * radius / pt1) + charge2 * bSign * TMath::ASin(0.07510020733 * radius / pt2);

  // circularity
  if (dphistar > TMath::Pi()) dphistar = TMath::Pi() * 2. - dphistar;
  if (dphistar < -TMath::Pi()) dphistar = -TMath::Pi() * 2. - dphistar;
  if (dphistar > TMath::Pi()) dphistar = TMath::Pi() * 2. - dphistar;

  return dphistar;
}

//=======================================================================================================================

void AliFlowAnalysisCRC::CheckPointersUsedInFinish()
{
  // Check all pointers used in method Finish().

  if(!fAvMultiplicity)
  {
    cout<<endl;
    cout<<" WARNING (QC): fAvMultiplicity is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowCorrelationsPro)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowCorrelationsPro is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowSquaredCorrelationsPro)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowSquaredCorrelationsPro is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowCorrelationsHist)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowCorrelationsHist is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if((fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights) && !fIntFlowExtraCorrelationsPro)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowExtraCorrelationsPro is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  for(Int_t power=0;power<2;power++)
  {
    if(!fIntFlowSumOfEventWeights[power])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowSumOfEventWeights[%d] is NULL in CheckPointersUsedInFinish() !!!!",power)<<endl;
      cout<<endl;
      exit(0);
    }
  } // end of for(Int_t power=0;power<2;power++)
  if(!fIntFlowProductOfCorrelationsPro)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowProductOfCorrelationsPro is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowSumOfProductOfEventWeights)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowSumOfProductOfEventWeights is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowCovariances)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowCovariances is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowQcumulants)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowQcumulants is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlow)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlow is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fCommonHists)
  {
    cout<<endl;
    cout<<" WARNING (QC): fCommonHists is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!(fCommonHistsResults2nd && fCommonHistsResults4th && fCommonHistsResults6th && fCommonHistsResults8th))
  {
    cout<<endl;
    cout<<" WARNING (QC): fCommonHistsResults2nd && fCommonHistsResults4th && fCommonHistsResults6th"<<endl;
    cout<<"               && fCommonHistsResults8th is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }

  // NUA stuff:
  for(Int_t sc=0;sc<2;sc++) // sin/cos
  {
    if(!fIntFlowCorrectionTermsForNUAPro[sc])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowCorrectionTermsForNUAPro[%d] is NULL in CheckPointersUsedInFinish() !!!!",sc)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowCorrectionTermsForNUAHist[sc])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowCorrectionTermsForNUAHist[%d] is NULL in CheckPointersUsedInFinish() !!!!",sc)<<endl;
      cout<<endl;
      exit(0);
    }
    for(Int_t lq=0;lq<2;lq++) // linear/quadratic
    {
      if(!fIntFlowSumOfEventWeightsNUA[sc][lq])
      {
        cout<<endl;
        cout<<Form(" WARNING (QC): fIntFlowSumOfEventWeightsNUA[%d][%d] is NULL in CheckPointersUsedInFinish() !!!!",sc,lq)<<endl;
        cout<<endl;
        exit(0);
      }
    } // end of for(Int_t lq=0;lq<2;lq++) // linear/quadratic
  } // end of for(Int_t power=0;power<2;power++)
  if(!fIntFlowProductOfCorrectionTermsForNUAPro)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowProductOfCorrectionTermsForNUAPro is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowSumOfProductOfEventWeightsNUA)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowSumOfProductOfEventWeightsNUA is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowCovariancesNUA)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowCovariancesNUA is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowQcumulantsErrorSquaredRatio)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowQcumulantsErrorSquaredRatio is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowDetectorBias)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowDetectorBias is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }

  if(fCalculateMixedHarmonics)
  {
    if(!(fMixedHarmonicsFlags))
    {
      cout<<endl;
      cout<<" WARNING (QC): fMixedHarmonicsFlags is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
      cout<<endl;
      exit(0);
    }
    if(!(f2pCorrelations && f3pCorrelations && f4pCorrelations && f5pCorrelations))
    {
      cout<<endl;
      cout<<" WARNING (QC): f2pCorrelations && f3pCorrelations && f4pCorrelations && f5pCorrelations is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
      cout<<endl;
      exit(0);
    }
    if(!(f2pCumulants && f3pCumulants && f4pCumulants && f5pCumulants))
    {
      cout<<endl;
      cout<<" WARNING (QC): f2pCumulants && f3pCumulants && f4pCumulants && f5pCumulants is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
      cout<<endl;
      exit(0);
    }
    for(Int_t power=0;power<2;power++)
    {
      if(!fMixedHarmonicEventWeights[power])
      {
        cout<<endl;
        cout<<Form(" WARNING (QC): fMixedHarmonicEventWeights[%d] is NULL in CheckPointersUsedInFinish() !!!!",power)<<endl;
        cout<<endl;
        exit(0);
      }
    } // end of for(Int_t power=0;power<2;power++)
    if(!(fMixedHarmonicProductOfEventWeights))
    {
      cout<<endl;
      cout<<" WARNING (QC): fMixedHarmonicProductOfEventWeights is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
      cout<<endl;
      exit(0);
    }
    if(!(fMixedHarmonicProductOfCorrelations))
    {
      cout<<endl;
      cout<<" WARNING (QC): fMixedHarmonicProductOfCorrelations is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
      cout<<endl;
      exit(0);
    }
  } // end of if(fCalculateMixedHarmonics)

  // Versus multiplicity:
  if(!fCalculateCumulantsVsM){return;}
  for(Int_t co=0;co<=3;co++) // cumulant order
  {
    if(!fIntFlowQcumulantsVsM[co])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowQcumulantsVsM[%d] is NULL in CheckPointersUsedInFinish() !!!!",co)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowVsM[co])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowVsM[%d] is NULL in CheckPointersUsedInFinish() !!!!",co)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowDetectorBiasVsM[co])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowDetectorBiasVsM[%d] is NULL in CheckPointersUsedInFinish() !!!!",co)<<endl;
      cout<<endl;
      exit(0);
    }
  } // end of for(Int_t c0=0;c0<=3;c0++) // cumulant order
  for(Int_t ci=0;ci<=3;ci++) // correlation index
  {
    if(!fIntFlowCorrelationsVsMPro[ci])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowCorrelationsVsMPro[%d] is NULL in CheckPointersUsedInFinish() !!!!",ci)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowSquaredCorrelationsVsMPro[ci])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowSquaredCorrelationsVsMPro[%d] is NULL in CheckPointersUsedInFinish() !!!!",ci)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowCorrelationsVsMHist[ci])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowCorrelationsVsMHist[%d] is NULL in CheckPointersUsedInFinish() !!!!",ci)<<endl;
      cout<<endl;
      exit(0);
    }
    for(Int_t power=0;power<2;power++)
    {
      if(!fIntFlowSumOfEventWeightsVsM[ci][power])
      {
        cout<<endl;
        cout<<Form(" WARNING (QC): fIntFlowSumOfEventWeightsVsM[%d][%d] is NULL in CheckPointersUsedInFinish() !!!!",ci,power)<<endl;
        cout<<endl;
        exit(0);
      }
    } // end of for(Int_t power=0;power<2;power++)
  } // end of for(Int_t ci=0;ci<=3;ci++) // correlation index
  for(Int_t i=0;i<6;i++)
  {
    if(!fIntFlowProductOfCorrelationsVsMPro[i])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowProductOfCorrelationsVsMPro[%d] is NULL in CheckPointersUsedInFinish() !!!!",i)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowSumOfProductOfEventWeightsVsM[i])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowSumOfProductOfEventWeightsVsM[%d] is NULL in CheckPointersUsedInFinish() !!!!",i)<<endl;
      cout<<endl;
      exit(0);
    }
    if(!fIntFlowCovariancesVsM[i])
    {
      cout<<endl;
      cout<<Form(" WARNING (QC): fIntFlowCovariancesVsM[%d] is NULL in CheckPointersUsedInFinish() !!!!",i)<<endl;
      cout<<endl;
      exit(0);
    }
  } // end of for(Int_t i=0;i<6;i++)
  if(!fIntFlowRebinnedInM)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowRebinnedInM is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }
  if(!fIntFlowQcumulantsRebinnedInM)
  {
    cout<<endl;
    cout<<" WARNING (QC): fIntFlowQcumulantsRebinnedInM is NULL in CheckPointersUsedInFinish() !!!!"<<endl;
    cout<<endl;
    exit(0);
  }

} // end of void AliFlowAnalysisCRC::CheckPointersUsedInFinish()

//=======================================================================================================================

void AliFlowAnalysisCRC::CheckPointersUsedInMake()
{
  // Check all pointers used in method Make(). // to be improved - check other pointers as well

  if(!fAvMultiplicity)
  {
    printf("\n WARNING (QC): fAvMultiplicity is NULL in CheckPointersUsedInMake() !!!!\n\n");
    exit(0);
  }
  if((fUsePhiWeights||fUsePtWeights||fUseEtaWeights||fUseTrackWeights) && !fIntFlowExtraCorrelationsPro)
  {
    printf("\n WARNING (QC): fIntFlowExtraCorrelationsPro is NULL in CheckPointersUsedInMake() !!!!\n\n");
    exit(0);
  }
  // 2D:
  if(fCalculate2DDiffFlow)
  {
    for(Int_t t=0;t<2;t++) // type = RP or POI
    {
      for(Int_t rci=0;rci<4;rci++) // reduced correlation index
      {
        if(!f2DDiffFlowCorrelationsPro[t][rci])
        {
          printf("\n WARNING (QC): f2DDiffFlowCorrelationsPro[%i][%i] is NULL in CheckPointersUsedInMake() !!!!\n\n",t,rci);
          exit(0);
        } // end of if(!f2DDiffFlowCorrelationsPro[t][rci])
      } // end of for(Int_t rci=0;rci<4;rci++) // reduced correlation index
    } // end of for(Int_t t=0;t<2;t++)
  } // end of if(fCalculate2DDiffFlow)

} // end of void AliFlowAnalysisCRC::CheckPointersUsedInMake()
