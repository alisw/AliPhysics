// $Id$

/* 
   Example macro for evaluating the tracking efficiencies of HLT tracker (runtracker.C).
   This assumes that you have have compiled with the DOMC flag on (see doc/README).
  
   path : path to where the alirunfile.root file is located. This is original rootfile
          containing the simulated particle arrays etc...
  
   trackpath : path to where the output file from the runtracker was written.
  
   offlinepath : path to where the files containing lists of the simulated particles are located.
                 This are files generated by the AliTPCComparison macro (good_tracks_tpc)

   All efficiencies and ptresoutions are filled in histograms (see AliHLTEvaluate::CreateHistograms)
   and written to file.
*/

#ifndef __CINT__
#include "AliHLTLogger.h"
#include "AliHLTEvaluate.h"
#include "AliHLTFileHandler.h"
#include "AliHLTDigitData.h"
#include "AliHLTTransform.h"
#include "AliLevel3.h"
#include <TROOT.h>
#include <TNtuple.h>
#include <TRandom.h>
#include <TSystem.h>
#include <TStyle.h>
#include <TFile.h>
#include <TGraphErrors.h>
#include <TCanvas.h>
#include <TF1.h>
#include <stdio.h>
#include <iostream.h>
#include <time.h>
#endif

void evaltracker(Char_t *path="./",Char_t *trackpath="./tracker/",char *offlinepath="./",int nevent=1)
{
  //Make sure you got the correct parameters:
  AliHLTTransform::Init(path,kTRUE);
  
  //Define which slices to include:
  Int_t slicerange[2]={0,35};
  
  //Define which padrows to include (should normally be all)
  //Int_t rowrange[2]={AliHLTTransform::GetFirstRow(-1),AliHLTTransform::GetLastRow(-1)};
  
  //Define the minimum number of clusters on a simulated track to be found:
  Int_t good = (Int_t)(0.4*AliHLTTransform::GetNRows());
  
  //Define the minumum number of clusters on a found track to be found (should normally be the same as above)
  Int_t nclusters = (Int_t)(0.4*AliHLTTransform::GetNRows());
  
  //Define which pt range to include
  Float_t ptmin = 0.1;
  Float_t ptmax = 4.;
  
  //Define the maximum ratio of false clusters which are allowed on a found track (default=0.1 -> 10%)
  Float_t maxfalseratio = 0.1;
  
  AliHLTEvaluate *a = new AliHLTEvaluate(trackpath,nclusters,good,ptmin,ptmax,slicerange);
  a->CreateHistos(20,0.1,4.1);//(nbins in pt,minpt,maxpt) -> the same as used by standard offline
  a->SetMaxFalseClusters(maxfalseratio);
  //a->SetStandardComparison(kFALSE); //use AliTPCComparison_HLT

  //Loop over the number of events:
  for(Int_t event=0; event<nevent; event++)
    {
      cout<<"Processing event "<<event<<endl;      
      
      //Load all reconstructed tracks for this event
      a->LoadData(event,kTRUE); //Last argument indicates that output data from tracker is written in whole slice format
      
      //Loop over cluster list for each track, retrieve MC id, and verify the found track
      a->AssignIDs();
      
      //Load the list of simulated particles in the event
      a->GetGoodParticles(offlinepath,event);
      
      //Fill the efficiency histograms
      a->FillEffHistos();

    }
  
  //Calculate efficiencies
  a->CalcEffHistos();

  //Save the plots to a rootfile:
  a->Write2File("hlt_efficiencies.root");
  
}

void ploteff(Char_t *rootfile="hlt_efficiencies.root")
{
  //Plot the efficiency vs pt.
  
  gStyle->SetOptStat(0);
  
  Double_t hltx[22];
  Double_t hlty[22];
  Double_t hltxerr[22];
  Double_t hltyerr[22];
  TFile *file = TFile::Open(rootfile);
  Int_t hltcounter=0;
  TH1* h = (TH1*)file->Get("fTrackEffPt");
  for(Int_t i=0; i<22; i++)
    {
      if(h->GetBinContent(i)==0) continue;
      hltx[hltcounter] = h->GetBinCenter(i);
      hlty[hltcounter] = h->GetBinContent(i);
      hltxerr[hltcounter] = 0;
      hltyerr[hltcounter] = h->GetBinError(i);
      hltcounter++;
    }
  file->Close();
  
  TGraphErrors *gr1 = new TGraphErrors(hltcounter,hltx,hlty,hltxerr,hltyerr);
  
  TCanvas *c1 = new TCanvas("c1","",1);
  TH1F *hist = c1->DrawFrame(0.1,0,3,1.4);
  c1->SetGridx();
  c1->SetGridy();
  gr1->SetTitle("");
  gr1->Draw("PL");
  hist->GetXaxis()->SetTitle("p_{t} [GeV]");
  hist->GetYaxis()->SetTitle("Tracking efficiency");
  gr1->SetMarkerStyle(20);
  gr1->SetLineWidth(2);
  gr1->SetMarkerSize(1.3);
}

void plotptres(Char_t *rootfile="hlt_efficiencies.root")
{
  //Plot the relative pt resolution vs pt.
  
  const Int_t n=15;
  
  Double_t hltx[15] = {0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0};
  Double_t hlty[n];
  Double_t hltyerr[n];
  Char_t string[1024];
  
  TFile *file = TFile::Open(rootfile);
  TH1F *hist = new TH1F("hist","",100,-10,10);
  TNtuple *fNtuppel=(TNtuple*)file->Get("fNtuppel");
  
  for(Int_t i=0; i<n; i++)
    {
      sprintf(string,"pt_gen > %f && pt_gen <= %f && nHits>63",hltx[i]-0.1,hltx[i]+0.1);
      fNtuppel->Draw("(pt_found-pt_gen)/pt_gen*100>>hist",string,"goff");
      TF1 *f1 = new TF1("f1","gaus");
      hist->Fit("f1","QN");
      hlty[i] = f1->GetParameter(2);
      hltyerr[i] = f1->GetParError(2);
      delete f1;
    }

  delete hist;
  file->Close();

  TGraphErrors *gr1 = new TGraphErrors(n,hltx,hlty,0,hltyerr);
  TCanvas *c1 = new TCanvas("c1","",1);
  hist = c1->DrawFrame(0.1,0,3,15);
  c1->SetGridx();
  c1->SetGridy();
  gr1->SetTitle("");
  gr1->Draw("PL");
  gr1->SetMarkerStyle(20);
  gr1->SetLineWidth(2);
  gr1->SetMarkerSize(1.3);
  hist->SetXTitle("p_{t} [GeV]");
  hist->SetYTitle("#Delta P_{T} / P_{T} [%]");
}
