var index = [{"name":"A Python Interface","link":"PythonInterface.html","text":"A Python Interface A Python Interface A Python Interface A Python Interface Python is a powerful, high-level interpreted language that is widely used within the particle physics community. It is particularly useful as an interactive language that provides fast proto-typing of code. An experimental Python interface to PYTHIA is available. This interface has been generated using A Python Interface SWIG (Simplified Wrapper and Interface Generator). Please note that this interface has not been extensively tested and consequently issues may arise. If bugs are found or additional features are required, as usual, please report them to the PYTHIA authors. A Python Interface Features An attempt has been made to translate all PYTHIA classes and functions to the Python interface as directly as possible. The following features are included in the Python interface: A Python Interface A Python Interface The interface is compatible with Python version A Python Interface 2.1 and beyond, including A Python Interface 3.5 , the current version of Python. A Python Interface All PYTHIA classes and functions are available. See A Python Interface main01.py for a direct Python translation of the C++ A Python Interface main01.cc example. A Python Interface Most of the plugin classes are also available in the interface. See A Python Interface main34.py for a direct Python translation of the C++ A Python Interface main34.cc example which uses the A Python Interface LHAupMadgraph class from A Python Interface include/Pythia8Plugins/LHAMadgraph.h. A Python Interface When available, documentation through the built-in A Python Interface help function in Python is provided. Please note that this documentation is automatically generated, similar to the A Python Interface Doxygen documentation. Consequently, the inline Python documentation is not a replacement for this manual. A Python Interface All operators defined in C++, e.g. A Python Interface Vec4*double , as well as reverse operators, e.g. A Python Interface double*Vec4 , are available. A Python Interface Classes with defined A Python Interface [] operators are iterable, using standard Python iteration, e.g. A Python Interface for prt in pythia.event. A Python Interface Classes with a A Python Interface << operator or a A Python Interface list function can be printed via the built-in A Python Interface print function in Python. Note this means that a string representation via A Python Interface str is also available for these classes in Python. A Python Interface Specific versions of templates needed by PYTHIA classes are available where the naming scheme is the template class name followed by its arguments (stripped of namespace specifiers); pointers to classes are prepended with A Python Interface Ptr. For example, A Python Interface vector<int> is available via the interface as A Python Interface VectorInt , A Python Interface map<string, Mode> as A Python Interface MapStringMode , and A Python Interface vector<ProcessContainer*> as A Python Interface VectorProcessContainerPtr. A Python Interface Derived classes in Python, for a subset of PYTHIA classes, can be passed back to PYTHIA. This is possible for all classes that can be passed to the A Python Interface Pythia class via the A Python Interface setXPtr functions and includes the following classes: A Python Interface BeamShape , A Python Interface DecayHandler , A Python Interface LHAup , A Python Interface MergingHooks , A Python Interface PDF , A Python Interface PhaseSpace , A Python Interface ResonanceWidths , A Python Interface RndmEngine , A Python Interface SigmaProcess , A Python Interface SpaceShower , A Python Interface TimeShower , and A Python Interface UserHooks. The protected functions and members of these classes are available through the Python interface. See A Python Interface main10.py for a direct Python translation of the C++ A Python Interface main10.cc example which uses a derived class from the A Python Interface UserHooks class to veto events. A Python Interface Limitations A variety of methods to interface C++ code with Python exist, each with its own advantages and disadvantages, some of which are being rapidly developed. Currently, for the purposes of an interface to PYTHIA, SWIG provides the best option. However, this may not remain the case, and the technical interface may be changed to some other method, e.g. A Python Interface cppyy , in the future. The Python interface to PYTHIA currently suffers the following limitations: A Python Interface A Python Interface In the A Python Interface CoupSUSY class all public members that are 3-by-3 arrays cannot be accessed, these include A Python Interface LsddX , A Python Interface LsuuX , A Python Interface LsduX , A Python Interface LsudX , A Python Interface LsvvX , A Python Interface LsllX , A Python Interface LsvlX , A Python Interface LslvX , as well as the equivalent A Python Interface R versions of these members. Additionally, A Python Interface rvLLE , A Python Interface rvLQD , and A Python Interface rvUDD cannot be accessed. A Python Interface In the A Python Interface MergingHooks class, the protected methods A Python Interface orderHistories , A Python Interface allowCutonRecState , and A Python Interface doWeakClustering with A Python Interface bool return values have been renamed as A Python Interface getOrderHistories , A Python Interface getAllowCutonRecState , and A Python Interface getDoWeakClustering , respectively, in the Python interface. A Python Interface The public A Python Interface headerStream , A Python Interface initStream , and A Python Interface eventStream members of the A Python Interface Writer class, used for writing LHEF output, cannot be accessed from the Python interface. A Python Interface For derived Python classes of the PYTHIA class A Python Interface LHAup , the protected member A Python Interface osLHEF cannot be accessed. A Python Interface The wrapper generated by SWIG is large (10 MB), and consequently the compile time can be significant. The only way to reduce the size of the wrapper is to remove functionality from the interface. A Python Interface Creating a derived Python class from a PYTHIA class, as described above in the features, is only possible for a subset of PYTHIA classes. However, if this feature is needed for specific classes, they can be added in the future upon request. This feature is not enabled by default for all classes to reduce the generated wrapper size. A Python Interface Python interfaces have not been generated for plugins within A Python Interface include/Pythia8Plugins which have direct external dependencies. This means there are no Python interfaces for any of the classes or functions defined in A Python Interface EvtGen.h , A Python Interface FastJet3.h , A Python Interface HepMC2.h , or A Python Interface LHAFortran.h. However, interfaces are available for all remaining plugins, including both A Python Interface LHAMadgraph.h and A Python Interface PowhegProcs.h. A Python Interface Installation To install the Python interface, both the A Python Interface python command, as well as the Python system header A Python Interface Python.h must be available. The directory containing the A Python Interface python command can be passed to the PYTHIA configuration via the option A Python Interface --with-python-bin , while the directory containing A Python Interface Python.h can be set with the option A Python Interface --with-python-include. An example configuration could be as follows, A Python Interface ./configure --with-python-include=/usr/include/python2.7 \    --with-python-bin=/usr/bin where the paths must be changed accordingly for the local system. If the location of A Python Interface Python.h is unknown, oftentimes the command A Python Interface python-config --includes will supply the correct path. Please note that the Python versions for the A Python Interface python command and A Python Interface Python.h header must match. This is of particular importance when compiling against Python 3. Many systems will provide the Python 3 command via A Python Interface python3 rather than A Python Interface python , so either a temporary alias should be made, or a soft link of the A Python Interface python3 command to A Python Interface python could also be made. However, take care, as many systems rely on Python 2 for things such as package managers, etc. Also note that if one wishes to utilize GZIP support (needed for the A Python Interface LHAupMadgraph plugin) then the option A Python Interface --with-gzip should also be provided. A Python Interface After configuring the Python interface for PYTHIA to be built and running A Python Interface make as usual, the following files should be generated in the directory A Python Interface lib. A Python Interface A Python Interface A Python Interface pythia8.py : the Python code for the interface. A Python Interface A Python Interface pythia8.pyc : the byte-compiled Python code for the interface. A Python Interface A Python Interface _pythia8.so : the C++ library needed for the interface. A Python Interface A Python Interface libpythia8.[so,dylib] : the standard shared PYTHIA library. A Python Interface To ensure that the A Python Interface pythia8.py module is available to Python, the system variable A Python Interface PYTHONPATH should be set similar to A Python Interface export PYTHONPATH=$(PREFIX_LIB):$PYTHONPATH where A Python Interface PREFIX_LIB is the directory A Python Interface lib which contains A Python Interface pythia8.py. Generally, the library paths should be set correctly, but it also may be necessary to set A Python Interface export LD_LIBRARY_PATH=$(PREFIX_LIB):$LD_LIBRARY_PATH where A Python Interface DYLD should be substituted for A Python Interface LD in OS X. Alternatively, it is also possible to define the Python path from within Python, as is done within the provided examples. A Python Interface Examples To use the Python interface for PYTHIA, start Python and A Python Interface import pythia8. The provided examples can be run by A Python Interface python mainXX.py where A Python Interface XX is the number of the example."},{"name":"A Second Hard Process","link":"ASecondHardProcess.html","text":"A Second Hard Process A Second Hard Process A Second Hard Process When you have selected a set of hard processes for hadron beams, the A Second Hard Process multiparton interactions framework can add further interactions to build up a realistic underlying event. These further interactions can come from a wide variety of processes, and will occasionally be quite hard. They do represent a realistic random mix, however, which means one cannot predetermine what will happen. Occasionally there may be cases where one wants to specify also the second hard interaction rather precisely. The options on this page allow you to do precisely that. A Second Hard Process Process Selection In principle the whole A Second Hard Process process selection allowed for the first process could be repeated for the second one. However, this would probably be overkill. Therefore here a more limited set of prepackaged process collections are made available, that can then be further combined at will. Since the description is almost completely symmetric between the first and the second process, you always have the possibility to pick one of the two processes according to the complete list of possibilities. A Second Hard Process Here comes the list of allowed sets of processes, to combine at will: A Second Hard Process A further process collection comes with a warning flag: A Second Hard Process Cuts and scales The second hard process obeys exactly the same selection rules for A Second Hard Process phase space cuts and A Second Hard Process couplings and scales as the first one does. Specifically, a A Second Hard Process pTmin cut for A Second Hard Process 2 &rarr; 2 processes would apply to the first and the second hard process alike, and ballpark half of the time the second could be generated with a larger A Second Hard Process pT than the first. (Exact numbers depending on the relative shape of the two cross sections.) That is, first and second is only used as an administrative distinction between the two, not as a physics ordering one. A Second Hard Process Optionally it is possible to pick the mass and A Second Hard Process pT A Second Hard Process phase space cuts separately for the second hard interaction. The main application presumably would be to allow a second process that is softer than the first, but still hard. But one is also free to make the second process harder than the first, if desired. So long as the two A Second Hard Process pT (or mass) ranges overlap the ordering will not be the same in all events, however. A Second Hard Process Cross-section calculation As an introduction, a brief reminder of Poissonian statistics. Assume a stochastic process in time, for now not necessarily a high-energy physics one, where the probability for an event to occur at any given time is independent of what happens at other times. Then the probability for A Second Hard Process n events to occur in a finite time interval is A Second Hard Process P_n = <n>^n exp(-<n>) / n! where A Second Hard Process <n> is the average number of events. If this number is small we can approximate A Second Hard Process exp(-<n>) = 1 , so that A Second Hard Process P_1 = <n> and A Second Hard Process P_2 = <n>^2 / 2 = P_1^2 / 2. A Second Hard Process Now further assume that the events actually are of two different kinds A Second Hard Process a and A Second Hard Process b , occurring independently of each other, such that A Second Hard Process <n> = <n_a> + <n_b>. It then follows that the probability of having one event of type A Second Hard Process a (or A Second Hard Process b ) and nothing else is A Second Hard Process P_1a = <n_a> (or A Second Hard Process P_1b = <n_b> ). From A Second Hard Process P_2 = (<n_a> + <n_b>)^2 / 2 = (P_1a + P_1b)^2 / 2 = (P_1a^2 + 2 P_1a P_1b + P_1b^2) / 2 it is easy to read off that the probability to have exactly two events of kind A Second Hard Process a and none of A Second Hard Process b is A Second Hard Process P_2aa = P_1a^2 / 2 whereas that of having one A Second Hard Process a and one A Second Hard Process b is A Second Hard Process P_2ab = P_1a P_1b. Note that the former, with two identical events, contains a factor A Second Hard Process 1/2 while the latter, with two different ones, does not. If viewed in a time-ordered sense, the difference is that the latter can be obtained two ways, either first an A Second Hard Process a and then a A Second Hard Process b or else first a A Second Hard Process b and then an A Second Hard Process a. A Second Hard Process To translate this language into cross-sections for high-energy events, we assume that interactions can occur at different A Second Hard Process pT values independently of each other inside inelastic nondiffractive (sometimes equated with 'minbias') events. Then the above probabilities translate into A Second Hard Process P_n = sigma_n / sigma_ND where A Second Hard Process sigma_ND is the total nondiffractive cross section. Again we want to assume that A Second Hard Process exp(-<n>) is close to unity, i.e. that the total hard cross section above A Second Hard Process pTmin is much smaller than A Second Hard Process sigma_ND. The hard cross section is dominated by QCD jet production, and a reasonable precaution is to require a A Second Hard Process pTmin of at least 20 GeV at LHC energies. (For A Second Hard Process 2 &rarr; 1 processes such as A Second Hard Process q qbar &rarr; gamma^*/Z^0 (&rarr; f fbar) one can instead make a similar cut on mass.) Then the generic equation A Second Hard Process P_2 = P_1^2 / 2 translates into A Second Hard Process sigma_2/sigma_ND = (sigma_1 / sigma_ND)^2 / 2 or A Second Hard Process sigma_2 = sigma_1^2 / (2 sigma_ND). A Second Hard Process Again different processes A Second Hard Process a, b, c, ... contribute, and by the same reasoning we obtain A Second Hard Process sigma_2aa = sigma_1a^2 / (2 sigma_ND) , A Second Hard Process sigma_2ab = sigma_1a sigma_1b / sigma_ND , and so on. A Second Hard Process There is one important correction to this picture: all collisions do no occur under equal conditions. Some are more central in impact parameter, others more peripheral. This leads to a further element of variability: central collisions are likely to have more activity than the average, peripheral less. Integrated over impact parameter standard cross sections are recovered, but correlations are affected by a 'trigger bias' effect: if you select for events with a hard process you favour events at small impact parameter which have above-average activity, and therefore also increased chance for further interactions. (In PYTHIA this is the origin of the 'pedestal effect', i.e. that events with a hard interaction have more underlying activity than the level found in minimum-bias events.) A Second Hard Process When you specify a matter overlap profile in the multiparton-interactions scenario, such an enhancement/depletion factor A Second Hard Process f_impact is chosen event-by-event and can be averaged during the course of the run. As an example, the double Gaussian form used in Tune A gives approximately A Second Hard Process <f_impact> = 2.5. In general, the more uneven the distribution the higher the A Second Hard Process <f_impact>. Also the A Second Hard Process pT0 parameter value has an impact, even if it is less important over a realistic range of values, although it implies that A Second Hard Process <f_impact> is energy-dependent. The origin of this effect is as follows. A lower A Second Hard Process pT0 implies more MPI activity at all impact parameters, so that the nondiffractive cross section A Second Hard Process sigma_ND increases, or equivalently the proton size. But if A Second Hard Process sigma_ND is fixed by data then the input radius of the matter overlap profile (not explicitly specified but implicitly adjusted at initialization) has to be shrunk  so that the output value can stay constant. This means that the proton matter is more closely packed and therefore A Second Hard Process <f_impact> goes up. A Second Hard Process The above equations therefore have to be modified to A Second Hard Process sigma_2aa = <f_impact> sigma_1a^2 / (2 sigma_ND) , A Second Hard Process sigma_2ab = <f_impact> sigma_1a sigma_1b / sigma_ND. Experimentalists often instead use the notation A Second Hard Process sigma_2ab = sigma_1a sigma_1b / sigma_eff , from which we see that PYTHIA 'predicts' A Second Hard Process sigma_eff = sigma_ND / <f_impact>. When the generation of multiparton interactions is switched off it is not possible to calculate A Second Hard Process <f_impact> and therefore it is set to unity. A Second Hard Process When this recipe is to be applied to calculate actual cross sections, it is useful to distinguish three cases, depending on which set of processes are selected to study for the first and second interaction. A Second Hard Process (1) The processes A Second Hard Process a for the first interaction and A Second Hard Process b for the second one have no overlap at all. For instance, the first could be A Second Hard Process TwoJets and the second A Second Hard Process TwoPhotons. In that case, the two interactions can be selected independently, and cross sections tabulated for each separate subprocess in the two above classes. At the end of the run, the cross sections in A Second Hard Process a should be multiplied by A Second Hard Process <f_impact> sigma_1b / sigma_ND to bring them to the correct overall level, and those in A Second Hard Process b by A Second Hard Process <f_impact> sigma_1a / sigma_ND. A Second Hard Process (2) Exactly the same processes A Second Hard Process a are selected for the first and second interaction. In that case it works as above, with A Second Hard Process a = b , and it is only necessary to multiply by an additional factor A Second Hard Process 1/2. A compensating factor of 2 is automatically obtained for picking two different subprocesses, e.g. if A Second Hard Process TwoJets is selected for both interactions, then the combination of the two subprocesses A Second Hard Process q qbar &rarr; g g and A Second Hard Process g g &rarr; g g can trivially be obtained two ways. A Second Hard Process (3) The list of subprocesses partly but not completely overlap. For instance, the first process is allowed to contain A Second Hard Process a or A Second Hard Process c and the second A Second Hard Process b or A Second Hard Process c , where there is no overlap between A Second Hard Process a and A Second Hard Process b. Then, when an independent selection for the first and second interaction both pick one of the subprocesses in A Second Hard Process c , half of those events have to be thrown, and the stored cross section reduced accordingly. Considering the four possible combinations of first and second process, this gives a A Second Hard Process sigma'_1 = sigma_1a + sigma_1c * (sigma_2b + sigma_2c/2) / (sigma_2b + sigma_2c) with the factor A Second Hard Process 1/2 for the A Second Hard Process sigma_1c sigma_2c term. At the end of the day, this A Second Hard Process sigma'_1 should be multiplied by the normalization factor A Second Hard Process f_1norm = <f_impact> (sigma_2b + sigma_2c) / sigma_ND here without a factor A Second Hard Process 1/2 (or else it would have been double-counted). This gives the correct A Second Hard Process (sigma_2b + sigma_2c) * sigma'_1 = sigma_1a * sigma_2b + sigma_1a * sigma_2c + sigma_1c * sigma_2b + sigma_1c * sigma_2c/2 The second interaction can be handled in exact analogy. A Second Hard Process For the considerations above it is assumed that the phase space cuts are the same for the two processes. It is possible to set the mass and transverse momentum cuts differently, however. This changes nothing for processes that already are different. For two collisions of the same type it is partly a matter of interpretation what is intended. If we consider the case of the same process in two non-overlapping phase space regions, most likely we want to consider them as separate processes, in the sense that we expect a factor 2 relative to Poissonian statistics from either of the two hardest processes populating either of the two phase space regions. In total we are therefore lead to adopt the same strategy as in case (3) above: only in the overlapping part of the two allowed phase space regions could two processes be identical and thus appear with a 1/2 factor, elsewhere the two processes are never identical and do not include the 1/2 factor. We reiterate, however, that the case of partly but not completely overlapping phase space regions for one and the same process is tricky, and not to be used without prior deliberation. A Second Hard Process The listing obtained with the A Second Hard Process pythia.stat() already contain these corrections factors, i.e. cross sections are for the occurrence of two interactions of the specified kinds. There is not a full tabulation of the matrix of all the possible combinations of a specific first process together with a specific second one (but the information is there for the user to do that, if desired). Instead A Second Hard Process pythia.stat() shows this matrix projected onto the set of processes and associated cross sections for the first and the second interaction, respectively. Up to statistical fluctuations, these two sections of the A Second Hard Process pythia.stat() listing both add up to the same total cross section for the event sample. A Second Hard Process There is a further special feature to be noted for this listing, and that is the difference between the number of 'selected' events and the number of 'accepted' ones. Here is how that comes about. Originally the first and second process are selected completely independently. The generation (in)efficiency is reflected in the different number of initially tried events for the first and second process, leading to the same number of selected events. While acceptable on their own, the combination of the two processes may be unacceptable, however. It may be that the two processes added together use more energy-momentum than kinematically allowed, or, even if not, are disfavoured when the PYTHIA approach to provide correlated parton densities is applied. Alternatively, referring to case (3) above, it may be because half of the events should be thrown for identical processes. Taken together, it is these effects that reduced the event number from 'selected' to 'accepted'. (A further reduction may occur if a A Second Hard Process user hook rejects some events.) A Second Hard Process It is allowed to use external Les Houches Accord input for the hardest process, and then pick an internal one for the second hardest. In this case PYTHIA does not have access to your thinking concerning the external process, and cannot know whether it overlaps with the internal or not. (External events A Second Hard Process q qbar' &rarr; e+ nu_e could agree with the internal A Second Hard Process W ones, or be a A Second Hard Process W' resonance in a BSM scenario, to give one example.) Therefore the combined cross section is always based on the scenario (1) above. Corrections for correlated parton densities are included also in this case, however. That is, an external event that takes a large fraction of the incoming beam momenta stands a fair chance of being rejected when it has to be combined with another hard process. For this reason the 'selected' and 'accepted' event numbers are likely to disagree. A Second Hard Process In the cross section calculation above, the A Second Hard Process sigma'_1 cross sections are based on the number of accepted events, while the A Second Hard Process f_1norm factor is evaluated based on the cross sections for selected events. That way the suppression by correlations between the two processes does not get to be double-counted. A Second Hard Process The A Second Hard Process pythia.stat() listing contains two final lines, indicating the summed cross sections A Second Hard Process sigma_1sum and A Second Hard Process sigma_2sum for the first and second set of processes, at the 'selected' stage above, plus information on the A Second Hard Process sigma_ND and A Second Hard Process <f_impact> used. The total cross section generated is related to this by A Second Hard Process <f_impact> * (sigma_1sum * sigma_2sum / sigma_ND) * (n_accepted / n_selected) with an additional factor of A Second Hard Process 1/2 for case 2 above. A Second Hard Process The error quoted for the cross section of a process is a combination in quadrature of the error on this process alone with the error on the normalization factor, including the error on A Second Hard Process <f_impact>. As always it is a purely statistical one and of course hides considerably bigger systematic uncertainties. A Second Hard Process A Second Hard Process Warning: the calculational machinery above has not (yet) been implemented for the case that the two interactions are to be associated with different impact-parameter profiles, as is the case for A Second Hard Process MultipartonInteractions:bProfile = 4 , i.e. when the radius depends on the A Second Hard Process x value. Results for the double cross section therefore cannot be trusted in this case. A Second Hard Process Event information Normally the A Second Hard Process process event record only contains the hardest interaction, but in this case also the second hardest is stored there. If both of them are A Second Hard Process 2 &rarr; 2 ones, the first would be stored in lines 3 - 6 and the second in 7 - 10. For both, status codes 21 - 29 would be used, as for a hardest process. Any resonance decay chains would occur after the two main processes, to allow normal parsing. The beams in 1 and 2 only appear in one copy. This structure is echoed in the full A Second Hard Process event event record. A Second Hard Process Most of the properties accessible by the A Second Hard Process A Second Hard Process pythia.info methods refer to the first process, whether that happens to be the hardest or not. The code and A Second Hard Process pT scale of the second process are accessible by the A Second Hard Process info.codeMPI(1) and A Second Hard Process info.pTMPI(1) , however. A Second Hard Process The A Second Hard Process sigmaGen() and A Second Hard Process sigmaErr() methods provide the cross section and its error for the event sample as a whole, combining the information from the two hard processes as described above. In particular, the former should be used to give the weight of the generated event sample. The statistical error estimate is somewhat cruder and gives a larger value than the subprocess-by-subprocess one  employed in A Second Hard Process pythia.stat() , but this number is anyway less relevant, since systematical errors are likely to dominate."},{"name":"Advanced Usage","link":"AdvancedUsage.html","text":"Advanced Usage Advanced Usage Advanced Usage On this page we collect information on a number of classes that the normal user would not encounter. There are cases where the information is essential, however, for instance to Advanced Usage implement your own showers. Advanced Usage The subsystems One aspect that complicates administration is that an event can contain several subsystems, each consisting of either 1) one MPI and its associated ISR and FSR or 2) one decaying resonance and its associated FSR. To first approximation these systems are assumed to evolve independently, but to second they are connected by the interleaved evolution, and potentially by colour-reconnection or rescattering effects. The partons of a given subsystem therefore do not have to be stored consecutively. Advanced Usage The Advanced Usage PartonSystems class is primarily used to keep track of the current positions of all partons belonging to each system, represented by the index Advanced Usage iPos for a parton stored in the event-record slot Advanced Usage event[iPos]. With 'all' we mean the current set of outgoing partons, as well as the currently defined two incoming partons that system (for 2&rarr;n processes) or one incoming parton in the case of a decay (1&rarr;n) process. No intermediate-state (off-shell) ISR or FSR partons are present. That is, the parton system stores all partons that could be subject to some action in the next step of the combined MPI/ISR/FSR/BR description. As a special case, an outgoing parton is stored even if it undergoes a rescattering, and thus no longer belongs to the final state proper. Advanced Usage Note also that an unstable (decaying) resonance will normally appear in two different systems; once, as an outgoing parton in the system that produced it (a hard process or the decay system of a previous resonance decay), and once as an incoming parton in its own decay system. Advanced Usage The Advanced Usage partonSystems instance of Advanced Usage PartonSystems class is a public member of the Advanced Usage Pythia top-level class, but is also available as a pointer Advanced Usage partonSystemsPtr in various Advanced Usage PartonLevel classes, e.g. inside the current instances of the Advanced Usage TimeShower and Advanced Usage SpaceShower classes. Advanced Usage A number of Advanced Usage PartonSystems methods can be used to set or get information on the subsystems: Advanced Usage Advanced Usage Advanced Usage clear() resets all the contents in preparation for the next event. Advanced Usage Advanced Usage addSys() add a new (initially empty) subsystem to the current list and return its index Advanced Usage iSys in the list, where index 0 is the hardest subcollision and so on. Advanced Usage Advanced Usage sizeSys() the number of separate subsystems. Advanced Usage Advanced Usage setInA(iSys, iPos), setInB(iSys, iPos) store position Advanced Usage iPos of the incoming parton from beam A or beam B to the Advanced Usage iSys 'th subcollision. These values are 0 initially, and should so remain if there are no beams, such as in resonance decays. Advanced Usage Advanced Usage setInRes(iSys, iPos) stores position Advanced Usage iPos of the incoming (decaying) resonance whose decay produced the outgoing partons for the Advanced Usage iSys 'th system. This value is 0 initially and should so remain for systems that are not produced by the decay of a resonance, such as 2&rarr;n subcollision systems. Advanced Usage Advanced Usage addOut(iSys, iPos) store position Advanced Usage iPos of a new outgoing parton in the Advanced Usage iSys 'th subcollision, by appending it at the end of the current vector, with beginning in slot 0. Advanced Usage Advanced Usage setOut(iSys, iMem, iPos) store position Advanced Usage iPos in the Advanced Usage iMem 'th slot in the vector of outgoing partons in the Advanced Usage iSys 'th subcollision. Here Advanced Usage iMem must be in the range already constructed by Advanced Usage addOut calls. Advanced Usage Advanced Usage replace(iSys, iPosOld, iPosNew) replace the existing incoming or outgoing parton position Advanced Usage iPosOld by Advanced Usage iPosNew in the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage setSHat(iSys, sHat) set the invariant squared mass Advanced Usage sHat of the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage hasInAB(iSys) true if an incoming parton has been set for beam A or beam B (and hence should have been set for both) in the Advanced Usage iSys 'th subcollision, else false. Advanced Usage Advanced Usage getInA(iSys), getInB(iSys) the position Advanced Usage iPos of the incoming parton from beam A or beam B to the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage hasInRes(iSys) true if an incoming (decaying) resonance has been set for the Advanced Usage iSys 'th parton system, else false. Advanced Usage Advanced Usage sizeOut(iSys) the number of outgoing partons in the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage getOut(iSys, iMem) the position Advanced Usage iPos of an outgoing parton in the Advanced Usage iSys 'th subcollision, with the Advanced Usage iMem range limited by Advanced Usage sizeOut(iSys). These partons are not guaranteed to appear in any particular order. Advanced Usage Advanced Usage sizeAll(iSys) the total number of incoming and outgoing partons in the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage getAll(iSys, iMem) the position Advanced Usage iPos of an incoming or outgoing parton in the Advanced Usage iSys 'th subcollision. In case there are beams it gives same as Advanced Usage getInA(iSys) and Advanced Usage getInB(iSys) for indices 0 and 1, and thereafter agrees with Advanced Usage getOut(iSys, iMem) offset two positions. In case there is an incoming (decaying) resonance set for the system, it gives the same as Advanced Usage getInRes(iSys) for index 0, and thereafter agrees with Advanced Usage getOut(iSys, iMem) offset one position. If there are neither beams nor an incoming resonance set for the system, it is identical with Advanced Usage getOut(iSys, iMem). Advanced Usage Advanced Usage getSystemOf(iPos, alsoIn) returns the system ( Advanced Usage iSys ) of the parton specified by Advanced Usage iPos. If the parton is outgoing in one system and incoming in another (eg a decaying resonance), the system in which it is incoming will be returned if Advanced Usage alsoIn == true , else the system in which it is outgoing will be returned. The default is Advanced Usage alsoIn = false. Advanced Usage Advanced Usage getSHat(iSys) the invariant squared mass Advanced Usage sHat of the Advanced Usage iSys 'th subcollision. Advanced Usage Advanced Usage list() print a listing of all the system information, except for the Advanced Usage sHat values. Advanced Usage New systems are created from the hard process, from resonance decays, and by the MPI, not from  any of the other components. Both FSR and ISR modify the position of partons, however. Since an FSR or ISR branching typically implies a new state with one more parton than before, an outgoing parton must be added to the system. Furthermore, in a branching, several existing partons may also be moved to new slots, including the incoming beam ones. In a FSR Advanced Usage 1 &rarr; 2 branching it is irrelevant which parton position you let overwrite the existing slot and which is added to the end of the system. Advanced Usage The system information must be kept up-to-date. Both the MPI, ISR, FSR and BR descriptions make extensive use of the existing information. As an example, the introduction of primordial Advanced Usage kT in the beam remnants will fail if the information on which final-state partons belong to which system is out-of-date. The introduction of rescattering as part of the MPI framework adds further complications, where an outgoing parton of one subsystem may be the incoming one of another system. This part of the code is still under development. Advanced Usage Currently the system information is kept throughout the continued history of the event. Specifically, resonance decays create new systems, appended to the existing ones. This could be useful during the hadronization stage, to collect the partons that belong to a resonance with preserved mass when a small string collapses to one particle, but is not yet used for that. Advanced Usage The beams The different subsystems are tied together by them sharing the same initial beam particles, and thereby being restricted by energy-momentum and flavour conservation issues. The information stored in the two beam particles, here called Advanced Usage beamA and Advanced Usage beamB , is therefore as crucial to keep correct as the above subsystem list. Advanced Usage Both beam objects are of the Advanced Usage BeamParticle class. Each such object contains a vector with the partons extracted from it. The number of such partons, Advanced Usage beamX.size() (X = A or B), of course is the same as the above number of subsystems in the event record. (The two diverge at the BR step, where further beam remnants are added to the beams without corresponding to new subsystems.) The individual partons are accessed by an overloaded indexing operator to a vector of Advanced Usage ResolvedParton objects. The Advanced Usage iPos() property corresponds to the Advanced Usage iPos one above, i.e. providing the position in the main event record of a parton. In particular, Advanced Usage beamA[iSys].iPos() = partonSystemsPtr->getInA(iSys) and Advanced Usage beamB[iSys].iPos() = partonSystemsPtr->getInB(iSys). Whereas thus the indices of the two incoming partons to a subsystem are stored in two places, the ones of the outgoing partons only appear in the system part of the Advanced Usage PartonSystems class. Advanced Usage Just as the subsystems in Advanced Usage PartonSystems must be updated, so must the information in the two Advanced Usage BeamParticle 's, e.g. with methods Advanced Usage beamX[iSys].iPos( iPosIn) when an incoming parton is replaced by a new one in line Advanced Usage iPosIn. Furthermore the new parton identity should be set by Advanced Usage beamX[iSys].id( idIn) and the new Advanced Usage x energy-momentum fraction by Advanced Usage beamX[iSys].x( xIn). The three can be combined in one go by Advanced Usage beamX[iSys].update( iPosIn, idIn, xIn). Advanced Usage To be specific, it is assumed that, at each step, the two incoming partons are moving along the Advanced Usage +-z axis and are massless. Since the event is constructed in the c.m. frame of the incoming beams this implies that Advanced Usage x = 2 E / E_cm. If the Advanced Usage x values are not defined accordingly or not kept up-to-date the BR treatment will not conserve energy-momentum. Advanced Usage In return, the Advanced Usage BeamParticle objects give access to some useful methods. The Advanced Usage beamX.xf( id, x, Q2) returns the standard PDF weight Advanced Usage x f_id(x, Q^2). More interestingly, Advanced Usage beamX.xfISR( iSys, id, x, Q2) returns the modified weight required when several subsystems have to share the energy and flavours. Thus Advanced Usage iSys is added as an extra argument, and the momentum already assigned to the other subsystems is not available for evolution, i.e. the maximal Advanced Usage x is correspondingly smaller than unity. Also flavour issues are handled in a similar spirit. Advanced Usage An additional complication is that a parton can be either valence or sea, and in the latter case the BR treatment also distinguishes companion quarks, i.e. quark-antiquark pairs that are assumed to come from the same original Advanced Usage g &rarr; q qbar branching, whether perturbative or not. This can be queried either with the Advanced Usage beamX[iSys].companion() method, for detailed information, or with the Advanced Usage beamX[iSys].isValence() , Advanced Usage beamX[iSys].isUnmatched() and Advanced Usage beamX[iSys].isCompanion() methods for yes/no answers whether a parton is valence, unmatched sea or matched sea. This choice should affect the ISR evolution; e.g., a valence quark cannot be constructed back to come from a gluon. Advanced Usage To keep this info up-to-date, the Advanced Usage beamX.pickValSeaComp() method should be called whenever a parton of a new flavour has been picked in the ISR backwards evolution, but not if the flavour has not been changed, since then one should not be allowed to switch back and forth between the same quark being considered as valence or as sea. Since the Advanced Usage pickValSeaComp() method makes use of the current parton-density values, it should be preceded by a call to Advanced Usage beamX.xfISR( iSys, id, x, Q2) , where the values in the call are the now finally accepted ones for the newly-found mother. (Such a call is likely to have been made before, during the evolution, but is not likely to be the most recent one, i.e. still in memory, and therefore had better be redone.)"},{"name":"ALPGEN Event Interface","link":"AlpgenEventInterface.html","text":"ALPGEN Event Interface ALPGEN Event Interface ALPGEN Event Interface This manual page describes the ALPGEN ALPGEN Event Interface Man03 event interface for PYTHIA8.  While future versions of ALPGEN will be able to write out events in LHEF format, previous versions always output events in an ALPGEN native format (a combination of a '.unw' and a '_unw.par' file). The ALPGEN component of this code contains a reader for this native format (for unweighted events), as well as parameter reading for both ALPGEN native and LHE file formats. The reader was designed to work together with an implementation of the ALPGEN-style parton-jet matching ALPGEN Event Interface JetMatchingAlpgen described on the ALPGEN Event Interface Jet Matching page. However, it will also work with a implementation of the Madgraph-style ALPGEN Event Interface Alw11 parton-jet matching ALPGEN Event Interface JetMatchingMadgraph also described on the ALPGEN Event Interface Jet Matching page. A sensible choice of ALPGEN Event Interface JetMatching parameters is needed when using ALPGEN files with Madgraph-style matching and vice versa. ALPGEN Event Interface It should be noted that all the functionality described here is provided through external routines, and therefore the presence of these features is dependent on the main program being used. This structure allows for the easy extensibility of the merging scheme. The files of interest are located in the ALPGEN Event Interface include/Pythia8Plugins/ subdirectory: ALPGEN Event Interface ALPGEN Event Interface ALPGEN Event Interface GeneratorInput.h : provides three classes for the reading of ALPGEN event and parameter files. ALPGEN Event Interface LHAupAlpgen is an ALPGEN Event Interface ALPGEN Event Interface LHAup derived class for reading in ALPGEN native format event files. ALPGEN Event Interface AlpgenPar is a class for the parsing of ALPGEN parameter files, making the information available through a simple interface. ALPGEN Event Interface AlpgenHooks is a ALPGEN Event Interface ALPGEN Event Interface UserHooks derived class that provides the ALPGEN Event Interface Alpgen:* options, described below. Further technical details of these classes are given at the end of this manual page. ALPGEN Event Interface ALPGEN Event Interface main32.cc, main32.cmnd : a sample main program and card file showing the usage of previous file and an MLM ALPGEN Event Interface UserHooks class. In combination, it reads in a sample ALPGEN (or Madgraph) event file while performing the MLM merging procedure as implemented in ALPGEN (or as in Madgraph). Some commented-out sets of options are provided in the card file, which can be activated to try different merging setups. ALPGEN Event Interface ALPGEN Event Interface main32.unw, main32_unw.par : an ALPGEN format event and parameter file containing 100 W + 3 jet events. It is not feasible to package large event files with the PYTHIA distribution, but this sample is enough to show the different components in action. ALPGEN Event Interface ALPGEN main options These following options are provided by the AlpgenHooks class, which must be loaded for this functionality to be present ALPGEN Event Interface ALPGEN event files that have been written out in LHEF format should be read in through the normal LHEF machinery (see ALPGEN Event Interface Beam Parameters ). Files in ALPGEN's native format, instead, may be processed using the ALPGEN Event Interface Alpgen:file option below. When using this option, the ALPGEN parameter file is stored in the PYTHIA Info object under the key ALPGEN Event Interface AlpgenPar , see the 'Header information' section of the ALPGEN Event Interface Event Information manual page for more details. Processes not implemented by the PYTHIA 6 interface supplied with ALPGEN are also not implemented here. ALPGEN Event Interface When reading in ALPGEN native event files, some momenta are shifted by the file reader to ensure energy-momentum conservation. The magnitude of these shifts should be small (around the MeV level in the worst case) and warnings will be produced if they are above a set threshold. A large number of warnings may signify unexpected behaviour and should potentially be investigated. It is also known that certain event classes, for example an event with both light and heavy ALPGEN Event Interface b quarks may give rise to these warnings. ALPGEN Event Interface The ALPGEN file reader supports the reading of the event and parameter files in gzip format with file extensions '.unw.gz' and '_unw.par.gz' respectively. This requires the use of external libraries, however, and the ALPGEN Event Interface README file in the main directory contains instructions on how to enable this. ALPGEN Event Interface All other ALPGEN Event Interface Alpgen:* options apply to both LHE and native file formats, and include options to guide the MLM merging procedure based on the parameters that are read in with the events file. ALPGEN Event Interface Class information Some more technical information about the different classes is given below. For clarity, some limited information on certain private methods is provided. ALPGEN Event Interface LHAupAlpgen This class is derived from the ALPGEN Event Interface ALPGEN Event Interface LHAup base class, and uses the standard machinery to pass initialisation and event data to PYTHIA. These standard functions are not documented here. The complete parameter file is stored in the PYTHIA Info object, if given, under the key ALPGEN Event Interface AlpgenPar. ALPGEN Event Interface AlpgenPar This class parses an ALPGEN parameter file and makes the information available through a simple interface. The information is stored internally in key/value (string/double) format. All lines prior to: ALPGEN Event Interface ************** run parameters are ignored, and in the general case, a line e.g. ALPGEN Event Interface 10  3.00000000000000     ! njets would be stored with key 'njets' and value '3.0'. The following lines are special cases where the line may be split or the key translated: ALPGEN Event Interface 3! hard process code  0.000  4.700 174.300  80.419  91.188 120.000! mc,mb,mt,mw,mz,mh  912.905 0.0914176  ! Crosssection +- error (pb)  100 29787.4 ! unwtd events, lum (pb-1) Njob= 2 In the first line, the key 'hard process code' is translated to 'hpc'. In the second, the mass values are split and each given an entry in the internal store. In the third, the cross section and cross section error are stored under the keys 'xsecup' and 'xerrup' respectively. Finally, the number of events and luminosity are stored under the keys 'nevent' and 'lum' respectively. In the event that a duplicate key is present, with differing values, the stored value is overwritten and a warning given. ALPGEN Event Interface AlpgenHooks This ALPGEN Event Interface ALPGEN Event Interface UserHooks derived class provides all the ALPGEN Event Interface Alpgen:* options. It is provided as a UserHooks class such that the code works regardless of whether ALPGEN native or LHE file formats are used. It is declared with virtual inheritance so that it may be combine with other UserHooks classes, see the 'Combining UserHooks' section below."},{"name":"aMC\@NLO Matching","link":"aMCatNLOMatching.html","text":"aMC\\@NLO Matching aMC\\@NLO Matching aMC\@NLO Matching The aMC\@NLO package aMC\\@NLO Matching Fri02 attempts to automate the MC\@NLO matching procedure aMC\\@NLO Matching Fri02. MC\@NLO interprets the parton shower as NLO subtraction method, and removes unwanted parton-shower contributions by extending the subtraction scheme used to generate NLO fixed-order results. Upon showering, an NLO accurate prediction for inclusive observables is achieved. This makes MC\@NLO a convenient NLO+PS matching scheme. A consistent extended subtraction in the NLO fixed-order result makes analytic knowledge of the shower emission probability necessary. Once this is known, interfacing the (parton-shower specific) NLO calculation with the shower is straightforward. aMC\\@NLO Matching To allow for a fast, automatic generation of shower subtractions that are used in the fixed-order calculation, Pythia allows to generate emissions with a 'global' recoil scheme, in which the recoil of an emission is shared among all final state particles. When using aMC\@NLO, this global recoil must be switched on. Please see aMC\\@NLO Matching Timelike Showers for details and options. aMC\\@NLO Matching A minimal set of settings necessary for a consistent treatment of aMC\@NLO inputs is aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching SpaceShower:pTmaxMatch = 1 aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching SpaceShower:pTmaxFudge = 1. aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching TimeShower:pTmaxMatch = 1 aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching TimeShower:pTmaxFudge = 1. aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching SpaceShower:MEcorrections = off aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching TimeShower:MEcorrections = off aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching TimeShower:globalRecoil = on aMC\\@NLO Matching &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; aMC\\@NLO Matching TimeShower:weightGluonToQuark = 1 aMC\\@NLO Matching and further (process-specific) settings related global recoils. aMC\\@NLO Matching Some comments are in order. The settings aMC\\@NLO Matching SpaceShower:pTmaxMatch = 1 , aMC\\@NLO Matching SpaceShower:pTmaxFudge = 1. , aMC\\@NLO Matching TimeShower:pTmaxMatch = 1 , aMC\\@NLO Matching TimeShower:pTmaxFudge = 1. are included to ensure that the correct parton shower starting scale (i.e. the scale set when generating the subtractions in MC\@NLO) is used within Pythia. Note that the last three options are default in Pythia8, and that the first option differs from the default only if the input state does not contain final state partons. aMC\\@NLO Matching Matrix element corrections to the parton shower splitting kernels have to be switched off by aMC\\@NLO Matching SpaceShower:MEcorrections = off and aMC\\@NLO Matching TimeShower:MEcorrections = off. This is necessary because the matrix element corrections are not suitable for showers in the global recoil scheme, and because it is not viable to include process-specific shower probabilities in an automatic framewrok like aMC\@NLO. aMC\\@NLO Matching aMC\\@NLO Matching TimeShower:globalRecoil = on is necessary. Formally, it is allowed to switch back to a local recoil treatment beyond the first proposed emission of any of the hard scattering partons in Born-type events. Pythia offers three choices at which stage the global recoil is dropped in favour of a local strategy. It is necessary to supplement the setting aMC\\@NLO Matching TimeShower:globalRecoil = on by additional settings specifying which global recoil strategy should be used. As these choices are up to the user, please consult aMC\\@NLO Matching Timelike Showers for details on these options. aMC\\@NLO Matching aMC\\@NLO Matching Finally, aMC\\@NLO Matching TimeShower:weightGluonToQuark = 1 is not default any longer, but was it at the time the subtractions were first implemented, and so is required  for consistency until further notice."},{"name":"Automated Variations of Shower Parameters","link":"Variations.html","text":"Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters for Uncertainty Bands While a number of different central 'tunes' of the Pythia parameters are provided, it is often desired  to study how event properties change when some of the parameters (such as those describing the parton showers) are varied.  Pythia8 now has the ability to provide a series of weights to reflect the change in probability for a particular final state to occur when a subset of parton-shower parameters are varied.  Details on the implementation and interpretation of these weights can be found in Automated Variations of Shower Parameters Mre16. Currently, the list of available automated variations (see Automated Variations of Shower Parameters full list below ) includes: Automated Variations of Shower Parameters Automated Variations of Shower Parameters The renormalization scale for QCD emissions in FSR; Automated Variations of Shower Parameters The renormalization scale for QCD emissions in ISR; Automated Variations of Shower Parameters The inclusion of non-singular terms in QCD emissions in FSR; Automated Variations of Shower Parameters The inclusion of non-singular terms in QCD emissions in ISR. Automated Variations of Shower Parameters The PDF members of a PDF family in LHAPDF6. Automated Variations of Shower Parameters Individual PDF members of a PDF family in LHAPDF6. Similar variations would be possible for QED emissions, but these have not yet been implemented. Automated Variations of Shower Parameters Since the computation of the uncertainty variations takes additional CPU time (albeit much less than would be required for independent runs with the equivalent variations), the automated uncertainty variations are switched off by default. Automated Variations of Shower Parameters The main intended purpose of these variations is to estimate perturbative uncertainties associated with the parton showers. Due to the pole at LambdaQCD, however, branchings near the perturbative cutoff can nominally result in very large reweighting factors, which is unwanted for typical applications. We therefore enable to limit the absolute (plus/minus) magnitude by which alphaS is allowed to vary by Automated Variations of Shower Parameters Likewise, non-singular-term variations are mainly intended to capture uncertainties related to missing higher-order tree-level matrix elements and are hence normally uninteresting for very soft branchings. The following parameter allows to switch off the variations of non-singular terms below a fixed perturbative threshold: Automated Variations of Shower Parameters By default, the automated shower uncertainty variations are enabled for the showers off the hardest interaction (and associated resonance decays), but not for the showers off MPI systems which would be more properly labeled as underlying-event uncertainties. If desired, the variations can be applied also to showers off MPI systems via the following switch: Automated Variations of Shower Parameters The following parameters allow one to switch off all variations below a fixed threshold.  It is specified in terms of a multiplier for the Automated Variations of Shower Parameters TimeShower:pTmin squared (FSR) or Automated Variations of Shower Parameters SpaceShower:pT0Ref squared (ISR). A separate cutoff can be specified for ISR or FSR: Automated Variations of Shower Parameters To ensure coverage of the phase space for the variations, the overestimate of the Sudakov used in the veto algorithm is artifically increased, which is compensated in the rejection factor. A larger factor reduces fluctuations at the cost of a longer generation time. The default parameters chosen are a compromise between time and fluctuations. Automated Variations of Shower Parameters The user can control whether the variations are calculated in all or specific stages of the event generation: Automated Variations of Shower Parameters Automated Variations of Shower Parameters UserHooks Warning: the calculation of uncertainty variations will only be consistent in the absence of any external modifications to the shower branching probabilities via the Automated Variations of Shower Parameters UserHooks framework. It is therefore strongly advised to avoid combining the automated uncertainty calculations with any such UserHooks modifications. Automated Variations of Shower Parameters Automated Variations of Shower Parameters Merging Warning: in multi-jet merging approaches, trial showers are used to generate missing Sudakov factor corrections to the hard matrix elements. Currently that framework is not consistently combined with the variations introduced here, so the two should not be used simultaneously. This restriction will be lifted in a future release. Automated Variations of Shower Parameters Specifying the Variations When Automated Variations of Shower Parameters UncertaintyBands:doVariations is switched on, the user can define an arbitrary number of (combinations of) uncertainty variations to perform. Each variation is defined by a string with the following generic format: Automated Variations of Shower Parameters Label keyword1=value keyword2=value ... where the user has complete freedom to specify the label, and each keyword must be selected from the Automated Variations of Shower Parameters list of currently recognised keywords below. Instead of an equal sign it is also possible to leave a blank between a keyword and its value. Automated Variations of Shower Parameters To exemplify, an uncertainty variation corresponding to simultaneously increasing both the ISR and FSR renormalisation scales by a factor of two would be defined as follows Automated Variations of Shower Parameters myVariation1 fsr:muRfac=2.0 isr:muRfac=2.0 Automated Variations of Shower Parameters Staying within the context of this example, the user might also want to check what a variation of the two scales independently of each other would produce. This can be achieved within the same run by adding two further variations, as follows: Automated Variations of Shower Parameters myVariation2 fsr:muRfac=2.0    myVariation3 isr:muRfac=2.0 Different histograms can then be filled with each set of weights as desired (see Automated Variations of Shower Parameters accessing the uncertainty weights below). Variations by smaller or larger factors can obviously also be added in the same way, again within one and the same run. Automated Variations of Shower Parameters Once a list of variations defined as above has been decided on, the whole list should be passed to Pythia in the form of a single Automated Variations of Shower Parameters 'vector of strings' , defined as follows: Automated Variations of Shower Parameters For completeness, we note that a command-file specification equivalent to the above default variations could look as follows: Automated Variations of Shower Parameters UncertaintyBands:List = {      alphaShi fsr:muRfac=0.5 isr:muRfac=0.5,      alphaSlo fsr:muRfac=2.0 isr:muRfac=2.0,      hardHi fsr:cNS=2.0 isr:cNS=2.0,      hardLo fsr:cNS=-2.0 isr:cNS=-2.0    } Note that each of the individual uncertainty-variation definitions (the elements of the vector) are separated by commas and that keywords separated only by spaces are interpreted as belonging to a single combined variation. Note also that the beginning and end of the vector is marked by curly braces. Automated Variations of Shower Parameters Accessing the Uncertainty Weights During the event generation, uncertainty weights will be calculated for each variation defined above, via the method described in Automated Variations of Shower Parameters Mre16. The resulting alternative weights for the event are accessible through the Automated Variations of Shower Parameters Pythia::info.weight(int iWeight=0) method. Automated Variations of Shower Parameters The baseline weight for each event (normally unity for an ordinary unweighted event sample) is not modified and corresponds to Automated Variations of Shower Parameters iWeight = 0. The uncertainty-variation weights are thus enumerated starting from Automated Variations of Shower Parameters iWeight = 1 for the first variation up to Automated Variations of Shower Parameters N for the last variation, in the order they were specified in Automated Variations of Shower Parameters UncertaintyBands:List. Automated Variations of Shower Parameters The total number of variations that have been defined, Automated Variations of Shower Parameters N , can be queried using Automated Variations of Shower Parameters Pythia::info.nWeights(). Automated Variations of Shower Parameters NLO Compensation Term for Renormalisation-Scale Variations Additionally, there is a run-time parameter: Automated Variations of Shower Parameters List of Recognised Keywords for Uncertainty Variations The following keywords adjust the renormalisation scales and non-singular terms for all FSR and ISR branchings, respectively: Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:muRfac : multiplicative factor applied to the renormalization scale for FSR branchings. Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:muRfac : multiplicative factor applied to the renormalization scale for ISR branchings. Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:cNS : additive non-singular ('finite') term in the FSR splitting functions. Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:cNS : additive non-singular ('finite') term in the ISR splitting functions. Note that the Automated Variations of Shower Parameters muRfac parameters are applied linearly to the renormalisation scale, hence &mu; Automated Variations of Shower Parameters 2 &rarr; ( Automated Variations of Shower Parameters muRfac ) Automated Variations of Shower Parameters 2 *&mu; Automated Variations of Shower Parameters 2. Automated Variations of Shower Parameters The keywords for PDF variations (plus and minus) is: Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:PDF:plus : any number Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:PDF:minus : any number The number is not used, but is there for syntactical consistency. Note, this uses the formula from the LHAPDF6 library to calculate the variation. Automated Variations of Shower Parameters Alternatively, the variation from the default to any other individual PDF member is calculated using the following syntax: Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:PDF:member : member number To force the calculation for ALL members of the PDF family, then use: Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters isr:PDF:family : any number The number is not used. Automated Variations of Shower Parameters Optionally, a further level of detail can be accessed by specifying variations for specific types of branchings, with the global keywords above corresponding to setting the same value for all branchings. Using the Automated Variations of Shower Parameters fsr:muRfac parameter for illustration, the individual branching types that can be specified are: Automated Variations of Shower Parameters Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:G2GG:muRfac : variation for g&rarr;gg branchings. Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:Q2QG:muRfac : variation for q&rarr;qg branchings. Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:G2QQ:muRfac : variation for g&rarr;qqbar branchings. Automated Variations of Shower Parameters Automated Variations of Shower Parameters fsr:X2XG:muRfac : variation for gluon bremsstrahlung off other types of particles (such as coloured new-physics particles). For the distinction between Automated Variations of Shower Parameters Q2QG and Automated Variations of Shower Parameters X2XG , the following switch can be used to control whether Automated Variations of Shower Parameters b and Automated Variations of Shower Parameters t quarks are considered to be Automated Variations of Shower Parameters Q or Automated Variations of Shower Parameters X particles (e.g. providing a simple way to control top-quark or bottom-quark radiation independently of the rest of the shower uncertainties):"},{"name":"Beam Parameters","link":"BeamParameters.html","text":"Beam Parameters Beam Parameters Beam Parameters The settings on this page relate to the beam identities and energies, to a beam momentum spread and to a beam interaction spot. As always, momenta and energies are to be given in units of GeV, and of space and time in mm. Beam Parameters Incoming beams The identities and energies of the two incoming beam particles should be specified using the settings in this section. Note that, if nothing is done, you will default to LHC at 14 TeV. Beam Parameters Currently the beam particles must be either a hadron pair, a lepton pair, a photon pair, a lepton and a hadron or a photon and a hadron. In the first category Beam Parameters p p and Beam Parameters pbar p combinations dominate, but it is also possible to combine with Beam Parameters pi^+ , Beam Parameters pi^- and Beam Parameters pi^0. In the second Beam Parameters e^+ e^- and Beam Parameters mu^+ mu^- would be the most useful combinations, but also others should work if combined with an appropriate hard process. Beam Parameters Variable collision energy There are two different machineries that can provide an event-by-event spread of collision energies. The one in this section is intended to allow for very large variations in collision energy, more-or-less from threshold to the highest LHC/FCC/cosmic-ray energies. This is made possible by interpolation in a grid of CM energies. Such a strategy requires the processes to have a smooth and well-understood energy dependence. In practice this limits us to the soft QCD processes betweeen two incoming hadrons. Thus the framework is convenient e.g. for studies of cosmic-ray cascades, or for secondary collisions in general. Beam Parameters The core extension in this option is that the multiparticle interactions (MPI) machinery is initialized over a (logarithmically spaced) grid of collision energies, from the maximal energy provided at the initialization down to a lower cutoff (see Beam Parameters eMinPert below). For each new event, with a new CM energy, a suitable interpolation is then performed among the generation coefficients determined at initialization. The MPI framework is what is needed to simulate hadronic nondiffractive events ( Beam Parameters SoftQCD:nonDiffractive ). Pretty much the same strategy is already used for diffraction, to handle MPIs inside the variable-mass diffractive systems. Thus all the Beam Parameters Soft QCD processes can be used within this framework. It is not possible to generate other processes with this framework, however, and the program will abort if you try. Beam Parameters The initalization of involves setting up optimal coefficients for the kinematics selection in the subsequent MPI generation, and finding the associated maximum of the differentialcross section. At a fixed energy this typically takes less than a second, and so normally is not noticeable.It is a major fraction of the full PYTHIA initialization time, however. Thus the initialization over a grid of energies raises the total initialization time appreciable, to the order of ten seconds. Initialization of diffraction contributes comparable numbers, when switched on. You should therefore not be surprised that the startup time is longer than usual. The subsequent event generation should not become noticeably slower, however. Beam Parameters There are three main settings in this framework. Beam Parameters To input the variable energy, the normal argument-less Beam Parameters Pythia::next() method has three siblings that take relevent arguments as required by the Beam Parameters Beams:frameType. Beam Parameters Beam momentum spread This framework currently is intended for a modest beam spread, such as experienced at hadron colliders. Thus it can be safely assumed that the physics does not change over the CM energy range probed, so that the parameters of the physics initialization at the nominal energy can be used as is. Therefore it can be used for all processes implemented in PYTHIA. It can Beam Parameters not be used for the more extensive energy spread, however, e.g. as expected at linear Beam Parameters e^+ e^- colliders. Also, any attempt to combine it with external Les Houches input of parton-level events is at own risk. This option cannot be combined with the variable-collision-energy option above, but will be switced off in such a case. Beam Parameters On this page you can set the momentum spread according to a simple Gaussian distribution. If you instead want a more sophisticated parametrization, you can write and link your own Beam Parameters Beam Parameters BeamShape class. Beam Parameters Beam interaction vertex On this page you can set the spread of the interaction vertex according to a simple Gaussian distribution. If you instead want a more sophisticated parametrization, you can write and link your own Beam Parameters Beam Parameters BeamShape class. Beam Parameters The distributions above are all centered at the origin. It is also possible to shift the above distributions to be centered around another nominal position. You must have Beam Parameters Beams:allowVertexSpread = on to use this possibility."},{"name":"Beam Remnants","link":"BeamRemnants.html","text":"Beam Remnants Beam Remnants Beam Remnants Beam Remnants Introduction The Beam Remnants BeamParticle class contains information on all partons extracted from a beam (so far). As each consecutive multiparton interaction defines its respective incoming parton to the hard scattering a new slot is added to the list. This information is modified when the backwards evolution of the spacelike shower defines a new initiator parton. It is used, both for the multiparton interactions and the spacelike showers, to define rescaled parton densities based on the Beam Remnants x and flavours already extracted, and to distinguish between valence, sea and companion quarks. Once the perturbative evolution is finished, further beam remnants are added to obtain a consistent set of flavours. The current physics framework is further described in Beam Remnants Sjo04. Beam Remnants The introduction of Beam Remnants rescattering in the multiparton interactions framework further complicates the processing of events. Specifically, when combined with showers, the momentum of an individual parton is no longer uniquely associated with one single subcollision. Nevertheless the parton is classified with one system, owing to the technical and administrative complications of more complete classifications. Therefore the addition of primordial Beam Remnants kT to the subsystem initiator partons does not automatically guarantee overall Beam Remnants pT conservation. Various tricks are used to minimize the mismatch, with a brute force shift of all parton Beam Remnants pT 's as a final step. Beam Remnants Much of the above information is stored in a vector of Beam Remnants ResolvedParton objects, which each contains flavour and momentum information, as well as valence/companion information and more. The Beam Remnants BeamParticle method Beam Remnants list() shows the contents of this vector, mainly for debug purposes. Beam Remnants The Beam Remnants BeamRemnants class takes over for the final step of adding primordial Beam Remnants kT to the initiators and remnants, assigning the relative longitudinal momentum sharing among the remnants, and constructing the overall kinematics and colour flow. This step couples the two sides of an event, and could therefore not be covered in the Beam Remnants BeamParticle class, which only considers one beam at a time. Beam Remnants The methods of these classes are not intended for general use, and so are not described here. Beam Remnants In addition to the parameters described on this page, note that the choice of Beam Remnants parton densities is made in the Beam Remnants Pythia class. Then pointers to the pdf's are handed on to Beam Remnants BeamParticle at initialization, for all subsequent usage. Beam Remnants Primordial Beam Remnants kT The primordial Beam Remnants kT of initiators of hard-scattering subsystems are selected according to Gaussian distributions in Beam Remnants p_x and Beam Remnants p_y separately. The widths of these distributions are chosen to be dependent on the hard scale of the central process and on the mass of the whole subsystem defined by the two initiators: Beam Remnants sigma = (sigma_soft * Q_half + sigma_hard * Q) / (Q_half + Q)  * m / (m + m_half * y_damp) Here Beam Remnants Q is the hard-process renormalization scale for the hardest process and the Beam Remnants pT scale for subsequent multiparton interactions, Beam Remnants m the mass of the system, and Beam Remnants sigma_soft , Beam Remnants sigma_hard , Beam Remnants Q_half , Beam Remnants m_half and Beam Remnants y_damp parameters defined below. Furthermore each separately defined beam remnant has a distribution of width Beam Remnants sigma_remn , independently of kinematical variables. Beam Remnants A net Beam Remnants kT imbalance is obtained from the vector sum of the primordial Beam Remnants kT values of all initiators and all beam remnants. This quantity is compensated by a shift shared equally between all partons, except that the dampening factor Beam Remnants m / (m_half + m) is again used to suppress the role of small-mass systems. Beam Remnants Note that the current Beam Remnants sigma definition implies that Beam Remnants <pT^2> = <p_x^2>+ <p_y^2> = 2 sigma^2. It thus cannot be compared directly with the Beam Remnants sigma of nonperturbative hadronization, where each quark-antiquark breakup corresponds to Beam Remnants <pT^2> = sigma^2 and only for hadrons it holds that Beam Remnants <pT^2> = 2 sigma^2. The comparison is further complicated by the reduction of primordial Beam Remnants kT values by the overall compensation mechanism. Beam Remnants Colour flow The colour in the separate subproccsses are tied together via the assignment of colour flow in the beam remnants. The assignment of colour flow is not known from first principles and therefore it is not an unambiguous procedure. Thus two different models have been implemented in Beam Remnants Pythia. These will be referred to as new and old, based on the time of the implementation. Beam Remnants The old model tries to reconstruct the colour flow in a way that a LO PS would produce the beam remnants. The starting point is the junction structure of the beam particle (if it is a baryon). The gluons are attached to a quark line and quark-antiquark pairs are added as if coming from a gluon splittings. Thus this model captures the qualitative behaviour that is expected from leading colour QCD. The model is described in more detail in Beam Remnants Sjo04. Beam Remnants The new model is built on the full SU(3) colour structure of QCD. The starting point is the scattered partons from the MPI. Each of these are initially assumed uncorrelated in colour space, allowing the total outgoing colour configuration to be calculated as an SU(3) product. Since the beam particle is a colour singlet, the beam remnant colour configuration has to be the inverse of the outgoing colour configuration. The minimum amount of gluons are added to the beam remnant in order to obtain this colour configuration. Beam Remnants The above assumption of uncorrelated MPIs in colour space is a good assumption for a few well separated hard MPIs. However if the number of MPIs become large and ISR is included, such that the energy scale becomes lower (and thus distances becomes larger), the assumption loses its validity. This is due to saturation effects. The modelling of saturation is done in crude manner, as an exponential suppresion of high multiplet states. Beam Remnants None of the models above can provide a full description of the colour flow in an event, however. Therefore additional colour reconfiguration is needed. This is referred to as colour reconnection. Several different models for colour reconnection are implemented, see Beam Remnants Colour Reconection. Beam Remnants Further variables Beam Remnants When assigning relative momentum fractions to beam-remnant partons, valence quarks are chosen according to a distribution like Beam Remnants (1 - x)^power / sqrt(x). This Beam Remnants power is given below for quarks in mesons, and separately for Beam Remnants u and Beam Remnants d quarks in the proton, based on the approximate shape of low- Beam Remnants Q^2 parton densities. The power for other baryons is derived from the proton ones, by an appropriate mixing. The Beam Remnants x of a diquark is chosen as the sum of its two constituent Beam Remnants x values, and can thus be above unity. (A common rescaling of all remnant partons and particles will fix that.) An additional enhancement of the diquark momentum is obtained by its Beam Remnants x value being rescaled by the Beam Remnants valenceDiqEnhance factor."},{"name":"Beam Shape","link":"BeamShape.html","text":"Beam Shape Beam Shape Beam Shape The Beam Shape Beam Parameters page explains how you can set a momentum spread of the two incoming beams, and a spread and offset for the location of the interaction vertex. The spread is based on a simple parametrization in terms of independent Gaussians, however, which is likely to be too primitive for realistic applications. Beam Shape It is therefore possible to define your own class, derived from the Beam Shape BeamShape base class, and hand it in to Pythia with the Beam Shape Beam Shape pythia.setBeamShapePtr( BeamShape*) method. Below we describe what such a class has to do. An explicit toy example is shown in Beam Shape main23.cc. Beam Shape The Beam Shape BeamShape base class has a very simple structure. It only has two main virtual methods. The first, Beam Shape init() , is used for initialization. The second, Beam Shape pick() , selects beam momentum and production vertex in the current event."},{"name":"Bose-Einstein Effects","link":"BoseEinsteinEffects.html","text":"Bose-Einstein Effects Bose-Einstein Effects Bose-Einstein Effects The Bose-Einstein Effects BoseEinstein class performs shifts of momenta of identical particles to provide a crude estimate of Bose-Einstein effects. The algorithm is the BE_32 one described in Bose-Einstein Effects Lon95 , with a Gaussian parametrization of the enhancement. We emphasize that this approach is not based on any first-principles quantum mechanical description of interference phenomena; such approaches anyway have many problems to contend with. Instead a cruder but more robust approach is adopted, wherein BE effects are introduced after the event has already been generated, with the exception of the decays of long-lived particles. The trick is that momenta of identical particles are shifted relative to each other so as to provide an enhancement of pairs closely separated, which is compensated by a depletion of pairs in an intermediate region of separation. Bose-Einstein Effects More precisely, the intended target form of the BE correlations in BE_32 is Bose-Einstein Effects f_2(Q) = (1 + lambda * exp(-Q^2 R^2))      * (1 + alpha * lambda * exp(-Q^2 R^2/9) * (1 - exp(-Q^2 R^2/4))) where Bose-Einstein Effects Q^2 = (p_1 + p_2)^2 - (m_1 + m_2)^2. Here the strength Bose-Einstein Effects lambda and effective radius Bose-Einstein Effects R are the two main parameters. The first factor of the equation is implemented by pulling pairs of identical hadrons closer to each other. This is done in such a way that three-momentum is conserved, but at the price of a small but non-negligible negative shift in the energy of the event. The second factor compensates this by pushing particles apart. The negative Bose-Einstein Effects alpha parameter is determined iteratively, separately for each event, so as to restore energy conservation. The effective radius parameter is here Bose-Einstein Effects R/3 , i.e. effects extend further out in Bose-Einstein Effects Q. Without the dampening Bose-Einstein Effects (1 - exp(-Q^2 R^2/4)) in the second factor the value at the origin would become Bose-Einstein Effects f_2(0) = (1 + lambda) * (1 + alpha * lambda) , with it the desired value Bose-Einstein Effects f_2(0) = (1 + lambda) is restored. The end result can be viewed as a poor man's rendering of a rapidly dampened oscillatory behaviour in Bose-Einstein Effects Q. Bose-Einstein Effects Further details can be found in Bose-Einstein Effects Lon95. For instance, the target is implemented under the assumption that the initial distribution in Bose-Einstein Effects Q can be well approximated by pure phase space at small values, and implicitly generates higher-order effects by the way the algorithm is implemented. The algorithm is applied after the decay of short-lived resonances such as the Bose-Einstein Effects rho , but before the decay of longer-lived particles. Bose-Einstein Effects This algorithm is known to do a reasonable job of describing BE phenomena at LEP. It has not been tested against data for hadron colliders, to the best of our knowledge, so one should exercise some judgment before using it. Therefore by default the master switch Bose-Einstein Effects HadronLevel:BoseEinstein is off. Furthermore, the implementation found here is not (yet) as sophisticated as the one used at LEP2, in that no provision is made for particles from separate colour singlet systems, such as Bose-Einstein Effects W 's and Bose-Einstein Effects Z 's, interfering only at a reduced rate. Bose-Einstein Effects Bose-Einstein Effects Warning: The algorithm will create a new copy of each particle with shifted momentum by BE effects, with status code 99, while the original particle with the original momentum at the same time will be marked as decayed. This means that if you e.g. search for all Bose-Einstein Effects pi+- in an event you will often obtain the same particle twice. One way to protect yourself from unwanted doublecounting is to use only particles with a positive status code, i.e. ones for which Bose-Einstein Effects event[i].isFinal() is Bose-Einstein Effects true. Bose-Einstein Effects Main parameters Assuming you have set Bose-Einstein Effects HadronLevel:BoseEinstein = on , you can regulate the detailed behaviour with the following settings."},{"name":"CKKW-L Merging","link":"CKKWLMerging.html","text":"CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L merging CKKW-L Merging Lon01 allows for a consistent combination of tree-level matrix elements containing multiple well-separated partons with each other and with parton showers. The result is a calculation that contains a mix of processes with different number of well-separated jets with fixed-order accuracy, improved by all-order resummation. The algorithm implemented  in PYTHIA is described in CKKW-L Merging Lon11. To perform matrix element merging,  the user has to supply LHE files CKKW-L Merging Alw07 for the hard process and the corresponding process with up to N additional jets. This mix of processes is then internally disentangled to ensure that the inclusive fixed-order inputs can be converted to exclusive cross sections that no longer overlap. Please note that subtleties (and setting scheme) for the EW-improved way of disentangling processes presented in CKKW-L Merging Chr15a is discussed in the section Electroweak Merging below. CKKW-L Merging The usage of the merging procedure is illustrated in a few example main  programs ( CKKW-L Merging main81.cc , CKKW-L Merging main82.cc , CKKW-L Merging main83.cc , CKKW-L Merging main84.cc and CKKW-L Merging main85.cc , together with the input files CKKW-L Merging main81.cmnd , CKKW-L Merging main82.cmnd , CKKW-L Merging main84.cmnd and CKKW-L Merging main85.cmnd ). These examples should of course only serve as  an illustration, and as such will not make use of the merging in all  possible ways. For full generality, the example programs link to LHAPDF,  FastJet and HepMC. Of course the user is welcome to  remove these dependencies. To remove the FastJet dependence, the functions calculating example observables have to be deleted. Removing the LHAPDF  dependence requires changing the cmnd input files to choose an inbuilt PDF,  as outlined in the CKKW-L Merging PDF documentation.  The HepMC dependence can be removed by erasing the code allowing for HepMC output. CKKW-L Merging Please note that a detailed tutorial on merging in Pythia is available from CKKW-L Merging http://home.thep.lu.se/Pythia/pythia8/mergingworksheet8160.pdf. CKKW-L Merging Three very short LHE files ( CKKW-L Merging w+_production_lhc_0.lhe , CKKW-L Merging w+_production_lhc_1.lhe , CKKW-L Merging w+_production_lhc_2.lhe ) are included in the distribution. These files are not intended for physics  studies, but only serve as input for the example main programs. For  realistic studies, the user has to supply LHE files. CKKW-L Merging In the generation of LHE files, the value of the factorisation scale used in  the PDFs is not important, since the cross section will be multiplied by ratios  of PDFs to adjust to the PYTHIA starting scales. The same is true for the  renormalisation scale (and starting value CKKW-L Merging &alpha; CKKW-L Merging s (M CKKW-L Merging Z ) )  used to evaluate CKKW-L Merging &alpha; CKKW-L Merging s. Coupling and scale choices by the user will be transferred to the merging routines. CKKW-L Merging Multi-jet events can suffer from infrared divergences in the calculation. Sensible matrix element generator (MEG) outputs should not contain phase space points in which the calculation is ill-defined, meaning infrared regions need to be removed by cuts. This is most conveniently done by disallowing the MEG to produce partons below a minimal parton-parton separation in a certain jet algorithm. Using dedicated cuts to regularise MEG output is of course possible as well. Any regularisation criterion defines the matrix element region: The parts of phase space in which the fixed order calculation is considered valid and preferable to the parton shower. Matrix element merging is combining MEG events in the matrix element region with parton shower events in regions outside the regularisation cut (often called parton shower region). Because the regularisation cut defines a boundary between the matrix element and parton shower regions, i.e. the regions to be merged into one inclusive sample, it is usually called CKKW-L Merging merging scale. Since many different cut choices may regularise the MEG calculation, many different merging scale definitions are possible. A few standard choices are listed below, as well as documentation on how to use a user-defined cut criterion. In combining matrix element and parton shower regions, the CKKW-L prescription tries to minimise the dependence on the merging scale. This can only be achieved if the combination of MEG events and parton shower populates the whole phase space. Additional cuts on the partons in the LHEF generation should hence be avoided as much as possible, meaning that the merging scale cut should always pose a more stringent cut than all other cuts on the partons. Of course, if the hard process itself is divergent, cuts need to be made. However, this should be chosen in such a way as to not exclude regions that will be available to the matrix elements with additional jets. An example is QCD di-jet production with additional jets: Say the CKKW-L Merging 2 &rarr; 2 process is regularised with a CKKW-L Merging pTmin cut of pTminCut = 100 GeV, and the CKKW-L Merging 2 - >3 sample is regularised with a CKKW-L Merging kTmin -cut of kTminCut = 50 GeV. This would mean that when reclustering the  emission in the 2 &rarr; 3 sample, we could end up with a CKKW-L Merging pT value CKKW-L Merging pTminNow of the 2 &rarr; 2 configuration with CKKW-L Merging pTminCut > pTminNow , which is excluded in the 2 &rarr; 2 sample. Thus, the 2 &rarr; 3 sample will include a Sudakov factor  not included in the 2 &rarr; 2 sample, resulting in merging scale  dependencies. Such dependencies can be avoided if the additional cuts on the hard process are minimal. CKKW-L Merging Of course, additional cuts on electroweak particles are allowed. These  should be the same for all samples with CKKW-L Merging 0 <= n <= N additional partons. CKKW-L Merging If it is not possible to generate LHE files with minimal cuts, the user can choose to use the CKKW-L Merging MergingHooks structures in order to decide how much influence to attribute to parton shower histories in which the reclustered lowest multiplicity process does not pass the matrix element cuts. This is  described below. CKKW-L Merging When generating LHE files, we advise against putting unstable  particles (e.g. massive gauge bosons) in the final state. Rather, specify a  resonance by its decay products, e.g. if Les Houches events for the CKKW-L Merging pp &rarr; Z + jets &rarr; e+e- + jets process are desired, generate the matrix element events with the CKKW-L Merging Z decay included. From a physical  point of view, on-shell final massive gauge bosons should not be considered  part of a hard process, since only the boson decay products will be detectable.  Furthermore, non-narrow-width approximation contributions are not present if  the ME generator only produces on-shell bosons. Interference effects between  different production channels for the decay products would also be neglected.  These points seem an unnecessary restriction on the accuracy of the ME  calculation.  In addition, there is a technical reason for this strategy. Since  some matrix element generators choose to put additional information on  intermediate bosons into Les Houches events, depending on if they pass a certain criterion (e.g. being close to the mass shell), without exact knowledge of this  criterion, the only feasible way of bookkeeping the hard process is by  identifying outgoing decay products. CKKW-L Merging Despite these considerations, (massive) gauge bosons in the final state are allowed in the hard process definition. This is useful particularly for Higgs physics, when different decays of the Higgs boson need to be simulated after the LHEF generation. CKKW-L Merging For all merging purposes, processes with different charge of outgoing leptons are considered different processes. That means e.g. that CKKW-L Merging e+&nu; CKKW-L Merging e + jets and CKKW-L Merging e-&nu;&#772; CKKW-L Merging e + jets are considered independent processes. If the user wishes to generate distributions including effects of more than one  process, merged samples for all independent processes should be generated  separately and added afterwards. Alternatively, to combine simple processes, combined LHE files can be used in conjunction with flexible containers (see below). CKKW-L Merging When the matrix element merging is used to produce HepMC CKKW-L Merging Dob01 files to be analysed  with RIVET CKKW-L Merging Buc10 , special care  needs to taken in how the cross section is read by RIVET (see below). CKKW-L Merging To specify the merging conditions, additionally information on the merging scale value and the functional definition of the merging scale is needed. A few  standard definitions of merging scales are available. We hope this makes the user interface less cumbersome. CKKW-L Merging Different choices intrinsic to the CKKW-L merging procedure might be relevant for the user as well. The base class CKKW-L Merging MergingHooks gives the user the opportunity to define the functional form of the merging scale.  In the following, the usage of the merging machinery to consistently include LHE files with additional jets into PYTHIA  will be discussed. CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Merging scale definitions CKKW-L Merging The quickest way to include processes with additional jets is to produce LHE files with one of the standard ways to define the merging scale. Three standard ways to define a merging scale (minimal CKKW-L Merging kT , minimal evolution CKKW-L Merging pT and by three cuts) are implemented. All of these prescriptions are equivalent - different definitions have only been introduced for the convenience of users, who might be limited by which cuts can be used in the generation of LHE files. Below, we describe how to switch on and use these different merging scale definitions. CKKW-L Merging Merging with merging scale defined in kT: CKKW-L Merging Currently, the name longitudinally invariant CKKW-L Merging kT is used for a few jet recombination algorithms with slightly different jet measures. A specific form can be chosen by setting the switch CKKW-L Merging If e.g. CKKW-L Merging W + jets merging should be performed, set this to CKKW-L Merging pp>e+ve ( CKKW-L Merging without white spaces or  quotation marks ). This string may contain resonances in the MG/ME notation, e.g. for merging CKKW-L Merging pp&rarr;Z W CKKW-L Merging + &rarr;q q&#772; e+&nu; CKKW-L Merging e + jets , the string CKKW-L Merging pp>(z>jj)(w+>e+ve) would be applicable. CKKW-L Merging A lot more flexible hard process definitions are possible. To not dwell too much on these details here, we will come back to the process string at the end of this section. CKKW-L Merging Merging with merging scale defined in Pythia evolution CKKW-L Merging pT : If the LHE file has been regularised by cutting on the minimal Pythia evolution CKKW-L Merging pT in the state, this can also be used as a merging scale right away. For this, change the switch CKKW-L Merging Merging with merging scale defined by a combination of cuts: It is possible to regularise QCD divergences in a LHE file by applying cuts to the kinematical CKKW-L Merging pT of jets ( CKKW-L Merging pT CKKW-L Merging i ), combined with a cut on CKKW-L Merging &Delta;R CKKW-L Merging ij between jets and a cut on invariant mass CKKW-L Merging Q CKKW-L Merging ij of jet pairs. The combination of these standard cuts can also serve as a merging scale. For this, use this setting CKKW-L Merging The values of the cuts will then be read from CKKW-L Merging With knowledge of these values, and CKKW-L Merging Merging:doCutBasedMerging , Pythia will use these cuts as a separation between matrix element phase space and parton shower region. If e.g. the Les Houches Events have been generated with the cuts CKKW-L Merging &Delta;R CKKW-L Merging ij = 0.1 , CKKW-L Merging pT CKKW-L Merging i = 20 GeV and CKKW-L Merging Q CKKW-L Merging ij = 40 GeV , set CKKW-L Merging Merging:QijMS=40. , CKKW-L Merging Merging:pTjMS=20. , CKKW-L Merging Merging:dRijMS=0.1 to perform a cut-based merging. Of course you will also need to set CKKW-L Merging Merging:Process and the maximal number of additional matrix element jets CKKW-L Merging Merging:nJetMax. CKKW-L Merging Les Houches events outside the matrix element region CKKW-L Merging Before continuing, we would like to point out that in general, the user should make sure that the events in the Les Houches file are actually calculated using the regularisation cut definition and value(s) supplied to Pythia as merging scale definition and value(s). However, if LH files with a large number of events and loose merging scale cuts are available, it might be useful to choose a higher merging scale value, e.g. for merging scale variations as part of uncertainty assessments. If CKKW-L merging is enabled, Pythia will by default check if events read from Les Houches file are in the matrix element region as defined by the merging scale definition and merging scale value. Events outside the matrix element region will be discarded. This will lead to warnings of the form ' CKKW-L Merging Les Houches Event fails merging scale cut. Cut by rejecting event '. These warnings should, in this case, rather be regarded as information. To change the default behaviour, use the flag CKKW-L Merging Defining the hard process To perform CKKW-L matrix element merging, the user has to decide on a hard process, and communicate this choice to Pythia. This is done by setting the input CKKW-L Merging Merging:Process. Note that the EW-improved 'merging of mergings' strategy presented in CKKW-L Merging Chr15a requires a very loose process definition that is discussed in the section Electroweak Merging below. CKKW-L Merging For single processes in the Standard Model or the MSSM a notation similar to MG4/MEis applicable. However, for some purposes, using a single simple process string is not satisfactory. Mixed W CKKW-L Merging + and W CKKW-L Merging - events in a single LHE file is a common example. For this case, it would of course be perfectly allowed to perform twice, once for W CKKW-L Merging + production and once for W CKKW-L Merging - production, and then add the results. Nevertheless, it seems reasonable to alleviate difficulties by allowing for less restrictive hard process definitions. Some generalisations of the process tag are available: Containers, user-defined particle tags and a very rudimentary option to 'guess' the hard process. The syntax of these settings is described below. CKKW-L Merging In case you want multiple processes in a LHE file to be treated on equal footing (e.g. CKKW-L Merging W CKKW-L Merging + + jets and CKKW-L Merging W CKKW-L Merging - + jets ), you should use flexible containers do specify the hard process. So far, we allow the use of the containers CKKW-L Merging LEPTONS , CKKW-L Merging NEUTRINOS , CKKW-L Merging BQUARKS. If you use these containers, the hard process definition is relatively flexible, meaning that Pythia will attempt a merging of QCD jets for each event in the LHE file, and assume that all particles matching one of the containers are products of the hard process. This is best explained by examples. If you want to have both CKKW-L Merging pp &rarr; e+ &nu; CKKW-L Merging e + jets and CKKW-L Merging pp &rarr; e- &nu;&#772; CKKW-L Merging e + jets events in a single file, you can set CKKW-L Merging Merging:Process=pp>LEPTONS,NEUTRINOS as hard process (note that for readability, you are allowed to use commata to separate container names). Combining e.g. the processes CKKW-L Merging pp &rarr; e+ &nu; CKKW-L Merging e and CKKW-L Merging pp &rarr; &mu;+ &nu; CKKW-L Merging &mu; is possible with the hard process definition CKKW-L Merging pp>LEPTONS,NEUTRINOS. CKKW-L Merging For maximal flexibility, the definition of the hard process by these containers does not mean that each Les Houches event needs to contain particles to match each container. It is enough if one container is matched. This means that with the string CKKW-L Merging pp>LEPTONS,NEUTRINOS , you can immediately process CKKW-L Merging pp &rarr; e+ e- events mixed with CKKW-L Merging pp &rarr; e+ &nu; CKKW-L Merging e events, since particles matching at least one container can be found in both cases. Another example for the usage of containers is mixing CKKW-L Merging pp &rarr; e+ &nu; CKKW-L Merging e and CKKW-L Merging pp &rarr; tt&#772; &rarr; e+ &nu; CKKW-L Merging e e- &nu;&#772; CKKW-L Merging e bb&#772;. This can be accommodated by the hard process string CKKW-L Merging Merging:Process=pp>LEPTONS,NEUTRINOS,BQUARKS. CKKW-L Merging There is however a conceptual limitation to containers: The hard process definition is necessary to ensure that when constructing lower multiplicity states (that will be used to calculate the correct merging weight), the structure of the hard process will be preserved. If e.g. we want the hard process to be CKKW-L Merging pp &rarr; Z &rarr; bb&#772; , we should ensure that the lowest multiplicity state contains a colour-singlet bb&#772;-pair. When reconstructing intermediate lower multiplicity states from multi-jet matrix elements, we should thus always be able to find at least one bb&#772;-pair. By mixing different processes in a LHE file, this requirement might already be violated at the level of Les Houches events. Flexible containers cannot give strong conditions which flavours should be preserved in the construction of the hard process. In order to avoid non-sensible results, it is hence CKKW-L Merging assumed that all particles matching any of the containers will be part of the lowest multiplicity process. This implies that if you decide to use the CKKW-L Merging BQUARKS container, all b-quarks in the LHE file will be interpreted as hard process particles, and never as additional radiation. CKKW-L Merging Another way to specify the hard process particles is to explicitly define the particle names and identifiers. This is necessary if the matrix element merging in Pythia does not contain the particles of interest. To make sure that the hard process is still treated correctly, it is possible to define particles in the process string. If you e.g. want the hard process to contain a particle 'zeta~' with PDG identifier '12345', produced in proton collisions, you have to include a user-defined particle tag by setting the process string to CKKW-L Merging pp>{zeta~,12345}. The  user-defined particle is enclosed in curly brackets, with syntax CKKW-L Merging {particle_name,particle_identifier} , where 'particle_name' and 'particle_identifier' are the particle name and particle identifier used for this particle in the input LHE file. User-defined particles are only allowed in the final state. You are free to fix user-defined particles with more common ones, as long as user-defined particles are put before more common particles in the process string. This means that if you e.g. wanted the hard process to contain a graviton in association with a positron and an electron-neutrino, you have to define the hard process as CKKW-L Merging pp>{G,39}e+ve. CKKW-L Merging Below you can find a list of particles predefined in the merging. If you wish to include a hard process with different final state particles, you may use the 'curly bracket notation' outlined above. CKKW-L Merging The set of incoming particles us limited to: CKKW-L Merging e- (electron), CKKW-L Merging e+ (positron), CKKW-L Merging mu- (muon), CKKW-L Merging mu+ (antimuon), CKKW-L Merging p (proton, container to hold all initial state coloured particles), CKKW-L Merging p~ (identical to CKKW-L Merging p container). CKKW-L Merging The following intermediate particles are allowed: CKKW-L Merging a (photon), CKKW-L Merging z (Z boson), CKKW-L Merging w- (W CKKW-L Merging - boson), CKKW-L Merging w+ (W CKKW-L Merging + boson), CKKW-L Merging h (scalar Higgs boson), CKKW-L Merging W (container to hold both W CKKW-L Merging - and W CKKW-L Merging + boson), CKKW-L Merging t (top quark), CKKW-L Merging t~ (anti-top), CKKW-L Merging dl , CKKW-L Merging dl~ , CKKW-L Merging ul , CKKW-L Merging ul~ , CKKW-L Merging sl , CKKW-L Merging sl~ , CKKW-L Merging cl , CKKW-L Merging cl~ , CKKW-L Merging b1 , CKKW-L Merging b1~ , CKKW-L Merging t1 , CKKW-L Merging t1~ , CKKW-L Merging dr , CKKW-L Merging dr~ , CKKW-L Merging ur , CKKW-L Merging ur~ , CKKW-L Merging sr , CKKW-L Merging sr~ , CKKW-L Merging cr , CKKW-L Merging cr~ , CKKW-L Merging b2 , CKKW-L Merging b2~ , CKKW-L Merging t2 , CKKW-L Merging t2~ (all MSSM squarks). CKKW-L Merging We have pre-defined the outgoing particles: CKKW-L Merging e+ , CKKW-L Merging e- , CKKW-L Merging ve~ , CKKW-L Merging ve , CKKW-L Merging mu+ , CKKW-L Merging mu- , CKKW-L Merging vm~ , CKKW-L Merging vm , CKKW-L Merging ta+ , CKKW-L Merging ta- , CKKW-L Merging vt~ , CKKW-L Merging vt (all SM leptons and neutrinos), CKKW-L Merging j~ (container to hold all final state coloured particles), CKKW-L Merging j (container to hold all final state coloured particles), CKKW-L Merging NEUTRINOS (container to hold all final state neutrinos and anti-neutrinos), CKKW-L Merging LEPTONS (container to hold all final state leptons and anti-leptons), CKKW-L Merging BQUARKS (container to hold final state b-quarks), CKKW-L Merging d~ , CKKW-L Merging d , CKKW-L Merging u~ , CKKW-L Merging u , CKKW-L Merging s~ , CKKW-L Merging s , CKKW-L Merging c~ , CKKW-L Merging c , CKKW-L Merging b~ , CKKW-L Merging b , CKKW-L Merging t~ , CKKW-L Merging t (all SM quarks), CKKW-L Merging a , CKKW-L Merging z , CKKW-L Merging w- , CKKW-L Merging w+ (all SM electro-weak bosons), CKKW-L Merging h (scalar Higgs boson), CKKW-L Merging W (container to hold both W CKKW-L Merging - and W CKKW-L Merging + boson), CKKW-L Merging n1 (MSSM neutralino), CKKW-L Merging dl~ , CKKW-L Merging dl , CKKW-L Merging ul~ , CKKW-L Merging ul , CKKW-L Merging sl~ , CKKW-L Merging sl , CKKW-L Merging cl~ , CKKW-L Merging cl , CKKW-L Merging b1~ , CKKW-L Merging b1 , CKKW-L Merging t1~ , CKKW-L Merging t1 , CKKW-L Merging dr~ , CKKW-L Merging dr , CKKW-L Merging ur~ , CKKW-L Merging ur , CKKW-L Merging sr~ , CKKW-L Merging sr , CKKW-L Merging cr~ , CKKW-L Merging cr , CKKW-L Merging b2~ , CKKW-L Merging b2 , CKKW-L Merging t2~ , CKKW-L Merging t2 (all MSSM squarks). Other outgoing particles are possible if you use the 'curly bracket notation' described earlier. CKKW-L Merging Finally, it is worth noting that including the header CKKW-L Merging Pythia8Plugins/aMCatNLOHooks.h (as is e.g. the case in the CKKW-L Merging main89.cc example) allows the user to instruct Pythia to 'guess' the hard process by setting CKKW-L Merging Merging:Process = guess. In this case, the code will inspect the hard process before starting the merging code, and set CKKW-L Merging Merging:Process on an event-by-event basis according to the rules implemented in CKKW-L Merging Pythia8Plugins/aMCatNLOHooks.h. It is instructive to understand these rules before using this feature. At present, the guess feature assumes that any non-colored particle, any particle with PDG ID larger than 21, and any quark not labelled as 'additional parton' through the CKKW-L Merging Merging:nQuarksMerge mode are part of the hard process definition. This e.g. enables usage for simple BSM processes. Please use this feature with caution. CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Histogramming the events After the event has been processed, histograms for observables of interest need to be filled. In order to achieve good statistical accuracy for all jet multiplicities and all subprocesses contributing to one jet multiplicity, generally a fixed number of unit-weighted events is read from each Les Houches Event file. To then arrive at the correct prediction, for each of these events, histogram bins should be filled with the corresponding cross section, or weighted with unit weight and normalised at the end to the generated cross section for each jet multiplicity separately. CKKW-L Merging Still another, even more important, event weight that has to applied on an  event-by-event basis is the CKKW-L-weight. This corrective weight is the main  outcome of the merging procedure and includes the correct no-emission  probabilities, PDF weights and coupling (&alpha; CKKW-L Merging s or &alpha; CKKW-L Merging em ) factors. This means that the merging implementation will generate weighted events. The CKKW-L-weight can be accessed by the following function: CKKW-L Merging CKKW-L Merging double Info::mergingWeight() &nbsp; CKKW-L Merging Returns the CKKW-L weight for the current event. CKKW-L Merging Note that to avoid confusion, this function does not include the the weight of a phase space point (given by CKKW-L Merging Info::weight() ). This weight will differ from unity when reading in weighted Les Houches events. In this case, the full weight with which to fill histogram bins is CKKW-L Merging Info::mergingWeight() * Info::weight(). CKKW-L Merging Finally, to arrive at a correct relative normalisation of the contributions from different number of additional jets in the matrix element, each histogram should be rescaled with the accepted cross section given by CKKW-L Merging Info::sigmaGen(). The accepted cross section includes the  effect of vetoes generating Sudakov form factors for the matrix elements, and  is in general only known after the run. CKKW-L Merging This final step can of course be skipped if the accepted cross section had been estimated before the histogramming run, and  histogram bins had instead been filled with the weight CKKW-L Merging Info::mergingWeight() * &sigma; CKKW-L Merging est (number of additional jets in current ME sample). This is the way HepMC events should be weighted to produce correct relative weights of events (see below, and particularly examine the example programs CKKW-L Merging main84.cc and CKKW-L Merging main85.cc ). CKKW-L Merging Examples how to use these options are given in CKKW-L Merging main81.cc ( CKKW-L Merging kT merging), CKKW-L Merging main84.cc (automatic MG/ME merging for RIVET usage), and CKKW-L Merging main85.cc (HepMC output for RIVET usage). CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Merging with user-defined merging scale function CKKW-L Merging For all other merging scale definitions, the procedure is slightly more  complicated, since the user has to write a small piece of code defining the  merging scale. To allow for a user defined procedure, set the input CKKW-L Merging Then, set the CKKW-L Merging Merging:nJetMax , CKKW-L Merging Merging:TMS and CKKW-L Merging Merging:Process input as before. CKKW-L Merging Since during execution, PYTHIA needs to evaluate the merging scale with the  definition of the user, the user interface is designed in a way similar to the CKKW-L Merging UserHooks strategy. The class controlling the merging scale  definition is called CKKW-L Merging MergingHooks. CKKW-L Merging Initialisation CKKW-L Merging To initialise the merging with user-defined merging scale, we should construct a class derived from CKKW-L Merging MergingHooks , with a constructor and destructor CKKW-L Merging CKKW-L Merging For the class to be called during execution, a pointer to an object of the class should be handed in with the CKKW-L Merging CKKW-L Merging CKKW-L Merging Pythia::setMergingHooksPtr( MergingHooks*) method.  An examples of this procedure are given in CKKW-L Merging main82.cc. CKKW-L Merging Defining a merging scale CKKW-L Merging Then, in the spirit of the CKKW-L Merging UserHooks class, the user needs to  supply the process to be merged by defining a methods to evaluate the merging scale variable. CKKW-L Merging The base class CKKW-L Merging MergingHooks contains many functions giving  information on the hard process, to make the definition of the merging scale as easy as possible: CKKW-L Merging Filling output histograms for the event then proceeds along the lines described above in 'Histogramming the events'. CKKW-L Merging The full procedure is outlined in CKKW-L Merging main82.cc. Special care needs to be  taken when the output is stored in the form of HepMC files for RIVET usage. CKKW-L Merging Defining a cut on lowest jet multiplicity events CKKW-L Merging It can sometimes happen that when generating LHE files, a fairly restrictive cut has been used when generating the lowest multiplicity matrix element  configurations. Then, it can happen that states that are (in the generation of a parton shower history) constructed by reclustering from higher multiplicity  configurations, do not pass this matrix element cut. CKKW-L Merging Consider as an example  pure QCD dijet merging, when up to one additional jet should be merged.  Three-jet matrix element configurations for which the reclustered two-jet state does not pass the cuts applied to the two-jet matrix element would never have  been produced by showering the two-jet matrix element. This means that the three-jet matrix element includes regions of phase space that would never have  been populated by the parton shower. Thus, since the matrix element phase space is larger than the shower phase space, merging scale dependencies are expected.  A priori, this is not troublesome, since the aim of matrix element merging is  to include regions of phase space outside the range of the parton shower approximation into the shower. An example is the inclusion of configurations  with only unordered histories. CKKW-L Merging Clearly, if the parton shower phase space is very constrained by applying  stringent cuts to the two-jet matrix element, merging scale dependencies can  become sizable, as was e.g. seen in CKKW-L Merging Lon11 when forcing shower emissions to be ordered both in the evolution variable and in rapidity. To  influence the effect of large phase space differences for shower emissions and matrix element configurations due to LHEF generation cuts, the user has to  write a small piece of code overwriting method CKKW-L Merging Note that this method gives the user access to the lowest multiplicity state,  which ( e.g. in the case of incomplete histories) does not have to be a CKKW-L Merging 2 &rarr; 2 configuration. Also, changing the weight of the current event by  hand is of course a major intervention in the algorithm, and should be  considered very carefully. Generally, if this facility would have to be used extensively, it is certainly preferable to be less restrictive when applying  additional, non-merging-scale-related cuts to the matrix element. CKKW-L Merging An example how to force a cut on lowest multiplicity reclustered states for pure QCD matrix element configurations is given by CKKW-L Merging main83.cc (to be used with e.g. CKKW-L Merging main82.cmnd ). CKKW-L Merging Influencing the construction of all possible histories CKKW-L Merging Even more powerful - and dangerous - is influencing the construction of histories directly. This should only be attempted by expert users. If you believe manipulations completely unavoidable, we advise you to take great care when redefining the following functions. CKKW-L Merging Clearly, these methods are highly intrusive. It could e.g. happen that no history is allowed, which would make merging impossible. One example where this method could be useful is if cuts on the core CKKW-L Merging 2 &rarr; 2 processes have to be checked, and the method CKKW-L Merging MergingHooks::dampenIfFailCuts(const Event& event) is not sufficiently effective. CKKW-L Merging Defining the hard process matrix element CKKW-L Merging The MergingHooks class also allows the expert user to define the matrix element of the hard process, by defining the method CKKW-L Merging The inclusion of the hard process matrix element into the choice of histories becomes relevant when the hard process matrix element has very strong phase space dependencies. QCD dijet cross sections for example strongly depend on the transverse momentum of the jets. So far, the authors have not encountered any changes upon inclusion of the full hard process matrix element, even for the QCD dijet case. CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Matrix element merging and HepMC output for RIVET Examples how to produce matrix element merged events to be analysed with RIVET are given by CKKW-L Merging main84.cc and CKKW-L Merging main85.cc. CKKW-L Merging The main issue is that the output of separate RIVET runs can not in general be combined. To perform a matrix element merging, we however need to runs over  different LHE files. The solution to this problem (so far) is to only perform  one RIVET run for all matrix elements, i.e. print the events for all ME parton  multiplicities, with the correct weights, to a single HepMC file. Since the correct weight includes the cross section of the different samples after Sudakov vetoes --- which is not a priori known --- the cross sections have to be  estimated in a test run, before the actual production run is performed. Finally, the cross section of the last event in the HepMC file has to be taken as the  full merged cross section CKKW-L Merging sigma_merge = Sum_{i=0}^N Sum_{j=0}*^{nEvents} sigma_est(i)*wckkwl(j). CKKW-L Merging This procedure is outlined in CKKW-L Merging main84.cc.  Input LHE files with only very inclusive cuts pose further difficulties. For such files (which were already addressed under the heading CKKW-L Merging Les Houches events outside the matrix element region ), the cross section after the merging scale cut is not known before the cut is performed. Using Pythia's CKKW-L Merging UserHooks facilities, it is possible to produce a valid estimate of the cross section after cuts. This however entails a careful cut definition by the user, which might become cumbersome for some in-built merging scale definitions. A reasonable alternative is using the switch CKKW-L Merging This switch also relies on knowledge on how many partons a LHE file should contain. This is important for real-emission kinematics in the case of NLO merging. The number of (additional) partons in a LHE file can be set with CKKW-L Merging The usage of these switches to obtain the necessary cross section estimate is illustrated in CKKW-L Merging main85.cc. The example CKKW-L Merging main85.cc program is intended as a 'front-end' for CKKW-L merging in Pythia8, so we will discuss the program briefly. CKKW-L Merging main85.cc should be used together with an input file (like CKKW-L Merging main85.cmnd ). The executable should be invoked with three arguments: the input file, the 'name' of the input LHE files, and the name of the output HepMC event file. To use the LHE files that are shipped with the Pythia distribution, a valid usage would be CKKW-L Merging CKKW-L Merging ./main85.exe ./main85.cmnd ./w_production ./myhepmc.hepmc CKKW-L Merging If you want to use other input LHE files, note that CKKW-L Merging main85.cc assumes the naming convention CKKW-L Merging name_tree_#nAdditionalJets.lhe. All settings can be included though the input file, so that CKKW-L Merging main85.cc does not have to be changed explicitly. CKKW-L Merging main85.cc first switches off showers, multiparton interactions and hadronisation, and estimates the cross sections (after enforcing the merging scale cut) of samples for different numbers of additional jets. Then, showers, MPI and hadronisation are switched on again, and the CKKW-L merging procedure is performed. Events will be read in a decreasing sequence of jet multiplicities, which also means that e.g. events with two additional partons in the LHE file will be printed to the HepMC file before events with one additional parton. CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Electroweak Merging Merging strategies like CKKW-L usually assume that the description of a (relatively simple) underlying process should be improved by combining with states that contain additional well-separated partons - with 'additional' measured with respect to the underlying process. As discussed in CKKW-L Merging Chr15a , this philosophy is not always sensible, and may lead to an unconvincing physics model. The bias can be greatly reduced by considering that in perturbation theory, corrections to seemingly very different underlying processes mix, so that there is no justification to classify some states as corrections to only one underlying process. Interactions that only contain vertices of only one theory (e.g. QCD) will mix with processes that contain only vertices of another interactions (e.g. QED). Underlying processes with very different coupling structures should thus be considered. This is the main aim of the electroweak merging scheme. The process CKKW-L Merging p p &rarr; W jet jet provides a good example, since it can be interpreted either as double-real-QCD-emission correction to CKKW-L Merging p p &rarr; W or as real-electroweak-emission correction to CKKW-L Merging p p &rarr; jet jet. The distinction is artificial, but the all-order resummation is very different in either case, leading to distinctly different predictions. Thus, a minimally biased method for assigning an underlying process has to be found. CKKW-L Merging The method of CKKW-L Merging Chr15a chooses the underlying process probabilistically for each phase space point based on a product of splitting kernels and full hard process matrix elements, and includes the correct all-order factors after this choice. In our previous example ( CKKW-L Merging p p &rarr; W jet jet ), this would mean that the hard scattering could be CKKW-L Merging p p &rarr; W or CKKW-L Merging p p &rarr; jet jet (or, depending on phase space considerations, also CKKW-L Merging p p &rarr; W jet ). The availability of CKKW-L Merging electro-weak showers in Pythia 8 is crucial for a consistent scheme that removes of double-counting, since double-counting is (in part) removed by applying no-emission probabilities. In order to e.g. ensure that a state in the CKKW-L Merging p p &rarr; jet jet does not, via W-boson emission, evolve into a state overlapping with CKKW-L Merging p p &rarr; W + two QCD emissions, the former has to be reweighted with an all-order no-electroweak-emission probability. As always, a small merging scale dependence is facilitated by accounting for for dynamical PDF evaluation and running couplings. An electroweak merging thus includes a reweighting with &alpha; CKKW-L Merging em ratios that are automatically included in the 'merging weight'. CKKW-L Merging As another consequence of probabilistically assigning the underlying process is the 'merging of mergings': Since purely partonic final states can evolve into jets + electroweak bosons states, it is necessary to treat bosons and partons on equal footing, meaning that well-separated boson states should be corrected with fixed-order inputs, while soft/collinear bosons should be associated with parton showering. Shortly, bosons and partons are treated identically. For our previous example, this means that the 'correct' set of fixed-order corrections that include up to three final state particles is CKKW-L Merging p p &rarr; n Ws + m jets , where any combination of n and m subject to CKKW-L Merging n + m <= 3 has to be included ( CKKW-L Merging p p &rarr; W , CKKW-L Merging p p &rarr; W jet , CKKW-L Merging p p &rarr; W jet jet , CKKW-L Merging p p &rarr; W W , CKKW-L Merging p p &rarr; W W W , CKKW-L Merging p p &rarr; W W jet , CKKW-L Merging p p &rarr; jet jet , CKKW-L Merging p p &rarr; jet jet jet ) For practical purposes, it is sometimes permitted to not combine a complete set of processes. Only the single W-state has been explicitly validated and in addition the weak PS does not include all possible splittings for multiple W emissions, therefore caution has to be taken if using this for multiple W states. CKKW-L Merging The 'merging of mergings' has important consequences for the (interested) user. Below, we give instructions on the usage of the electroweak merging. CKKW-L Merging Fixed-order inputs for electroweak merging The electroweak merging leads to the idea of a 'merging of mergings'. This has to be enforced also at the fixed-order sample generation stage, with two main requirements. CKKW-L Merging A fully consistent treatment requires the generation of samples containing all states with a number of emissions that is less than or equal to the 'maximal possible number of emissions of any type' that should be corrected, cf. the CKKW-L Merging W jet jet example above.  In practise, it is often permitted to disregard some (set of) samples since their impact on an analysis is negligible. If e.g. an analyis always requires missing transverse momentum and a single lepton, and we assume perfect lepton acceptances, then it would be permitted to disregard the multi-W samples in the example. If the collision energy is in addition low (~up to fews of TeVs), then the probability for a pure QCD state to emit W-bosons is often low enough so that the pure jet samples can be neglected. However, you should think very carefully before settling on any shortcuts. CKKW-L Merging Any particle that could count as an emission has to be included in the calculation of the particle separations that define the merging scale. If e.g. W-bosons are considered emissions, then any state with W-bosons that are collinear with another emission should be removed from the fixed-order sample. Such configurations will instead be produced through parton showering. This requirement means that you might have to define your own cut including this condition in your favourite fixed-order matrix element generator. At the risk of losses in efficiency, you can also use samples with very loose cuts and have Pythia enforce the merging scale cut when reading your input events. The latter is only possible if you use the merging scale definition CKKW-L Merging Merging:doPTLundMerging = on. CKKW-L Merging Enabling the electroweak merging The electroweak merging is currently only tested for processes containing W-bosons and jets. For a consistent merging, it is necessary to enable W-boson emissions by using CKKW-L Merging TimeShower:weakShower    = on , CKKW-L Merging TimeShower:weakShowerMode  = 1 , CKKW-L Merging SpaceShower:weakShower    = on , CKKW-L Merging SpaceShower:weakShowerMode = 1 , and CKKW-L Merging WeakShower:externalSetup  = on. CKKW-L Merging To enable the electroweak merging, use the following switch. CKKW-L Merging As explained above, the electroweak (EW) merging treats all shower-producible particles equally. This also means that the merging scale definition must include a separation of W-bosons and partons to define if a state is in the (well-separated) fixed-order region or if it is in the (soft/collinear) parton shower region. Such a cut can be implemented inside the (external) matrix element generator. On the other hand, Pythia 8 allows the usage of samples with very loose cuts and can enforce the correct merging scale cut by rejecting input events that do not pass the cut. This is also possible for the EW merging, albeit only for the merging scale definition that is enabled by using CKKW-L Merging Merging:doPTLundMerging = on. We recommend using this strategy for users that do not wish to implement the cut directly into the ME generation, and who are prepared to accept a loss of efficiency because of Pythia's a-posteriori rejection. CKKW-L Merging Defining the 'inclusive' merging process Since the concept of a single 'hard process' is not suitable for the EW merging, the process should be defined in a rather loose manner. This loose definition is still done by setting the input CKKW-L Merging Merging:Process.  Processes for EW merging should use the containers CKKW-L Merging Jinc , CKKW-L Merging Winc , CKKW-L Merging Ainc and CKKW-L Merging Zinc , which tell the code which particles could be possible 'additional' emissions. No other particle defnitions are allowed, and none of the settings discussed in the 'Defining the hard process' section are relevant here.  Examples of allowed process definitions are CKKW-L Merging CKKW-L Merging Merging:Process = pp > Jinc,Winc meaning that W-bosons and partons are treated on equal footing (i.e. this is the setting applicable to the example used earlier). The merging will then include pure QCD multijet events, W+jets events, multi-W+jets events and pure multi-W events; CKKW-L Merging CKKW-L Merging Merging:Process = pp > Jinc,Zinc meaning that Z-bosons and partons are treated on equal footing; CKKW-L Merging CKKW-L Merging Merging:Process = pp > Jinc,Winc,Zinc meaning that W-bosons, Z-bosons and partons are treated on equal footing. CKKW-L Merging Setting the number of additional particles Since the EW merging probabilistically decides on the 'underlying process', it is a priori not possible to set the maximal number of additional emissions on top of this underlying process. A CKKW-L Merging p p &rarr; W jet jet state would e.g. contain two additional emissions if interpreted as correction to CKKW-L Merging p p &rarr; W , and only one additional emission if interpreted as correction to CKKW-L Merging p p &rarr; jet jet. Pythia 8 consequently decides dynamically how to set the additional number of emissions. CKKW-L Merging The maximal number of emissions, set by using the CKKW-L Merging Merging:nJetMax setting, still has to be defined to allow a sensible treatment of the 'highest-multiplicity' states. We thus redefine the meaning of CKKW-L Merging Merging:nJetMax to 'maximal possible number of emissions of any type'. As an example, CKKW-L Merging Merging:nJetMax = 3 if you want to perform a 'merging of mergins' containing states with up to three partons, or up to two partons and one W-boson, or up to one parton and two W-bosons, or up to three W-bosons. CKKW-L Merging CKKW-L Merging CKKW-L Merging CKKW-L Merging Further variables For more advanced manipulations of the merging machinery, all parameter  changes that were investigated in CKKW-L Merging Lon11 are supplied. Please  check CKKW-L Merging Lon11 for a detailed discussion of the switches. CKKW-L Merging These switches allow enthusiastic users to perform a systematic assessment of the merging prescription. Apart from this, we advise the non-expert user to keep the default values."},{"name":"Colour reconnection","link":"ColourReconnection.html","text":"Colour reconnection Colour reconnection Colour Reconnection The colour flows in the separate subprocesses defined in the multiparton-interactions scenario are tied together via the assignment of colour flow in the beam remnant. This is not an unambiguous procedure, and currently two different methods are implemented. In the first model the colour flow is reconstructed by how a PS could have constructed the configuration. In the second model, the full QCD colour calculation is taken into account, however the dynamical effects are modeled loosely, only an overall saturation is taken into account. The idea is to later account for other dynamical effects through colour reconnections. Colour reconnection A simple 'minimal' procedure of colour flow only via the beam remnants does not result in a scenario in agreement with data, however, notably not a sufficiently steep rise of Colour reconnection <pT>(n_ch). The true origin of this behaviour and the correct mechanism to reproduce it remains one of the big unsolved issues at the borderline between perturbative and nonperturbative QCD. Since no final answer is known, several models are implemented. The different models also rely on the two different colour assignments in the beam remnant. There are two, somewhat motivated, models implemented: the original PYTHIA scheme and a new scheme that tries to incorporate more of the colour knowledge from QCD. Colour reconnection The original PYTHIA scheme relies on the PS-like colour configuration of the beam remnant. This is combined with an additional step, wherein the gluons of a lower- Colour reconnection pT MPI system are merged with the ones in a higher-pT MPI. A more detailed description of the merging can be found below. Relative to the other models it tests fewer reconnection possibilities, and therefore tends to be reasonably fast. Colour reconnection The new scheme Colour reconnection Chr14a relies on the full QCD colour configuration in the beam remnant. This is followed up by a colour reconnection, where the potential string energy is minimized (ie. the Colour reconnection lambda measure is minimized). The QCD colour rules are also incorporated in the colour reconnection, and determine the probability that a reconnection is allowed. The model also allows the creation of junction structures. Colour reconnection In addition to the two models described above, a simple model is implemented, wherein gluons can be moved from one location to another so as to reduce the total string length. This is one out of a range of simple models developed to study potential colour reconnection effects e.g. on top mass Colour reconnection Arg14 , not from the point of view of having the most realistic description, but in order to probe the potential worst-case spread of predictions. All of these models are made available separately in Colour reconnection include/Pythia8Plugins/ColourReconnectionHooks.h , with the setup illustrated in Colour reconnection examples/main29.cc , but only the gluon-move one is sufficiently general and realistic that it has been included among the standard options here. Colour reconnection Finally, the SK I and SK II models Colour reconnection Sjo94 have a smaller range of applicability, originally intended for Colour reconnection e^+ e^- &rarr; W^+ W^- , but in this context offers a more detailed approach. They are not suitable for hadronic collisions, since they would only address CR inside a gauge boson pair, and not CR in the rest of the event. Colour reconnection The MPI-based scheme In this scheme partons are classified by which MPI system they belong to. The colour flow of two such systems can be fused, and if so the partons of the lower- Colour reconnection pT system are added to the strings defined by the higher- Colour reconnection pT system in such a way as to give the smallest total string length. The bulk of these lower- Colour reconnection pT partons are gluons, and this is what the scheme is optimized to handle. Colour reconnection In more detail, an MPI system with a scale Colour reconnection pT of the hard interaction (normally Colour reconnection 2 &rarr; 2 ) can be merged with one of a harder scale with a probability that is Colour reconnection pT0_Rec^2 / (pT0_Rec^2 + pT^2) , where Colour reconnection pT0_Rec is Colour reconnection range times Colour reconnection pT0 , the latter being the same energy-dependent dampening parameter as used for MPIs. Thus it is easy to merge a low- Colour reconnection pT system with any other, but difficult to merge two high- Colour reconnection pT ones with each other. Colour reconnection The reconnection procedure is applied iteratively. Thus first the reconnection probability Colour reconnection P = pT0_Rec^2 / (pT0_Rec^2 + pT^2) of the lowest- Colour reconnection pT system is found, and gives the probability for merger with the second-lowest one. If not merged, it is tested with the third-lowest one, and so on. For the Colour reconnection m 'th higher system the reconnection probability thus becomes Colour reconnection (1 - P)^(m-1) P. That is, there is no explicit dependence on the higher Colour reconnection pT scale, but implicitly there is via the survival probability of not already having been merged with a lower- Colour reconnection pT system. Also note that the total reconnection probability for the lowest- Colour reconnection pT system in an event with Colour reconnection n systems becomes Colour reconnection 1 - (1 - P)^(n-1). Once the fate of the lowest- Colour reconnection pT system has been decided, the second-lowest is considered with respect to the ones above it, then the third-lowest, and so on. Colour reconnection Once it has been decided which systems should be joined, the actual merging is carried out in the opposite direction. That is, first the hardest system is studied, and all colour dipoles in it are found (including to the beam remnants, as defined by the holes of the incoming partons). Next each softer system to be merged is studied in turn. Its gluons are, in decreasing Colour reconnection pT order, inserted on the colour dipole Colour reconnection i,j that gives the smallest Colour reconnection (p_g p_i)(p_g p_j)/(p_i p_j) , i.e. minimizes the 'disturbance' on the existing dipole, in terms of Colour reconnection pT^2 or Colour reconnection Lambda measure (string length). The insertion of the gluon means that the old dipole is replaced by two new ones. Also the (rather few) quark-antiquark pairs that can be traced back to a gluon splitting are treated in close analogy with the gluon case. Quark lines that attach directly to the beam remnants cannot be merged but are left behind. Colour reconnection The joining procedure can be viewed as a more sophisticated variant of the one introduced already in Colour reconnection Sjo87. Clearly it is ad hoc. It hopefully captures some elements of truth. The lower Colour reconnection pT scale a system has the larger its spatial extent and therefore the larger its overlap with other systems. It could be argued that one should classify individual initial-state partons by Colour reconnection pT rather than the system as a whole. However, for final-state radiation, a soft gluon radiated off a hard parton is actually produced at late times and therefore probably less likely to reconnect. In the balance, a classification by system Colour reconnection pT scale appears sensible as a first try. Colour reconnection Note that the reconnection is carried out before resonance decays are considered by default. Colour inside a resonance therefore is not reconnected. The Colour reconnection Colour reconnection PartonLevel:earlyResDec can be switched on to perform resonance decays before colour reconnection, and then the partons from resonance decays could be affected. Ideally the time scales of resonance decays and of colour reconnection should be picked dynamically, but this is not yet the case. Notably the Colour reconnection W , Colour reconnection Z and Colour reconnection t have intermediate decay time scales, somewhat but not much shorter than typical hadronization times, whereas the Colour reconnection H is much more long-lived. Colour reconnection The newer scheme The newer CR scheme builds on the minimization of the string length as well as the colour rules from QCD. A main feature of the new model is the introduction of junction structures. These are possible outcomes of the reconnection in addition to the more common string-string reconnections. The model works by constructing all pair of dipoles that are allowed to reconnect by QCD colour rules and switching if the new pair has a lower string length. Junctions are also allowed to be directly produced from three, and in some special cases, four dipoles. This is done iteratively until no further allowed reconnection lowers the total string length. Colour reconnection According to QCD colour rules, an uncorrelated triplet and anti-triplet are allowed to form a singlet state Colour reconnection 1/9 times. This is reflected in the model by giving each dipole a colour number between 0-8 and only dipoles with the same colour number are allowed to reconnect. The junction probability is given by the product of two triplets, which provides an anti-triplet Colour reconnection 1/3 times. This is achieved in the model by allowing reconnections between dipoles where modulo three of the color numbers agree. In addition to the colour rules, the dipoles also need to be causally connected in order to perform a reconnection. The definition of causally connected dipoles is not exact, and several different options are available. All the time dilation modes introduce a tuneable parameter, which provides a handle on the overall amount of colour reconnection. Colour reconnection When the two strings are allowed to reconnect, they will reconnect if it lowers the total string length. The total string length is in the model defined by an approximation to the Colour reconnection lambda -measure. Several options for different approximations are available. The Colour reconnection lambda -measure is not well understood, especially for junction structures, and a tuneable parameter is introduced to vary the behaviour between junctions and ordinary strings. Colour reconnection To avoid problems with very low mass string and junction structures, these are excluded from participating in the colour reconnections. This is achieved by forming the dipole or junction into a pseudo-particle if the invariant mass is too low. Especially the approximations made in the Colour reconnection lambda -measure provides problems at low invariant masses. Colour reconnection The new CR scheme introduce several tuneable parameters, which all are listed below. In addition to these, other parameters in PYTHIA also need to retuned to account for the new CR. The default values below, together with changing Colour reconnection MultipartonInteractions:pT0Ref = 2.15 and Colour reconnection ColourReconnection:allowDoubleJunRem = off , provides a good starting point. Additional fragmentation variables were also adjusted in the first tune, but these provide a smaller change (see Colour reconnection Chr14a for a complete list). Colour reconnection The gluon-move scheme This approach contains two steps, a first 'move' one and an optional second 'flip' one. Both are intended to reduce the total 'string length' Colour reconnection lambda measure of an event. For multiparton topologies the correct Colour reconnection lambda measure can become quite cumbersome, so here it is approximated by the sum of Colour reconnection lambda contributions from each pair of partons connected by a colour string piece. For two partons Colour reconnection i and Colour reconnection j with invariant mass Colour reconnection m_ij this contribution is defined as Colour reconnection lambda_ij = ln(1 + m^2_ij / m2Lambda). The 1 is added ad hoc to avoid problems in the Colour reconnection m_ij &rarr; 0 limit, problems which mainly comes from the approximate treatment, and Colour reconnection m2Lambda is a parameter set below. Colour reconnection In the move step all final gluons are identified, alternatively only a fraction Colour reconnection fracGluon of them, and also all colour-connected parton pairs. For each gluon and each pair it is calculated how the total Colour reconnection lambda would shift if the gluon would be removed from its current location and inserted in between the pair. The gluon move that gives the largest negative shift, if any, is then carried out. Alternatively, only shifts more negative than Colour reconnection dLambdaCut are considered. The procedure is iterated so long as allowed moves can be found. Colour reconnection There is some fine print. If a colour singlet subsystem consists of two gluons only then it is not allowed to move any of them, since that then would result in in a colour singlet gluon. Also, at most as many moves are made as there are gluons, which normally should be enough. A specific gluon may be moved more than once, however. Finally, a gluon directly connected to a junction cannot be moved, and also no gluon can be inserted between it and the junction. This is entirely for practical reasons, but should not be a problem, since junctions are rare in this model. Colour reconnection The gluon-move steps will not break the connection between string endpoints, in the sense that a quark and an antiquark that are colour-connected via a number of gluons will remain so, only the number and identity of the intermediate gluons may change. Such a scenario may be too restrictive. Therefore an optional second flip step is introduced. In it all such colour chains are identified, omitting closed gluon loops. The lambda change is defined by what happens if the two colour lines are crossed somewhere, e.g. such that two systems Colour reconnection q1 - g1 - qbar1 and Colour reconnection q2 - g2 - qbar2 are flipped to Colour reconnection q1 - g1 - g2 - qbar2 and Colour reconnection q2 - qbar1. The flip that gives the largest Colour reconnection lambda reduction is carried out, again with Colour reconnection dLambdaCut offering a possibility to restrict the options. As with the move step, the procedure is repeated so long as it is allowed. An important restriction is imposed, however, that a given system is only allowed to flip once, and not with itself. The practical reason is that repeated flips could split off closed gluon loops quite easily, which tends to result in bad agreement with data. Colour reconnection As an option, singlet subsystems containing a junction may or may not be allowed to take part in the flip step. Since the number of junction systems is limited in this model the differences are not so important. Colour reconnection The Colour reconnection e^+ e^- colour reconnection schemes The SK I and SK II models Colour reconnection Sjo94 were specifically developed for Colour reconnection e^+ e^- &rarr; W^+ W^- &rarr; q_1 qbar_2 q_3 qbar_4 at LEP 2, and equally well works for Colour reconnection e^+ e^- &rarr; gamma^*/Z^0 gamma^*/Z^0. They are not intended to handle hadronic collisions, except in special contexts. The prime of these is Higgs decays of the same character as above, Colour reconnection H^0 &rarr;  W^+ W^- / Z^0 Z^0 , since the Higgs is sufficiently long-lived that its decay products can be considered separately from the rest of the event. The administrative machinery for this possibility is not yet in place, however. Colour reconnection The labels I and II refer to the colour-confinement strings being modelled either by analogy with type I or type II superconductors. In the former model the strings are viewed as transversely extended 'bags'. The likelihood of reconnection is then related to the integrated space-time overlap of string pieces from the Colour reconnection W^+ with those from the Colour reconnection W^-. In the latter model instead strings are assumed to be analogous with vortex lines, where all the topological information is stored in a thin core region. Reconnection therefore only can occur when these cores pass through each other. Colour reconnection Both of these models are based on a detailed modelling of the space-time separation of the Colour reconnection W^+ and Colour reconnection W^- decay vertices, on the subsequent shower evolution, on the continued space-time evolution of all the string pieces stretched between the showered partons, and on the cutoff provided by the strings disappearing by the hadronization process. As such, they are more sophisticated than any other reconnection models. Unfortunately they would not easily carry over to hadronic collisions, where both the initial and the final states are far more complicated, and the space-time details less well controlled. Colour reconnection The SK II model has few free parameters, giving more predictive power. Conversely, SK I has a a free overall CR strength parameter, making it more convenient for tunes to data. The LEP collaborations have used SK I as a common reference to establish the existence of CR in Colour reconnection W^+ W^- events."},{"name":"Compositeness Processes","link":"CompositenessProcesses.html","text":"Compositeness Processes Compositeness Processes Compositeness Processes Compositeness scenarios may give rise to sharp resonances of excited quarks and leptons. An excited copy of the first generation is implemented, consisting of spin 1/2 particles. The possibility of contact interactions between SM fermions is also implemented in the context of Compositeness Processes 2 &rarr; 2 quark or fermion-lepton scattering. Compositeness Processes Related to excited fermions, the current implementation contains gauge interaction production by quark-gluon fusion or lepton-photon fusion and contact interaction production by quark-quark or quark-antiquark scattering. For both the Compositeness Processes 2 &rarr; 1 and Compositeness Processes 2 &rarr; 2 processes a non-trivial angular dependence is included in the decay, however, only decays into gauge bosons are supported, i.e. not decays through contact interactions. In additions to the compositeness scale and couplings listed below, you are expected to change the excited-fermion masses in accordance with what is desired. See Compositeness Processes Bau90 for conventions. Compositeness Processes The contact interactions are implemented according to Compositeness Processes Eic83. The processes include the SM contributions as well as interference. For this reason the processes below converge toward the SM equivalents when the contact interaction contributions are close to zero, e.g. Compositeness Processes HardQCD:qq2qq and Compositeness Processes HardQCD:qqbar2qqbarNew in the case of quark scattering. Compositeness Processes It should also be noted that the Compositeness Processes gamma*/Z/Z' production process available with Compositeness Processes NewGaugeBoson:ffbar2gmZZprime is prepared for pair-production of excited quarks and leptons, assuming the same gauge couplings as for the non-excited fermions. What is missing is the actual decay channels in the list of Compositeness Processes Z' decay modes, which have to be added by hand, e.g. by Compositeness Processes 32:addChannel = 1 1. 100 4000001 -4000001 Compositeness Processes You can use Compositeness Processes Zprime:gmZmode to decide which gauge boson propagators actually are included in the simulation, and thus e.g. switch off the Compositeness Processes Z' part of the propagator. You may also want to switch off other decay channels and set the minimal mass to be at the threshold for the studied pair production (or suitably below it, if the excited fermions have a non-negligible width). Compositeness Processes Excited fermions, production processes A few different production processes have been implemented, which normally would not overlap and therefore could be run together. Compositeness Processes Excited fermions, parameters The basic couplings of the model are Compositeness Processes Contact interactions, production processes The processes including contact interactions are Compositeness Processes Contact interactions, parameters"},{"name":"Couplings and Scales","link":"CouplingsAndScales.html","text":"Couplings and Scales Couplings and Scales Couplings and Scales Here is collected some possibilities to modify the scale choices of couplings and parton densities for all internally implemented hard processes. This is based on them all being derived from the Couplings and Scales SigmaProcess base class. The matrix-element coding is also used by the multiparton-interactions machinery, but there with a separate choice of Couplings and Scales alpha_strong(M_Z^2) value and running, and separate PDF scale choices. Also, in Couplings and Scales 2 &rarr; 2 and Couplings and Scales 2 &rarr; 3 processes where resonances are produced, their couplings and thereby their Breit-Wigner shapes are always evaluated with the resonance mass as scale, irrespective of the choices below. Couplings and Scales We stress that couplings and scales are set separately from the values on this page for Couplings and Scales multiparton interactions , Couplings and Scales timelike showers , and Couplings and Scales spacelike showers. This allows a bigger flexibility, but also requires a bit more work e.g. if you insist on using the same Couplings and Scales alpha_s everywhere. Couplings and Scales Couplings and K factor The size of QCD cross sections is mainly determined by Couplings and Scales The actual value is then regulated by the running to the Couplings and Scales Q^2 renormalization scale, at which Couplings and Scales alpha_strong is evaluated Couplings and Scales QED interactions are regulated by the Couplings and Scales alpha_electromagnetic value at the Couplings and Scales Q^2 renormalization scale of an interaction. Couplings and Scales In addition there is the possibility of a global rescaling of cross sections (which could not easily be accommodated by a changed Couplings and Scales alpha_strong , since Couplings and Scales alpha_strong runs) Couplings and Scales Renormalization scales The Couplings and Scales Q^2 renormalization scale can be chosen among a few different alternatives, separately for Couplings and Scales 2 &rarr; 1 , Couplings and Scales 2 &rarr; 2 and two different kinds of Couplings and Scales 2 &rarr; 3 processes. In addition a common multiplicative factor may be imposed. Couplings and Scales Factorization scales Corresponding options exist for the Couplings and Scales Q^2 factorization scale used as argument in PDF's. Again there is a choice of form for Couplings and Scales 2 &rarr; 1 , Couplings and Scales 2 &rarr; 2 and Couplings and Scales 2 &rarr; 3 processes separately. For simplicity we have let the numbering of options agree, for each event class separately, between normalization and factorization scales, and the description has therefore been slightly shortened. The default values are Couplings and Scales not necessarily the same, however."},{"name":"Dark Matter Processes","link":"DarkMatterProcesses.html","text":"Dark Matter Processes Dark Matter Processes Dark Matter Processes This page contains the production of Dirac fermion Dark Matter via new Dark Matter Processes s -channel mediators. A summary of the physics scenarios and parameters involved can be found in Dark Matter Processes Des18. Examples how these processes can be run are found in Dark Matter Processes main75.cc and Dark Matter Processes main76.cc. Dark Matter Processes The particles in the scenarios considered here are a mix of established PDG ones (51 - 55) and extensions thereof ( 56 - 59), as follows: Dark Matter Processes Dark Matter Processes Dark Matter Processes 51 Dark Matter Processes Scalar DM (currently unused); Dark Matter Processes Dark Matter Processes 52 Dark Matter Processes Fermionic DM ( Dark Matter Processes chi_1 ); Dark Matter Processes Dark Matter Processes 53 Dark Matter Processes Vector DM (currently unused); Dark Matter Processes Dark Matter Processes 54 Dark Matter Processes Scalar (or pseudoscalar) mediator ( Dark Matter Processes S ); Dark Matter Processes Dark Matter Processes 55 Dark Matter Processes Vector (or axial vector) mediator ( Dark Matter Processes Z' ); Dark Matter Processes Dark Matter Processes 56 Dark Matter Processes Charged scalar partner ( Dark Matter Processes l^~ ); Dark Matter Processes Dark Matter Processes 57 Dark Matter Processes Singly charged partner ( Dark Matter Processes chi^+ ); Dark Matter Processes Dark Matter Processes 58 Dark Matter Processes Neutral partner ( Dark Matter Processes chi_2 ); Dark Matter Processes Dark Matter Processes 59 Dark Matter Processes Doubly charged partner ( Dark Matter Processes chi^++ ). Dark Matter Processes Scalar Mediator Dark Matter Processes Fermion couplings to scalar S are assumed to be proportional to mass of the fermion and couplings are the factor multiplying SM Higgs coupling (i.e. sin(mixing) in case of portal models). Dark Matter Processes Vector Mediator Dark Matter Processes Z' The Vector mediator model assumes a simplified U(1) model with couplings to fermionic Dark Matter.  Both vector and axial couplings are possible.  Interference with Dark Matter Processes gamma/Z is currently not implemented, therefore this should mainly be used when Dark Matter Processes Z' &rarr; X Xbar.  However, a quick check of dijet or dilepton cross sections can be made by setting the mode Dark Matter Processes Zp:decayMode. Dark Matter Processes The vector and axial couplings of fermionic DM to the Dark Matter Processes Z'^0 can be set freely. The couplings of quarks and leptons can either be chosen freely for a new Dark Matter Processes U(1) or be given by kinetic mixing with the SM Dark Matter Processes U(1)_Y. The SM fermion couplings are assumed to be universal, i.e. generation-independent. The choice of fixed axial and vector couplings implies a resonance width that increases linearly with the Dark Matter Processes Z' mass. Also some overall coupling strengths can be chosen freely. Dark Matter Processes Drell-Yan production of charged co-annihilation partners We implement two models of co-annihilating Dark Matter where the co-annihilation partner carries EW charge and therefore can be produced via Drell-Yan production.  The underlying model and production process can be selected by choosing the parameter Dark Matter Processes DM:DYtype. Dark Matter Processes The first model consists of co-annihilation with a scalar with leptonic quantum numbers and which couples to a right-handed SM lepton and a Dirac fermion Dark Matter via Yukawa couplings.  It is possible to choose lepton flavour violating couplings. Dark Matter Processes The next model is a generalisation of the mixed gaugino sector of Supersymmetry parametrised by one SM singlet and one SU(2) N-plet which mix to form Dark matter.  N = 2, 3 and 5 are supported by the code.  The main motivation for this choice is to provide a fully flexible implementation to calculate production of long-lived particles at the LHC.  The resultant spectrum consists of one neutral partner, one singly charged partner, and one doubly charged partner (in the case of the 5-plet).  The only free parameters are masses of the singlet and N-plet and the mixing suppression scale. This determines both production and decay of the particles and can cover a range of signatures including displaced leptons and vertices, long-lived, kinked or disappearing tracks. Dark Matter Processes The Yukawa couplings can be set using Dark Matter Processes The parameters for the singlet-N-plet model can be set via the following:"},{"name":"Deuteron Production","link":"DeuteronProduction.html","text":"Deuteron Production Deuteron Production Deuteron Production After the final state particles of an event are produced, protons and neutrons are selected and combined into pairs which may form deuterons. A generalized version of the model in Deuteron Production Dal15 is implemented here. The cross-sections used to determine if a combination binds into a deuteron are differential in Deuteron Production k &equiv; |p Deuteron Production 1 - p Deuteron Production 2 | where Deuteron Production p Deuteron Production i are the momenta of the binding combination in the center-of-mass frame of the combination. Here all notation is used to specify deuteron production, but anti-deuteron production is also provided where the anti-particles for all relevant particles are used. Deuteron Production To ensure conservation of momentum and energy, the final state for each deuteron production channel is required to have at least two final products, where one product is a deuteron. This is in contrast to the traditional coalescence model of Deuteron Production Scd63 and Deuteron Production Kap80 where typically only a deuteron is produced from a two-body initial state and so momentum and energy are not conserved. Here, a modified coalescence model can be used where the final state can be specified as a deuteron and a photon. Deuteron Production The default deuteron production setup is taken from Deuteron Production Dal15 , where 8 production channels are defined: Deuteron Production Deuteron Production Deuteron Production p+ n0 &rarr; gamma 2H Deuteron Production Deuteron Production p+ n0 &rarr; pi0 2H Deuteron Production Deuteron Production p+ n0 &rarr; pi0 pi0 2H Deuteron Production Deuteron Production p+ n0 &rarr; pi+ pi- 2H Deuteron Production Deuteron Production p+ p+ &rarr; pi+ 2H Deuteron Production Deuteron Production p+ p+ &rarr; pi+ pi0 2H Deuteron Production Deuteron Production n0 n0 &rarr; pi- 2H Deuteron Production Deuteron Production n0 n0 &rarr; pi- pi0 2H These channels, and the models used to calculate their differential cross-sections, can be fully specified by the user as detailed below. The Deuteron Production DeuteronProduction class performs the deuteron production, first building all valid two-particle combinations, then determining whether the combinations bind, and finally performing an isotropic decay of the bound state into the specified final state. Deuteron Production Main parameters Assuming you have set Deuteron Production HadronLevel:DeuteronProduction = on , you can regulate the detailed behaviour with the following settings. Deuteron Production Deuteron Production Warning : changed Deuteron Production mvec and Deuteron Production wvec values must be provided as a comma-separated list enclosed in braces, Deuteron Production {...}. Deuteron Production Technical parameters The maximum cross-section for each deuteron production channel is calculated using an initial grid search followed by the simplex algorithm. Assuming parameters similar to the default parameters above are used, the following technical parameters should not need to be changed. However, if the maximum finding fails for a given configuration, the following can be modified to ensure appropriate determination of the cross-section maximums."},{"name":"Diffraction","link":"Diffraction.html","text":"Diffraction Diffraction Diffraction Diffraction is not well understood, and several alternative approaches have been proposed, both for the cross section of diffractive events and for the particle production in these. For the latter we here follow a fairly conventional Pomeron-based one, in the Ingelman-Schlein spirit Diffraction Ing85 , but integrated to make full use of the standard PYTHIA machinery for multiparton interactions, parton showers and hadronization Diffraction Nav10,Cor10a. This is the approach pioneered in the PomPyt program by Ingelman and collaborators Diffraction Ing97. Diffraction For ease of use (and of modelling), the Pomeron-specific parts of the generation of inclusive ('soft') diffractive events are subdivided into three sets of parameters that are rather independent of each other: Diffraction (i) the total, elastic and diffractive cross sections are parametrized as functions of the CM energy, or can be set by the user to the desired values, see the Diffraction Total Cross Sections page; Diffraction (ii) once it has been decided to have a diffractive process, a Pomeron flux parametrization is used to pick the mass of the diffractive system(s) and the Diffraction t of the exchanged Pomeron, also here see the Diffraction Total Cross Sections page; Diffraction (iii) a diffractive system of a given mass is classified either as low-mass unresolved, which gives a simple low- Diffraction pT string topology, or as high-mass resolved, for which the full machinery of multiparton interactions and parton showers are applied, making use of Diffraction Pomeron PDFs. Diffraction The parameters related to multiparton interactions, parton showers and hadronization are kept the same as for normal nondiffractive events, with only a few exceptions. This may be questioned, especially for the multiparton interactions, but we do not believe that there are currently enough good diffractive data that would allow detailed separate tunes. Diffraction The above subdivision may not represent the way 'physics comes about'. For instance, the total diffractive cross section can be viewed as a convolution of a Pomeron flux with a Pomeron-proton total cross section. Since neither of the two is known from first principles there will be a significant amount of ambiguity in the flux factor. The picture is further complicated by the fact that the possibility of simultaneous further multiparton interactions ('cut Pomerons') will screen the rate of diffractive systems. In the end, our set of parameters refers to the effective description that emerges out of these effects, rather than to the underlying 'bare' parameters. Diffraction In the event record the diffractive system in the case of an excited proton is denoted Diffraction p_diffr , code 9902210, whereas a central diffractive system is denoted Diffraction rho_diffr , code 9900110. Apart from representing the correct charge and baryon numbers, no deeper meaning should be attributed to the names. Diffraction PYTHIA also includes a possibility to select hard diffraction. This machinery relies on the same sets of parameters as described above, for the Pomeron flux and PDFs. The main difference between the hard and the soft diffractive frameworks is that the user can select any PYTHIA hard process in the former case, e.g. diffractive Diffraction Z 's or Diffraction W 's, whereas only QCD processes are generated in the latter. These QCD processes are generated inclusively, which means that mostly they occur in the low- Diffraction pT region, even if a tail stretches to higher Diffraction pT scales, thus overlapping with hard diffraction. Both hard and soft diffractive processes also include the normal PYTHIA machinery, such as MPIs and showers, but for the former the MPI framework can additionally be used to determine whether a hard process survives as a diffractive event or not. The different diffractive types - low mass soft, high mass soft and hard diffraction - are described in more detail below. Diffraction Separation of soft diffraction into low and high masses Preferably one would want to have a perturbative picture of the dynamics of Pomeron-proton collisions, like multiparton interactions provide for proton-proton ones. However, while PYTHIA by default will only allow collisions with a CM energy above 10 GeV, the mass spectrum of diffractive systems will stretch to down to the order of 1.2 GeV. It would not be feasible to attempt a perturbative description there. Therefore we do offer a simpler low-mass description, with only longitudinally stretched strings, with a gradual switch-over to the perturbative picture for higher masses. The probability for the latter picture is parametrized as Diffraction P_pert = P_max ( 1 - exp( (m_diffr - m_min) / m_width ) ) which vanishes for the diffractive system mass Diffraction m_diffr < m_min , and is Diffraction 1 - 1/e = 0.632 for Diffraction m_diffr = m_min + m_width , assuming Diffraction P_max = 1. Diffraction Low-mass soft diffraction When an incoming hadron beam is diffractively excited, it is modeled as if either a valence quark or a gluon is kicked out from the hadron. In the former case this produces a simple string to the leftover remnant, in the latter it gives a hairpin arrangement where a string is stretched from one quark in the remnant, via the gluon, back to the rest of the remnant. The latter ought to dominate at higher mass of the diffractive system. Therefore an approximate behaviour like Diffraction P_q / P_g = N / m^p is assumed. Diffraction When a gluon is kicked out from the hadron, the longitudinal momentum sharing between the the two remnant partons is determined by the same parameters as above. It is plausible that the primordial Diffraction kT may be lower than in perturbative processes, however: Diffraction High-mass soft diffraction The perturbative description need to use parton densities of the Pomeron. The options are described in the page on Diffraction PDF Selection. The standard perturbative multiparton interactions framework then provides cross sections for parton-parton interactions. In order to turn these cross section into probabilities one also needs an ansatz for the Pomeron-proton total cross section. In the literature one often finds low numbers for this, of the order of 2 mb. These, if taken at face value, would give way too much activity per event. There are ways to tame this, e.g. by a larger Diffraction pT0 than in the normal pp framework. Actually, there are many reasons to use a completely different set of parameters for MPI in diffraction than in pp collisions, especially with respect to the impact-parameter picture, see below. A lower number in some frameworks could alternatively be regarded as a consequence of screening, with a larger 'bare' number. Diffraction For now, however, an attempt at the most general solution would carry too far, and instead we patch up the problem by using a larger Pomeron-proton total cross section, such that average activity makes more sense. This should be viewed as the main tunable parameter in the description of high-mass diffraction. It is to be fitted to diffractive event-shape data such as the average charged multiplicity. It would be very closely tied to the choice of Pomeron PDF; we remind that some of these add up to less than unit momentum sum in the Pomeron, a choice that also affect the value one ends up with. Furthermore, like with hadronic cross sections, it is quite plausible that the Pomeron-proton cross section increases with energy, so we have allowed for a power-like dependence on the diffractive mass. Diffraction Also note that, even for a fixed CM energy of events, the diffractive subsystem will range from the abovementioned threshold mass Diffraction m_min to the full CM energy, with a variation of parameters such as Diffraction pT0 along this mass range. Therefore multiparton interactions are initialized for a few different diffractive masses, currently five, and all relevant parameters are interpolated between them to obtain the behaviour at a specific diffractive mass. Furthermore, Diffraction A B &rarr; X B and Diffraction A B &rarr; A X are initialized separately, to allow for different beams or PDF's on the two sides. These two aspects mean that initialization of MPI is appreciably slower when perturbative high-mass diffraction is allowed. Diffraction Diffraction tends to be peripheral, i.e. occur at intermediate impact parameter for the two protons. That aspect is implicit in the selection of diffractive cross section. For the simulation of the Pomeron-proton subcollision it is the impact-parameter distribution of that particular subsystem that should rather be modeled. That is, it also involves the transverse coordinate space of a Pomeron wavefunction. The outcome of the convolution therefore could be a different shape than for nondiffractive events. For simplicity we allow the same kind of options as for nondiffractive events, except that the Diffraction bProfile = 4 option for now is not implemented. Diffraction Hard diffraction When PYTHIA is requested to generate a hard process, by default it is assumed that the full perturbative cross section is associated with nondiffractive topologies. With the options in this section, PYTHIA includes a possibility for creating a perturbative process diffractively, however. This framework is denoted hard diffraction to distiguish it from soft diffraction, but recall that the latter contains a tail of high- Diffraction pT processes that could alternatively be obtained as hard diffraction. The idea behind hard diffraction is similar to soft diffraction, as they are both based on the Pomeron model. The proton is thus modelled as having a Pomeron component, described by the Pomeron fluxes switch Diffraction SigmaDiffractive:PomFlux , see Diffraction here , and the partonic content of the Pomeron is described by the Pomeron PDFs, see Diffraction here. From these components we can evaluate the probability for the chosen hard process to have been coming from a diffractively excited system, based on the ratio of the Pomeron flux convoluted with Pomeron PDF to the inclusive proton PDF. Diffraction If the hard process is likely to have been created inside a diffractively excited system, then we also evaluate the momentum fraction carried by the Pomeron, Diffraction x_Pomeron , and the momentum transfer, Diffraction t , in the process. This information can also be extracted in the main programs, see eg. example Diffraction main61.cc. Diffraction Further, we distiguish between two alternative scenarios for the classification of hard diffraction. The first is based solely on the Pomeron flux and PDF, as described above. In the second an additional requirement is imposed, wherein the MPI machinery is not allowed to generate any extra MPIs at all, since presumably these would destroy the rapidity gap and thereby the diffractive nature. We refer to the former as MPI-unchecked and the latter as MPI-checked hard diffraction. The MPI-checked option is likely to be the more realistic one, but the MPI-unchecked one offers a convenient baseline for the study of MPI effects, which still are poorly understood. Diffraction Recently, a scenario for hard diffraction with Diffraction gamma beams has been introduced. Thus hard diffraction can be evaluated for both Diffraction gamma + gamma and Diffraction gamma + p processes within the usual photoproduction framework. A Pomeron can be taken from a Diffraction gamma beam only if the photon is resolved. Currently this photon is then assumed always to be in a virtual Diffraction rho state, thus leaving behind a physical Diffraction rho beam remnant. If the Pomeron is taken from the proton, in the Diffraction gamma + parton framework, the photon is allowed to interact with the Pomeron with both its resolved and unresolved components. If the Pomeron is taken from the resolved Diffraction gamma , the proton Pomeron flux is used but rescaled by a factor of Diffraction sigma_tot^gamma+p/sigma_tot^pp , as a very first approximation to this unmeasured distribution. Otherwise all options are available as for hard diffraction in Diffraction pp processes, and all limitations and cautions apply as for the photoproduction framework. Diffraction For the selected hard processes, the user can choose whether to generate the inclusive sample of both diffractive and nondiffractive topologies or diffractive only, and in each case with the diffractive ones distinguished either MPI-unchecked or MPI-checked. Diffraction There is also the possibility to select only a specific subset of events in hard diffraction. Diffraction The Pomeron PDFs have not been scaled to unit momentum sum by the H1 Collaboration, but instead they let the PDF normalization float after the flux had been normalized to unity at Diffraction x_Pom=0.03. This means that the H1 Pomeron has a momentum sum that is about a half. It could be brought to unit momentum sum by picking the parameter Diffraction PDF:PomRescale to be around 2. In order not to change the convolution of the flux and the PDFs, the flux then needs to be rescaled by the inverse. This introduces a new rescaling parameter: Diffraction When using the MBR flux, the model requires a renormalization of the Pomeron flux. This suppresses the flux with approximately a factor of ten, thus making it incompatible with the MPI suppression of the hard diffraction framework. We have thus implemented an option to renormalize the flux. If you wish to use the renormalized flux of the MBR model, you must generate the MPI-unchecked samples, otherwise diffractive events will be suppressed twice. Diffraction The transverse matter profile of the Pomeron, relative to that of the proton, is not known. Generally a Pomeron is supposed to be a smaller object in a localized part of the proton, but one should keep an open mind. Therefore below you find three extreme scenarios, which can be compared to gauge the impact of this uncertainty."},{"name":"Electroweak Processes","link":"ElectroweakProcesses.html","text":"Electroweak Processes Electroweak Processes Electroweak Processes This page contains processes involving Prompt-photon, Electroweak Processes gamma^*/Z^0 and Electroweak Processes W^+- production, plus a few with Electroweak Processes t -channel boson exchange. Electroweak Processes Prompt photon processes This group collects the processes where one or two photons are produced by the hard process. Additional sources of photons include parton showers and hadron decays. A Electroweak Processes pT cut is required to stay away from the unphysical low- Electroweak Processes pT region. An eikonalized description, intended to be valid at all Electroweak Processes pT , is included as part of the multiparton-interactions framework. Electroweak Processes Weak boson processes Under this heading we group processes involving the production of a single electroweak gauge boson, i.e. a Electroweak Processes gamma^*/Z^0 or a Electroweak Processes W^+- , or a pair of them, or one of them in combination with a parton. Since the three sets are partly conflicting, each is associated with its own group flag. In addition, Electroweak Processes t -channel exchange of such a boson between two fermions form a separate group. Electroweak Processes Note that the Electroweak Processes Z^0 and Electroweak Processes W^+- decay modes generated with the processes below only include those Standard-Model ones that are allowed for on-shell decays. Thus several other processes that receive contributions from off-shell resonances are listed separately, e.g. for Electroweak Processes top or Electroweak Processes fourth generation fermions. Electroweak Processes There is one flag that can be used to influence the Electroweak Processes gamma^*/Z^0 structure in all the processes below where it is produced, unless otherwise stated. Electroweak Processes Boson exchange The two processes in this subgroup is included as part of the multiparton-interactions framework. Electroweak Processes Single boson Electroweak Processes Boson pair Note that, in the decay of the two vector bosons produced by an Electroweak Processes f fbar &rarr; V V process, the full four-fermion correlations from the leading-order Electroweak Processes f fbar &rarr; V V &rarr; 4f matrix elements are included Electroweak Processes Gun86 (with some extensions by the authors). The matrix elements are provided in the double-resonant approach, i.e. excludes graph like Electroweak Processes f fbar &rarr; V &rarr; f fbar &rarr; f fbar V &rarr; 4f. Electroweak Processes Boson and parton Electroweak Processes Photon Collision Processes A few electroweak two-photon production processes are available. To use them, photon PDFs have to be defined for the incoming beam particles. This is the case for the internal NNPDF 2.3 QCD+QED sets, as well as some further ones available in the LHAPDF library, but not for all PDFs. Electroweak Processes Photon-Parton Processes Electroweak Processes Photon-parton production processes. See comment related to PDFs above. Also relevant for direct-resolved processes in photon-photon collisions. Two instances of a given process are created when mixing processes where the direct photon can come from either side. In this case the process code in the parentheses is used when the direct photon is from side A."},{"name":"Error Checks","link":"ErrorChecks.html","text":"Error Checks Error Checks Error Checks There is a few settings related to error checking during program execution. Many other checks are performed as well, but do not have any specific setting related to themselves."},{"name":"Event Analysis","link":"EventAnalysis.html","text":"Event Analysis Event Analysis Event Analysis Event Analysis Introduction The routines in this section are intended to be used to analyze event properties. As such they are not part of the main event generation chain, but can be used in comparisons between Monte Carlo events and real data. They are rather free-standing, but assume that input is provided in the PYTHIA 8 Event Analysis Event format, and use a few basic facilities such as four-vectors. Their ordering is mainly by history; for current LHC applications the final one, Event Analysis SlowJet , is of special interest. Event Analysis In addition to the methods presented here, there is also the possibility to make use of Event Analysis external jet finders. Event Analysis Sphericity The standard sphericity tensor is Event Analysis S^{ab} = (sum_i p_i^a p_i^b) / (sum_i p_i^2) where the Event Analysis sum i runs over the particles in the event, Event Analysis a, b = x, y, z, and Event Analysis p without such an index is the absolute size of the three-momentum. This tensor can be diagonalized to find eigenvalues and eigenvectors. Event Analysis The above tensor can be generalized by introducing a power Event Analysis r , such that Event Analysis S^{ab} = (sum_i p_i^a p_i^b p_i^{r-2}) / (sum_i p_i^r) In particular, Event Analysis r = 1 gives a linear dependence on momenta and thus a collinear safe definition, unlike sphericity. Event Analysis To do sphericity analyses you have to set up a Event Analysis Sphericity instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. Event Analysis After the analysis has been performed, a few methods are available to return the result of the analysis of the latest event: Event Analysis There is also one method that returns information accumulated for all the events analyzed so far. Event Analysis Thrust Thrust is obtained by varying the thrust axis so that the longitudinal momentum component projected onto it is maximized, and thrust itself is then defined as the sum of absolute longitudinal momenta divided by the sum of absolute momenta. The major axis is found correspondingly in the plane transverse to thrust, and the minor one is then defined to be transverse to both. Oblateness is the difference between the major and the minor values. Event Analysis The calculation of thrust is more computer-time-intensive than e.g. linear sphericity, introduced above, and has no specific advantages except historical precedent. In the PYTHIA 6 implementation the search was sped up at the price of then not being guaranteed to hit the absolute maximum. The current implementation studies all possibilities, but at the price of being slower, with time consumption for an event with Event Analysis n particles growing like Event Analysis n^3. Event Analysis To do thrust analyses you have to set up a Event Analysis Thrust instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. Event Analysis After the analysis has been performed, a few methods are available to return the result of the analysis of the latest event: Event Analysis There is also one method that returns information accumulated for all the events analyzed so far. Event Analysis ClusterJet Event Analysis ClusterJet (a.k.a. Event Analysis LUCLUS and Event Analysis PYCLUS ) is a clustering algorithm of the type used for analyses of Event Analysis e^+e^- events, see the PYTHIA 6 manual. All visible particles in the events are clustered into jets. A few options are available for some well-known distance measures. Cutoff distances can either be given in terms of a scaled quadratic quantity like Event Analysis y = pT^2/E^2 or an unscaled linear one like Event Analysis pT. Event Analysis Note that we have deliberately chosen not to include the Event Analysis e^+e^- equivalents of the Cambridge/Aachen and anti- Event Analysis kRT algorithms. These tend to be good at clustering the densely populated (in angle) cores of jets, but less successful for the sparsely populated transverse regions, where many jets may come to consist of a single low-momentum particle. In hadron collisions such jets could easily be disregarded, while in Event Analysis e^+e^- annihilation all particles derive back from the hard process. Event Analysis To do jet finding analyses you have to set up a Event Analysis ClusterJet instance, and then feed in events to it, one at a time. The results for the latest event are available as output from a few methods. Event Analysis After the analysis has been performed, a few Event Analysis ClusterJet class methods are available to return the result of the analysis: Event Analysis There is also one method that returns information accumulated for all the events analyzed so far. Event Analysis CellJet Event Analysis CellJet (a.k.a. Event Analysis PYCELL ) is a simple cone jet finder in the UA1 spirit, see the PYTHIA 6 manual. It works in an Event Analysis (eta, phi, eT) space, where Event Analysis eta is pseudorapidity, Event Analysis phi azimuthal angle and Event Analysis eT transverse energy. It will draw cones in Event Analysis R = sqrt(Delta-eta^2 + Delta-phi^2) around seed cells. If the total Event Analysis eT inside the cone exceeds the threshold, a jet is formed, and the cells are removed from further analysis. There are no split or merge procedures, so later-found jets may be missing some of the edge regions already used up by previous ones. Not all particles in the event are assigned to jets; leftovers may be viewed as belonging to beam remnants or the underlying event. It is not used by any experimental collaboration, but is closely related to the more recent and better theoretically motivated anti- Event Analysis kT algorithm Event Analysis Cac08. Event Analysis To do jet finding analyses you have to set up a Event Analysis CellJet instance, and then feed in events to it, one at a time. Especially note that, if you want to use the options where energies are smeared in order so emulate detector imperfections, you must hand in an external random number generator, preferably the one residing in the Event Analysis Pythia class. The results for the latest event are available as output from a few methods. Event Analysis After the analysis has been performed, a few Event Analysis CellJet class methods are available to return the result of the analysis: Event Analysis There is also one method that returns information accumulated for all the events analyzed so far. Event Analysis SlowJet Event Analysis SlowJet is a simple program for doing jet finding according to either of the Event Analysis kT , anti- Event Analysis kT , and Cambridge/Aachen algorithms, in a cylindrical coordinate frame. The name is obviously an homage to the Event Analysis FastJet program Event Analysis Cac06, Cac12. That package contains many more algorithms, with many more options, and, above all, is Event Analysis much faster. Therefore Event Analysis SlowJet is not so much intended for massive processing of data or Monte Carlo files as for simple first tests. Nevertheless, within the advertised capabilities of Event Analysis SlowJet , it has been checked to find identically the same jets as Event Analysis FastJet. The time consumption typically is around or below that to generate an LHC Event Analysis pp event in the first place, so is not prohibitive. But the time rises rapidly for large multiplicities, so obviously Event Analysis SlowJet can not be used for tricks like distributing a dense grid of pseudoparticles to be able to define jet areas, like Event Analysis FastJet can, and also not for events with much pileup or other noise. Event Analysis The recent introduction of Event Analysis fjcore , containing the core functionality of Event Analysis FastJet in a very much smaller package, has changed the conditions. It now is possible (even encouraged by the authors) to distribute the two Event Analysis fjcore files as part of the PYTHIA package. Therefore the Event Analysis SlowJet class doubles as a convenient front end to Event Analysis fjcore , managing the conversion back and forth between PYTHIA and Event Analysis FastJet variables. Some applications may still benefit from using the native codes, but the default now is to let Event Analysis SlowJet call on Event Analysis fjcore for the jet finding. Event Analysis The first step is to decide which particles should be included in the analysis, and with what four-momenta. The Event Analysis SlowJet constructor allows to pick a maximum pseudorapidity defined by the extent of the assumed detector, to pick among some standard options of which particles to analyze, and to allow for some standard mass assumptions, like that all charged particles have the pion mass. Obviously this is only a restricted set of possibilities. Event Analysis Full flexibility can be obtained by deriving from the base class Event Analysis SlowJetHook to write your own Event Analysis include method. This will be presented with one final-state particle at a time, and should return Event Analysis true for those particles that should be analyzed. It is also possible to return modified four-momenta and masses, to take into account detector smearing effects or particle identity misassignments, but you must respect Event Analysis E^2 - p^2 = m^2. Event Analysis Alternatively you can modify the event record itself, or a copy of it (if you want to keep the original intact). For instance, only final particles are considered in the analysis, i.e. particles with positive status code, so negative status code should then be assigned to those particles that you do not want to see analyzed. Again four-momenta and masses can be modified, subject to Event Analysis E^2 - p^2 = m^2. Event Analysis The jet reconstructions is then based on sequential recombination with progressive removal, using the Event Analysis E recombination scheme. To be more specific, the algorithm works as follows. Event Analysis Event Analysis Each particle to be analyzed defines an original cluster. It has a well-defined four-momentum and mass at input. From this information the triplet Event Analysis (pT, y, phi) is calculated, i.e. the transverse momentum, rapidity and azimuthal angle of the cluster. Event Analysis Define distance measures of all clusters Event Analysis i to the beam Event Analysis d_iB = pT_i^2p and of all pairs Event Analysis (i,j) relative to each other Event Analysis d_ij = min( pT_i^2p, pT_j^2p) DeltaR_ij^2 / R^2 where Event Analysis DeltaR_ij^2 = (y_i - y_j)^2 + (phi_i - phi_j)^2. The jet algorithm is determined by the user-selected Event Analysis p value, where Event Analysis p = -1 corresponds to the anti- Event Analysis kT one, Event Analysis p = 0 to the Cambridge/Aachen one and Event Analysis p = 1 to the Event Analysis kT one. Also Event Analysis R is chosen by the user, to give an approximate measure of the size of jets. However, note that jets need not have a circular shape in Event Analysis (y, phi) space, so Event Analysis R can not straight off be interpreted as a jet radius. Event Analysis Find the smallest of all Event Analysis d_iB and Event Analysis d_ij. Event Analysis If this is a Event Analysis d_iB then cluster Event Analysis i is removed from the clusters list and instead added to the jets list. Optionally, a Event Analysis pTjetMin requirement is imposed, where only clusters with Event Analysis pT > pTjetMin are added to the jets list. If so, some of the analyzed particles will not be part of any final jet. Event Analysis If instead the smallest measure is a Event Analysis d_ij then the four-momenta of the Event Analysis i and Event Analysis j clusters are added to define a single new cluster. Convert this four-momentum to a new Event Analysis (pT, y, phi) triplet and update the list of Event Analysis d_iB and Event Analysis d_ij. Event Analysis Return to step 3 until no clusters remain. Event Analysis To do jet finding analyses you first have to set up a Event Analysis SlowJet instance, where the arguments of the constructor specifies the details of the subsequent analyses. Thereafter you can feed in events to it, one at a time, and have them analyzed by the Event Analysis analyze method. Information on the resulting jets can be extracted by a few different methods. The minimal procedure only requires one call per event to do the analysis. We will begin by presenting it, and only afterwards some extensions. Event Analysis After the analysis has been performed, a few Event Analysis SlowJet class methods are available to return the result of the analysis: Event Analysis These are the basic methods. For more sophisticated usage it is possible to trace the clustering, one step at a time. It requires the native jet finding code, Event Analysis useFJcore = false in the constructor. If so, the Event Analysis setup method should be used to read in the event and find the initial smallest distance. Each subsequent Event Analysis doStep will then do one cluster joining and find the new smallest distance. You can therefore interrogate which clusters will be joined next before the joining actually is performed. Alternatively you can take several steps in one go, or take steps down to a predetermined number of jets plus remaining clusters. Event Analysis With this extension, the methods Event Analysis double pT(int i) , Event Analysis double y(int i) , Event Analysis double phi(int i) , Event Analysis Vec4 p(int i) , Event Analysis double m(int i) and Event Analysis int multiplicity(int i) can be used as before. Furthermore, Event Analysis list() generalizes Event Analysis Three further methods can be used to check what will happen next. Event Analysis Finally, and separately, the Event Analysis SlowJetHook class can be used for a more smart selection of which particles to include in the analysis. For instance, isolated and/or high- Event Analysis pT muons, electrons and photons should presumably be identified separately at an early stage, and then not clustered to jets. Event Analysis Technically, it works like with Event Analysis User Hooks. That is, PYTHIA contains the base class. You write a derived class. In the main program you create an instance of this class, and hand it in to Event Analysis SlowJet ; in this case already as part of the constructor. Event Analysis The following methods should be defined in your derived class. Event Analysis It is also possible to define further methods of your own. One such could e.g. be called directly in the main program before the Event Analysis analyze method is called, to identify and bookkeep some event properties you may not want to reanalyze for each individual particle."},{"name":"Event Information","link":"EventInformation.html","text":"Event Information Event Information Event Information The Event Information Info class collects various one-of-a-kind information, some relevant for all events and others for the current event. An object Event Information info is a public member of the Event Information Pythia class, so if you e.g. have declared Event Information Pythia pythia , the Event Information Info methods can be accessed by Event Information pythia.info.method(). Most of this is information that could also be obtained e.g. from the event record, but is here more directly available. It is primarily intended for processes generated internally in PYTHIA, but many of the methods would work also for events fed in via the Les Houches Accord. Event Information List information Event Information The beams Event Information Initialization Event Information The event type Event Information Hard process initiators The methods in this sections refer to the two initial partons of the hard Event Information 2 &rarr; n process (diffraction excluded; see below). Event Information Hard process parton densities and scales The methods in this section refer to the partons for which parton densities have been defined, in order to calculate the cross section of the hard process (diffraction excluded; see below). Event Information These partons would normally agree with the ones above, the initiators of the Event Information 2 &rarr; n process, but it does not have to be so. Currently the one counterexample is POWHEG events Event Information Ali10. Here the original hard process could be Event Information 2 &rarr; (n-1). The NLO machinery at times would add an initial-state branching to give a Event Information 2 &rarr; n process with a changed initial state. In that case the values in this section refer to the original Event Information 2 &rarr; (n-1) state and the initiator ones above to the complete Event Information 2 &rarr; n process. The Event Information Info::list() printout will contain a warning in such cases. Event Information For external events in the Les Houches format, the pdf information is obtained from the optional Event Information #pdf line. When this information is absent, the parton identities and Event Information x values agree with the initiator ones above, while the pdf values are unknown and therefore set to vanish. The Event Information alpha_s and Event Information alpha_em values are part of the compulsory information. The factorization and renormalization scales are both equated with the one compulsory scale value in the Les Houches standard, except when a Event Information #pdf line provides the factorization scale separately. If Event Information alpha_s , Event Information alpha_em or the compulsory scale value are negative at input then new values are defined as for internal processes. Event Information Hard process kinematics The methods in this section provide info on the kinematics of the hard processes, with special emphasis on Event Information 2 &rarr; 2 (diffraction excluded; see below). Event Information Soft Diffraction Information on the primary elastic or Event Information diffractive process ( Event Information A B &rarr; A B, X1 B, A X2, X1 X2, A X B ) can be obtained with the methods in the 'Hard process kinematics' section above. The variables here obviously are Event Information s, t, u, ... rather than Event Information sHat, tHat, uHat, ... , but the method names remain to avoid unnecessary duplication. Most other methods are irrelevant for a primary elastic/diffractive process. Event Information Central diffraction Event Information A B &rarr; A X B is a Event Information 2 &rarr; 3 process, and therefore most of the Event Information 2 &rarr; 2 variables are no longer relevant. The Event Information tHat() and Event Information uHat() methods instead return the two Event Information t values at the Event Information A &rarr; A and Event Information B &rarr; B vertices, and Event Information pTHat() the average transverse momentum of the three outgoing 'particles', while Event Information thetaHat() and Event Information phiHat() are undefined. Event Information While the primary interaction does not contain a hard process, the diffractive subsystems can contain them, but need not. Specifically, double diffraction can contain two separate hard subprocesses, which breaks the methods above. Most of them have been expanded with an optional argument to address properties of diffractive subsystems. This argument can take four values: Event Information Event Information 0 : default argument, used for normal nondiffractive events or the primary elastic/diffractive process (see above); Event Information 1 : the Event Information X1 system in single diffraction Event Information A B &rarr; X1 B or double diffraction Event Information A B &rarr; X1 X2 ; Event Information 2 : the Event Information X2 system in single diffraction Event Information A B &rarr; A X2 or double diffraction Event Information A B &rarr; X1 X2 ; Event Information 3 : the Event Information X system in central diffraction Event Information A B &rarr; A X B. The argument is defined for all of the methods in the three sections above, 'Hard process initiators', 'Hard process parton densities and scales' and 'Hard process kinematics', with the exception of the Event Information isValence methods. Also the four final methods of 'The event type' section, the Event Information ...Sub() methods, take this argument. But recall that they will only provide meaningful answers, firstly if there is a system of the requested type, and secondly if there is a hard subprocess in this system. A simple check for this is that Event Information id1() has to be nonvanishing. The methods below this section do not currently provide information specific to diffractive subsystems, e.g. the MPI information is not bookkept in such cases. Event Information Hard Diffraction Information on the momentum fraction taken from the beam and the momentum transfer in the hard diffractive process. Note that when side A is diffractively exited, then the Pomeron has been taken from side B and vice versa. Event Information Photons from lepton beams Information about the kinematics of photon-photon collisions from lepton beams. Event Information Event weight and activity Event Information Multiparton interactions As already noted, these methods do not make sense for diffractive topologies, and should not be used there. Partly this is physics, but mainly it is for technical reasons, e.g. that double diffraction involves two separate systems that would have to be bookkept as such. Event Information Cross sections Here are the currently available methods related to the event sample as a whole, for the default value Event Information i = 0 , and otherwise for the specific process code provided as argument. This is the number obtained with Event Information Info::code() , while the further subdivision given by Event Information Info::codeSub() is not bookkept. While continuously updated during the run, it is recommended only to study these properties at the end of the event generation, when the full statistics is available. The individual process results are not available if Event Information a second hard process has been chosen, but can be gleaned from the Event Information pythia.stat() output. Event Information Loop counters Mainly for internal/debug purposes, a number of loop counters from various parts of the program are stored in the Event Information Info class, so that one can keep track of how the event generation is progressing. This may be especially useful in the context of the Event Information Event Information User Hooks facility. Event Information Parton shower history The following methods are mainly intended for internal use, e.g. for matrix-element matching. Event Information Les Houches Event File 3.0 information Les Houches Event files can conform to version 1.0 and version 3.0 of the standard (version 2.0 having been extended to 3.0). The LHEF version of an input file can can be accessed by Event Information Event Information The Event Information Info class also provides a suitable interface to the information stored after reading Les Houches Event files in the updated format Event Information But14. An example main program using LHEF 3.0 information is Event Information main38.cc. Event Information LHEF 3.0 offers new features both in the initialisation and the event sections of the input files. Possible information include extended use of XML tags in the Event Information <header> and Event Information <init> blocks.  The LHEF 3.0 information is stored in a series Event Information struct 's: Event Information -- &nbsp; &nbsp; The Event Information <initrwgt> tag is a container  tag for weight and weightgroup tags.  This information is stored  internally in Event Information LHAinitrwgt.  Currently, there is no dedicated  output for this tag. However, all the information stored in the tag can  be retrieved by using the Event Information Info class member pointer Event Information LHAinitrwgt Info::initrwgt. Event Information -- &nbsp; &nbsp; Multiple Event Information <weightgroup> tags:  Container tag for weight tags. Currently, there is no dedicated  output for this tag. However, all the information stored in the tag can  be retrieved by using the Event Information Info class member pointer Event Information vector<LHAweightgroups> * Info::weightgroups. Event Information -- &nbsp; &nbsp; Multiple Event Information <weight> tags: Tag defining  auxiliary information on an event weight, e.g. the identifier and information  on what the weight represents. All the information stored in the tag can  be retrieved by using the Event Information Info class member pointer Event Information vector<LHAweightgroups> * Info::init_weights. This vector  contains all Event Information <weight> tags in the Event Information <initrwgt> container and its subcontainer Event Information <weightgroup> tags. The size of the vector can be accessed  through the method Event Information Event Information -- &nbsp; &nbsp; Multiple Event Information <generator> tags: Store  information on the generators used in the event generation. All the  information stored in the tag can be retrieved by using the Event Information Info class member pointer Event Information vector<LHAgenerators> * Info::generators. More easy-to-use  output functions are available. The size of this vector can be obtained from Event Information Event Information The complete header can be obtained with the Event Information Info class member Event Information string getHeaderBlock(). Event Information The contents of a Event Information <generator> tag can be accessed through the method Event Information Event Information Attributes of the Event Information <generator> tag (e.g. the generator Event Information name and Event Information version ) can be accessed via Event Information Event Information To obtain information on cross sections, the following two methods can be used Event Information Event Information Event Information Possible information also includes extended use of XML tags in the Event Information <event> blocks: Event Information -- &nbsp; &nbsp; The Event Information <rwgt> tag is a container  tag for wgt tags. Currently, there is no dedicated  output for this tag. It can however be retrieved by using the Event Information Info class member pointer Event Information LHArwgt Info::rwgt. Event Information -- &nbsp; &nbsp; Multiple Event Information <wgt> tags: Tag defining  the event weight in the detailed version of LHEF 3.0.  All the information  stored in the tag can be retrieved by using the Event Information Info class  member pointer Event Information vector<LHAwgt> * Info::weights_detailed.  More easy-to-use output functions are available. The size of this vector  can be obtained from Event Information Event Information A convenient access point to the information stored in the Event Information <wgt> tags is the Event Information Info class member Event Information vector<double> Info::weights_detailed_vector. The entries of this vector are ordered according to how Event Information <wgt> tags appear in the event block. Event Information The contents of a Event Information <wgt> tag can be accessed through the method Event Information Event Information Attributes of the Event Information <wgt> tag (e.g. the weight Event Information id ) can be accessed via Event Information Event Information -- &nbsp; &nbsp; The Event Information <weights> tag: Tag containing  a vector of Event Information double entries for weights in the compressed version  of LHEF 3.0. All the information stored in the tag can be retrieved by using  the Event Information Info class member pointer Event Information LHAweights *  Info::weights and the vector Event Information vector<double>  Info::weights_compressed. More easy-to-use output functions are  available. The size of this vector can be obtained from Event Information Event Information The n'th weight can be accessed through the method Event Information Event Information Attributes of the Event Information <weights> tag (not normally used) can be accessed via Event Information Event Information -- &nbsp; &nbsp; The Event Information <scales> tag: Contains information  on different scales used by the matrix element generator. All the information  stored in the tag can be retrieved by using the Event Information Info class  member pointer Event Information LHAweights * Info::scales. More easy-to-use  output functions are available. The contents of the scales tag can be  obtained from Event Information Event Information However, note that the actual scale values are stored as attributes (called e.g. Event Information muf or Event Information mur ). Attributes of the Event Information <scales> tag can be accessed via Event Information Event Information Finally, arbitrary attributes of the Event Information <event> tag are supported. Attributes of the Event Information <event> tag can be accessed by Event Information Event Information Additional comments appearing in the Event Information <event> tag can be obtained with the Event Information Info class member Event Information string getEventComments(). Event Information Header information A simple string key/value store, mainly intended for accessing information that is stored in the header block of Les Houches Event (LHE) files. In principle, any Event Information LHAup derived class can set this header information, which can then be read out later. Although the naming convention is arbitrary, in practice, it is dictated by the XML-like format of LHE files, see Event Information Les Houches Accord for more details."},{"name":"Event Statistics","link":"EventStatistics.html","text":"Event Statistics Event Statistics Event Statistics At the end of the run you will want to write out the final statistics on number of events generated, the corresponding cross sections and the number of errors encountered. This is done with the Event Statistics pythia.stat() method, assuming Event Statistics pythia is an instance of the Event Statistics Pythia class.The method is steered entirely by settings values, see Event Statistics here. Event Statistics Cross-section statistics The Event Statistics ProcessLevel::statistics() method cannot be accessed directly, but only via the Event Statistics Pythia::stat() call above. When called it will loop over the list of existing processes, and for each write out name, code, the number of tried, selected and accepted events, the cross section and the estimated error on the latter. The three different event numbers are related to the Monte Carlo method used, whereby an initial upper estimate of the cross section is used to select a large number of trial phase-space points, whereof then not all survive. Rejections are normally done by the internal machinery, but can also be obtained by Event Statistics user hooks. Therefore: Event Statistics Event Statistics Event Statistics tried events reflect the original number of phase-space points probed, as part of the upper estimate; Event Statistics Event Statistics selected events correspond to those that survive the internal Monte-Carlo selection procedure; Event Statistics Event Statistics accepted events are those that also survive the additional user cuts. In most runs there would be no user hooks implemented, and then the numbers of selected and of accepted events will agree. Aborted events (see below) usually appear in the selected statistics but not in the accepted one. Event Statistics For Les Houches events the total cross section will be correctly displayed; however the (optional) error value will not be used, so that the reported error will be smaller than the correct statistical ones, and often vanish completely. Furthermore, while the number of events is shown for each user process, the cross section is only for the sum of them. Event Statistics Error messages When Pythia is run, errors may occur, and give rise to warning messages. These may be of varying severity, as follows: Event Statistics Event Statistics Event Statistics Abort means things went seriously wrong, and the initialization or event generation failed. In the former case it is not possible to generate events at all, in the latter the current event is flawed and should be skipped. In either case the respective method, Event Statistics Pythia::init() or Event Statistics Pythia::next() , then also returns the value Event Statistics false. There are occasions where an abort may be deliberate, such as when a file of Les Houches Events is read and the end of the file is reached. Event Statistics Event Statistics Error normally is less severe. Typically the program will back up one step and try again. There are cases where this is not possible, in particular during the initialization and the generation of a hard process, and then the error may be followed by an abort as a direct consequence (with two separate messages). Event Statistics Event Statistics Warning is even less severe. In some cases the program will try again, with  good chances of success, in others no measure at all need to be taken. Event Statistics The error messages is handled by a small part of the Event Statistics Info class. It is handed any abort, error or warning messages during the event generation phase, and will store each distinct message, with a counter for how many times it is issued. Thus it is possible to limit the number of identical messages issued, currently hardcoded so that each kind of error message is only printed once ( Event Statistics static const int TIMESTOPRINT = 1 ). This can be overridden by the calling routine, so that all messages of this kind are shown, which is particularly relevant for the initialization  stage. The summary table printed by Event Statistics Pythia::stat() provides a table with all the different messages issued, in alphabetical order, with the total number of times each was generated. Event Statistics Multiparton-interactions statistics If you call Event Statistics Pythia::stat() with Event Statistics Stat:showPartonLevel = true also statistics on multiparton interactions is printed, comprising a list of all allowed subprocesses with how many times each of them has been generated. For the nondiffractive process this also includes the hardest interaction, while else the hardest process is excluded from the statistics. (This is because the hardest process is of the same character and generated by the same machinery in the former case but not in the latter. Also, for the former case only, the standard statistics listing only lists nondiffractive as one single process, i.e. does not further specify the character of the hardest subprocess, so there is not any overlap between the two.)"},{"name":"External Decays","link":"ExternalDecays.html","text":"External Decays External Decays External Decays External Decays DecayHandler is a base class for the external handling of decays. It is intended for normal particle decays, primarily External Decays B mesons and External Decays tau , and cannot be used to redirect decays of heavy resonances like External Decays t or External Decays Z^0. The user-written derived class is called if a pointer to it has been given with the External Decays External Decays pythia.decayPtr() method, where it also is specified which particles it will be called for. This particle information is accessible with the External Decays External Decays doExternalDecay() method. External Decays The main pure virtual method in External Decays DecayHandler to do the decay is: External Decays At input, these vectors each have size one, so that External Decays idProd[0] , External Decays mProd[0] and External Decays pProd[0] contain information on the particle that is to be decayed. At output, the vectors should have increased by the addition of all the decay products. Even if initially defined in the rest frame of the mother, the products should have been boosted so that their four-momenta add up to the External Decays pProd[0] of the decaying particle. External Decays Should it be of interest to know the prehistory of the decaying particle, e.g. to set some helicity information affecting the decay angular distribution, the full event record is available read-only, with info in which slot External Decays iDec the decaying particle is stored. External Decays The routine should return External Decays true if it managed the decay and External Decays false otherwise, in which case External Decays Pythia will try to do the decay itself. This e.g. means you can choose to do some decay channels yourself, and leave others to External Decays Pythia. To avoid double-counting, the channels you want to handle should be switched off in the External Decays Pythia particle database. In the beginning of the external External Decays decay method you should then return External Decays false with a probability given by the sum of the branching ratios for those channels you do not want to handle yourself. External Decays Note that the decay vertex is always set by External Decays Pythia , and that External Decays B-Bbar oscillations have already been taken into account, if they were switched on. Thus External Decays idProd[0] may be the opposite of External Decays event[iDec].id() , where the latter provides the code at production. External Decays One limitation of the method above is that it is only intended for one decay step, not for a sequential decay chain. (At least not for displaying such intermediate steps.) That is, the control for any subsequent decays returns to PYTHIA. If you want to avoid this another method exists, with one extra argument: External Decays Here the new External Decays motherProd vector also has size one at input, with External Decays motherProd[0] = 0. At output it should have increaed in size in the same way as the other arrays. Particles that come directly from the mother should have value 0, whereas secondary decay products should have the index of the mother in the arrays. To simplify parsing, particles having the same mother should be placed consecutively in the arrays, and daughters can not be put before their mothers. When the particles are transferred to the standard event record, the full mother-daughter relations will be reconstructed from the new array, and any particle with daughters will be considered to have decayed. For long-lived intermediate particles also vertex information will take this into account. User-selected secondary decay channels will be accepted as they are, however, without any knowledge whether the user has allowed for particle-antiparticle oscillations before that decay. Therefore a simple exponential decay time will be used to find secondary vertices. External Decays While primarily intended for sequential decays, of course the External Decays chainDecay method can be used also for simple decays in one step, and is then equivalent with External Decays decay one. This is useful if a particle species has some decay channels that lead to sequential decays whereas others do not. During code execution it is first checked whether External Decays chainDecay can do the decay, and if not External Decays decay is offered to. By default External Decays chainDecay returns false, so if you only overload External Decays decay it will be called. If you want to you can choose to handle the decays of some particles in one of the methods and other particles in the other method, so long as you return false for those decays you do not handle. External Decays The choice of which method to use can be done by the user in the method External Decays A sample test program is available in External Decays main17.cc , providing a simple example of how to use this facility. External Decays EvtGen The external External Decays B and External Decays C -hadron decay program EvtGen performs a chain of decays, rather than single particle decays, to propagate helicity information throughout the chain. Consequently, EvtGen cannot be simply interfaced via the External Decays DecayHandler class. A special class, External Decays EvtGenDecays , is provided in External Decays Pythia8Plugins which can be called after an event has been generated, to perform all remaining decays via EvtGen. An example of how to use this class is provided in External Decays main48.cc. A more detailed discussion of some physics considerations, notably event weights for forced decays, can be found in External Decays this note."},{"name":"Extra-Dimensional Processes","link":"ExtraDimensionalProcesses.html","text":"Extra-Dimensional Processes Extra-Dimensional Processes Extra-Dimensional Processes Scenarios with extra dimensions (ED) allow a multitude of processes. Currently three different categories of processes are implemented. The first involves the production of excited Kaluza Klein states within so-called Randall-Sundrum (RS) scenarios, the second is related to resonance production in TeV-1 sized extra dimensions and the third relates to phenomena from large extra dimensions (LED). Due to the close relation between the LED model and a so-called unparticle model, similar unparticle processes are also kept in this section. Extra-Dimensional Processes Randall-Sundrum Resonances, production processes The graviton (G*) and gluon (KKgluon*) resonance states are assigned PDG code 5100039 and 5100021 respectively. The G* processes are described in Extra-Dimensional Processes Bij01 and the KKgluon* process in Extra-Dimensional Processes Ask11. Decays into fermion and boson pairs are handled with the correct angular distributions, while subsequent decays are handled isotropically. Extra-Dimensional Processes There are two lowest-order processes that together normally should be sufficient for a simulation of Extra-Dimensional Processes G^* production. Extra-Dimensional Processes In addition there are three first-order processes included. These are of less interest, but can be used for dedicated studies of the high- Extra-Dimensional Processes pT tail of Extra-Dimensional Processes G^* production. As usual, it would be double counting to include the lowest-order and first-order processes simultaneously. Therefore the latter ones are not included with the Extra-Dimensional Processes ExtraDimensionsG*:all = on option. In this set of processes all decay angles are assumed isotropic. Extra-Dimensional Processes There is also one process for the production of a gluon resonance. Extra-Dimensional Processes Randall-Sundrum Resonances, parameters In the above scenario the main free parameters are the masses, which are set as usual. In addition there are the following coupling parameters. The coupling Extra-Dimensional Processes kappaMG follows the conventions in Extra-Dimensional Processes Bij01 , where as the flavour dependent couplings follow the conventions used in Extra-Dimensional Processes Dav01. Extra-Dimensional Processes TeV^-1 Sized Extra Dimension, production processes This section contains a processes involving the production of electroweak KK gauge bosons, i.e. Extra-Dimensional Processes gamma_{KK}/Z_{KK} , in one TeV^-1 sized extra dimension. The process is described in Extra-Dimensional Processes Bel10 and allows for individual final states to be specified. Extra-Dimensional Processes TeV^-1 Sized Extra Dimension, parameters Irrespective of the parameter options used, the particle produced, Extra-Dimensional Processes gamma_{KK}/Z_{KK} , will always be assigned code 5000023. Extra-Dimensional Processes Large Extra Dimensions, production processes The LED graviton, where the KK-modes normally are summed and do not give rise to phenomena individually, is assigned PDG code 5000039. The graviton emission and virtual graviton exchange processes use the same implementation as the corresponding unparticle processes, which are all described in Extra-Dimensional Processes Ask10. It is also possible to generate monojet events from scalar graviton emission as described in Extra-Dimensional Processes Azu05 , by turning on the option Extra-Dimensional Processes GravScalar. Extra-Dimensional Processes Extra-Dimensional Processes Note: As discussed in Extra-Dimensional Processes Ask09 , for the graviton or unparticle emission processes the underlying Breit-Wigner mass distribution should be matched to the graviton mass spectrum in order to achieve an optimal MC efficiency. Extra-Dimensional Processes The following lowest order graviton emission processes are available. Extra-Dimensional Processes The following LED processes with virtual graviton exchange are available. Extra-Dimensional Processes Dijet production including graviton exchange is also available, using the same effective theory approach as the LED G exchange processes above or including more detailed amplitudes in accordance with Extra-Dimensional Processes Fra11. In case of the latter, the value of Extra-Dimensional Processes LambdaT is used as the value of the cut-off scale Extra-Dimensional Processes Lambda. For this reason the dijet processes only relates to the LED model and no unparticle versions are available. The processes are grouped together like their Extra-Dimensional Processes HardQCD equivalents and should therefore converge to the same results in the limit of an insignificant graviton contribution. Extra-Dimensional Processes Extra-Dimensional Processes Warning: These LED dijets processes are still being validated. Extra-Dimensional Processes Large Extra Dimensions, parameters Extra-Dimensional Processes Unparticles, production processes As mentioned above, the similar unparticle and graviton processes share the same implementations. The unparticle processes, however, only use the dedicated unparticle parameters below. The unparticle is also assigned the PDG code 5000039 and is therefore called Extra-Dimensional Processes Graviton in the event record. The graviton and unparticle emission as well as virtual graviton and unparticle exchange processes are described in Extra-Dimensional Processes Ask10. Extra-Dimensional Processes Extra-Dimensional Processes Note: As discussed in Extra-Dimensional Processes Ask09 , for the graviton or unparticle emission processes the underlying Breit-Wigner mass distribution should be matched to the graviton mass spectrum in order to achieve an optimal MC efficiency. Extra-Dimensional Processes The following unparticle emission processes are available. Extra-Dimensional Processes The following processes with virtual unparticle exchange are available. Extra-Dimensional Processes Unparticles, parameters"},{"name":"Flavour Selection","link":"FlavourSelection.html","text":"Flavour Selection Flavour Selection Flavour Selection The Flavour Selection StringFlav class handles the choice of a new flavour in the fragmentation process, and the production of a new hadron from a set of input flavours. It is mainly used by the string fragmentation machinery (including ministrings), but also e.g. in some particle decays and for some beam-remnant cases. The basic concepts are in agreement with Flavour Selection And83. An alternative 'thermal model' is described further below. Flavour Selection Flavour Selection Flavour Selection Flavour Selection Flavour Selection for Gaussian Flavour Selection pT Distribution The relative production rates of different particle species is influenced by the parameters below. Some have only an impact on one specific quantity, but most directly or indirectly have consequences for many observables. Therefore the values to use have to be viewed in the context of a complete Flavour Selection tune. Flavour Selection New flavours The main parameters of the selection of a new flavour are Flavour Selection Standard-meson production The bulk of the particle production corresponds to the lowest-lying pseudoscalar and vector multiplets. Their production rates are determined by the parameters in this section. Flavour Selection For a given set of flavours, produced according to the probabilities outlined above, the ratio of vector-to-pseudocalar meson production is described by the parameters below. The maximum allowed rate for each case has been set according to spin-counting rules, but we expect the real rates to be lower, especially for lighter mesons, owing to the vector-pseudoscalar mass splitting. Flavour Selection Inside each light-quark meson nonet, an octet-singlet mixing angle describes the mixing of the two flavour-diagonal isoscalar = 0 states. (For terminology and details see Flavour Selection Yao06 , chapter 14 on the quark model.) This angle is needed to specify the probability for such a Flavour Selection q qbar state to project onto a specific meson. More transparent formulae are obtained by introducing the angle Flavour Selection alpha = theta + 54.7 degrees: Flavour Selection f  = (uubar + ddbar)/sqrt(2) * sin(alpha) + ssbar * cos(alpha) Flavour Selection f' = (uubar + ddbar)/sqrt(2) * cos(alpha) - ssbar * sin(alpha) Flavour Selection Further, the simple model overestimates the production of Flavour Selection eta and, in particular, Flavour Selection eta' mesons, which can be rectified by Flavour Selection Excited-meson production Several excited mesons, ie. with radial or orbital excitations, have been observed at non-negligible production rates. Extrapolated to all states a fair fraction of all particle production might proceed through such states. There are big uncertainties, however, since these excited mesons in many cases are extremely poorly known. This also means that the modeling of their production and decay is very primitive, and even that the inclusion of the production of such states may lead to a degraded agreement with data. Currently the default is that all such production is switched off. Flavour Selection Parameters are provided to switch them on. By demand, this machinery has been made more flexible than in the past. Therefore one parameter is provided for each combination of heaviest flavour ( Flavour Selection u/d , Flavour Selection s , Flavour Selection c or Flavour Selection b ) and multiplet produced. In each case the production rate is normalized to that of the lowest-lying pseudoscalar of the same flavour content, as for the vector-meson rates introduced above. The multiplets available are the four obtained for one unit of orbital angular momentum, in the nonrelativistic classification. Using Flavour Selection J to denote the sum of quark spin Flavour Selection S and orbital angular momentum Flavour Selection L , i.e. what would normally be called the spin of the meson, one has: Flavour Selection Flavour Selection a pseudovector multiplet with Flavour Selection L=1, S=0, J=1 ; Flavour Selection a scalar multiplet with Flavour Selection L=1, S=1, J=0 ; Flavour Selection a pseudovector multiplet with Flavour Selection L=1, S=1, J=1 ; Flavour Selection a tensor multiplet with Flavour Selection L=1, S=1, J=2. The maximum allowed rate for each case has been set according to spin-counting rules, but we expect the real rates to be significantly lower, owing to mass suppression. Flavour Selection In addition, an octet-singlet mixing angle is needed for each multiplet, as for the pseudoscalar and vector multiplets above. Only for the tensor multiplet does any determination exist; for the other multiplets default has been chose so that Flavour Selection ssbar does not mix with the light quarks, and so that the Flavour Selection ssbar state is the heavier of the two. Flavour Selection Baryon production The relative rate of baryon production is mainly given by the quark and diquark production parameters above, plus SU(6) Clebsch-Gordans. The one modifiable parameter related to these coefficients is Flavour Selection In addition, if popcorn production is allowed, wherein a set of mesons ( Flavour Selection M ) may be produced in between the baryon ( Flavour Selection B ) and the antibaryon ( Flavour Selection Bbar ), a set of further parameters is introduced. Currently only the simplest scenario is implemented, wherein at most one intermediate meson may be produced. Flavour Selection Finally, there are some indications that leading-baryon production may be further suppressed. A proper description should probably be based on a suppression of early production times Flavour Selection Ede97 , but we here only implement a simpler version where production near the end of a string, as defined by rank, is suppressed. The more detailed studies suggest that leading Flavour Selection c and Flavour Selection b baryon production will be less suppressed, so we leave it open to set light- and heavy-baryon suppression separately. Flavour Selection Flavour Selection Flavour Selection Flavour Selection Flavour Selection for Thermal Flavour Selection pT Distribution If the hadronic Flavour Selection pT is generated according to the non-default thermal distribution, i.e. if Flavour Selection StringPT:thermalModel = on , the choice of a new flavour in the fragmentation process, and the production of a new hadron from a set of input flavours, depends mainly on the hadron mass Flavour Selection Fis16. For a given Flavour Selection pT value the new flavour is chosen according to Flavour Selection exp( -mT_had/T) = exp( - sqrt( pT_had^2 + mT_had^2 )/T). Here Flavour Selection T is primarily given by Flavour Selection StringPT:temperature , but can be further modified in the context of closely packed strings, Flavour Selection StringPT:closePacking = on. Additional factors are included from theory arguments, for instance the ratio of vector-to-pseudocalar meson production is set according to spin-counting rules. Note that the octet-singlet mixing angles in the light-quark meson nonets are taken from the parameters above. Currently popcorn production has not been implemented, i.e. a baryon and an antibaryon are nearest neighbours in the flavour fragmentation chain, and share the flavours of one diquark. In addition the following two factors are introduced to provide an improved description of the flavour composition, although not as good as obtained in the default Gaussian scenario, with its bigger selection of free parameters. Flavour Selection Flavour Selection Flavour Selection The following parameters are used to determine which hadrons to choose from. By default only the pseudoscalar and vector meson nonet (L=0) and baryons with u/d/s quarks are included. For an already-existing heavier flavour, say c or b, this corresponds to picking only u/d/s for the new quark(s). Flavour Selection Note: The computer time for selecting the flavour of new hadrons goes linearly with the number of hadrons included. Therefore we recommend sticking to the default options as heavier hadrons are produced less likely anyway."},{"name":"Four-Vectors","link":"FourVectors.html","text":"Four-Vectors Four-Vectors Four-Vectors The Four-Vectors Vec4 class gives a simple implementation of four-vectors. The member function names are based on the assumption that these represent four-momentum vectors. Thus one can get or set Four-Vectors p_x, p_y, p_z and Four-Vectors e , but not Four-Vectors x, y, z or Four-Vectors t. This is only a matter of naming, however; a Four-Vectors Vec4 can equally well be used to store a space-time four-vector. Four-Vectors The Four-Vectors Particle object contains a Four-Vectors Vec4 p that stores the particle four-momentum, and another Four-Vectors Vec4 vProd for the production vertex. For the latter the input/output method names are adapted to the space-time character rather than the normal energy-momentum one. Thus a user would not normally access the Four-Vectors Vec4 classes directly, but only via the methods of the Four-Vectors Particle class, see Four-Vectors Particle Properties. Four-Vectors Nevertheless you are free to use the PYTHIA four-vectors, e.g. as part of some simple analysis code based directly on the PYTHIA output, say to define the four-vector sum of a set of particles. But note that this class was never set up to allow complete generality, only  to provide the operations that are of use inside PYTHIA. There is no separate class for three-vectors, since such can easily be represented by four-vectors where the fourth component is not used. Four-Vectors Four-vectors have the expected functionality: they can be created, copied, added, multiplied, rotated, boosted, and manipulated in other ways. Operator overloading is implemented where reasonable. Properties can be read out, not only the components themselves but also for derived quantities such as absolute momentum and direction angles. Four-Vectors Constructors and basic operators A few methods are available to create or copy a four-vector: Four-Vectors Member methods for input The values stored in a four-vector can be modified in a few different ways: Four-Vectors Member methods for output A number of methods provides output of basic or derived quantities: Four-Vectors Friend methods for output There are also some Four-Vectors friend methods that take one, two or three four-vectors as argument. Several of them only use the three-vector part of the four-vector. Four-Vectors Operations with four-vectors Of course one should be able to add, subtract and scale four-vectors, and more: Four-Vectors There are also a few related operations that are normal member methods: Four-Vectors Rotations and boosts A common task is to rotate or boost four-vectors. In case only one four-vector is affected the operation may be performed directly on it. However, in case many particles are affected, the helper class Four-Vectors RotBstMatrix can be used to speed up operations. Four-Vectors For a longer sequence of rotations and boosts, and where several Four-Vectors Vec4 are to be rotated and boosted in the same way, a more efficient approach is to define a Four-Vectors RotBstMatrix , which forms a separate auxiliary class. You can build up this 4-by-4 matrix by successive calls to the methods of the class, such that the matrix encodes the full sequence of operations. The order in which you do these calls must agree with the imagined order in which the rotations/boosts should be applied to a four-momentum, since in general the operations do not commute. Four-Vectors (Mathematically you would e.g. define Four-Vectors M = M_3 M_2 M_1 in that Four-Vectors M p = M_3( M_2( M_1 p) ) ). That is, operations on the four-vector Four-Vectors p are carried out in the order first Four-Vectors M_1 , then Four-Vectors M_2 and finally Four-Vectors M_3. Thus Four-Vectors M_1, M_2, M_3 is also the order in which you should input rotations and boosts to Four-Vectors M .)"},{"name":"Fourth-Generation Processes","link":"FourthGenerationProcesses.html","text":"Fourth-Generation Processes Fourth-Generation Processes Fourth-Generation Processes A fourth generation can be accommodated within the Standard Model, without the introduction of any new concepts. Many experimental constraints exist, but it has not been fully excluded. Therefore we offer a simple implementation, along the lines of the top. It could also be useful as a template for studies of other new particles with similar characteristics. Fourth-Generation Processes The fourth generation are given names as in the third, but with a prime, i.e. Fourth-Generation Processes b' with PDG code 7, Fourth-Generation Processes t' with code 8, Fourth-Generation Processes tau' with code 17, and Fourth-Generation Processes nu'_tau with code 18. Most important for you is to assign a mass hierarchy, to decide which fermions can decay into which. The current implementation assumes that mass splittings are big enough that fourth-generation fermions can decay to third-generation ones by the emission of an on-shell Fourth-Generation Processes W. To this end, the standard three-generation CKM mixing matrix has been extended to include a fourth generation, see below. Since no mixing has been implemented in the neutrino sector it would be assumed that the lighter of Fourth-Generation Processes tau' and Fourth-Generation Processes nu'_tau is stable. No decay modes have been implemented that go beyond the Standard Model, so modifications would be needed if e.g. also SUSY is included in the game. Fourth-Generation Processes Production processes Fourth-Generation Processes 1) Fourth-Generation Processes b' processes Different ways to produce Fourth-Generation Processes b' quarks, singly or in pairs. For a Fourth-Generation Processes b' t' pair see section 3 below. Fourth-Generation Processes 2) Fourth-Generation Processes t' processes Different ways to produce Fourth-Generation Processes t' quarks, singly or in pairs. For a Fourth-Generation Processes b' t' pair see section 3 below. Fourth-Generation Processes 3) Pair-processes with different flavours Different ways to produce two different fourth-generation fermions. Fourth-Generation Processes Missing in this list is scatterings Fourth-Generation Processes q q' &rarr; t' b' by Fourth-Generation Processes t -channel exchange of a Fourth-Generation Processes W^+- boson, since currently the matrix element for such processes have not been implemented for two massive particles in the final state. Since this process would involve two CKM-suppressed vertices it ought to be small. Fourth-Generation Processes Parameters The Cabibbo-Kobayashi-Maskawa matrix is extended by seven further values. So as not to mess up the Standard Model, the normal 3 * 3 matrix is kept unitary, and so the new off-diagonal elements lead to a slight breaking of this. For exploratory studies this should be good enough; more detailed 4 * 4 tunes to data would only make sense the day there are evidence for the existence of a fourth generation."},{"name":"Fragmentation","link":"Fragmentation.html","text":"Fragmentation Fragmentation Fragmentation Fragmentation in PYTHIA is based on the Lund string model Fragmentation And83, Sjo84. Several different aspects are involved in the physics description, which  here therefore is split accordingly. This also, at least partly, reflect the set of classes involved in the fragmentation machinery. Fragmentation The variables collected here have a very wide span of usefulness. Some would be central in any hadronization tuning exercise, others should not be touched except by experts. Fragmentation The fragmentation flavour-choice machinery is also used in a few other places of the program, notably particle decays, and is thus described on the separate Fragmentation Flavour Selection page. Fragmentation Fragmentation functions The Fragmentation StringZ class handles the choice of longitudinal lightcone fraction Fragmentation z according to one of two possible shape sets. Fragmentation The Lund symmetric fragmentation function Fragmentation And83 is the only alternative for light quarks. It is of the form Fragmentation f(z) = (1/z) * (1-z)^a * exp(-b m_T^2 / z) with the two main free parameters Fragmentation a and Fragmentation b to be tuned to data. They are stored in Fragmentation In the context of fits to experimental data, note that the Fragmentation a and Fragmentation b parameters typically exhibit a very high degree of correlation. An option for choosing an alternative parameterisation is therefore provided, whereby the user specifies the desired average value of the fragmentation function for primary rho mesons instead of the Fragmentation b parameter. The Fragmentation a parameter should still be given by Fragmentation StringZ:aLund as usual. The rho has been chosen as reference since its mass is near the average of the primary hadron production, while pions come to dominate only after secondary decays. This option can be enabled via the following flag: Fragmentation In principle, each flavour can have a different Fragmentation a. Then, for going from an old flavour Fragmentation i to a new Fragmentation j one the shape is Fragmentation f(z) = (1/z) * z^{a_i} * ((1-z)/z)^{a_j} * exp(-b * m_T^2 / z) This is only implemented for s quarks and diquarks relative to normal quarks: Fragmentation Finally, the Bowler modification Fragmentation Bow81 introduces an extra factor Fragmentation 1/z^{r_Q * b * m_Q^2} for heavy quarks. To keep some flexibility, a multiplicative factor Fragmentation r_Q is introduced, which ought to be unity (provided that quark masses were uniquely defined) but can be set in Fragmentation Within the string framework, the Fragmentation b parameter is universal, i.e. common for all flavours. Nevertheless, for fits to experimental data, better agreement can be obtained if both Fragmentation a_Q and Fragmentation b_Q can be set freely in a general expression Fragmentation f(z) = 1/z^{1 + r_Q * b_Q * m_Q^2} * (1-z)^a_Q * exp(-b_Q m_T^2 / z) The below switches and values can be used to achieve this. They should be used with caution and constitute clear deviations from the Lund philosophy. Fragmentation As another nonstandard alternative, it is possible to switch over to the Peterson/SLAC formula Fragmentation Pet83 Fragmentation f(z) = 1 / ( z * (1 - 1/z - epsilon/(1-z))^2 ) for charm, bottom and heavier (defined as above) by the three flags Fragmentation When switched on, the corresponding epsilon values are chosen to be Fragmentation Fragmentation Fragmentation pT The Fragmentation StringPT class handles the choice of fragmentation Fragmentation pT. At each string breaking the quark and antiquark of the pair are supposed to receive opposite and compensating Fragmentation pT kicks. How they are distributed depends on the following flag: Fragmentation Gaussian Distribution For Fragmentation StringPT:thermalModel = off the quarks receive Fragmentation pT kicks according to a Gaussian distribution in Fragmentation p_x and Fragmentation p_y separately. Call Fragmentation sigma_q the width of the Fragmentation p_x and Fragmentation p_y distributions separately, i.e. Fragmentation d(Prob) = exp( -(p_x^2 + p_y^2) / 2 sigma_q^2). Then the total squared width is Fragmentation <pT^2> = <p_x^2> +  <p_y^2> = 2 sigma_q^2 = sigma^2. It is this latter number that is stored in Fragmentation Since a normal hadron receives Fragmentation pT contributions for two string breakings, it has a Fragmentation <p_x^2>_had = <p_y^2>_had = sigma^2 , and thus Fragmentation <pT^2>_had = 2 sigma^2. Fragmentation Some studies on isolated particles at LEP has indicated the need for a slightly enhanced rate in the high- Fragmentation pT tail of the above distribution. This would have to be reviewed in the context of a complete retune of parton showers and hadronization, but for the moment we stay with the current recipe, to boost the above Fragmentation pT by a factor Fragmentation enhancedWidth for a small fraction Fragmentation enhancedFraction of the breakups, where Fragmentation In the context of some toy studies Fragmentation Fis16 the following three options have also been introduced, but are not part of any recommended framework. Fragmentation Thermal Distribution For Fragmentation StringPT:thermalModel = on the quark Fragmentation pT is generated such that the resulting hadron Fragmentation pT follows a thermal distribution Fragmentation d(Prob) = exp( -pT_had/T) d^2pT_had with temperature Fragmentation T , whose value is given by Fragmentation Common setup for enhanced width If strings are closely packed, e.g. as a consequence of MPIs, it is likely that they receive an increased string tension, which translates into a broader Fragmentation pT spectrum, see further Fragmentation Fis16. It also means an enhanced rate (or rather reduced suppression) of heavy-particle production relative to pions. This can be regulated by the flag and parameters below. Fragmentation Jet joining procedure String fragmentation is carried out iteratively from both string ends inwards, which means that the two chains of hadrons have to be joined up somewhere in the middle of the event. This joining is described by parameters that in principle follows from the standard fragmentation parameters, but in a way too complicated to parametrize. The dependence is rather mild, however, so for a sensible range of variation the parameters in this section should not be touched. Fragmentation This Fragmentation W_min_smeared is then compared with the current remaining Fragmentation W_transverse to determine if there is energy left for further particle production. If not, i.e. if Fragmentation W_transverse < W_min_smeared , the final two particles are produced from what is currently left, if possible. (If not, the fragmentation process is started over.) Fragmentation Colour tracing Fragmentation Simplifying systems There are a few situations when it is meaningful to simplify the original task, one way or another. Fragmentation Ministrings The Fragmentation MiniStringFragmentation machinery is only used when a string system has so small invariant mass that normal string fragmentation is difficult/impossible. Instead one or two particles are produced, in the former case shuffling energy-momentum relative to another colour singlet system in the event, while preserving the invariant mass of that system. With one exception parameters are the same as defined for normal string fragmentation, to the extent that they are at all applicable in this case.  A discussion of the relevant physics is found in Fragmentation Nor00. The current implementation does not completely abide to the scheme presented there, however, but has in part been simplified. (In part for greater clarity, in part since the class is not quite finished yet.) Fragmentation Junction treatment A junction topology corresponds to an Y arrangement of strings i.e. where three string pieces have to be joined up in a junction. Such topologies can arise if several valence quarks are kicked out from a proton beam, or in baryon-number-violating SUSY decays. Special attention is necessary to handle the region just around the junction, where the baryon number topologically is located. The junction fragmentation scheme is described in Fragmentation Sjo03. The parameters in this section should not be touched except by experts."},{"name":"Hadron Scattering","link":"HadronScattering.html","text":"Hadron Scattering Hadron Scattering Hadron Scattering This page describes a few simple hadron (re)scattering models. They are intended to take into account that the overlap of multiple strings at low transverse dimensions is likely to lead to some collective effects, not unlike those observed in heavy-ion collisions, even if not quite as pronounced. Specifically, it is assumed that the hadrons produced can scatter against each other on the way out, before the fragmenting system has had time to expand enough that the hadrons get free. Thereby heavier particles are shifted to higher transverse momenta, at the expense of the lighter ones. Hadron Scattering The main switch on/off switch for rescattering is Hadron Scattering HadronLevel:HadronScatter , which by the default is off, since all models are rather simplistic and have to be used with some caution. Currently there are three different options available: Hadron Scattering The New Model for Hadron Scattering Within the new model, there are two options available for how hadron pairs are found: Hadron Scattering Rapidity based This corresponds to Hadron Scattering HadronScatter:mode = 0. Hadron Scattering Probe all hadron pairs with an invariant mass Hadron Scattering m Hadron Scattering inv < (m Hadron Scattering 2 Hadron Scattering 1 +p Hadron Scattering 2 Hadron Scattering Max ) Hadron Scattering 1/2 + (m Hadron Scattering 2 Hadron Scattering 2 +p Hadron Scattering 2 Hadron Scattering Max ) Hadron Scattering 1/2 with the parameter Hadron Scattering p Hadron Scattering Max Hadron Scattering If a hadron pair passes this cut, the scattering probability for hadrons of different strings is Hadron Scattering P Hadron Scattering DS (&#x394y) = P Hadron Scattering max Hadron Scattering DS (1 - &#x394y/&#x394y Hadron Scattering max ) with rapidity difference Hadron Scattering &#x394y of the hadron pair and the parameters Hadron Scattering &#x394y Hadron Scattering max Hadron Scattering and Hadron Scattering P Hadron Scattering max Hadron Scattering DS , see Hadron Scattering below. If the hadrons are produced within the same string the probability is Hadron Scattering P Hadron Scattering DS (&#x394y) P Hadron Scattering max Hadron Scattering SS if the hadrons are further apart from each other as Hadron Scattering HadronScatter:neighbourFar , Hadron Scattering 0 if they are closer together as Hadron Scattering HadronScatter:neighbourNear , and linear between the maximum Hadron Scattering HadronScatter:maxProbSS and minimum probability Hadron Scattering HadronScatter:minProbSS inbetween. Hadron Scattering Rapidity and Azimuth based This corresponds to Hadron Scattering HadronScatter:mode = 1. Hadron Scattering All hadron pairs are considered. The scattering probability for hadrons of different strings is Hadron Scattering P Hadron Scattering DS (&#x394y,&#x394&#x3C6) = P Hadron Scattering max Hadron Scattering DS (1 - ((&#x394y) Hadron Scattering 2 +(&#x394&#x3C6) Hadron Scattering 2 ) Hadron Scattering 1/2 /R Hadron Scattering max ) with rapidity difference Hadron Scattering &#x394y and difference in azimuth Hadron Scattering &#x394&#x3C6 of the hadron pair and the parameters Hadron Scattering R Hadron Scattering max Hadron Scattering and Hadron Scattering P Hadron Scattering max Hadron Scattering DS , see Hadron Scattering below. The probability for hadron pairs from the same string is similar to the one before. Hadron Scattering Common Parameters The following paramters are used for both the above cases: Hadron Scattering The Old Model for Hadron Scattering Hadron Scattering Warning: This is still at an experimental level, and should not be used unless you know what you are doing. Hadron Scattering Hadron selection Hadron Scattering Scattering probability Hadron Scattering Hadron Production Vertices It is not trivial to define where in space-time that the primary hadrons are produced by the string fragmentation machinery. The basic strategy is well-defined in a 1+1-dimensional picture, as represented by a single straight string stretched between massless Hadron Scattering q and Hadron Scattering qbar endpoints Hadron Scattering And83. Even so there is no unique definition of the production vertex of the hadron straddling two adjacent breakup vertices, and the transverse width of the string adds a further smearing. Some of that ambiguity is reflected in the options below. The major step in complexity comes with the introduction of more convoluted string topologies, however. Here the momentum-space description contains a number of ambiguities, notably for those hadrons that straddle two or more different string regions, that were only overcome by a set of reasonable simplifications Hadron Scattering Sjo84. The space-time picture introduced here inherits all these problems, and thus many of the same prescriptions, but also require a few further simplifications and assumptions. Hadron Scattering Below the main switches and parameters of this picture are described. Note, however, that that the machinery is still under development and should be used with caution. Hadron Scattering When on, the machinery assigns space-time production vertices to all primary hadrons, i.e. those that are produced directly from the string breakups. These vertices can be read out by the Hadron Scattering event[i].vProd() method. Note that the length unit is mm, and mm/s for time. To study the hadronization process it is natural to cnvert to fm. The conversion constants Hadron Scattering FM2MM Hadron Scattering = 10^12 and Hadron Scattering MM2FM Hadron Scattering = 10^-12 are defined inside the Hadron Scattering Pythia8 namespace, available in user programs that include Hadron Scattering Pythia8/Pythia.h. Hadron Scattering Secondary vertices are set in decays, but by default only for scales of the order of mm or above. That is, decays on the fm scale, like for Hadron Scattering rho mesons, then are not considered. When the machinery in this section is switched on, also such displacements are considered, see further Hadron Scattering HadronVertex:rapidDecays below. Do note that the factor Hadron Scattering 10^12 separation between fm and mm scales means that the two do not mix well, i.e. any contribution of the latter kind would leave little trace of the former when stored in double-precision real numbers. For this reason it is also not meaningful to combine studies of hadron production vertices with displaced Hadron Scattering pp collision vertices from the profile of the incoming bunches."},{"name":"Hadron-Level Standalone","link":"HadronLevelStandalone.html","text":"Hadron-Level Standalone Hadron-Level Standalone Hadron-Level Standalone The Les Houches Accord allows external process-level configurations to be fed in, for subsequent parton-level and hadron-level generation to be handled internally by PYTHIA. There is no correspondingly standardized interface if you have external events that have also been generated through the parton-level stage, so that only the hadron-level remains to be handled. A non-standard way to achieve this exists, however, and can be useful both for real applications and for various tests of the hadronization model on its own. Hadron-Level Standalone The key trick is to set the flag Hadron-Level Standalone ProcessLevel:all = off. When Hadron-Level Standalone pythia.next() is called it then does not try to generate a hard process. Since there are no beams, it is also not possible to perform the normal Hadron-Level Standalone PartonLevel step. (It is still possible to generate final-state radiation, but this is not automatic. It would have to be done by hand, using the Hadron-Level Standalone pythia.forceTimeShower(...) method, before Hadron-Level Standalone pythia.next() is called.) Thus only the Hadron-Level Standalone HadronLevel methods are called, to take the current content of the event record stored in Hadron-Level Standalone pythia.event as a starting point for any hadronization and decays that are allowed by the normal parameters of this step. Often the input would consist solely of partons grouped into colour singlets, but also (colour-singlet) particles are allowed. Hadron-Level Standalone To set up all the parameters, a Hadron-Level Standalone pythia.init() call has to be used, without any arguments. In brief, the structure of the main program therefore should be something like Hadron-Level Standalone Pythia pythia;                     // Declare generator.  Event& event = pythia.event            // Convenient shorthand.  pythia.readString('ProcessLevel:all = off'); // The trick!  pythia.init();                     // Initialization.  for (int iEvent = 0; iEvent < nEvent; ++iEvent) {    // Insert filling of event here!    pythia.next();                    // Do the hadron level.  } Of course this should be supplemented by analysis of events, error checks, and so on, as for a normal PYTHIA run. The unique aspect is how to fill the Hadron-Level Standalone event inside the loop, before Hadron-Level Standalone pythia.next() is called. Hadron-Level Standalone Input configuration To set up a new configuration the first step is to throw away the current one, with Hadron-Level Standalone event.reset(). This routine will also reserve the zeroth entry in the even record to represent the event as a whole. Hadron-Level Standalone With the Hadron-Level Standalone event.append(...) methods a new entry is added at the bottom of the current record, i.e. the first time it is called entry number 1 is filled, and so on. The Hadron-Level Standalone append method basically exists in four variants, either without or with history information, and with four-momentum provided either as a Hadron-Level Standalone Vec4 four-vector or as four individual components: Hadron-Level Standalone append( id, status, col, acol, p, m)  append( id, status, col, acol, px, py, pz, e, m)  append( id, status, mother1, mother2, daughter1, daughter2, col, acol, p, m)  append( id, status, mother1, mother2, daughter1, daughter2, col, acol, px, py, pz, e, m) The methods return the index at which the entry has been stored, but normally you would not use this feature. Hadron-Level Standalone All the four methods have two final, optional arguments. The Hadron-Level Standalone scale one is highly relevant if you want to perform parton showers in addition to hadronization; see the Hadron-Level Standalone pythia.forceTimeShower() description below. The final Hadron-Level Standalone pol one denotes polarization, and could be used to perform polarized Hadron-Level Standalone tau decays. Hadron-Level Standalone You can find descriptions of the input variables Hadron-Level Standalone here. The PDG particle code Hadron-Level Standalone id and the Les Houches Accord colour Hadron-Level Standalone col and anticolour Hadron-Level Standalone acol tags must be set correctly. The four-momentum and mass have to be provided in units of GeV; if you omit the mass it defaults to 0. Hadron-Level Standalone Outgoing particles that should hadronize should be given status code 23. Often this is the only status code you need. You could e.g. also fill in incoming partons with -21 and intermediate ones with -22, if you so wish. Usually the choice of status codes is not crucial, so long as you recall that positive numbers correspond to particles that are still around, while negative numbers denote ones that already hadronized or decayed. However, so as not to run into contradictions with the internal PYTHIA checks (when Hadron-Level Standalone Check:event = on ), or with external formats such as HepMC, we do recommend the above codes. When Hadron-Level Standalone pythia.next() is called the positive-status particles that hadronize/decay get the sign of the status code flipped to negative but the absolute value is retained. The new particles are added with normal PYTHIA status codes. Hadron-Level Standalone For normal hadronization/decays in Hadron-Level Standalone pythia.next() the history encoded in the mother and daughter indices is not used. Therefore the first two Hadron-Level Standalone append methods, which set all these indices vanishing, should suffice. The subsequent hadronization/decays will still be properly documented. Hadron-Level Standalone The exception is when you want to include junctions in your string topology, i.e. have three string pieces meet. Then you must insert in your event record the (decayed) particle that is the reason for the presence of a junction, e.g. a baryon beam remnant from which several valence quarks have been kicked out, or a neutralino that underwent a baryon-number-violating decay. This particle must have as daughters the three partons that together carry the baryon number. Hadron-Level Standalone When Hadron-Level Standalone ProcessLevel:all = off the Hadron-Level Standalone pythia.next() call applied to a parton-level confguration will hadronize it, without generating any parton showers. Indeed, the point of the framework described here is to be able to feed in complete showered parton topologies for hadronization. (The exception is if you feed in a resonance, see next section.) As an option, however, it is possible to generate a shower before the Hadron-Level Standalone pythia.next() step by using the Hadron-Level Standalone pythia.forceTimeShower( int iBeg, int iEnd, double pTmax, int nBranchMax = 0) method. Here Hadron-Level Standalone iBeg and Hadron-Level Standalone iEnd give the range of partons that should be allowed to shower, Hadron-Level Standalone pTmax the maximum Hadron-Level Standalone pT scale of emissions, and a nonzero Hadron-Level Standalone nBranchMax a maximum number of allowed branchings. Additionally, a Hadron-Level Standalone scale has to be set for each parton that should shower, which requires an additional final argument to the Hadron-Level Standalone append methods above, or alternatively separately with the Hadron-Level Standalone pythia.event[i].scale(...) method. This scale limits the maximum Hadron-Level Standalone pT allowed for each parton, in addition to the global Hadron-Level Standalone pTmax. When not set the scale defaults to 0, meaning no radiation for that parton. Hadron-Level Standalone The sample program in Hadron-Level Standalone main21.cc illustrates how you can work with this facility, both for simple parton configurations and for more complicated ones with junctions, and also how to force a shower. Hadron-Level Standalone As an alternative to setting up a topology with the methods above, a Hadron-Level Standalone Les Houches Event File (LHEF) can also provide the configurations, using the 'no-beams' extension. For parsing reasons the Hadron-Level Standalone <init> and Hadron-Level Standalone </init> tags need to be present as two separate lines, but there need not be anything between them. If there is, then the beam identities should be picked to be 0. A standard Hadron-Level Standalone <LesHouchesEvents version='1.0'> line must also be at the top of the file. For the rest only the Hadron-Level Standalone <event>....</event> blocks need to be present, one for each event. You should select Hadron-Level Standalone Beams:frameType = 4 and provide the file name in Hadron-Level Standalone Beams:LHEF , but setting Hadron-Level Standalone ProcessLevel:all = off here is superfluous since the absence of beams is enough to make this apparent. Needless to say, an externally linked Hadron-Level Standalone LHAup class works as well as an LHEF, with Hadron-Level Standalone Beams:frameType = 5. Hadron-Level Standalone The event information to store in the LHEF, or provide by the Hadron-Level Standalone LHAup , is essentially the same as above. The only difference is in status codes: outgoing particles should have 1 instead of 23, and intermediate resonances 2 instead of -22. Incoming partons, if any, are -1 instead of -21. Hadron-Level Standalone Extensions to resonance decays With the above scheme, Hadron-Level Standalone pythia.next() will generate hadronization, i.e. string fragmentation and subsequent decays of normal unstable particles. Alternatively it could be used to decay Hadron-Level Standalone resonances , i.e. Hadron-Level Standalone W, Z , top, Higgs, SUSY and other massive particles. Hadron-Level Standalone The default when a resonance is encountered is to decay it, let the decay products shower, and finally hadronize the partons. Should a decay sequence already be provided at input, this sequence will be used as input for the showers, which are handled consecutively, followed by hadronization. Thus, a Higgs could be provided alone, or decaying to a pair of Hadron-Level Standalone W bosons, or the same with the Hadron-Level Standalone W 's decaying further to fermion pairs. Needless to say, correct process-specific angular correlations in decays should not be expected when the process is unspecified. Hadron-Level Standalone If you do not want resonances to decay then you can use the Hadron-Level Standalone ProcessLevel:resonanceDecays = off setting. If instead you want them to decay but not shower, you can use either Hadron-Level Standalone PartonLevel:FSR = off or Hadron-Level Standalone PartonLevel:FSRinResonances = off. A warning here is that, generally, it is not a good idea to provide a part of the shower history but not all, e.g. Hadron-Level Standalone Z^0 &rarr; q qbar g : it is not straightforward to avoid doublecouning or other problems within this simpler alternative to a full-scale event generation. Hadron-Level Standalone The input configuration has to follow the rules described above, i.e. Hadron-Level Standalone ProcessLevel:all = off should be set for internal input, but is not necessary for LHEF input. It is possible to combine several resonances, and other coloured or uncoloured particles into the same event. Partonic daughters of resonances would then shower, but other partons not. It may be possible to fool the program, however, since this is not a fully tested core functionality, so don't combine wildly if there is no reason to. Hadron-Level Standalone Repeated hadronization or decay An alternative approach is possible with the Hadron-Level Standalone pythia.forceHadronLevel() routine. This method does a call to the Hadron-Level Standalone HadronLevel methods, irrespective of the value of the Hadron-Level Standalone HadronLevel:all flag. If you hadronize externally generated events it is equivalent to a Hadron-Level Standalone pythia.next() call with Hadron-Level Standalone ProcessLevel:all = off. Hadron-Level Standalone This method truly sticks to the hadron level, and thus cannot handle resonance decays. The real application instead is for repeated hadronization of the same PYTHIA process- and parton-level event. This may for some studies help to save time, given that these two first step are more time-consuming than the hadronization one. Hadron-Level Standalone For repeated hadronization you should first generate an event as usual, but with Hadron-Level Standalone HadronLevel:all = off. This event you can save in a temporary copy, e.g. Hadron-Level Standalone Event savedEvent = pythia.event. Inside a loop you copy back with Hadron-Level Standalone pythia.event = savedEvent , and call Hadron-Level Standalone pythia.forceHadronLevel() to obtain a new hadronization history. Hadron-Level Standalone A more limited form of repetition is if you want to decay a given kind of particle repeatedly, without having to generate the rest of the event anew. This could be the case e.g. in Hadron-Level Standalone B physics applications. Then you can use the Hadron-Level Standalone pythia.moreDecays() method, which decays all particles in the event record that have not been decayed but should have been done so. The Hadron-Level Standalone pythia.particleData.mayDecay( id, false/true) method may be used to switch off/on the decays of a particle species Hadron-Level Standalone id , so that it is not decayed in the Hadron-Level Standalone pythia.next() call but only inside a loop over a number of tries. Hadron-Level Standalone Between each loop the newly produced decay products must be removed and the decayed particle status restored to undecayed. The former is simple, since the new products are appended to the end of the event record: Hadron-Level Standalone event.saveSize() saves the initial size of the event record, and Hadron-Level Standalone event.restoreSize() can later be used repeatedly to restore this original size, which means that the new particles at the end are thrown away. The latter is more complicated, and requires the user to identify the positions of all particles of the species and restore a positive status code with Hadron-Level Standalone event[i].statusPos(). Hadron-Level Standalone The Hadron-Level Standalone main15.cc program illustrates both these methods, i.e. either repeated hadronization or repeated decay of PYTHIA events."},{"name":"Heavy Ions","link":"HeavyIons.html","text":"Heavy Ions Heavy Ions Heavy Ions PYTHIA does not normally handle collisions involving heavy ions, but it includes a facility where a model for combining several nucleon-nucleon collisions into one heavy ion collision can be implemented. One such model, called Heavy Ions Angantyr , is provided with PYTHIA and is inspired by the old Fritiof program from the Lund group Heavy Ions And87 with recent improvements Heavy Ions Bie16a (see below). Heavy Ions To allow for the generation of collisions with heavy ions, PYTHIA includes a handful of nuclei with PDG numbers on the form 100ZZZAAAI: Heavy Ions 4 He (1000020040), Heavy Ions 6 Li (1000030060), Heavy Ions 12 C (1000060120), Heavy Ions 16 O (1000080160), Heavy Ions 63 Cu (1000290630), Heavy Ions 129 Xe (1000541290), Heavy Ions 197 Au (1000791970), and Heavy Ions 208 Pb (1000822080), but more can be added using the function Heavy Ions ParticleData::addParticle. Heavy Ions If Heavy Ions HeavyIon:mode is on, the normal initialization in Heavy Ions Pythia::init() is early on diverted to an object with the base class Heavy Ions HeavyIons which may instantiate secondary Heavy Ions Pythia objects needed to generate different types of nucleon-nucleon collisions that can be merged together into a full heavy ion event. This is all done in the virtual Heavy Ions HeavyIons::init() function. Subsequent calls to Heavy Ions Pythia::next() will then also be diverted to the virtual function Heavy Ions HeavyIons::next() which will be responsible for building up the heavy ion collision. The final event will be available in the primary Heavy Ions Pythia object. Heavy Ions The Heavy Ions HeavyIon class is very simple and flexible and basically only specifies that the Heavy Ions HeavyIons::init() and Heavy Ions HeavyIons::next() functions are overridden in a subclass. But there are a few additional helper classes that should be generic enough to be used by any model implemented. Heavy Ions Heavy Ions The Heavy Ions Nucleon class represents a single nucleon in a nuclei. It can be a proton or a neutron ( Heavy Ions id() ), it has a position in impact parameter space ( Heavy Ions Vec2 ), both absolute ( Heavy Ions bPos() ) and relative to the nuclei ( Heavy Ions nPos() ), and optionally it can be in a particular state represented by a vector of real numbers which are completely model dependent. Heavy Ions The Heavy Ions SubCollision class represents a potential nucleon-nucleon  collision between a projectile and a target Heavy Ions Nucleon. Heavy Ions The Heavy Ions NucleusModel class is a base class for implementing a model for the distribution in impact parameter space of nucleons in a nucleus. There are two ready-made subclasses called Heavy Ions WoodsSaxonModel , implementing a standard Woods-Saxon distribution, and Heavy Ions GLISSANDOModel , implementing the more advanced model in Heavy Ions Bro09,Ryb14. Heavy Ions The Heavy Ions ImpactParameterGenerator is used to sample the impact parameter space for the colliding nuclei. The base class implements a Gaussian sampling, which means that the events produced will always be weighted. Other distributions can be implemented in subclasses. Heavy Ions The Heavy Ions SubCollisionModel is used to generate individual, potential nucleon-nucleon Heavy Ions SubCollision s. Two subclasses are available, one called Heavy Ions NaiveSubCollisionModel which treats nucleons as simple black disks, and one implementing a more advanced model called Heavy Ions DoubleStrikman described below. Heavy Ions The Heavy Ions HIInfo class contains information related to the generated heavy ion events. Heavy Ions The Heavy Ions HIUserHooks class is provided to simplify the customization of a model implemented as a Heavy Ions HeavyIons subclass. It can be used to eg. change the Heavy Ions ImpactParamerGenerator used, in a way similar to how the Heavy Ions UserHooks and Heavy Ions MergingHooks classes are used. Heavy Ions The default model in PYTHIA is called Angantyr and is inspired by the old Fritiof model Heavy Ions And86 with improvements described in Heavy Ions Bie16a. The main idea is to stack parton level events, corresponding to individual nucleon-nucleon sub-collisions, on top of each other and hadronise them together. Heavy Ions Heavy Ions Please note: although it is possible to use Heavy Ions Rope Hadronisation in heavy ion collisions, these two modules have not yet been validated to work properly together. Also the parameters in the model have not been properly tuned, so the results from running must not be taken as definitive predictions. Heavy Ions To determine which projectile nucleon interacts with which target nucleon, special care is taken to determine in which way the nucleons interact. In a standard Heavy Ions Glauber calculations one typicaly only cares about if a sub-collision is inelastic or not, but in Angantyr this is divided up, so that each inelastic sub-collision can either be single-diffractive, double-diffractive or absorptive (ie. non-diffractive). To achieve this, Angantyr uses a model with fluctuating radii of the nucleons resulting in a fluctuating nucleon-nucleon cross section inspired by the model by Strikman et al. Heavy Ions Alv13. The model for this includes a number of parameters which should be fitted to reproduce inclusive nucleon-nucleon cross sections. To be consistent, the values used comes from PYTHIA's internal model of Heavy Ions total cross sections. Heavy Ions The default model for nucleon fluctuations has three parameters, the general fitting machinery in Heavy Ions SubCollisionModel allows for up to eight parameters. Heavy Ions The fitting procedure in Heavy Ions SubCollisionModel is a kind of genetic algorith where a population of parameter values are allowed to evolve for a number of generations. In the end the the parameter set in the final population  which gives the best inclusive cross sections is picked. Eight different cross sections may be fitted to but it is possible to select only some of them: Heavy Ions After all possible nucleon-nucleon sub-collisions has been determined, they are ordered in increasing nucleon-nucleon impact parameter. This list is then gone through in order several time. First all absorptive sub-collisions are treated. One full nucleon-nucleon non-diffractive minimum bias event is generated for each possible absorptive sub-colision. These are also ordered in impact parameter. Note that one target nucleon can interact absorptively with several target nucleons, in a first round only those absorptive sub-collisions involving nucleons that have not already interacted absorptively are are assigned a non-diffractive event. Heavy Ions If PYTHIA is not set up to generate minimum bias events, one or more of the generated non-diffractive events will be replaced by events generated with the selected signal process, and the cross section reported will be modified accordingly. Heavy Ions In a second round only those potential absorptive sub-collisions are considered where one nucleon has already been assinged a full non-diffractive event. In the Angantyr model it is then assumed that the other nuclean will contribute to the final state as if it had just been diffractively excited. Therefore a corresponding single-diffractive event is generated, the elastically scattered beam particle is discarded and the rest is added to the previous non-diffractive event, shuffling a bit with the kinematics so that the total emergy and momentum is conserved. Heavy Ions To generate these single-diffraction events to emulate multiple absorptive sub-collisions a special Heavy Ions Pythia object is used. To allow flexibility this object need not have exactly the same settings as the the one generating events for normal single-diffraction sub-collisions. To manipulate this Heavy Ions Pythia object a special form of settings can be used. All settings available for Heavy Ions Heavy Ions Diffraction , Heavy Ions Heavy Ions MultipartonInteractions , Heavy Ions Heavy Ions PDF , Heavy Ions Heavy Ions SigmaDiffractive and Heavy Ions Heavy Ions PDF can be set separately for this Heavy Ions Pythia object by prefixing their names with Heavy Ions HI.  As an example, setting Heavy Ions HISigmaDiffractive:PomFlux and Heavy Ions HIPDF:PomSet will set the Heavy Ions SigmaDiffractive:PomFlux and Heavy Ions PDF:PomSet options for this Heavy Ions Pythia object. Heavy Ions After all absorptive sub-collisions have been dealt with, the diffractive and elastic sub-collisions are dealt with in a similar way. In the end there will be a number of parton level events which are finally stacked together, and then hadronised. Finally nucleus remnants constructed from the non-interacting nucleans, are added to complete the full nucleaus-nucleus collision."},{"name":"HelacOnia Processes","link":"HelacOniaProcesses.html","text":"HelacOnia Processes HelacOnia Processes HelacOnia Processes HelacOnia HelacOnia Processes Sha15 is an external package which provides automated calculations for heavy quarkonia production using NRQCD, similar in style to HelacOnia Processes MadGraph5 and the extension MadOnia, which is only available for MadGraph4. This can be useful when additional quarkonia processes other than the internal processes provided in HelacOnia Processes Onia are needed, including matrix elements which are not spin-averaged, as well as the ability to produce HelacOnia Processes n -leg matrix elements beyond the leading tree-level diagrams. The HelacOnia code can be downloaded from HelacOnia Processes HelacOnia Processes http://helac-phegas.web.cern.ch/helac-phegas/helac-onia.html , where only version 2 and above is compatible with PYTHIA. HelacOnia Processes Within HelacOnia, events can automatically be passed to PYTHIA for additional processing, e.g. showering, MPI, and hadronization. However, in many cases it may be simpler to produce HelacOnia events directly in PYTHIA. The HelacOnia Processes LHAupHelaconia class provided in HelacOnia Processes Pythia8Plugins/LHAHelaconia is designed to provide such utility. Here we will describe how this can be used to wrap the HelacOnia generator as a PYTHIA Les Houches interface. HelacOnia Processes Of course, HelacOnia can also output files of parton-level events according to the HelacOnia Processes LHEF standard, that can be read in and processed further by PYTHIA 8. This is the most commonly used approach, and requires no further description here. HelacOnia Processes HelacOnia executable inside PYTHIA The HelacOnia Processes Pythia::setLHAupPtr(LHAup* lhaUpPtr) method allows a Pythia generator to accept a pointer to an object derived from the HelacOnia Processes HelacOnia Processes LHAup base class. Such an object will be initialized from within Pythia, and be called repeatedly to generate the next parton-level event, using the LHA specification as a standard to transfer the relevant information back to Pythia. Properly constructed, the operation of an HelacOnia Processes LHAup object thus is almost completely hidden from the user, and generates events almost like an ordinary internal Pythia process. HelacOnia Processes The HelacOnia Processes LHAupHelaconia is precisely such a class, derived from HelacOnia Processes LHAup , that contains the code needed to wrap a HelacOnia executable. Thereby the generation of HelacOnia processes from within Pythia becomes straightforward. An explicit example is provided in HelacOnia Processes main35.cc. We describe some of the key elements used there and in the general case."},{"name":"HepMC Interface","link":"HepMCInterface.html","text":"HepMC Interface HepMC Interface HepMC Interface An interface to the HepMC HepMC Interface Dob01 standard event record format has been provided by M. Kirsanov. The code is stored in HepMC Interface include/Pythia8Plugins/HepMC2.h. To use it, the relevant libraries need to be linked, as explained in the HepMC Interface README file. Only version 2.06 (or later) of HepMC is supported, by agreement with the LHC experimental community. HepMC Interface The (simple) procedure to translate PYTHIA 8 events into HepMC ones is illustrated in the HepMC Interface main41.cc , HepMC Interface main42.cc and HepMC Interface main43.cc main programs. At the core is a call to the HepMC Interface HepMC::Pythia8ToHepMC::fill_next_event( pythia, hepmcevt, ievnum = -1) which takes a reference of the generator object and uses it, on the one hand, to read out and convert the event record in HepMC Interface pythia.event and, on the other hand, to extract and store parton-density (PDF), cross section and other information for the hard subprocess from HepMC Interface pythia.info. There is also an alternative form that does not requires access to the full HepMC Interface pythia object, but only the event record, at the expense of a reduced information storage, see below. HepMC Interface While PYTHIA always stores momenta in units of GeV, with HepMC Interface c = 1 , HepMC nowadays can be built either for MeV or GeV as default, a choice that can then be overridden on an event-by-event basis, see e.g. the HepMC Interface main41.cc code. When filling the HepMC event record, PYTHIA will convert to the unit specified for the current HepMC event record. HepMC Interface Also for length units there are choices, and again the PYTHIA interface will convert to the units set for the HepMC event record. Here the mm choice of PYTHIA seems to be shared by most other programs, and is HepMC default. HepMC Interface The status code is now based on the new standard introduced for HepMC 2.05, see the HepMC Interface Event::statusHepMC(...) conversion routine for details. HepMC Interface The current values from HepMC Interface pythia.info.sigmaGen() and HepMC Interface pythia.info.sigmaErr() are stored for each event, multiplied by HepMC Interface 10^9 to convert from mb to pb. Note that PYTHIA improves its accuracy by Monte Carlo integration in the course of the run, so the values associated with the last generated event should be the most accurate ones. If events also come with a dimensional weight, like in some Les Houches strategies, this weight is in units of pb. HepMC Interface Direct output to HepMC Provided that PYTHIA is properly linked to HepMC, implementation of the most common user case (run PYTHIA with a runcard, output HepMC) exists. The example HepMC Interface main93 implements this. The sample command file HepMC Interface main93.cmnd provides a good starting point. The line: HepMC Interface Main:writeHepMC = on is the switch needed to write a HepMC file. The example is then run with: HepMC Interface ./main93 -c main93.cmnd and a HepMC file is then written. HepMC Interface There are several other useful command line options to HepMC Interface main93. They are all displayed by running HepMC Interface ./main93 -h. HepMC Interface The public methods Here comes a complete list of all public methods of the HepMC Interface Pythia8ToHepMC class in the HepMC Interface HepMC ( HepMC Interface not HepMC Interface Pythia8 !) namespace. HepMC Interface The following paired methods can be used to set and get the status of some switches that modify the behaviour of the conversion routine. The HepMC Interface set methods have the same default input values as the internal initialization ones, so that a call without an argument (re)stores the default."},{"name":"Hidden Valley Processes","link":"HiddenValleyProcesses.html","text":"Hidden Valley Processes Hidden Valley Processes Hidden Valley Processes This Hidden Valley (HV) scenario has been developed specifically to allow the study of visible consequences of radiation in a hidden sector, by recoil effect. A key aspect is therefore that the normal timelike showering machinery has been expanded with a third kind of radiation, in addition to the QCD and QED ones. These three kinds of radiation are fully interleaved, i.e. evolution occurs in a common Hidden Valley Processes pT -ordered sequence. The scenario is described in Hidden Valley Processes Car10. Furthermore hadronization in the hidden sector has been implemented. Three main scenarios for production into and decay out of the hidden sector can be compared, in each case either for an Abelian or a non-Abelian gauge group in the HV. For further details see Hidden Valley Processes Car11. Hidden Valley Processes Warning : do not use the alternative hadronization scenarios Hidden Valley Processes StringPT:thermalModel = on or Hidden Valley Processes StringPT:mT2suppression = on in conjunction with Hidden Valley processes, since they have not been constructed to work together. Hidden Valley Processes Particle content and properties For simplicity we assume that the HV contains an unbroken Hidden Valley Processes SU(N) gauge symmetry. This is used in the calculation of production cross sections. These could be rescaled by hand for other gauge groups. Hidden Valley Processes A minimal HV particle content has been introduced. Firstly, there is a set of 12 particles that mirrors the Standard Model flavour structure, and is charged under both the SM and the HV symmetry groups. Each new particle couples flavour-diagonally to a corresponding SM state, and has the same SM charge and colour, but in addition is in the fundamental representation of the HV colour, as follows: Hidden Valley Processes Hidden Valley Processes Dv , identity 4900001, partner to the normal Hidden Valley Processes d quark; Hidden Valley Processes Hidden Valley Processes Uv , identity 4900002, partner to the normal Hidden Valley Processes u quark; Hidden Valley Processes Hidden Valley Processes Sv , identity 4900003, partner to the normal Hidden Valley Processes s quark; Hidden Valley Processes Hidden Valley Processes Cv , identity 4900004, partner to the normal Hidden Valley Processes c quark; Hidden Valley Processes Hidden Valley Processes Bv , identity 4900005, partner to the normal Hidden Valley Processes b quark; Hidden Valley Processes Hidden Valley Processes Tv , identity 4900006, partner to the normal Hidden Valley Processes t quark; Hidden Valley Processes Hidden Valley Processes Ev , identity 4900011, partner to the normal Hidden Valley Processes e lepton; Hidden Valley Processes Hidden Valley Processes nuEv , identity 4900012, partner to the normal Hidden Valley Processes nue neutrino; Hidden Valley Processes Hidden Valley Processes MUv , identity 4900013, partner to the normal Hidden Valley Processes mu lepton; Hidden Valley Processes Hidden Valley Processes nuMUv , identity 4900014, partner to the normal Hidden Valley Processes numu neutrino; Hidden Valley Processes Hidden Valley Processes TAUv , identity 4900015, partner to the normal Hidden Valley Processes tau lepton; Hidden Valley Processes Hidden Valley Processes nuTAUv , identity 4900016, partner to the normal Hidden Valley Processes nutau neutrino. Hidden Valley Processes Collectively we will refer to these states as Hidden Valley Processes Fv ; note, however, that they need not be fermions themselves. Hidden Valley Processes In addition the model contains the HV gauge particle, either a HV-gluon or a HV-photon, but not both; see Hidden Valley Processes Ngauge above: Hidden Valley Processes Hidden Valley Processes gv , identity 4900021, is the massless gauge boson of the HV Hidden Valley Processes SU(N) group; Hidden Valley Processes Hidden Valley Processes gammav , identity 4900022,  is the massless gauge boson of the HV Hidden Valley Processes U(1) group. Hidden Valley Processes Finally, for the basic HV scenario, there is a new massive particle with only HV charge sitting in the fundamental representation of the HV gauge group: Hidden Valley Processes Hidden Valley Processes qv , identity 4900101. Hidden Valley Processes The typical scenario would be for pair production of one of the states presented first above, e.g. Hidden Valley Processes g g &rarr; Dv Dvbar. Such a Hidden Valley Processes Dv can radiate gluons and photons like an SM quark, but in addition HV-gluons or HV-photons in a similar fashion. Eventually the Hidden Valley Processes Dv will decay like Hidden Valley Processes Dv &rarr; d + qv. The strength of this decay is not set as such, but is implicit in your choice of width for the Hidden Valley Processes Dv state. Thereafter the Hidden Valley Processes d and Hidden Valley Processes qv can radiate further within their respective sectors. The Hidden Valley Processes qv , Hidden Valley Processes gv or Hidden Valley Processes gammav are invisible, so their fate need not be considered further. Hidden Valley Processes While not part of the standard scenario, as an alternative there is also a kind of Hidden Valley Processes Z' resonance: Hidden Valley Processes Hidden Valley Processes Zv , identity 4900023, a boson that can couple both to pairs of Standard Model fermions and to Hidden Valley Processes qv qvbar pairs. Mass, total width and branching ratios can be set as convenient. Hidden Valley Processes This opens up for alternative processes Hidden Valley Processes l^+l^-, q qbar &rarr; Zv &rarr; qv qvbar. Hidden Valley Processes The possibility of a leakage back from the hidden sector will be considered in the Hadronization section below. For the Hidden Valley Processes U(1) case the Hidden Valley Processes gammav acquires a mass and can decay back to a Standard-Model fermion pair, while the Hidden Valley Processes qv remains invisible. The Hidden Valley Processes SU(N) alternative remains unbroken, so confinement holds and the Hidden Valley Processes gv is massless. A string like Hidden Valley Processes qv - gv - ... - gv - qvbar can break by the production of new Hidden Valley Processes qv - qvbar pairs, which will produce Hidden Valley Processes qv-qvbar mesons. It would be possible to build a rather sophisticated hidden sector by trivial extensions of the HV flavour content. For now, however, the Hidden Valley Processes qv can be duplicated in up to eight copies with the same properties except for the flavour charge. These are assigned codes 4900101 - 4900108. This gives a total of 64 possible lowest-lying mesons. We also include a duplication of that, into two multiplets, corresponding to the pseudoscalar and vector mesons of QCD. For now, again, these are assumed to have the same mass and other properties. By default, only the flavour-diagonal ones can decay back into the Standard-Model sector, however, while the rest remains in the hidden sector. It is therefore only necessary to distinguish a few states: Hidden Valley Processes Hidden Valley Processes pivDiag , identity 4900111, a flavour-diagonal HV-meson with spin 0 that can decay back into the Standard-Model sector; Hidden Valley Processes Hidden Valley Processes rhovDiag , identity 4900113, a flavour-diagonal HV-meson with spin 1 that can decay back into the Standard-Model sector; Hidden Valley Processes Hidden Valley Processes pivUp , identity 4900211, an off-diagonal HV-meson with spin 0 that is stable and invisible, with an antiparticle Hidden Valley Processes pivDn with identity -4900211; the particle is the one where the code of the flavour is larger than that of the antiflavour; Hidden Valley Processes Hidden Valley Processes rhovUp , identity 4900213, an off-diagonal HV-meson with spin 1 that is stable and invisible, with an antiparticle Hidden Valley Processes rhovDn with identity -4900213; again the particle is the one where the code of the flavour is larger than that of the antiflavour; Hidden Valley Processes Hidden Valley Processes ggv , identity 4900991, is only rarely used, to handle cases where it is kinematically impossible to produce an HV-meson on shell, and it therefore is assumed to de-excite by the emission of invisible Hidden Valley Processes gv-gv v-glueball bound states. Hidden Valley Processes By changing ParticleData, it is possible to allow decays even for the off-diagonal Up/Dn mesons. Hidden Valley Processes Only the spin of the HV-gluon or HV-photon is determined unambiguously to be unity, for the others you can make your choice. Hidden Valley Processes You should set the Hidden Valley Processes Fv and Hidden Valley Processes qv masses appropriately, with the latter smaller than the former two to allow decays. When Hidden Valley Processes U(1) hadronization is switched on, you need to set the Hidden Valley Processes gammav mass and decay modes. For Hidden Valley Processes SU(N) hadronization the HV-meson masses should be set to match the Hidden Valley Processes qv ones. The simplest is to assume that Hidden Valley Processes m_qv defines a constituent mass, so that Hidden Valley Processes m_HVmeson = 2 m_qv. The Hidden Valley Processes hvMesonDiag decay modes also need to be set. Hidden Valley Processes Production processes Hidden Valley Processes Timelike showers One key point of this HV scenario is that radiation off the HV-charged particles is allowed. This is done by the standard final-state showering machinery. (HV particles are not produced in initial-state radiation.) All the (anti)particles Hidden Valley Processes Fv and Hidden Valley Processes qv have one (negative) unit of HV charge. That is, radiation closely mimics the one in QCD. Both QCD, QED and HV radiation are interleaved in one common sequence of decreasing emission Hidden Valley Processes pT scales. Each radiation kind defines a set of dipoles, usually spanned between a radiating parton and its recoil partner, such that the invariant mass of the pair is not changed when a radiation occurs. This need not follow from trivial colour assignments, but is often obvious. For instance,  in a decay Hidden Valley Processes Qv &rarr; q + qv the QCD dipole is between the Hidden Valley Processes q and the hole after Hidden Valley Processes Qv , but Hidden Valley Processes qv becomes the recoiler should a radiation occur, while the role of Hidden Valley Processes q and Hidden Valley Processes qv is reversed for HV radiation. Hidden Valley Processes This also includes matrix-element corrections for a number of decay processes, with colour, spin and mass effects included Hidden Valley Processes Nor01. They were calculated within the context of the particle content of the MSSM, however, which does not include spin 1 particles with unit colour charge. In such cases spin 0 is assumed instead. By experience, the main effects come from mass and colour flow anyway, so this is not a bad approximation. (Furthermore the MSSM formulae allow for Hidden Valley Processes gamma_5 factors from wave functions or vertices; these are even less important.) Hidden Valley Processes An emitted Hidden Valley Processes gv can branch in its turn, Hidden Valley Processes gv &rarr; gv + gv. This radiation may affect momenta in the visible sector by recoil effect, but this is a minor effect relative to the primary emission of the Hidden Valley Processes gv. Hidden Valley Processes While the default model has a fixed Hidden Valley coupling Hidden Valley Processes alpha_HV , some further work Hidden Valley Processes Scw15 has considered the impact of a running coupling. This is included as an option. Hidden Valley Processes Hadronization By default the HV particles with no Standard Model couplings are not visible. Their presence can only be deduced by the observation of missing (transverse) momentum in the event as a whole. In the current implementation it is possible to simulate two different scenarios where activity can leak back from the hidden sector. Hidden Valley Processes The first possibility is relevant for the Hidden Valley Processes U(1) scenario. The Hidden Valley Processes U(1) group may be broken, so that the Hidden Valley Processes gammav acquires a mass. Furthermore, the Hidden Valley Processes gammav may have a small mixing angle with the normal photon, or with some Hidden Valley Processes Z' state or other mediator, and may thus decay back into Standard Model particles. The Hidden Valley Processes qv still escapes undetected; recall that there is no confinement in the Hidden Valley Processes U(1) option. Hidden Valley Processes In order to enable this machinery two commands are necessary, Hidden Valley Processes 4900022:m0 = ... to set the Hidden Valley Processes gammav mass to the desired value, and Hidden Valley Processes 4900022:onMode = on to enable Hidden Valley Processes gammav decays. The default Hidden Valley Processes gammav decay table contains all Standard Model fermion-antifermion pairs, except top, with branching ratios in proportion to their coupling to the photon, whenever the production channel is allowed by kinematics. This table could easily be tailored to more specific models and needs. For instance, for a mass below 1 - 2 GeV, it would make sense to construct a table of exclusive hadronic decay channels rather than go the way via a hadronizing quark pair. Hidden Valley Processes The Hidden Valley Processes gammav are expected to decay so rapidly that no secondary vertex will be detectable. However, it is possible to set Hidden Valley Processes 4900022:tau0 to a finite lifetime (in mm) that will be used to create separated secondary vertices. Hidden Valley Processes The second, more interesting, possibility is relevant for the Hidden Valley Processes SU(N) scenarios. Here the gauge group remains unbroken, i.e. Hidden Valley Processes gv is massless, and the partons are confined. Like in QCD, the HV-partons can therefore be arranged in one single HV-colour-ordered chain, with a Hidden Valley Processes qv in one end, a Hidden Valley Processes qvbar in the other, and a varying number of Hidden Valley Processes gv in between. Each event will only contain (at most) one such string, (i) since perturbative branchings Hidden Valley Processes gv &rarr; qv qvbar have been neglected, as is a reasonable approximation for QCD, and (ii) since HV-colours are assigned in the Hidden Valley Processes N_C &rarr; infinity limit, just like in the handling of string fragmentation in QCD. The HV-string can then fragment by the nonperturbative creation of Hidden Valley Processes qv qvbar pairs, leading to the formation of HV-mesons along the string, each with its Hidden Valley Processes qv from one vertex and its Hidden Valley Processes qvbar from the neighbouring one. Hidden Valley Processes Since, so far, we have only assumed there to be one Hidden Valley Processes qv species, all produced Hidden Valley Processes qv qvbar HV-mesons are of the same flavour-diagonal species. Such an HV-meson can decay back to the normal sector, typically by whatever mediator particle allowed production in the first place. In this framework the full energy put into the HV sector will leak back to the normal one. To allow more flexibility, an ad hoc possibility of Hidden Valley Processes n_Flav different Hidden Valley Processes qv species is introduced. For now they are all assumed to have the same mass and other properties, but distinguished by some flavour-like property. Only the flavour-diagonal ones can decay, meaning that only a fraction (approximately) Hidden Valley Processes 1/n_Flav of the HV-energy leaks back, while the rest remains in the hidden sector. Hidden Valley Processes This scenario contains more parameters than the first one, for the Hidden Valley Processes U(1) group. They can be subdivided into two sets. One is related to particle properties, both for Hidden Valley Processes qv and for the two different kinds of HV-mesons, here labeled 4900111 and 4900113 for the diagonal ones, and +-4900211 and +-4900213 for the off-diagonal ones. It makes sense to set the HV-meson masses to be twice the Hidden Valley Processes qv one, as in a simple constituent mass context. Furthermore the Hidden Valley Processes hvMesonDiag decay modes need to be set up. Like with the Hidden Valley Processes gammav in the Hidden Valley Processes U(1) option, the default decay table is based on the branching ratios of an off-shell photon. Hidden Valley Processes The second set are fragmentation parameters that extend or replace the ones used in normal string fragmentation. Some of them are not encoded in the same way as normally, however, but rather scale as the Hidden Valley Processes qv mass is changed, so as to keep a sensible default behaviour. This does not mean that deviations from this set should not be explored, or that other scaling rules could be preferred within alternative scenarios. These parameters are as follows."},{"name":"Higgs Processes","link":"HiggsProcesses.html","text":"Higgs Processes Higgs Processes Higgs Processes This page documents Higgs production within and beyond the Standard Model (SM and BSM for short). This includes several different processes and, for the BSM scenarios, a large set of parameters that would only be fixed within a more specific framework such as MSSM. Some choices can be made irrespective of the particular model: Higgs Processes One setting is specific to the Standard Model: Higgs Processes Standard-Model Higgs, basic processes This section provides the standard set of processes that can be run together to provide a reasonably complete overview of possible production channels for a single SM Higgs. The main parameter is the choice of Higgs mass, which can be set in the normal Higgs Processes ParticleData database; thereafter the properties within the SM are essentially fixed. Higgs Processes Standard-Model Higgs, further processes A number of further production processes has been implemented, that are specializations of some of the above ones to the high- Higgs Processes pT region. The sets therefore could not be used simultaneously without unphysical double-counting, as further explained below. They are not switched on by the Higgs Processes HiggsSM:all flag, but have to be switched on for each separate process after due consideration. Higgs Processes The first three processes in this section are related to the Higgs point coupling to fermions, and so primarily are of interest for Higgs Processes b quarks. It is here useful to begin by reminding that a process like Higgs Processes b bbar &rarr; H^0 implies that a Higgs Processes b/bbar is taken from each incoming hadron, leaving behind its respective antiparticle. The initial-state showers will then add one Higgs Processes g &rarr; b bbar branching on either side, so that effectively the process becomes Higgs Processes g g &rarr; H0 b bbar. This would be the same basic process as the Higgs Processes g g &rarr; H^0 t tbar one used for top. The difference is that (a) no PDF's are defined for top and (b) the shower approach would not be good enough to provide sensible kinematics for the Higgs Processes H^0 t tbar subsystem. By contrast, owing to the Higgs Processes b being much lighter than the Higgs, multiple gluon emissions must be resummed for Higgs Processes b , as is done by PDF's and showers, in order to obtain a sensible description of the total production rate,  when the Higgs Processes b quarks predominantly are produced at small Higgs Processes pT values. Higgs Processes The second set of processes are predominantly first-order corrections to the Higgs Processes g g &rarr; H^0 process, again dominated by the top loop. We here only provide the kinematical expressions obtained in the limit that the top quark goes to infinity, but scaled to the finite-top-mass coupling in Higgs Processes g g &rarr; H^0. (Complete loop expressions are available e.g. in PYTHIA 6.4 but are very lengthy.) This provides a reasonably accurate description for 'intermediate' Higgs Processes pT values, but fails when the Higgs Processes pT scale approaches the top mass. Higgs Processes Beyond-the-Standard-Model Higgs, introduction Further Higgs multiplets arise in a number of scenarios. We here concentrate on the MSSM scenario with two Higgs doublets, but with flexibility enough that also other two-Higgs-doublet scenarios could be represented by a suitable choice of parameters. Conventionally the Higgs states are labeled Higgs Processes h^0, H^0, A^0 and Higgs Processes H^+-. If the scalar and pseudocalar states mix the resulting states are labeled Higgs Processes H_1^0, H_2^0, H_3^0. In process names and parameter explanations both notations will be used, but for settings labels we have adapted the shorthand hybrid notation Higgs Processes H1 for Higgs Processes h^0(H_1^0) , Higgs Processes H2 for Higgs Processes H^0(H_2^0) and Higgs Processes A3 for Higgs Processes A^0(H_3^0). (Recall that the Higgs Processes Settings database does not distinguish upper- and lowercase characters, so that the user has one thing less to worry about, but here it causes problems with Higgs Processes h^0 vs. Higgs Processes H^0 .) We leave the issue of mass ordering between Higgs Processes H^0 and Higgs Processes A^0 open, and thereby also that of Higgs Processes H_2^0 and Higgs Processes H_3^0. Higgs Processes Beyond-the-Standard-Model Higgs, basic processes This section provides the standard set of processes that can be run together to provide a reasonably complete overview of possible production channels for a single neutral Higgs state in a two-doublet scenarios such as MSSM. The list of processes for neutral states closely mimics the one found for the SM Higgs. Some of the processes vanish for a pure pseudoscalar Higgs Processes A^0 , but are kept for flexibility in cases of mixing with the scalar Higgs Processes h^0 and Higgs Processes H^0 states, or for use in the context of non-MSSM models. This should work well to represent e.g. that a small admixture of the 'wrong' parity would allow a process such as Higgs Processes q qbar &rarr; A^0 Z^0 , which otherwise is forbidden. However, note that the loop integrals e.g. for Higgs Processes g g &rarr; h^0/H^0/A^0 are hardcoded to be for scalars for the former two particles and for a pseudoscalar for the latter one, so absolute rates would not be correctly represented in the case of large scalar/pseudoscalar mixing. Higgs Processes 1) Higgs Processes h^0(H_1^0) processes Higgs Processes 2) Higgs Processes H^0(H_2^0) processes Higgs Processes 3) Higgs Processes A^0(H_3^0) processes Higgs Processes 4) Higgs Processes H+- processes Higgs Processes 5) Higgs-pair processes Higgs Processes Beyond-the-Standard-Model Higgs, further processes This section mimics the above section on 'Standard-Model Higgs, further processes', i.e. it contains higher-order corrections to the processes already listed. The two sets therefore could not be used simultaneously without unphysical double-counting. They are not controlled by any group flag, but have to be switched on for each separate process after due consideration. We refer to the standard-model description for a set of further comments on the processes. Higgs Processes 1) Higgs Processes h^0(H_1^0) processes Higgs Processes 2) Higgs Processes H^0(H_2^0) processes Higgs Processes 3) Higgs Processes A^0(H_3^0) processes Higgs Processes Parameters for Beyond-the-Standard-Model Higgs production and decay This section offers a big flexibility to set couplings of the various Higgs states to fermions and gauge bosons, and also to each other. The intention is that, for scenarios like MSSM, you should use standard input from the Higgs Processes SUSY Les Houches Accord , rather than having to set it all yourself. In other cases, however, the freedom is there for you to use. Kindly note that some of the internal calculations of partial widths from the parameters provided do not include mixing between the scalar and pseudoscalar states. Higgs Processes Masses would be set in the Higgs Processes ParticleData database, while couplings are set below. When possible, the couplings of the Higgs states are normalized to the corresponding coupling within the SM. When not, their values within the MSSM are indicated, from which it should be straightforward to understand what to use instead. The exception is some couplings that vanish also in the MSSM, where the normalization has been defined in close analogy with nonvanishing ones. Some parameter names are asymmetric but crossing can always be used, i.e. the coupling for Higgs Processes A^0 &rarr; H^0 Z^0 obviously is also valid for Higgs Processes H^0 &rarr; A^0 Z^0 and Higgs Processes Z^0 &rarr; H^0 A^0. Note that couplings usually appear quadratically in matrix elements. Higgs Processes Another set of parameters are not used in the production stage but exclusively for the description of angular distributions in decays."},{"name":"Histograms","link":"Histograms.html","text":"Histograms Histograms Histograms The Histograms Hist class gives a simple implementation of one-dimensional histograms, useful for quick-and-dirty testing, without the need to link to more sophisticated packages. For this reason it is used in many of the Histograms sample main programs found in the Histograms examples subdirectory. Histograms Basic principles We here provide a simple overview of what is involved. As a first step you need to declare a histogram, with name, title, number of bins and Histograms x range (from, to). Histograms Hist ZpT( 'Z0 pT spectrum', 100, 0., 100.); Alternatively you can first declare it and later define it: Histograms Hist ZpT;   ZpT.book( 'Z0 pT spectrum', 100, 0., 100.); Once declared, its contents can be added by repeated calls to Histograms fill , Histograms ZpT.fill( 22.7, 1.); where the first argument is the Histograms x value and the second the weight. Since the weight defaults to 1 the last argument could have been omitted in this case. Histograms A set of overloaded operators have been defined, so that histograms can be added, subtracted, divided or multiplied by each other. Then the contents are modified accordingly bin by bin. Thus the relative deviation between two histograms Histograms data and Histograms theory can be found as Histograms diff = (data - theory) / (data + theory); assuming that Histograms diff , Histograms data and Histograms theory have been booked with the same number of bins and Histograms x range. That responsibility rests on the user; some checks are made for compatibility, but not enough to catch all possible mistakes. Histograms Also overloaded operations with double real numbers are available. Again these four operations are defined bin by bin, i.e. the corresponding amount is added to, subtracted from, multiplied by or divided by each bin. The double number can come before or after the histograms, with obvious results. Thus the inverse of a histogram Histograms result is given by Histograms 1. / result. The two kind of operations can be combined, e.g. Histograms allpT = ZpT + 2. * WpT Finally, also the Histograms +=, -+, *=, /= are overloaded, with the right-hand side being either a histogram or a real number. Histograms Basic output format A histogram can be printed by making use of the overloaded << operator, e.g.: Histograms cout << ZpT; The printout format is inspired by the old HBOOK one. To understand how to read this format, consider the simplified example Histograms 3.50*10^ 2  9      3.00*10^ 2  X  7      2.50*10^ 2  X  1X      2.00*10^ 2  X6 XX      1.50*10^ 2  XX5XX      1.00*10^ 2  XXXXX      0.50*10^ 2  XXXXX        Contents         *10^ 2  31122         *10^ 1  47208         *10^ 0  79373        Low edge  --         *10^ 1  10001         *10^ 0  05050 The key feature is that the Histograms Contents and Histograms Low edge have to be read vertically. For instance, the first bin has the contents Histograms 3 * 10^2 + 4 * 10^1 + 7 * 10^0 = 347. Correspondingly, the other bins have contents 179, 123, 207 and 283. The first bin stretches from Histograms -(1 * 10^1 + 0 * 10^0) = -10 to the beginning of the second bin, at Histograms -(0 * 10^1 + 5 * 10^0) = -5. Histograms The visual representation above the contents give a simple impression of the shape. An Histograms X means that the contents are filled up to this level, a digit in the topmost row the fraction to which the last level is filled. So the 9 of the first column indicates this bin is filled 9/10 of the way from Histograms 3.00*10^2 = 300 to Histograms 3.50*10^2 = 350 , i.e. somewhere close to 345, or more precisely in the range 342.5 to 347.5. Histograms The printout also provides some other information, such as the number of entries, i.e. how many times the histogram has been filled, the total weight inside the histogram, the total weight in underflow and overflow, and the mean value and root-mean-square width (disregarding underflow and overflow). The mean and width assumes that all the contents is in the middle of the respective bin. This is especially relevant when you plot a integer quantity, such as a multiplicity. Then it makes sense to book with limits that are half-integers, e.g. Histograms Hist multMPI( 'number of multiparton interactions', 20, -0.5, 19.5); so that the bins are centered at 0, 1, 2, ..., respectively.  This also avoids ambiguities which bin gets to be filled if entries are exactly at the border between two bins. Also note that the Histograms fill( xValue) method automatically performs a cast to double precision where necessary, i.e. Histograms xValue can be an integer. Histograms Matplotlib output format Assuming you have Python installed on your platform, it is possible to generate simple Histograms Matplotlib/Pyplot Python code from the histograms generated above, which then can be run to produce PDF plots. This should be done near the end of a run, after the histograms have been filled and properly normalized, as an alternative or complement to the basic output format above. Histograms In  a first step you must then decide on the name of the Python program, e.g.: Histograms HistPlot hpl( 'bosonpT'); where file ending Histograms .py is added automatically. Histograms For each new frame the name should be given, which will later give rise to a PDF file, with ending Histograms .pdf added automatically. If you leave the name field empty the same file will be used as for the latest named one, i.e. producing several frames in one file. One can optionally also give title and Histograms x and Histograms y axis labels: Histograms hpl.frame( 'pTdist', 'Boson pT distributions', 'pT (GeV)', 'sigma'); Next, existing Histograms Hist histograms can be added to the frame, one by one: Histograms hpl.add( ZpT, '-');  hpl.add( WpT, '--,indigo');  hpl.add( ZpT + 2. * WpT , '', 'pT spectrum of Z, W+ and W-'); where the second argument tells how each histogram will be plotted. Default is histogram style, 'h', but the values can also be connected with full lines '-', dashed ones '--', or dash-dotted ones '-.', or plotted as points '.' or crosses 'x', to mention some of the many options offered by Pyplot. Here you can also specify the colour, separated by a comma from the line style, to override the normal colour cycle. The most common colours can be given just as a single letter, such as 'r', 'g', 'b', but a more extensive Histograms colour palette allow finetuning to nuances such as 'orange', 'gold', 'darkgreen', 'royalblue', 'crimson', and so on. A third argument can set the legend of each histogram; by default it is taken as the title of histogram. Histograms Finally the plot code itself will be set up by Histograms hpl.plot(); where optionally it is possible to demand a logarithmic Histograms y scale. Histograms The Histograms frame - add - plot steps can be repeated as needed, each giving rise to a separate PDF file with a plot. In case a plot is to be generated from a single histogram the three steps can be joined into one Histograms hpl.plotFrame( 'onlyZ', ZpT ); where only the name of the PDF file and the histogram are compulsory, while further arguments as discussed above are optional. Histograms At the end, a file Histograms bosonpT.py has now been generated with the proper plotting commands. Additionally a data file has been generated for each histogram to be plotted, Histograms pTdist-0.dat, pTdist-1.dat , etc. Now doing Histograms python bosonpT.py in a terminal window will produce the plots, such as Histograms pTdist.pdf and Histograms onlyZ.pdf. You may of course edit the python file further to improve on the finer details. Histograms Examples are provided in Histograms main03.cc and Histograms main07.cc , where the latter is the simpler one. The Histograms main51.cc example illustrates that the Histograms x scale can be chosen logarithmically, by using an optional last argument when histograms are booked. Histograms The methods We here collect a more complete and formal overview of the methods."},{"name":"Implement New Showers","link":"ImplementNewShowers.html","text":"Implement New Showers Implement New Showers Implement New Showers In case you want to replace the PYTHIA initial- and final-state showers by your own, it is possible but not trivial. The point is that multiparton interactions (MPI), initial-state radiation (ISR) and final-state radiation (FSR) in general appear in one single interleaved sequence of decreasing Implement New Showers pT values. Therefore shower replacements would have to be able to play the game by such rules, as we will outline further below. Of course, this still leaves the field open exactly how to define what to mean by Implement New Showers pT , how to handle recoil effects, how the colour flow is affected, and so on, so there is certainly room for alternative showers. A first example of a shower implemented within the PYTHIA context is Implement New Showers VINCIA. Implement New Showers For the moment we assume you want to keep the MPI part of the story unchanged, and make use of the existing beam-remnants (BR) machinery. If you want to replace both MPI, ISR, FSR and BR then you had better replace the whole Implement New Showers PartonLevel module of the code. If, in addition, you want to produce your own hard processes, then you only need the Implement New Showers hadron-level standalone part of the machinery. Implement New Showers In order to write replacement codes for ISR and/or FSR it is useful to be aware of which information has to be shared between the different components, and which input/output structure is required of the relevant methods. For details, nothing beats studying the existing code. However, here we provide an overview, that should serve as a useful introduction. Implement New Showers It should be noted that we here primarily address the problem in its full generality, with interleaved MPI, ISR and FSR. There exists an option Implement New Showers TimeShower:interleave = off where only MPI and ISR would be interleaved and FSR be considered after these two, but still before BR. Most of the aspects described here would apply also for that case. By contrast, resonance decays are only considered after all the four above components, and timelike showers in those decays would never be interleaved with anything else, so are much simpler to administrate. Implement New Showers Therefore the Implement New Showers Implement New Showers pythia.setShowerPtr( timesDecPtr, timesPtr, spacePtr) method allows two separate pointers to be set to instances of derived Implement New Showers TimeShower classes. The first is only required to handle decays, say of Implement New Showers Z^0 or Implement New Showers Upsilon , with no dependence on beam remnants or ISR. The second, as well as Implement New Showers spacePtr , has to handle the interleaved evolution of MPI, ISR and FSR. Therefore you are free to implement only the first, and let the PYTHIA default showers take care of the latter two. But, if you wanted to, you could also set Implement New Showers timesDecPtr = 0 and only provide a Implement New Showers timesPtr , or only a Implement New Showers spacePtr. If your timelike shower does both cases, the first two pointers can agree. The only tiny point to take into account then is that Implement New Showers init( beamAPtr, beamBPtr) is called twice, a first time to Implement New Showers timesDecPtr with beam pointers 0, and a second time to Implement New Showers timesPtr with nonvanishing beam pointers. Implement New Showers The event record and associated information Obviously the main place for sharing information is the event record, specifically the Implement New Showers Event event member of Implement New Showers Pythia , passed around as a reference. It is assumed you already studied how it works, so here we only draw attention to a few aspects of special relevance. Implement New Showers One basic principle is that existing partons should not be overwritten. Instead new partons should be created, even when a parton only receives a slightly shifted momentum and for the rest stays the same. Such 'carbon copies' by final-state branchings should be denoted by both daughter indices of the original parton pointing to the copy, and both mother indices of the copy to the original. If the copy instead is intended to represent an earlier step, e.g. in ISR backwards evolution, the role of mothers and daughters is interchanged. The Implement New Showers event.copy( iCopy, newStatus) routine can take care of this tedious task; the sign of Implement New Showers newStatus tells the program which case to assume. Implement New Showers To make the event record legible it is essential that the Implement New Showers status codes are selected appropriately to represent the reason why each new parton is added to the record. Also remember to change the status of a parton to be negative whenever an existing parton is replaced by a set of new daughter partons. Implement New Showers Another important parton property is Implement New Showers scale() , which does not appear in the normal event listing, but only if you use the extended Implement New Showers Event:listScaleAndVertex = on option. This property is supposed to represent the production scale (in GeV) of a parton. In the current FSR and ISR algorithms it is used to restrict from above the allowed Implement New Showers pT values for branchings of this particular parton. Beam remnants and other partons that should not radiate are assigned scale 0. Implement New Showers Auxiliary to the event record proper is the Implement New Showers Implement New Showers PartonSystems class, that keep track of which partons belong together in the same scattering subsystem. This information must be kept up-to-date during the shower evolution. Implement New Showers For initial-state showers it is also necessary to keep track of the partonic content extracted from the beams. This information is stored in the Implement New Showers Implement New Showers BeamParticle class. Implement New Showers The TimeShower interface If you want to replace the Implement New Showers TimeShower class this would involve replacing the virtual methods among the following ones. Implement New Showers One of the major complications when combining fixed-order calculations with parton showers comes from constructing a parton shower history. This crucial step requires very precise knowledge of the functional forms of the evolution variable (e.g. transverse momentum), the auxiliary variable (e.g. an energy sharing variable), as well as the parton shower splitting probabilities and the (inverse) parton shower momentum mapping. All of these are readily available within the parton shower, but can be difficult to reconstruct, particularly if non-general improvements are included in the parton shower. To minimise code proliferation and bug potential, the timelike showers contain easy-access functions that can be loaded directly from PYTHIA's merging machinery. Note that within a new shower, you do not need to use these functions or all of the inputs transferred to these functions. Any dummy definition is acceptable. Implement New Showers The easy-access functions are listed in the following. They use some common terminology, wherein Implement New Showers iRad is the position in the event record of the radiating parton, Implement New Showers iRec is the position of the recoiling partner of the dipole, which ensures overall energy and momentum conservation in the splitting, and Implement New Showers iEmt is the position of the radiated parton, all after the splitting. (The ones before are stored in Implement New Showers iRadBef and Implement New Showers iRecBef , not used here.) Obviously the distinctions between Implement New Showers iRad and Implement New Showers iEmt , or between Implement New Showers iRad and Implement New Showers iRec , are a matter of choice. Implement New Showers The SpaceShower interface If you want to replace the Implement New Showers SpaceShower class this would involve replacing the virtual methods in the following. You will find that much of the story reminds of Implement New Showers TimeShower above, and actually some cut-and-paste of text is involved. In some respects the description is simpler, since there are no special cases for resonance decays and non-interleaved evolution. Thus there is no correspondence to the Implement New Showers TimeShower::shower(...) routine. Implement New Showers As mentioned at the end of the section on timelike showers, it can be beneficial to merging and matching machinery of PYTHIA if some additional functionality is available. This in particular includes easy access to a) the evolution variable, b) the auxiliary (energy-sharing) variable, c) to parton shower splitting probabilities and d) to the (inverse) parton shower momentum mapping. Thus, as in the timelike case, it can be beneficial to define the functions"},{"name":"Jet Finders","link":"JetFinders.html","text":"Jet Finders Jet Finders Jet Finders Jet Finders Pythia comes with three Jet Finders built-in jet finders , Jet Finders ClusterJet for Jet Finders e^+e^- events and Jet Finders SlowJet and Jet Finders CellJet for hadron collider ones. Especially the latter is not so well matched to the standards of its field, however. (But it is closely related to the anti- Jet Finders kT algorithm, so is also not completely disconnected Jet Finders Cac08 .) Jet Finders Jet Finders SlowJet can do jet finding according to the current-day Jet Finders kT , Cambridge/Aachen and anti- Jet Finders kT algorithms. It can be run in two modes. The original one is a native implementation which, as the name indicates, is rather slow. However, with the release of the Jet Finders fjcore code from Jet Finders FastJet Jet Finders Cac06, Cac12 , the default mode has become to use the Jet Finders fjcore methods. This is transparent to the user. Jet Finders FastJet Jet Finders SlowJet does not exhaust all the posssibilities of the Jet Finders fjcore code, so users are welcome to extend on the existing functionality by a direct usage of the Jet Finders fjcore methods. Jet Finders Missing from Jet Finders fjcore is a number of aspects, such as jet areas functionality, background estimation, access to other algorithms via plugins, interface to CGAL and tools such as filters and taggers. Therefore, for more sophisticated jet studies the complete Jet Finders FastJet package needs to be linked. This is foreseen in the configure file in the Jet Finders examples subdirectory, and the Jet Finders main71.cc and Jet Finders main72.cc programs contain examples how it can be used with Jet Finders Pythia events. (Even if these examples do not go beyond the functionality that Jet Finders SlowJet can offer.) Jet Finders The latter program makes use of the Jet Finders include/Pythia8Plugins/FastJet3.h header file, contributed by Gavin Salam. This allows simple input of a Jet Finders Pythia particle into a Jet Finders FastJet one, either retaining only the four-momentum or the full particle information. Thereby more sophisticated selectors become possible at the Jet Finders FastJet level. This code could be duplicated, with trivial modifications, to augment the Jet Finders fjcore package functionality in an identical manner, should the need arise."},{"name":"Jet Matching","link":"JetMatching.html","text":"Jet Matching Jet Matching Jet Matching This manual page describes the parton-jet matching interfaces for PYTHIA8. In this approach, usually referred to as MLM matching Jet Matching Man02, Man07 , the final jets after parton-shower evolution and jet clustering are matched to the original partons. The event is accepted if a reasonable match is found, and rejected if not. The rejection step in an approximate way introduces a Sudakov form factor on to the hard processes. Notably the parton shower should not generate an emission that would doublecount hard activity already included in the matrix-element description. Within this general ansatz, different technical solutions can be adopted. We provide two alternatives, one based on the algorithm used in ALPGEN Jet Matching Man03 , and another on the one used in Madgraph Jet Matching Alw11 , both reimplemented from scratch here. The main points of these two algorithms are outlined further down on this page. Jet Matching We also allow for two alternative sources of external events, one in the ALPGEN native format and one in the Madgraph LHEF-based one. All four combinations of input format and matching style are implemented. In the following it is therefore important to keep the two aspects apart, whenever the ALPGEN and Madgraph labels are used. Jet Matching Currently all the files of interest are located in the Jet Matching include/Pythia8Plugins/ subdirectory: Jet Matching Jet Matching Jet Matching JetMatching.h contains the machinery for the parton-jet matching, in the two Jet Matching JetMatchingAlpgen and Jet Matching JetMatchingMadgraph classes. Jet Matching Jet Matching GeneratorInput.h contains three classes for the reading of ALPGEN event and parameter files, and one for the reading of Madgraph parameters. Jet Matching Jet Matching CombineMatchingInput.h contains three classes that combine the reading of events with the matching of them. Jet Matching Jet Matching main32.cc, main32.cmnd : a sample main program and card file showing the usage of the previous files/classes. Jet Matching Event input source External sources of partons are used in the parton-jet matching process. The source of the partons has been separated from the implementation of the matching algorithm. By default, PYTHIA8 contains a machinery to process Les Houches Event Files (LHEFs) as described on the Jet Matching Les Houches Accord and Jet Matching Beam Parameters pages. Madgraph5 adheres to this format, but also contains some further non-standardized information that can be used. The parsing of the native ALPGEN file format is described on the Jet Matching Alpgen Event Interface page. Jet Matching Commonly, the source of external partons also contains information about how a particular type of matching algorithm should be employed. This information is handled by the Jet Matching AlpgenPar class for ALPGEN files, and Jet Matching MadgraphPar for LHEFs. The user can choose to set default matching parameters using the Jet Matching Jet Matching Alpgen:setMLM flag for ALPGEN files. For LHEFs, instead, the setting of default parameters is controlled with the Jet Matching JetMatching:setMad flag: Jet Matching Jet Matching parameters A class Jet Matching JetMatching , derived from Jet Matching UserHooks , is used to define the basic structure of a parton-jet matching algorithm. Two versions are implemented here, based on the FORTRAN code provided by the ALPGEN and Madgraph packages, respectively: Jet Matching JetMatchingAlpgen and Jet Matching JetMatchingMadgraph. The matching parameters are defined with the Jet Matching JetMatching:* keyword. Jet Matching Scheme and Usage Jet Matching Jet algorithm The choice of jet algorithm and associated parameters can be adjusted with the settings below. The PYTHIA8 internal Jet Matching CellJet and Jet Matching SlowJet routines are used for jet finding.  See the Jet Matching Event Analysis page for more details. Jet Matching Merging parameters The following options are the three main parameters for the merging procedure. Although here they are in principle free parameters, they should be heavily influenced by the hard process generation cuts. These values can be set automatically based on the information in the ALPGEN file or LHEF. Jet Matching Exclusive mode The following settings determine whether clustered jets which do not match an original hard parton are allowed. They are typically permitted in the highest jet multiplicity sample, where the parton shower may produce extra hard jets, without risk of double counting. Any extra jet produced by the shower must be softer than any matched light jet, or else the event is vetoed. Jet Matching Jet matching The following parameters control the criteria for matching a clustered jet to a hard parton. Jet Matching Alpgen-specific parameters Jet Matching Madgraph-specific parameters Jet Matching A preliminary implementation of the FxFx prescription for combining multiple NLO calculations Jet Matching Fre12 is available. We would like to stress that this implementation is still undergoing validation. FxFx merging with aMC\@NLO shares most parameters with the leading-order (MadGraph-style) MLM prescriptions and can be activated by using the three additional settings below. Jet Matching Alpgen-style parton-jet matching and merging This section describes the Alpgen-style MLM merging algorithm for PYTHIA8. The most common reference to the algorithm is Jet Matching Man02. In many respects, however, the implementation provided in the ALPGEN package should be considered the official description of the MLM merging procedure. Although designed primarily to work with events generated with ALPGEN, it can in principle also be used with events from a different source. This should not be done without thought, however, and it is up to the user to understand the details of the algorithm and the implications of using a different hard process generator. Jet Matching First, either the Jet Matching CellJet or Jet Matching SlowJet jet algorithm is chosen. Both of these algorithms have an Jet Matching R and an Jet Matching etaMax parameter. In addition, Jet Matching CellJet has an Jet Matching eTmin and Jet Matching SlowJet has a Jet Matching pTmin parameter. These are the primary three parameters of the merging procedure, and in practice are set dependent on the cuts applied to the matrix element (ME) generation. We stress that the merging procedure is not tied to the geometry of a specific physical detector, but only to the match between the original partons and the resulting jets, using standard jet algorithms in the phase space region where partons have been generated. Jet Matching ME samples with different jet multiplicities are run through the event generator, and the generation interrupted after parton showers have been applied, but before resonance decays and beam remnants have been processed. Note in particular that top quarks will not yet be decayed, which may lead to slight differences with the PYTHIA 6 interface included with the ALPGEN package. In what follows, the hardness measure of jets/partons is taken to be Jet Matching eT when Jet Matching CellJet is used and Jet Matching pT when Jet Matching SlowJet is used. The hard system (ignoring all MPI systems) is then analysed: Jet Matching Jet Matching The particles in the original matrix element process are sorted into    light partons, heavy partons and other particles. For backwards    compatibility, a light parton is defined as the set Jet Matching (d, u, s, c,    b, g) with zero mass. A heavy parton is defined as the set Jet Matching (c, b, t) with non-zero mass. Jet Matching All particles not originating from the heavy partons or other    particles are passed to the jet algorithm and clustered. Jet Matching Clustered jets are matched to the light partons in the original ME    process. There are two different methods which can be used: Jet Matching Jet Matching Method 1: The following is done for each parton, in order      of decreasing hardness. The Jet Matching delta R between the parton      and all jets is calculated and the smallest value taken. If      this is less than the jet Jet Matching R parameter, possibly      multiplied by a constant, the jet and parton are considered to      match, and the jet is removed from further consideration.      Note that for Jet Matching CellJet the Jet Matching delta R measure      is in Jet Matching (eta, phi) , while for Jet Matching SlowJet , it is      in Jet Matching (y, phi). Jet Matching Method 2: This method is only possible when using the Jet Matching SlowJet algorithm. Before the clustering is performed,      extremely soft 'ghost' particles are added to the event at the Jet Matching (y, phi) coordinates of the original matrix element      partons. If such a particle is clustered into a jet, the parton      and jet are considered to match. The idea of 'ghost' particles      was originally introduced by FastJet as a way to measure jet      areas Jet Matching Cac06 and should not affect clustering with an      infrared-safe jet algorithm. Jet Matching If there is a light ME parton remaining which has not been matched    to a jet, then the event is vetoed. If all ME partons have been    matched to a jet, but there are still some extra jets remaining,    then two options are possible: Jet Matching Jet Matching Exclusive mode: the event is vetoed. This is typically used when      there are ME samples with higher jet multiplicities, which would      fill in the extra jets. Jet Matching Inclusive mode: the event is retained if the extra jets are softer      than the softest matched jet. This is typically used when      there is no ME sample with higher jet multiplicity, so the parton      shower should be allowed to give extra jets. Jet Matching All particles originating from the heavy partons are passed to the    jet algorithm and clustered. Jet Matching The clustered jets are again matched to the original partons, but    there is no requirement for a match to be present; all matched jets    are immediately discarded. The matching procedure is much the same    as for light partons, but with two differences when Jet Matching delta R matching is used. First, a different Jet Matching R parameter than that    used by the jet algorithm may optionally be given. Second, all jets    that are within the given radius of the parton are matched, not    just the one with the smallest Jet Matching delta R measure. If there    are still extra jets remaining then in exclusive mode the event is    immediately vetoed, while in inclusive mode the event is retained if    the extra jets are softer than the softest Jet Matching light matched jet. Jet Matching Some different options are provided, specified further above in the parameters section. These are set so that, by default, the algorithm closely follows the official MLM interface provided in the ALPGEN package. Jet Matching All vetoing of events is done through the usual Jet Matching User Hooks machinery, and is therefore already taken into account in the cross section. In the output from Jet Matching Jet Matching Pythia::stat() , the difference between the 'Selected' and 'Accepted' columns gives the number of events that have not survived the vetoing procedure. It is still the responsibility of the user to add together the results from runs with different jet multiplicities. In the simplest case, when ALPGEN input is used and the hard process parameters are used to guide the merging procedure, it is enough to set the Jet Matching JetMatching:nJetMax parameter. Jet Matching Madgraph-style parton-jet Merging and Matching Jet Matching This section describes the Madgraph-style parton-jet matching algorithm for PYTHIA8. Jet Matching First, the k Jet Matching T jet algorithm is applied using the PYTHIA8 Jet Matching SlowJet implementation. The Jet Matching useStandardR = false is used, ie. the Jet Matching (delta R)^2 separation is defined as Jet Matching 2 (cosh(delta y) - cos(delta phi)) rather than the more common Jet Matching (delta y)^2 + delta phi)^2. The Jet Matching R , Jet Matching etaMax , and a Jet Matching pTmin parameters are specified. By default, Jet Matching R = 1 and Jet Matching pTmin = qCut. It is not recommended to change these. These should match the algorithm parameters used in the Madgraph Matrix Element (ME) generation. Jet Matching ME samples with different jet multiplicities are run through the event generator, and the generation is interrupted after parton showers have been applied, but before resonance decays and beam remnants have been processed. In what follows, the hardness measure of jets/partons is taken to be Jet Matching k Jet Matching T relative to Jet Matching qCut. The hard system (ignoring all MPI systems) is analyzed: Jet Matching Jet Matching The hard partons in the original matrix element process, provided by    the LHEF, are sorted into light partons, heavy partons and other    particles. A heavy parton is defined by the Jet Matching JetMatching:nQmatch or by the Jet Matching maxjetflavor value in the LHEF. Jet Matching nQmatch refers to the absolute value of    the quark PDG identity code. Jet Matching All partons arising from the parton shower are sorted based on their    motherhood. A showered parton arising from a heavy parton or 'other'    parton classified in the previous step is not passed to the jet    algorithm. All other partons are clustered into light jets. Jet Matching It is checked whether there are 'too few' or 'too many' light jets.    If the number of light jets is less than the number of light partons    defined by Jet Matching nQmatch , the event is vetoed. If the number is    larger, the event is vetoed only in exclusive mode (defined below). Jet Matching In exclusive mode, the number of jets matches the number of light    partons. In inclusive mode, the jets are re-clustered until the number    of jets equals the number of light partons. Next, each light hard    parton is clustered, one at a time, with the jets until a match is found.    A match is defined as a squared cluster scale that equals: Jet Matching Jet Matching Jet Matching |clFact| * qCut for inclusive mode, Jet Matching Jet Matching |clFact| * max(qCut,min(p Jet Matching T (parton))) for exclusive mode, Jet Matching clFact &ge; 0, or Jet Matching Jet Matching |clFact| * min(k Jet Matching T (parton)) for exclusive       mode, Jet Matching clFact < 0. If no match is found, the event is vetoed. When a parton    matches a jet, the jet is removed from the collection, and    the process continues. The process terminates when all partons    are matched to a jet, or a parton is unmatched. Jet Matching All particles originating from the heavy partons are not used. In exclusive mode, it is expected that ME samples with higher parton multiplicity are available to fill the phase space above Jet Matching qCut. The inclusive mode is when there are no such samples, and the parton shower is used to fill the phase space. Jet Matching Some different options are provided, specified further above. These are set so that, by default, the algorithm closely follows the FORTRAN interface Jet Matching ME2Pythia provided in the Madgraph package. Jet Matching All vetoing of events is done through the usual Jet Matching User Hooks machinery, and is therefore already taken into account in the cross section. In the output from Jet Matching Jet Matching Pythia::stat() , the difference between the 'Selected' and 'Accepted' columns gives the number of events that have not survived the vetoing procedure. It is still the responsibility of the user to add together the results from runs with different jet multiplicities. In the simplest case, when the hard process parameters are used to guide the merging procedure, events will be matched in the exclusive mode. Jet Matching Madgraph-style jet matching with no internal vetoes (assuming an external veto implementation) Jet Matching This section describes the facilities that allow expert users to use their own veto code to perform a Madgraph-style jet matching. This can e.g. be useful to assess jet matching uncertainties without having to process the same input events multiple times. Jet Matching As a first step, any vetoes in the Pythia Jet Matching need to be disabled by using Jet Matching JetMatching:doVeto = off. In this mode, Pythia only stores all the information that is necessary to check (and apply) the shower-kT or kT-MLM vetoes externally by hand. This information can be accessed by calling the functions Jet Matching We do not currently supply example code for this very advanced functionality. Interested expert users should feel free to contact the Pythia authors for further explanations. Jet Matching Jet Matching A note on combining UserHooks As have been noted above, the matching is implemented using classes derived from the Jet Matching Jet Matching UserHooks class, thereby gaining access to the event generation process at the relevant locations. For native ALPGEN files, which do not adhere to the Les Houches standards, it is also necessary to intervene with a Jet Matching UserHooks -derived Jet Matching AlpgenHooks to handle the extraction and setting of relevant extra information. Jet Matching One must then combine multiple Jet Matching UserHooks classes, such that the functionality of both is present. A prerequisite is that the different Jet Matching UserHooks classes should be declared with virtual inheritance, e.g. Jet Matching class JetMatching : virtual public UserHooks Without this option, when combining two Jet Matching UserHooks -derived classes, two copies of the base Jet Matching UserHooks class would be created, leading to ambiguities. Jet Matching The two first classes in Jet Matching CombineMatchingInput.h combine ALPGEN input with the two different matching schemes, e.g. for the first Jet Matching class JetMatchingAlpgenInputAlpgen : public AlpgenHooks,  public JetMatchingAlpgen { public:  // Constructor and destructor.  JetMatchingAlpgenInputAlpgen(Pythia& pythia) : AlpgenHooks(pythia),    JetMatchingAlpgen() { }  ~JetMatchingAlpgenInputAlpgen() {}  // Initialisation.  virtual bool initAfterBeams() {    if (!AlpgenHooks::initAfterBeams()) return false;    if (!JetMatchingAlpgen::initAfterBeams()) return false;    return true;  }  // Process level vetos.  virtual bool canVetoProcessLevel() {    return JetMatchingAlpgen::canVetoProcessLevel();  }  .... }; This class inherits from both Jet Matching AlpgenHooks and Jet Matching JetMatchingAlpgen. Any functions which are present in both classes should be overridden with a function that calls the different parent methods in the desired order. In the above example, the only shared methods are the constructor and Jet Matching initAfterBeams()."},{"name":"Left-Right-Symmetry Processes","link":"LeftRightSymmetryProcesses.html","text":"Left-Right-Symmetry Processes Left-Right-Symmetry Processes Left-Right-Symmetry Processes At current energies, the world is left-handed, i.e. the Standard Model contains an Left-Right-Symmetry Processes SU(2)_L group. Left-right symmetry at some larger scale implies the need for an Left-Right-Symmetry Processes SU(2)_R group. Thus the particle content is expanded by right-handed Left-Right-Symmetry Processes Z_R^0 and Left-Right-Symmetry Processes W_R^+- and right-handed neutrinos. The Higgs fields have to be in a triplet representation, leading to doubly-charged Higgs particles, one set for each of the two Left-Right-Symmetry Processes SU(2) groups. Also the number of neutral and singly-charged Higgs states is increased relative to the Standard Model, but a search for the lowest-lying states of this kind is no different from e.g. the freedom already accorded by the MSSM Higgs scenarios. Left-Right-Symmetry Processes PYTHIA implements the scenario of Left-Right-Symmetry Processes Hui97. Left-Right-Symmetry Processes The Left-Right-Symmetry Processes W_R^+- has been implemented as a simple copy of the ordinary Left-Right-Symmetry Processes W^+- , with the exception that it couples to right-handed neutrinos instead of the ordinary left-handed ones. Thus the standard CKM matrix is used in the quark sector, and the same vector and axial coupling strengths, leaving only the mass as free parameter. The Left-Right-Symmetry Processes Z_R^0 implementation (without interference with the photon or the ordinary Left-Right-Symmetry Processes Z^0 ) allows decays both to left- and right-handed neutrinos, as well as other fermions, according to one specific model ansatz. Obviously both the Left-Right-Symmetry Processes W_R^+- and the Left-Right-Symmetry Processes Z_R^0 descriptions are  likely to be simplifications, but provide a starting point. Left-Right-Symmetry Processes For the doubly-charged Higgs bosons, the main decay modes implemented are Left-Right-Symmetry Processes H_L^++ &rarr; W_L^+ W_L^+, l_i^+ l_j^+ ( Left-Right-Symmetry Processes i, j generation indices) and Left-Right-Symmetry Processes H_R^++ &rarr; W_R^+ W_R^+, l_i^+ l_j^+. Left-Right-Symmetry Processes The right-handed neutrinos can be allowed to decay further. Assuming them to have a mass below that of Left-Right-Symmetry Processes W_R^+- , they decay to three-body states via a virtual Left-Right-Symmetry Processes W_R^+- , Left-Right-Symmetry Processes nu_Rl &rarr; l+- f fbar' , where both lepton charges are allowed owing to the Majorana character of the neutrinos. If there is a significant mass splitting, also sequential decays Left-Right-Symmetry Processes nu_Rl &rarr; l+- l'-+  nu'_Rl are allowed. Currently the decays are isotropic in phase space. If the neutrino masses are close to or above the Left-Right-Symmetry Processes W_R^ ones, this description has to be substituted by a sequential decay via a real Left-Right-Symmetry Processes W_R^ (not implemented, but actually simpler to do than the one here). Left-Right-Symmetry Processes Production processes A few different production processes have been implemented, which normally would not overlap and therefore could be run together. Left-Right-Symmetry Processes Parameters The basic couplings of the model are Left-Right-Symmetry Processes The corresponding vacuum expectation value Left-Right-Symmetry Processes v_R is assumed given by Left-Right-Symmetry Processes v_R = sqrt(2) M_WR / g_R and is not stored explicitly. Left-Right-Symmetry Processes The Yukawa couplings of a lepton pair to a Left-Right-Symmetry Processes H^-- , assumed the same for Left-Right-Symmetry Processes H_L^-- and Left-Right-Symmetry Processes H_R^-- , is described by a symmetric 3-by-3 matrix. The default matrix is dominated by the diagonal elements and especially by the Left-Right-Symmetry Processes tau tau one."},{"name":"Leptoquark Processes","link":"LeptoquarkProcesses.html","text":"Leptoquark Processes Leptoquark Processes Leptoquark Processes Leptoquarks arise in many scenarios, and can have widely different characteristics, with respect to spin, isospin am d flavour. The current implementation in no sense attempts to exhaust these possibilities, but only to encode one of the simplest possibilities, with a single scalar leptoquark, denoted Leptoquark Processes LQ and assigned PDG code 42. The leptoquark is assumed to carry specific quark and lepton quantum numbers, by default Leptoquark Processes u quark plus electron. These flavour numbers are conserved, i.e. a process such as Leptoquark Processes u e^- &rarr; LQ &rarr; d nu_e is not allowed. Leptoquark Processes Although only one leptoquark is implemented, its flavours may be changed arbitrarily to study the different possibilities. The flavours of the leptoquark are defined by the quark and lepton flavours in the decay mode list. Therefore, to change from the current Leptoquark Processes u e^- to Leptoquark Processes c mu^+ , say, you only need a line Leptoquark Processes Leptoquark Processes pythia.readString('42:0:products = 4 -13'); Leptoquark Processes in your main program, or the equivalent in a command file. The former must always be a quark, while the latter could be a lepton or an antilepton; a charge-conjugate partner is automatically defined by the program. At initialization, the charge is recalculated as a function of the flavours defined; also the leptoquark name is redefined to be of the type Leptoquark Processes LQ_q,l , where actual quark and lepton flavours are displayed. Leptoquark Processes The leptoquark is likely to be fairly long-lived, in which case it could have time to fragment into a mesonic- or baryonic-type state, which would decay later on. Currently this possibility is not handled; therefore the leptoquark is always assumed to decay before fragmentation. For that reason the leptoquark can also not be put stable. Leptoquark Processes Production processes Four production processes have been implemented, which normally would not overlap and therefore could be run together. Leptoquark Processes Parameters In the above scenario the main free parameters are the leptoquark flavour content, set as already described, and the Leptoquark Processes LQ mass, set as usual. In addition there is one further parameter."},{"name":"Les Houches Accord","link":"LesHouchesAccord.html","text":"Les Houches Accord Les Houches Accord Les Houches Accord The Les Houches Accord (LHA) for user processes Les Houches Accord Boo01 is the standard way to input parton-level information from a matrix-elements-based generator into PYTHIA. The conventions for which information should be stored has been defined in a Fortran context, as two commonblocks. Here a C++ equivalent is defined, as a single class. The most common application is to read input from a Les Houches Event File (LHEF) Les Houches Accord Alw06 , but it is also possible to have a runtime interface to another program. Les Houches Accord A 'no-beams' extension, currently not part of the standard, has been implemented. In this case only one part of a complete event is studied, and so no meaningful beam information can be set. The prime example is to study the decay properties of a resonance, where a parton-level decay chain is provided as input, and then showers and nadronization should be added. Another example would be where a given partonic configuration would be hadronized, without any previous showers. See further below and in the Les Houches Accord Hadron-Level Standalone description. Les Houches Accord Another unofficial extension is the support for Double Parton Scattering (DPS), i.e. when two hard scatterings should be defined. This is allowed by letting one follow after the other in the event listing, such that two Les Houches Accord 2 &rarr; 2 scatterings are specified by eight lines. It is here required that daughters are located below mothers strictly within each scattering separately, since the logic needed to sort out an arbitrary ordering is deemed overkill for such a peripheral case. An additional line Les Houches Accord #scaleShowers scale1 scale2 can be attached after the event proper, where the starting shower scale can be defined for each scattering separately; if not present both scatterings evolve down from the standard scale value. The Les Houches Accord LHAup method Les Houches Accord bool scaleShowersIsSet() tells whether such information has been set for the current event and, if so, Les Houches Accord double scaleShowers(int i) return the two scale values for arguments 0 and 1. Les Houches Accord The Les Houches Accord LHAup class is a base class, containing reading and printout functions, plus two pure virtual functions, one to set initialization information and one to set information on each new event. Derived classes have to provide these two virtual functions to do the actual work. The existing derived classes are for reading information from a Les Houches Event File, from the respective Fortran commonblocks, or from PYTHIA 8 itself. Les Houches Accord You are free to write your own derived classes, using the rules and methods to be described below. Normally, pointers to objects of such derived classes should be handed in with the Les Houches Accord Les Houches Accord Pythia::setLHAupPtr( LHAup*) method. However, with the LHEF format a filename can replace the pointer, see further below. Les Houches Accord Let us now describe the methods at your disposal to do the job. Les Houches Accord Initialization The Les Houches Accord LHAup class stores information equivalent to the Les Houches Accord /HEPRUP/ commonblock, as required to initialize the event generation chain. The main difference is that the vector container now allows a flexible number of subprocesses to be defined. For the rest, names have been modified, since the 6-character-limit does not apply, and variables have been regrouped for clarity, but nothing fundamental is changed. Les Houches Accord Inside Les Houches Accord setInit() , such information can be set by the following methods: Les Houches Accord Note : PYTHIA does not make active use of the (optional) Les Houches Accord xErr values, but calculates a statistical cross section error based on the spread of event-to-event weights. This should work fine for strategy options +-1, but not for the others. Specifically, for options +-2 and +-3 the weight spread may well vanish, and anyway is likely to be an underestimate of the true error. If the author of the LHA input information does provide error information you may use that - this information is displayed at initialization. If not, then a relative error decreasing like Les Houches Accord 1/sqrt(n_acc) , where Les Houches Accord n_acc is the number of accepted events, should offer a reasonable estimate. Les Houches Accord Information is handed back by the following methods (that normally you would not need to touch): Les Houches Accord Les Houches Accord Event input The Les Houches Accord LHAup class also stores information equivalent to the Les Houches Accord /HEPEUP/ commonblock, as required to hand in the next parton-level configuration for complete event generation. The main difference is that the vector container now allows a flexible number of partons to be defined. For the rest, names have been modified, since the 6-character-limit does not apply, and variables have been regrouped for clarity, but nothing fundamental is changed. Les Houches Accord The LHA standard is based on Fortran arrays beginning with index 1, and mother information is defined accordingly. In order to be compatible with this convention, the zeroth line of the C++ particle array is kept empty, so that index 1 also here corresponds to the first particle. One small incompatibility is that the Les Houches Accord sizePart() method returns the full size of the particle array, including the empty zeroth line, and thus is one larger than the true number of particles ( Les Houches Accord NUP ). Les Houches Accord Inside a normal Les Houches Accord setEvent(...) call, information can be set by the following methods: Les Houches Accord Information is handed back by the following methods: Les Houches Accord From the information in the event record it is possible to set the flavour and Les Houches Accord x values of the initiators Les Houches Accord This information is returned by the methods Les Houches Accord In the LHEF description Les Houches Accord Alw06 an extension to include information on the parton densities of the colliding partons is suggested. This optional further information can be set by Les Houches Accord This information is returned by the methods Les Houches Accord The maximum scale for parton-shower evolution of a Les Houches event is regulated by the Les Houches Accord Les Houches Accord TimeShower:pTmaxMatch and Les Houches Accord Les Houches Accord SpaceShower:pTmaxMatch modes. If you want to guarantee that the input Les Houches Accord scale value is respected, as is often the case in matching/merging procedures, you should set both of these modes to 1. That only affects the hard process, while resonance decays are still processed using the resonance mass to set the upper limit. However, the optional Les Houches Accord Les Houches Accord Beams:strictLHEFscale = on setting restricts also resonance-decay emissions to be below the input Les Houches Accord scale value. Les Houches Accord As a further non-standard feature, it is also possible to read in the separate scale values of all final particles. Such scale values could be used e.g. to restrict the maximum scale for shower evolutions for each parton separately. This reading will only be applied if the Les Houches Accord Beams:setProductionScaleFromLHEF switch is true (see Les Houches Accord Les Houches Accord Beam Parameters for details). This information is returned by the method Les Houches Accord double LHAup::scale(int i). When no such information has been read from the LHEF, the scale defaults to -1. Les Houches Accord Les Houches Accord The LHA expects the decay of resonances to be included as part of the hard process, i.e. if unstable particles are produced in a process then their decays are also described. This includes Les Houches Accord Z^0, W^+-, H^0 and other short-lived particles in models beyond the Standard Model. Should this not be the case then PYTHIA will perform the decays of all resonances it knows how to do, in the same way as for internal processes. Note that you will be on slippery ground if you then restrict the decay of these resonances to specific allowed channels since, if this is not what was intended, you will obtain the wrong cross section and potentially the wrong mix of different event types. (Since the original intention is unknown, the cross section will not be corrected for the fraction of open channels, i.e. the procedure used for internal processes is not applied in this case.) Les Houches Accord Even if PYTHIA can select resonance decay modes according to its internal tables, there is normally no way for it to know which decay angular correlations should exist in the simulated process. Therefore almost all decays are isotropic. The exceptions are Higgs and top decays, in the decay chains Les Houches Accord H &rarr; WW/ZZ &rarr; f fbar f' fbar' and Les Houches Accord t &rarr; b W &rarr; b f fbar , where the process-independent correlations implemented for internal processes are used. If part of the decay chain has already been set, however (e.g. Les Houches Accord H &rarr; WW/ZZ or Les Houches Accord t &rarr; b W ), then decay is still isotropic. Les Houches Accord The LHA standard only allows for one hard subcollision in an event. Further multiparton interactions are supposed to be handled by the internal MPI machinery. As a nonstandard feature, it is possible to input two hard subcollisions in the same event, to match the internal Les Houches Accord second hard process machinery. In such cases two partons are extracted from each of the two incoming hadrons. A restriction is that, unlike the single-subprocess case, it is important that the partons are input in the order that PYTHIA later would need. That is, the two subcollisions should follow each other, with instate preceding outstate. Any resonance decay chain should be put at the end, after both interactions. As illustration, consider double Les Houches Accord W production. With Les Houches Accord 1 and Les Houches Accord 2 labelling the two subcollisions, and Les Houches Accord A and Les Houches Accord B the two incoming hadron beams, the event record ordering should be Les Houches Accord in_A1 - in_B1 - W_1 - in_A2 - in_B2 - W_2 - f_1 - fbar_1 - f_2 - fbar_2 , where Les Houches Accord f fbar is the fermion decay products of the respective Les Houches Accord W. A limitation is that currently only one input scale is used, that thereby limits all further partonic activity in the same way for both processes. Les Houches Accord Transfer to the PYTHIA process record There are a few settings available for event input. They take effect when the LHA event record is translated to the PYTHIA Les Houches Accord process event record, but leaves the LHA event record itself unchanged. Les Houches Accord An interface to Les Houches Event Files The LHEF standard ( Les Houches Accord Alw06 , Les Houches Accord But14 ) specifies a format where a single file packs initialization and event information. This has become the most frequently used procedure to process external parton-level events in Pythia. To access this, you must set Les Houches Accord Beams:frameType = 4 and Les Houches Accord Beams:LHEF to be the file name, see Les Houches Accord Beam Parameters. Internally this name is then used to create an instance of the derived class Les Houches Accord LHAupLHEF , which can do the job of reading an LHEF. Les Houches Accord As some information in a Les Houches Event File init block is only known at the end of generation, some programs choose to output this as a separate file. If so, the name of this file can be specified by Les Houches Accord Les Houches Accord Beams:LHEFheader. Les Houches Accord The two key compulsory parts of an LHEF is the initialization information stored in an init block, enclosed by a matching Les Houches Accord <init> - Les Houches Accord </init> pair of lines, and the event input, with each event enclosed by a matching Les Houches Accord <event> - Les Houches Accord </event> pair of lines. In the case of the no-beams extension the init block may be empty, but the Les Houches Accord <init> and Les Houches Accord </init> lines must be included for the file parsing to work as expected. It is also possible to have a non-empty init block, with the beams assigned code 0, and optionally a number of specified 'processes'. Les Houches Accord The latest update of the LHEF format Les Houches Accord But14 introduced a multitude of different optional features. This means that apart from the Les Houches Accord <init> and Les Houches Accord <event> tags, a plethora of new, optional information is available. Furthermore, the inclusion of an arbitrary number of attributes into the tags should be supported. The LHEF reader in Pythia adheres to the updated LHEF format without any restriction. The new generation information available through the updated LHEF format can be retrieved by using Pythia's Les Houches Accord Info class. For a detailed description, please consult the section 'Les Houches Event File 3.0 information' in Les Houches Accord Event Information. Les Houches Accord The LHEF reader can also read in and store header blocks. By default this option is switched on, but may be controlled through the Les Houches Accord Les Houches Accord Beams:readLHEFheaders flag if necessary. The information can later be read out through the Les Houches Accord Info class for further processing. Due to the non-standard nature of the information in these blocks they are stored whole, and PYTHIA itself makes no further attempt to process their meaning. Les Houches Accord Because Les Houches Event files tend not to adhere strictly to XML conventions, to consistently read in header information, certain choices must be made. The primary goal is to make as much information available as possible. First, information sitting directly in the <header> block is stored under the key 'base'. Second, the tags starting and ending each sub block must be on their own line. Finally, the contents of comment blocks, <!-- -->, are still stored. The header keys are formed hierarchically from the names of the header blocks. This behaviour is illustrated in the following example: Les Houches Accord <header>    BaseA    <hblock1>     1A     <hblock11>      11A <hblock111>      </hblock111> 11B     </hblock11>     1B    </hblock1>    <hblock2>     2A     <!-- 2B -->    </hblock2>    BaseB  </header> which would lead to the following information being stored in the Les Houches Accord Info class: Les Houches Accord Les Houches Accord Les Houches Accord Key Les Houches Accord Value Les Houches Accord Les Houches Accord base Les Houches Accord BaseA Les Houches Accord BaseB Les Houches Accord Les Houches Accord hblock1 Les Houches Accord 1A Les Houches Accord 1B Les Houches Accord Les Houches Accord hblock1.hblock11 Les Houches Accord 11A <hblock111> Les Houches Accord </hblock111> 11B Les Houches Accord Les Houches Accord hblock2 Les Houches Accord 2A Les Houches Accord <!-- 2B --> Les Houches Accord Les Houches Accord Normally the LHEF would be in uncompressed format, and thus human-readable if opened in a text editor. A possibility to read gzipped files has been added, based on the Boost and zlib libraries, which therefore have to be linked appropriately in order for this option to work. See the Les Houches Accord README file in the main directory for details on how to do this. Les Houches Accord An example how to generate events from an LHEF is found in Les Houches Accord main11.cc. Note the use of Les Houches Accord Info::atEndOfFile() to find out when the whole LHEF has been processed. Les Houches Accord To allow the sequential use of several event files, the Les Houches Accord Les Houches Accord Beams:newLHEFsameInit can be set Les Houches Accord true. Then there will be no initialization, except that the existing Les Houches Accord LHAupLHEF class instance will be deleted and replaced by one pointing to the new file. It is assumed (but never checked) that the initialization information is identical, and that the new file simply contains further events of exactly the same kind as the previous one. An example of this possibility, and the option to mix with internal processes, is found in Les Houches Accord main12.cc. A variant, based on input in a command file, is given in Les Houches Accord main13.cc. Les Houches Accord In C++, real numbers are printed with an 'E' to denote the exponent part, e.g. 1.23E+04, and are read in accordingly. Other languages may use other letters, e.g. Fortran allows either 'E' or 'D'. A file using the latter convention would not be readable by the standard routines. In case you have such an 'incorrectly formatted' file, a conversion to a new corrected file could be done e.g. using Les Houches Accord sed , as a one-line command Les Houches Accord sed -e 's/\([0-9]\.\{0,1\}\)[dD]\([+-]\{0,1\}[0-9]\)/\1E\2/g' old.lhe > new.lhe This replaces a 'd' or 'D' with an 'E' only when it occurs in the combination Les Houches Accord Les Houches Accord (digit) ('.' or absent) ('d' or 'D') ('+', '-' or absent) (digit) Les Houches Accord It will work on all parts of the file, also inside a Les Houches Accord <header>...</header> block. For conversion only inside the Les Houches Accord <init>...</init> and Les Houches Accord <event>...</event> blocks, create a file Les Houches Accord convert.sed containing Les Houches Accord /<init>/,/<\/init>/bconv  /<event>/,/<\/event>/bconv  b  :conv  s/\([0-9]\.\{0,1\}\)[dD]\([+-]\{0,1\}[0-9]\)/\1E\2/g and run it with Les Houches Accord sed -f convert.sed old.lhe > new.lhe Les Houches Accord The workhorses of the Les Houches Accord LHAupLHEF class are three methods found in the base class, so as to allow them to be reused in other contexts. Les Houches Accord These three main methods build on a number of container classes and a generic LHEF reader class (called Les Houches Accord Reader ) found in Les Houches Accord LHEF3.h and Les Houches Accord LHEF3.cc. The Les Houches Accord Reader handles all the parsing and storage necessary to adhere with Les Houches Accord But14. (A matching Les Houches Accord Writer class is also available; see documentation in Les Houches Accord LHEF3.h how it can be used.) All parsing that is not strictly part of the LHEF format (e.g. the reading of header information) is instead performed directly in the Les Houches Accord LHAupLHEF methods. Les Houches Accord Some other small utility routines are: Les Houches Accord A few other methods, most of them derived from the base class, streamlines file opening and closing, e.g. if several LHE files are to be read consecutively, without the need for a complete reinitialization. This presupposes that the events are of the same kind, only split e.g. to limit file sizes. Les Houches Accord A runtime Fortran interface The runtime Fortran interface requires linking to an external Fortran code. In order to avoid problems with unresolved external references when this interface is not used, the code has been put in a separate Les Houches Accord include/Pythia8Plugins/LHAFortran.h file, that is not included in any of the other library files. Instead it should be included in the user-supplied main program, and used to create a derived class that contains the implementation of two methods below that call the Fortran program to do its part of the job. Les Houches Accord The Les Houches Accord LHAupFortran class derives from Les Houches Accord LHAup. It reads initialization and event information from the LHA standard Fortran commonblocks, assuming these commonblocks behave like two Les Houches Accord extern 'C' struct named Les Houches Accord heprup_ and Les Houches Accord hepeup_. (Note the final underscore, to match how the gcc compiler internally names Fortran files.) Les Houches Accord The instantiation does not require any arguments. Les Houches Accord The user has to supply implementations of the Les Houches Accord fillHepRup() and Les Houches Accord fillHepEup() methods, that is to do the actual calling of the external Fortran routines that fill the Les Houches Accord HEPRUP and Les Houches Accord HEPEUP commonblocks. The translation of this information to the C++ structure is provided by the existing Les Houches Accord setInit() and Les Houches Accord setEvent() code. Les Houches Accord Up to and including version 8.125 the Les Houches Accord LHAupFortran class was used to construct a runtime interface to PYTHIA 6.4. This was convenient in the early days of PYTHIA 8 evolution, when this program did not yet contain hard-process generation, and the LHEF standard did not yet exist. Nowadays it is more of a bother, since a full cross-platform support leads to many possible combinations. Therefore this support has been removed, but can still be recuperated from previous code versions, in a reduced form up to version 8.176. Les Houches Accord Methods for LHEF output The main objective of the Les Houches Accord LHAup class is to feed information from an external program into PYTHIA. It can be used to export information as well, however. Specifically, there are four routines in the base class that can be called to write a Les Houches Event File. These should be called in sequence in order to build up the proper file structure. Les Houches Accord PYTHIA 8 output to a Les Houches Event File version 1.0 The above methods could be used by any program to write an LHEF. For PYTHIA 8 to do this, a derived class already exists, Les Houches Accord LHAupFromPYTHIA8. In order for it to do its job, it must gain access to the information produced by PYTHIA, specifically the Les Houches Accord process event record and the generic information stored in Les Houches Accord info. Therefore, if you are working with an instance Les Houches Accord pythia of the Les Houches Accord Pythia class, you have to instantiate Les Houches Accord LHAupFromPYTHIA8 with pointers to the Les Houches Accord process and Les Houches Accord info objects of Les Houches Accord pythia : Les Houches Accord Les Houches Accord LHAupFromPYTHIA8 myLHA(&pythia.process, &pythia.info); Les Houches Accord The method Les Houches Accord setInit() should be called to store the Les Houches Accord pythia initialization information in the LHA object, and Les Houches Accord setEvent() to store event information. Furthermore, Les Houches Accord updateSigma() can be used at the end of the run to update cross-section information, cf. Les Houches Accord closeLHEF(true) above. An example how the generation, translation and writing methods should be ordered is found in Les Houches Accord main20.cc. Les Houches Accord Currently there are some limitations, that could be overcome if necessary. Firstly, you may mix many processes in the same run, but the cross-section information stored in Les Houches Accord info only refers to the sum of them all, and therefore they are all classified as a common process 9999. Secondly, you should generate your events in the CM frame of the collision, since this is the assumed frame of stored Les Houches events, and no boosts have been implemented for the case that Les Houches Accord Pythia::process is not in this frame. Les Houches Accord The LHEF standard is the agreed format to store the particles of a hard process, as input to generators, whereas output of final states is normally handled using the Les Houches Accord HepMC standard. It is possible to use LHEF also here, however. It requires that the above initialization is replaced by Les Houches Accord Les Houches Accord LHAupFromPYTHIA8 myLHA(&pythia.event, &pythia.info); Les Houches Accord i.e. that Les Houches Accord process is replaced by Les Houches Accord event. In addition, the Les Houches Accord PartonLevel:all = off command found in Les Houches Accord main20.cc obviously must be removed if one wants to obtain complete events. Les Houches Accord PYTHIA 8 output to a Les Houches Event File version 3.0 PYTHIA 8 also supports LHEF 3.0 output, and we include a general LHEF3 writer ( Les Houches Accord Pythia::Writer of LHEF3.h and LHEF3.cc) for this purpose. The functions of this file writer are used in the Les Houches Accord LHEF3FromPYTHIA8. This latter class allows users to output PYTHIA events in LHEF3 format from a PYTHIA main program. An example of how to use Les Houches Accord LHEF3FromPYTHIA8 is found in the Les Houches Accord main20lhef3.cc example. Please note that, although similar, the usage of Les Houches Accord LHEF3FromPYTHIA8 differs from the usage of Les Houches Accord LHAupFromPYTHIA8 , with Les Houches Accord LHEF3FromPYTHIA8 requiring fewer function calls. Les Houches Accord To print a comprehensive LHE file, Les Houches Accord LHEF3FromPYTHIA8 is constructed with pointers to an Les Houches Accord Event object, as well as pointers to instances of Les Houches Accord Settings , Les Houches Accord Info and Les Houches Accord ParticleData , giving e.g. a constructor call Les Houches Accord Les Houches Accord LHEF3FromPYTHIA8 myLHEF3(&pythia.event, &pythia.settings, &pythia.info, &pythia.particleData); Les Houches Accord As a next step, you should open the output file by using the Les Houches Accord LHAupFromPYTHIA8 member function Les Houches Accord Les Houches Accord openLHEF(string name) Les Houches Accord where Les Houches Accord name is the output file name. Les Houches Accord Then, the method Les Houches Accord setInit() should be called to store the initialization information (read from Les Houches Accord settings and Les Houches Accord info ) and write the header and init blocks into the output file. Note that at this stage, the cross section printed in the init block is not sensible, as no integration has yet taken place. The init block can be updated at the end of the event generation (see below). Les Houches Accord During event generation, you should use Les Houches Accord setEvent() to write the event information (as read from Les Houches Accord info and Les Houches Accord event ) to the output file. Les Houches Accord Finally, before leaving your main program, it is necessary to close the output file by using the Les Houches Accord LHAupFromPYTHIA8 member function Les Houches Accord Les Houches Accord closeLHEF( bool doUpdate = false) Les Houches Accord The boolean variable Les Houches Accord doUpdate is optional. If Les Houches Accord doUpdate is used, and if Les Houches Accord doUpdate = true , then the init block of the output file will be updated with the latest cross section information. Les Houches Accord Currently there are some limitations, that could be overcome if necessary. Firstly, you may mix many processes in the same run, but the cross-section information stored in Les Houches Accord info only refers to the sum of them all, and therefore they are all classified as a common process 9999. Secondly, you should generate your events in the CM frame of the collision, since this is the assumed frame of stored Les Houches events, and no boosts have been implemented for the case that Les Houches Accord Pythia::process is not in this frame."},{"name":"MadGraph5 Processes","link":"MadGraph5Processes.html","text":"MadGraph5 Processes MadGraph5 Processes MadGraph5 Processes Here we will describe two special ways to make use of MadGraph5 and MadGraph5_aMC\@NLO MadGraph5 Processes Alw11,Alw14 inside PYTHIA, either by exporting Madgraph process code or by wrapping the MadGraph5_aMC\@NLO generator as a PYTHIA Les Houches interface. MadGraph5 Processes Of course, MadGraph5 can also output files of parton-level events according to the MadGraph5 Processes LHEF standard, that can be read in and processed further by PYTHIA 8. This is the most commonly used approach, and requires no further description here. MadGraph5 Processes MadGraph5 code inside PYTHIA By far the easiest way to implement new processes into PYTHIA 8 is by using the matrix-element generator MadGraph5. This program has an option to output the results of a matrix-element calculation as a set of PYTHIA 8 C++ classes (plus further auxiliary code), that can then be linked and used as MadGraph5 Processes semi-internal processes, meaning they are handled identically with normal internal ones. This way, MadGraph5 can be used to implement processes from any model that can be written in  terms of a Lagrangian. Any MadGraph5 Processes 2 &rarr; 1 , MadGraph5 Processes 2 &rarr; 2 and MadGraph5 Processes 2 &rarr; 3 processes can be implemented, the limit being set by the absence of efficient phase space generator algorithms for higher multiplicities in PYTHIA. Features such as MadGraph5 Processes s -channel resonances are automatically implemented in the process classes.  Besides the process library and necessary model files, also an example main program is generated for each set of processes, which can be easily modified to perform the desired analyses. MadGraph5 Processes In order to create a PYTHIA 8 process library with MadGraph5, first download the MadGraph5 package from MadGraph5 Processes https://launchpad.net/madgraph5 , and untar the package. You can then specify the location of your MadGraph5 Processes pythia81xx directory in the file MadGraph5 Processes input/mg5_configuration.txt : MadGraph5 Processes MadGraph5 Processes pythia8_path = ./pythia81xx MadGraph5 Processes The location can be either relative (to the directory MadGraph5 Processes MadGraph5_v_x_x_x/. ) or absolute. MadGraph5 Processes For any model that is already implemented in the MadGraph5 package, you can directly use the model. Start the MadGraph5 interface MadGraph5 Processes bin/mg5 , and do: MadGraph5 Processes import model model_name generate your_process_in_mg5_syntax add process your_next_process_in_mg5_syntax ... output pythia8 [path_to_pythia81xx_directory] MadGraph5 Processes For examples of MG5 process syntax, please see MadGraph5 Processes http://madgraph.phys.ucl.ac.be/EXAMPLES/example_mg5.html or type MadGraph5 Processes help generate. If you specified the path to the MadGraph5 Processes pythia81xx directory in the MadGraph5 Processes mg5_configuration file, you do not need to enter it in the MadGraph5 Processes output command. MadGraph5 Processes If your preferred model is found on the FeynRules model wiki page, MadGraph5 Processes http://feynrules.irmp.ucl.ac.be/wiki/ModelDatabaseMainPage , download the UFO (Universal FeynRules Output) tar file for the model, untar in the MadGraph5 Processes models/ directory, and use as above. MadGraph5 Processes If you want to implement a new model which has not yet been implemented, you can do this either using the Mathematica package FeynRules (see MadGraph5 Processes http://feynrules.irmp.ucl.ac.be/ ) or directly edit the UFO model files of the most similar model in the MadGraph5 Processes models/ directory. MadGraph5 Processes The resulting output from the MadGraph5 Processes output pythia8 command is: MadGraph5 Processes MadGraph5 Processes A process directory MadGraph5 Processes Processes_modelname with the model information and the files needed for all processes defined for this model, placed in the MadGraph5 Processes pythia81xx main directory. The model files are MadGraph5 Processes Parameters_modelname.h/cc and MadGraph5 Processes HelAmps_modelname.h/cc , and the process files for each process class (with the same mass, spin and color of the initial/final state particles) are called MadGraph5 Processes Sigma_modelname_processname.h/cc. The directory also contains a MadGraph5 Processes makefile and a model parameter file MadGraph5 Processes param_card_modelname.dat. MadGraph5 Processes An example main program in the directory MadGraph5 Processes examples/ (in the MadGraph5 Processes pythia81xx main directory) called MadGraph5 Processes main_modelname_N.cc and a corresponding makefile MadGraph5 Processes Makefile_modelname_N. This main program links in the process classes in the process directory described above. To run the example main program, just go to the MadGraph5 Processes examples/ directory and run MadGraph5 Processes MadGraph5 Processes make -f Makefile_modelname_N MadGraph5 Processes or run MadGraph5 Processes launch directly inside the MadGraph5 command line interface. MadGraph5 Processes Note that in order for PYTHIA 8 to be able to automatically decay any new particles, it is necessary to specify the branching ratios of the particles in the MadGraph5 Processes param_card file, see MadGraph5 Processes Ska04,Alw07 for details. MadGraph5 Processes For further technical details, please see the MadGraph5 release paper MadGraph5 Processes Alw11 and the MadGraph5 Processes semi-internal processes page. MadGraph5 Processes Currently the standard way of interfacing is to use the LHEF standard with an intermediate event file. The advantage is that then the MadGraph5 phase space generator can be used, which opens up for processes with more than three particles in the final state. The disadvantages are that it is less easy to mix and match with existing PYTHIA processes, and that one needs to regenerate and store large LHEF files for different  kinematics cuts or parameter values. MadGraph5 Processes Please cite the MadGraph5 release paper MadGraph5 Processes Alw11 if you use MadGraph5 to generate process libraries for PYTHIA 8. MadGraph5 Processes MadGraph5_aMC\@NLO executable inside PYTHIA The MadGraph5 Processes Pythia::setLHAupPtr(LHAup* lhaUpPtr) method allows a Pythia generator to accept a pointer to an object derived from the MadGraph5 Processes MadGraph5 Processes LHAup base class. Such an object will be initialized from within Pythia, and be called repeatedly to generate the next parton-level event, using the LHA specification as a standard to transfer the relevant information back to Pythia. Properly constructed, the operation of an MadGraph5 Processes LHAup object thus is almost completely hidden from the user, and generates events almost like an ordinary internal Pythia process. MadGraph5 Processes The MadGraph5 Processes LHAupMadgraph is precisely such a class, derived from MadGraph5 Processes LHAup , that contains the code needed to wrap a MadGraph5_aMC\@NLO executable. Thereby the generation of Madgraph processes from within Pythia becomes straightforward. An explicit example is provided in MadGraph5 Processes main34.cc. We describe some of the key elements used there and in the general case. MadGraph5 Processes Note that GZIP support must be enabled in the Pythia executable, so use the MadGraph5 Processes --with-gzip option in the MadGraph5 Processes configure step before Pythia compilation. MadGraph5 Processes Events are generated with MadGraph utilizing the MadGraph5 Processes gridpack method for MadGraph5 and an MadGraph5 Processes equivalent method for aMC\@NLO. Consequently the run directory, MadGraph5 Processes 'madgraphrun' by default, does not need to be deleted between independent runs with the same configuration (excluding random seeds). Indeed, keeping the directory significantly speeds the generation process, particularly for NLO generation with aMC\@NLO as the grid initialization can be skipped after the initial run."},{"name":"Main-Program and Related Settings","link":"MainProgramSettings.html","text":"Main-Program and Related Settings Main-Program and Related Settings Main-Program and Related Settings Main-Program and Related Settings Introduction The main program is up to the user to write. However, Main-Program and Related Settings sample main programs are provided. In one such class of programs, key settings of the run are read in from a 'cards file'. For experimental collaborations this is actually the most common way to run a program like PYTHIA. The commands in such a file may be of two types Main-Program and Related Settings (a) instructions directly to Main-Program and Related Settings Pythia , like which processes to generate, and Main-Program and Related Settings (b) instructions to the main program for what it should do, like how many events to generate, and how many events should be listed. Main-Program and Related Settings In principle these two kinds could be kept completely separate. However, to make life simpler, a few useful main-program settings are defined on this page, so that they are recognized by the Main-Program and Related Settings Settings machinery. They can thus be put among the other cards without distinction. It is up to you to decide which ones, if any, you actually want to use when you write your main program. Main-Program and Related Settings To further reduce the necessary amount of main-program code, some of the tasks that you can steer from your main program can also be done internally. This in particular relates to some information printing. To give an example, Main-Program and Related Settings pythia.event.list() can be inserted to print an event, i.e. all the particles belonging to it. Given the length of these listings one would list only a few events at the beginning of the run, to get some feeling for the character of events. This could be achieved e.g. with a main-program statement Main-Program and Related Settings Main-Program and Related Settings if (iEvent < 3) pythia.event.list() Main-Program and Related Settings to list the first three events in a loop over Main-Program and Related Settings iEvent , after Main-Program and Related Settings pythia.next() has been used to generate the next event. Alternatively a Main-Program and Related Settings Next:numberShowEvent = 3 setting, e.g. in a command file, would achieve the same, by an internal call at the end of Main-Program and Related Settings pythia.next(). Main-Program and Related Settings The settings names on this page thus fall into four main groups Main-Program and Related Settings Main-Program and Related Settings Main-Program and Related Settings Init:... denote actions that automatically may be taken during the Main-Program and Related Settings pythia.init() call. Main-Program and Related Settings Main-Program and Related Settings Next:... denote actions that automatically may be taken during the Main-Program and Related Settings pythia.next() call. Main-Program and Related Settings Main-Program and Related Settings Stat:... denote actions that automatically may be taken during the Main-Program and Related Settings pythia.stat() call. Main-Program and Related Settings Main-Program and Related Settings Main:... denote actions that you yourself have the freedom to make use of in your main program. Main-Program and Related Settings Initialization settings Main-Program and Related Settings Event-generation settings Main-Program and Related Settings Statistics Main-Program and Related Settings Main-program settings The settings in this section Main-Program and Related Settings must be under the control of the user, i.e. there are no internal equivalents. The first one is especially important and would be a standard feature of any separate command file. Main-Program and Related Settings The Main-Program and Related Settings Main:... options works like this. Once you have used the Main-Program and Related Settings pythia.readFile(fileName) method to read in the cards file, where the values have been set, you can interrogate the Main-Program and Related Settings Settings database to make the values available in your main program. A slight complication is that you need to use a different Main-Program and Related Settings Settings method for each of the four possible return types that you want to extract. To save some typing the same method names are found directly in the Main-Program and Related Settings Pythia class, and these just send on to the Main-Program and Related Settings Settings ones to do the job, e.g. Main-Program and Related Settings Main-Program and Related Settings int nEvent = pythia.mode('Main:numberOfEvents'); Main-Program and Related Settings The area of subruns is covered separately below. A few spares are also defined after that, for unforeseen applications. Main-Program and Related Settings Subruns You can use Main-Program and Related Settings subruns to carry out several tasks in the same run. In that case you will need repeated instances of the first setting below in your command file, and could additionally use the second and third as well. Main-Program and Related Settings Spares For currently unforeseen purposes, a few dummy settings are made available here. The user can set the desired value in a 'cards file' and then use that value in the main program as desired."},{"name":"Master Switches","link":"MasterSwitches.html","text":"Master Switches Master Switches Master Switches Sometimes it may be convenient to omit certain aspects of the event generation chain. This cannot be motivated in a full-blown production run, but can often be convenient for own understanding and for debug purposes. The flags on this page allow just that. Master Switches The event generation is subdivided into three levels: the process level, the parton level and the hadron level, and flags are grouped accordingly. Master Switches Process Level The Master Switches ProcessLevel class administrates the initial step of the event generation, wherein the basic process is selected. Currently this is done either using some of the internal processes, or with Les Houches Accord input. Master Switches There could not be a complete event without an initial process, so it would not be a normal action to switch off this step. Furthermore, without a process set, it is also not possible to carry out the tasks on the parton level. It is still possible, however, to hadronize a parton-level configuration provided by some external program. Master Switches For Master Switches ProcessLevel:all = on one part of the event generation on this level may be switched off individually: Master Switches It is possible to stop the generation immediately after the basic process has been selected, see Master Switches PartonLevel:all below. Master Switches PartonLevel The Master Switches PartonLevel class administrates the middle step of the event generation, i.e. the evolution from an input (hard) process from Master Switches ProcessLevel , containing a few partons only, to a complete parton-level configuration to be handed on to Master Switches HadronLevel. This step involves the application of initial- and final-state radiation, multiparton interactions and the structure of beam remnants. Master Switches For Master Switches PartonLevel:all = on some parts of the event generation on this level may be switched off individually: Master Switches Switching off all the above MPI/ISR/FSR switches is Master Switches not equivalent to setting Master Switches PartonLevel:all = off. In the former case a minimal skeleton of parton-level operations are carried out, such as tying together the scattered partons with the beam remnants into colour singlets, and storing this information in the Master Switches event record. It is therefore possible to go on and hadronize the event, if desired. In the latter case Master Switches no operations at all are carried out on the parton level, and therefore it is also not possible to go on to the hadron level. Master Switches It is possible to stop the generation immediately after the parton level has been set up, see Master Switches HadronLevel:all below. Master Switches HadronLevel The Master Switches HadronLevel class administrates the final step of the event generation, wherein the partonic configuration from Master Switches PartonLevel is hadronized, including string fragmentation and secondary decays. Master Switches Most of the code in this class itself deals with subdividing the partonic content of the event into separate colour singlets, that can be treated individually by the string fragmentation machinery. When a junction and an antijunction are directly connected, it also breaks the string between the two, so that the topology can be reduced back to two separate one-junction systems, while still preserving the expected particle flow in the junction-junction string region(s). Master Switches For Master Switches HadronLevel:all = on some parts of the event generation on this level may be switched off individually: Master Switches Printing"},{"name":"Matching and Merging","link":"MatchingAndMerging.html","text":"Matching and Merging Matching and Merging Matching and Merging Starting from a Born-level leading-order (LO) process, higher orders can be included in various ways. The three basic approaches would be Matching and Merging Matching and Merging A formal order-by-order perturbative calculation, in each order higher including graphs both with one particle more in the final state and with one loop more in the intermediate state. This is accurate to the order of the calculation, but gives no hint of event structures beyond that, with more particles in the final state. Today next-to-leading order (NLO) is standard, while next-to-next-to-leading order (NNLO) is coming. This approach thus is limited to few orders, and also breaks down in soft and collinear regions, which makes it unsuitable for matching to hadronization. Matching and Merging Real emissions to several higher orders, but neglecting the virtual/loop corrections that should go with it at any given order. Thereby it is possible to allow for topologies with a large and varying number of partons, at the prize of not being accurate to any particular order. The approach also opens up for doublecounting, and as above breaks down in soft and colliner regions. Matching and Merging The parton shower provides an approximation to higher orders, both real and virtual contributions for the emission of arbitrarily many particles. As such it is less accurate than either of the two above, at least for topologies of well separated partons, but it contains a physically sensible behaviour in the soft and collinear limits, and therefore matches well onto the hadronization stage. Given the pros and cons, much of the effort in recent years has involved the development of different prescriptions to combine the methods above in various ways. Matching and Merging The common traits of all combination methods are that matrix elements are used to describe the production of hard and well separated particles, and parton showers for the production of soft or collinear particles. What differs between the various approaches that have been proposed are which matrix elements are being used, how doublecounting is avoided, and how the transition from the hard to the soft regime is handled. These combination methods are typically referred to as 'matching' or 'merging' algorithms. There is some confusion about the distinction between the two terms, and so we leave it to the inventor/implementor of a particular scheme to choose and motivate the name given to that scheme. Matching and Merging PYTHIA comes with methods, to be described next, that implement or support several different kind of algorithms. The field is open-ended, however: any external program can feed in Matching and Merging Les Houches events that PYTHIA subsequently showers, adds multiparton interactions to, and hadronizes. These events afterwards can be reweighted and combined in any desired way. The maximum Matching and Merging pT of the shower evolution is set by the Les Houches Matching and Merging scale , on the one hand, and by the values of the Matching and Merging SpaceShower:pTmaxMatch , Matching and Merging TimeShower:pTmaxMatch and other parton-shower settings, on the other. Typically it is not possible to achieve perfect matching this way, given that the PYTHIA Matching and Merging pT evolution variables are not likely to agree with the variables used for cuts in the external program. Often one can get close enough with simple means but, for an improved matching, Matching and Merging User Hooks can be inserted to control the steps taken on the way, e.g. to veto those parton shower branchings that would doublecount emissions included in the matrix elements. Matching and Merging Zooming in from the 'anything goes' perspective, the list of relevent approaches actively supported is as follows. Matching and Merging Matching and Merging For many/most resonance decays the first branching in the shower is merged with first-order matrix elements Matching and Merging Ben87, Nor01. This means that the emission rate is accurate to NLO, similarly to the POWHEG strategy (see below), but built into the Matching and Merging timelike showers. The angular orientation of the event after the first emission is only handled by the parton shower kinematics, however. Needless to say, this formalism is precisely what is tested by Matching and Merging Z^0 decays at LEP1, and it is known to do a pretty good job there. Matching and Merging Also the Matching and Merging spacelike showers contain a correction to first-order matrix elements, but only for the one-body-final-state processes Matching and Merging q qbar &rarr; gamma^*/Z^0/W^+-/h^0/H^0/A0/Z'0/W'+-/R0 Matching and Merging Miu99 and Matching and Merging g g &rarr; h^0/H^0/A0 , and only to leading order. That is, it is equivalent to the POWHEG formalism for the real emission, but the prefactor 'cross section normalization' is LO rather than NLO. Therefore this framework is less relevant, and has been superseded the following ones. Matching and Merging The POWHEG strategy Matching and Merging Nas04 provides a cross section accurate to NLO. The hardest emission is constructed with unit probability, based on the ratio of the real-emission matrix element to the Born-level cross section, and with a Sudakov factor derived from this ratio, i.e. the philosophy introduced in Matching and Merging Ben87. Matching and Merging While POWHEG is a generic strategy, the POWHEG BOX Matching and Merging Ali10 is an explicit framework, within which several processes are available. The code required for merging the PYTHIA showers with POWHEG input can be found in Matching and Merging include/Pythia8Plugins/PowHegHooks.h , and is further described on a Matching and Merging separate page. A user example is found in Matching and Merging examples/main31. Matching and Merging The other traditional approach for NLO calculations is the MC\@NLO one Matching and Merging Fri02. In it the shower emission probability, without its Sudakov factor, is subtracted from the real-emission matrix element to regularize divergences. It therefore requires a analytic knowledge of the way the shower populates phase space. The aMC\@NLO package Matching and Merging Fre11 offers an implementation for PYTHIA 8, developed by Paolo Torrielli and Stefano Frixione. The global-recoil option of the PYTHIA final-state shower has been constructed to be used for the above-mentioned subtraction. Matching and Merging Multi-jet merging in the CKKW-L approach Matching and Merging Lon01 is directly available. Its implementation, relevant parameters and test programs are documented on a Matching and Merging separate page. Matching and Merging Multi-jet matching in the MLM approach Matching and Merging Man02, Man07 is also available, either based on the ALPGEN or on the Madgraph variant, and with input events either from ALPGEN or from Madgraph. For details see Matching and Merging separate page. Matching and Merging Unitarised matrix element + parton shower merging (UMEPS) is directly available. Its implementation, relevant parameters and test programs are documented on a Matching and Merging separate page. Matching and Merging Next-to-leading order multi-jet merging (in the NL3 and UNLOPS approaches) is directly available. Its implementation, relevant parameters and test programs are documented on a Matching and Merging separate page. Matching and Merging Next-to-leading order jet matching in the FxFx approach is also available. For details see Matching and Merging separate page. Matching and Merging Matching and Merging Matching and Merging MC\@NLO, jet matching, multi-jet merging and NLO merging with main89.cc A common Pythia main program for MC\@NLO NLO+PS matching, MLM jet matching, FxFx (NLO) jet matching, CKKW-L merging, UMEPS merging and UNLOPS (NLO) merging is available through Matching and Merging main89.cc , together with the input files Matching and Merging main89mlm.cmnd , Matching and Merging main89fxfx.cmnd , Matching and Merging main89ckkwl.cmnd , Matching and Merging main89umeps.cmnd and Matching and Merging main89unlops.cmnd. The interface to MLM jet matching relies on MadGraph, while all other options of Matching and Merging main89.cc use aMC\@NLO input. Matching and Merging main89.cc produces HepMC events Matching and Merging Dob01 , that can be histogrammed (e.g. using RIVET Matching and Merging Buc10 ), or used as input for a detector simulation. If the user is not familiar with HepMC analysis tools, it is possible to instead use Pythia's histogramming routines. For this, remove the lines referring to HepMC, and histogram events as illustrated (for CKKW-L) for the histogram Matching and Merging histPTFirstSum in Matching and Merging main84.cc , i.e. using Matching and Merging weight*normhepmc as weight. Matching and Merging All settings can be transferred to Matching and Merging main89.cc through an input file. The input file is part of the command line input of Matching and Merging main89.cc , i.e. you can execute Matching and Merging main89 with the command Matching and Merging Matching and Merging ./main89 myInputFile.cmnd myhepmc.hepmc Matching and Merging to read the input Matching and Merging myInputFile.cmnd and produce the output file Matching and Merging myhepmc.hepmc. Since Matching and Merging main89.cc is currently a 'front-end' for different types of matching/merging, we will briefly discuss the inputs for this sample program in the following. Matching and Merging Inputs In its current form, Matching and Merging main89.cc uses LHEF input to transfer (weighted) phase space points to Pythia. It is possible to include all parton multiplicities in one LHEF sample. If e.g. UMEPS merging for W-boson + up to two additional partons is to be performed, one LHE file containing W+zero, W+one and W+two parton events is required. Matching and Merging All input settings are handed to Matching and Merging main89.cc in the form of an input file. We have included the input settings files Matching and Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; Matching and Merging main89mlm.cmnd , which illustrates the MLM jet matching interface, Matching and Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; Matching and Merging main89ckkwl.cmnd , which illustrates the CKKW-L multi-jet merging interface, Matching and Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; Matching and Merging main89umeps.cmnd , which illustrates the UMEPS multi-jet merging interface, and Matching and Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; Matching and Merging main89fxfx.cmnd , which illustrates the FxFx NLO jet matching interface, Matching and Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; Matching and Merging main89unlops.cmnd , which illustrates the UNLOPS multi-jet NLO merging interface. Matching and Merging Other settings (e.g. using Matching and Merging main89.cc as simple LO+PS or as MC\@NLO interface) are of course possible. In the following, we will briefly explain how input for the five choices above are generated and handled. Matching and Merging MLM jet matching with main89.cc For MLM jet matching, Matching and Merging main89.cc currently relies on LHEF input from MadGraph. Due to the particular unweighting strategy performed in the generation of these inputs, the sample program starts by estimating the cross section. After this estimate, MLM jet matching within the Madgraph approach is performed in a second Pythia run. Example MLM settings can be found in Matching and Merging main89mlm.cmnd. Please consult Matching and Merging Jet Matching for more details. Matching and Merging CKKW-L merging with main89.cc For CKKW-L merging, Matching and Merging main89.cc currently relies on LHEF inputs generated with the leading-order mode of aMC\@NLO (i.e. events should be generated with Matching and Merging ./bin/generate_events aMC\@LO ). No run to estimate the cross section estimate is needed. Example CKKW-L settings can be found in Matching and Merging main89ckkwl.cmnd. Please consult Matching and Merging CKKW-L merging for more details. Matching and Merging UMEPS merging with main89.cc For UMEPS merging, Matching and Merging main89.cc currently relies on LHEF inputs generated with the leading-order mode of aMC\@NLO as well (see above). Matching and Merging main89.cc automatically assigns if an event will be used as 'standard' event or as 'subtractive' contribution. Example UMEPS settings can be found in Matching and Merging main89umeps.cmnd. Please consult Matching and Merging UMEPS merging and Matching and Merging CKKW-L merging for more details. Matching and Merging FxFx (NLO) jet matching with main89.cc For FxFx jet matching, Matching and Merging main89.cc relies on MC\@NLO input LHE files generated with aMC\@NLO. To produce FxFx outputs in aMC\@NLO, the settings Matching and Merging PYTHIA8  = parton_shower , Matching and Merging 3 = ickkw and Matching and Merging x = ptj are necessary in your aMC\@NLO run card. Here, Matching and Merging x is the value of the matching scale in FxFx, i.e. has be identical to Matching and Merging JetMatching:qCutME in the Pythia inputs. Example FxFx settings for Pythia can be found in Matching and Merging main89fxfx.cmnd. Please consult Matching and Merging Jet Matching and Matching and Merging aMC\@NLO matching for more details. Matching and Merging UNLOPS (NLO) merging with main89.cc For UNLOPS merging, Matching and Merging main89.cc currently relies on LHEF inputs generated with the aMC\@NLO. The UNLOPS interface in Matching and Merging main89.cc requires a) leading-order inputs generated with the leading-order mode of aMC\@NLO, using the UNLOPS prescription, and b) next-to-leading-order inputs generated with the NLO mode of aMC\@NLO, using the UNLOPS prescription. To produce UNLOPS outputs in aMC\@NLO, the settings Matching and Merging PYTHIA8  = parton_shower , Matching and Merging 4 = ickkw and Matching and Merging x = ptj are necessary in your aMC\@NLO run card. Here, Matching and Merging x is the value of the merging scale in UNLOPS, i.e. has be identical to Matching and Merging Merging:TMS in the Pythia inputs. Matching and Merging main89.cc will then process NLO inputs and LO inputs consecutively, and will automatically assign if an event will be used as 'standard' event or as 'subtractive' contribution. Example UNLOPS settings can be found in Matching and Merging main89umeps.cmnd. Please consult Matching and Merging UMEPS merging and Matching and Merging CKKW-L merging for more details. Matching and Merging Matching and Merging Matching and Merging Matching and Merging Implementing an external ME+PS combination scheme and interfacing this plugin with Pythia For experts and developers of new matching/merging schemes, Pythia also offers the possibility to completely replace its internal merging machinery with a user-defined plugin code (much in the same way that parton shower plugins (cf. Matching and Merging Implement New Showers ) are possible). This allows for maximum flexibility while still benefiting from the full Pythia event generation machinery. Note that the ME+PS merging with the VINCIA and DIRE shower plugins make use of this flexibility, and might thus provide helpful clarifications.  Of course, implementing your own, new matching/merging scheme is a non-trivial task, and comprehensive guidelines on how to proceed are impossible to set. However, it is important that an external matching/merging plugin interfaces to Pythia in a simple and well-defined manner. Here, we will document which C++ functions are necessary to be able to use an external matching/merging (MM) plugin within Pythia. Matching and Merging To understand how to design a MM plugin for Pythia, it is useful to review how Pythia's internal merging machinery is structured. The interaction between the core Pythia and the merging code is governed by the Matching and Merging Merging and Matching and Merging MergingHooks classes. Note that for moderately complex requirements, it may be sufficient to only replace Pythia's instance of Matching and Merging MergingHooks with a pointer to an external class (cf. Matching and Merging CKKW-L merging ). The latter two classes are supplemented with the helper classes Matching and Merging History and Matching and Merging HardProcess. The latter gathers information on the (user-supplied information about the) hard core scattering process to which hard jets are added by ME+PS merging. It is only used as a helper to the Matching and Merging MergingHooks class. The Matching and Merging History class contains the implementation of all internal (LO or NLO) merging schemes. The Matching and Merging Merging class acts as a bridge between the implementation in the Matching and Merging History class and the rest of the Pythia code. Matching and Merging To implement an external MM plugin, you will have to write classes that derive from the Matching and Merging Merging , Matching and Merging MergingHooks and Matching and Merging HardProcess classes of Pythia. For special cases, it might also be permissible to only implement a replacement of the Matching and Merging Merging class, while still using Pythia's implementation of the other two classes.  The external MM plugin can then be transferred to and used by Pythia much in the same way as Matching and Merging UserHooks classes or shower plugins. More concretely, an external MM code will be used if a pointer to an instance of the external classes is transferred to Pythia via the methods Matching and Merging The option to only use a user-defined Matching and Merging MergingHooks instance is already documented in the item Matching and Merging CKKW-L merging and will not be discussed further. We will now focus on how to implement external Matching and Merging Merging , Matching and Merging MergingHooks and Matching and Merging HardProcess classes that can be used as a complete replacement of the Pythia methods.  Let us assume that you want to create a class of type Matching and Merging MyMerging , and you call its instance Matching and Merging myMerging. For this external ME+PS merging class to be interfaced to Pythia, the class needs to inherit from the Matching and Merging Pythia8::Merging base class. It is further necessary to define the following functions that serve as interface to Pythia: Matching and Merging For more details on how to design your Matching and Merging MyMerging class, and to understand the interface to Pythia, studying Pythia's internal code is unavoidable. Each potential developer of a MM plugin should do so. Matching and Merging The other main ingredient of the interface to MM plugins is a new implementation of the Matching and Merging MergingHooks class. Let us assume that you want to create a class of type Matching and Merging MyMergingHooks , and you call its instance Matching and Merging myMergingHooks. For this class to be interfaced to Pythia, it will need to inherit from the Matching and Merging Pythia8::MergingHooks base class. Matching and Merging The Matching and Merging MergingHooks base class allows for further virtual functions that are not directly called by Pythia, and are hence not necessary to define. Th usage of these functions within Pythia's Matching and Merging Merging and Matching and Merging History classes is documented in Matching and Merging CKKW-L merging. The additional (optional) virtual functions are: Matching and Merging The internal implementation of Matching and Merging MergingHooks in Pythia heavily relies on the Matching and Merging HardProcess helper class. It is in principle not necessary to follow the same strategy when implementing a derived Matching and Merging MyMergingHooks class. However, to benefit from the Pythia implementation, and to allow for a structure similar to the internal code also for an external MM plugin, it is also possible to effectively replace (in the Matching and Merging MergingHooks class) the pointer to an instance of Matching and Merging HardProcess with a pointer to an external implementation. Let us assume that you want to create a class of type Matching and Merging MyHardProcess , and you call its instance Matching and Merging myHardProcess. For this class to be interfaced to Matching and Merging MergingHooks (or the derived Matching and Merging MyMergingHooks class), it will need to inherit from the Matching and Merging Pythia8::HardProcess base class."},{"name":"Multiparton Interactions","link":"MultipartonInteractions.html","text":"Multiparton Interactions Multiparton Interactions Multiparton Interactions The starting point for the multiparton interactions physics scenario in PYTHIA is provided by Multiparton Interactions Sjo87. Recent developments have included a more careful study of flavour and colour correlations, junction topologies and the relationship to beam remnants Multiparton Interactions Sjo04 , interleaving with initial-state radiation Multiparton Interactions Sjo05 , making use of transverse-momentum-ordered initial- and final-state showers, with the extension to fully interleaved evolution covered in Multiparton Interactions Cor10a. A framework to handle rescattering is described in Multiparton Interactions Cor09. Multiparton Interactions A big unsolved issue is how the colour of all these subsystems is correlated. For sure there is a correlation coming from the colour singlet nature of the incoming beams, but in addition final-state colour rearrangements may change the picture. Indeed such extra effects appear necessary to describe data, e.g. on Multiparton Interactions <pT>(n_ch). A simple implementation of colour rearrangement is found as part of the Multiparton Interactions beam remnants description. Multiparton Interactions Main variables Multiparton Interactions Matching to hard process The maximum Multiparton Interactions pT to be allowed for multiparton interactions is related to the nature of the hard process itself. It involves a delicate balance between not double-counting and not leaving any gaps in the coverage. The best procedure may depend on information only the user has: how the events were generated and mixed (e.g. with Les Houches Accord external input), and how they are intended to be used. Therefore a few options are available, with a sensible default behaviour. Multiparton Interactions Cross-section parameters The rate of interactions is determined by Multiparton Interactions The actual value is then regulated by the running to the scale Multiparton Interactions pT^2 , at which it is evaluated Multiparton Interactions QED interactions are regulated by the Multiparton Interactions alpha_electromagnetic value at the Multiparton Interactions pT^2 scale of an interaction. Multiparton Interactions Note that the choices of Multiparton Interactions alpha_strong and Multiparton Interactions alpha_em made here override the ones implemented in the normal process machinery, but only for the interactions generated by the Multiparton Interactions MultipartonInteractions class. Multiparton Interactions In addition there is the possibility of a global rescaling of cross sections (which could not easily be accommodated by a changed Multiparton Interactions alpha_strong , since Multiparton Interactions alpha_strong runs) Multiparton Interactions The processes used to generate multiparton interactions form a subset of the standard library of hard processes. The input is slightly different from the standard hard-process machinery, however, since incoming flavours, the Multiparton Interactions alpha_strong value and most of the kinematics are already fixed when the process is called. It is possible to regulate the set of processes that are included in the multiparton-interactions framework. Multiparton Interactions Cross-section regularization There are two complementary ways of regularizing the small- Multiparton Interactions pT divergence, a sharp cutoff and a smooth dampening. These can be combined as desired, but it makes sense to coordinate with how the same issue is handled in Multiparton Interactions spacelike showers. Actually, by default, the parameters defined here are used also for the spacelike showers, but this can be overridden. Multiparton Interactions Regularization of the divergence of the QCD cross section for Multiparton Interactions pT &rarr; 0 is obtained by a factor Multiparton Interactions pT^4 / (pT0^2 + pT^2)^2 , and by using an Multiparton Interactions alpha_s(pT0^2 + pT^2). An energy dependence of the Multiparton Interactions pT0 choice is introduced by two further parameters, so that Multiparton Interactions pT0Ref is the Multiparton Interactions pT0 value for the reference CM energy, Multiparton Interactions pT0Ref = pT0(ecmRef). Multiparton Interactions Warning: if a large Multiparton Interactions pT0 is picked for multiparton interactions, such that the integrated interaction cross section is below the nondiffractive inelastic one, this Multiparton Interactions pT0 will automatically be scaled down to cope. Multiparton Interactions The actual Multiparton Interactions pT0 parameter used at a given CM energy scale, Multiparton Interactions ecmNow , is obtained from a power law or a logarithmic parametrization. The former is default with hadron beams and the latter for photon-photon collisions. Multiparton Interactions Alternatively, or in combination, a sharp cut can be used. Multiparton Interactions G&ouml;sta Gustafson has proposed (private communication, unpublished) that the amount of screening, as encapsulated in the Multiparton Interactions pT0 parameter, fluctuates from one event to the next. Specifically, high-activity event are more likely to lead to interactions at large Multiparton Interactions pT scales, but the high activity simultaneously leads to a larger screening of interactions at smaller Multiparton Interactions pT. Such a scenario can approximately be simulated by scaling up the Multiparton Interactions pT0 by a factor Multiparton Interactions sqrt(n) , where Multiparton Interactions n is the number of interactions considered so far, including the current one. That is, for the first interaction the dampening factor is Multiparton Interactions pT^4 / (pT0^2 + pT^2)^2 , for the second Multiparton Interactions pT^4 / (2 pT0^2 + pT^2)^2 , for the third Multiparton Interactions pT^4 / (3 pT0^2 + pT^2)^2 , and so on. Optionally the scheme may also be applied to ISR emissions. For simplicity the same Multiparton Interactions alpha_s(pT0^2 + pT^2) is used throughout. Note that, in this scenario the Multiparton Interactions pT0 scale must be lower than in the normal case to begin with, since it later is increased back up. Also note that the idea with this scenario is to propose an alternative to colour reconnection to understand the rise of Multiparton Interactions <pT>(n_ch) , so that the amount of colour reconnection should be reduced. Multiparton Interactions Impact-parameter dependence The choice of impact-parameter dependence is regulated by several parameters. The ones listed here refer to nondiffractive topologies only, while their equivalents for diffractive events are put in the Multiparton Interactions Diffraction description. Note that there is currently no Multiparton Interactions bProfile = 4 option for diffraction. Other parameters are assumed to agree between diffractive and nondiffractive topologies. Multiparton Interactions Rescattering It is possible that a parton may rescatter, i.e. undergo a further interaction subsequent to the first one. The machinery to model this kind of physics has only recently become fully operational Multiparton Interactions Cor09 , and is therefore not yet so well explored. Multiparton Interactions The rescattering framework has ties with other parts of the program, notably with the Multiparton Interactions beam remnants. Multiparton Interactions Further variables These should normally not be touched. Their only function is for cross-checks. Multiparton Interactions Technical notes Relative to the articles mentioned above, not much has happened. The main news is a technical one, that the phase space of the Multiparton Interactions 2 &rarr; 2 (massless) QCD processes is now sampled in Multiparton Interactions dy_3 dy_4 dpT^2 , where Multiparton Interactions y_3 and Multiparton Interactions y_4 are the rapidities of the two produced partons. One can show that Multiparton Interactions (dx_1 / x_1) * (dx_2 / x_2) * d(tHat) = dy_3 * dy_4 * dpT^2 Furthermore, since cross sections are dominated by the 'Rutherford' one of Multiparton Interactions t -channel gluon exchange, which is enhanced by a factor of 9/4 for each incoming gluon, effective structure functions are defined as Multiparton Interactions F(x, pT2) = (9/4) * xg(x, pT2) + sum_i xq_i(x, pT2) With this technical shift of factors 9/4 from cross sections to parton densities, a common upper estimate of Multiparton Interactions d(sigmaHat)/d(pT2) < pi * alpha_strong^2 / pT^4 is obtained. Multiparton Interactions In fact this estimate can be reduced by a factor of 1/2 for the following reason: for any configuration Multiparton Interactions (y_3, y_4, pT2) also one with Multiparton Interactions (y_4, y_3, pT2) lies in the phase space. Not both of those can enjoy being enhanced by the Multiparton Interactions tHat &rarr; 0 singularity of Multiparton Interactions d(sigmaHat) propto 1/tHat^2. Or if they are, which is possible with identical partons like Multiparton Interactions q q &rarr; q q and Multiparton Interactions g g &rarr; g g , each singularity comes with half the strength. So, when integrating/averaging over the two configurations, the estimated Multiparton Interactions d(sigmaHat)/d(pT2) drops. Actually, it drops even further, since the naive estimate above is based on Multiparton Interactions (4 /9) * (1 + (uHat/sHat)^2) < 8/9 < 1 The 8/9 value would be approached for Multiparton Interactions tHat &rarr; 0 , which implies Multiparton Interactions sHat >> pT2 and thus a heavy parton-distribution penalty, while parton distributions are largest for Multiparton Interactions tHat = uHat = -sHat/2 , where the above expression evaluates to 5/9. A fudge factor is therefore introduced to go the final step, so it can easily be modified when further non-Rutherford processes are added, or should parton distributions change significantly. Multiparton Interactions At initialization, it is assumed that Multiparton Interactions d(sigma)/d(pT2) < d(sigmaHat)/d(pT2) * F(x_T, pT2) * F(x_T, pT2)      * (2 y_max(pT))^2 where the first factor is the upper estimate as above, the second two the parton density sum evaluated at Multiparton Interactions y_3 = y_ 4 = 0 so that Multiparton Interactions x_1 = x_2 = x_T = 2 pT / E_cm , where the product is expected to be maximal, and the final is the phase space for Multiparton Interactions -y_max < y_{3,4} < y_max. The right-hand side expression is scanned logarithmically in Multiparton Interactions y , and a Multiparton Interactions N is determined such that it always is below Multiparton Interactions N/pT^4. Multiparton Interactions To describe the dampening of the cross section at Multiparton Interactions pT &rarr; 0 by colour screening, the actual cross section is multiplied by a regularization factor Multiparton Interactions (pT^2 / (pT^2 + pT0^2))^2 , and the Multiparton Interactions alpha_s is evaluated at a scale Multiparton Interactions pT^2 + pT0^2 , where Multiparton Interactions pT0 is a free parameter of the order of 2 - 4 GeV. Since Multiparton Interactions pT0 can be energy-dependent,  an ansatz Multiparton Interactions pT0(ecm) = pT0Ref * (ecm/ecmRef)^ecmPow is used, where Multiparton Interactions ecm is the current CM frame energy, Multiparton Interactions ecmRef is an arbitrary reference energy where Multiparton Interactions pT0Ref is defined, and Multiparton Interactions ecmPow gives the energy rescaling pace. For technical reasons, also an absolute lower Multiparton Interactions pT scale Multiparton Interactions pTmin , by default 0.2 GeV, is introduced. In principle, it is possible to recover older scenarios with a sharp Multiparton Interactions pT cutoff by setting Multiparton Interactions pT0 = 0 and letting Multiparton Interactions pTmin be a larger number. Multiparton Interactions The above scanning strategy is then slightly modified: instead of an upper estimate Multiparton Interactions N/pT^4 one of the form Multiparton Interactions N/(pT^2 + r * pT0^2)^2 is used. At first glance, Multiparton Interactions r = 1 would seem to be fixed by the form of the regularization procedure, but this does not take into account the nontrivial dependence on Multiparton Interactions alpha_s , parton distributions and phase space. A better Monte Carlo efficiency is obtained for Multiparton Interactions r somewhat below unity, and currently Multiparton Interactions r = 0.25 is hardcoded.  In the generation a trial Multiparton Interactions pT2 is then selected according to Multiparton Interactions d(Prob)/d(pT2) = (1/sigma_ND) * N/(pT^2 + r * pT0^2)^2 * ('Sudakov') For the trial Multiparton Interactions pT2 , a Multiparton Interactions y_3 and a Multiparton Interactions y_4 are then selected, and incoming flavours according to the respective Multiparton Interactions F(x_i, pT2) , and then the cross section is evaluated for this flavour combination. The ratio of trial/upper estimate gives the probability of survival. Multiparton Interactions Actually, to profit from the factor 1/2 mentioned above, the cross section for the combination with Multiparton Interactions y_3 and Multiparton Interactions y_4 interchanged is also tried, which corresponds to exchanging Multiparton Interactions tHat and Multiparton Interactions uHat , and the average formed, while the final kinematics is given by the relative importance of the two. Multiparton Interactions Furthermore, since large Multiparton Interactions y values are disfavoured by dropping PDF's, a factor Multiparton Interactions WT_y = (1 - (y_3/y_max)^2) * (1 - (y_4/y_max)^2) is evaluated, and used as a survival probability before the more time-consuming PDF+ME evaluation, with surviving events given a compensating weight Multiparton Interactions 1/WT_y. Multiparton Interactions An impact-parameter dependence is also allowed. Based on the hard Multiparton Interactions pT scale of the first interaction, and enhancement/depletion factor is picked, which multiplies the rate of subsequent interactions. Multiparton Interactions Parton densities are rescaled and modified to take into account the energy-momentum and flavours kicked out by already-considered interactions."},{"name":"New-Gauge-Boson Processes","link":"NewGaugeBosonProcesses.html","text":"New-Gauge-Boson Processes New-Gauge-Boson Processes New-Gauge-Boson Processes This page contains the production of new New-Gauge-Boson Processes Z'^0 and New-Gauge-Boson Processes W'^+- gauge bosons, e.g. within the context of a new New-Gauge-Boson Processes U(1) or New-Gauge-Boson Processes SU(2) gauge group, and also a (rather speculative) horizontal gauge boson New-Gauge-Boson Processes R^0. Left-right-symmetry scenarios also contain new gauge bosons, but are described New-Gauge-Boson Processes separately. New-Gauge-Boson Processes New-Gauge-Boson Processes Z'^0 This group only contains one subprocess, with the full New-Gauge-Boson Processes gamma^*/Z^0/Z'^0 interference structure for couplings to fermion pairs. It is possible to pick only a subset, e.g, only the pure New-Gauge-Boson Processes Z'^0 piece. No higher-order processes are available explicitly, but the ISR showers contain automatic matching to the New-Gauge-Boson Processes Z'^0 + 1 jet matrix elements, as for the corresponding &nbsp New-Gauge-Boson Processes gamma^*/Z^0 process. New-Gauge-Boson Processes The couplings of the New-Gauge-Boson Processes Z'^0 to quarks and leptons can either be assumed universal, i.e. generation-independent, or not. In the former case eight numbers parametrize the vector and axial couplings of down-type quarks, up-type quarks, leptons and neutrinos, respectively. Depending on your assumed neutrino nature you may want to restrict your freedom in that sector, but no limitations are enforced by the program. The default corresponds to the same couplings as that of the Standard Model New-Gauge-Boson Processes Z^0 , with axial couplings New-Gauge-Boson Processes a_f = +-1 and vector couplings New-Gauge-Boson Processes v_f = a_f - 4 e_f sin^2(theta_W) , with New-Gauge-Boson Processes sin^2(theta_W) = 0.23. Without universality the same eight numbers have to be set separately also for the second and the third generation. The choice of fixed axial and vector couplings implies a resonance width that increases linearly with the New-Gauge-Boson Processes Z'^0 mass. New-Gauge-Boson Processes By a suitable choice of the parameters, it is possible to simulate just about any imaginable New-Gauge-Boson Processes Z'^0 scenario, with full interference effects in cross sections and decay angular distributions and generation-dependent couplings; the default values should mainly be viewed as placeholders. The conversion from the coupling conventions in a set of different New-Gauge-Boson Processes Z'^0 models in the literature to those used in PYTHIA is described in New-Gauge-Boson Processes Cio08. New-Gauge-Boson Processes Here are the couplings always valid for the first generation, and normally also for the second and third by trivial analogy: New-Gauge-Boson Processes Here are the further couplings that are specific for a scenario with New-Gauge-Boson Processes Zprime:universality switched off: New-Gauge-Boson Processes The coupling to the decay channel New-Gauge-Boson Processes Z'^0 &rarr; W^+ W^- is more model-dependent. By default it is therefore off, but can be switched on as follows. New-Gauge-Boson Processes A massive New-Gauge-Boson Processes Z'^0 is also likely to decay into Higgs bosons and potentially into other now unknown particles. Such possibilities clearly are quite model-dependent, and have not been included for now. New-Gauge-Boson Processes Finally, to allow the exploration of more BSM physics scenarios, we include the possibility of the New-Gauge-Boson Processes Z'^0 (and hence the New-Gauge-Boson Processes gamma and New-Gauge-Boson Processes Z^0 ) coupling to a fourth generation of fermions. This provides redundancy with and extensions beyond those processes implemented as New-Gauge-Boson Processes fourth-generation processes. By default, the decay channels for the fourth-generation and not included. They are enabled using: New-Gauge-Boson Processes Here are the further couplings that are specific for a scenario with New-Gauge-Boson Processes Zprime:universality switched off: New-Gauge-Boson Processes New-Gauge-Boson Processes W'^+- The New-Gauge-Boson Processes W'^+- implementation is less ambitious than the New-Gauge-Boson Processes Z'^0. Specifically, while indirect detection of a New-Gauge-Boson Processes Z'^0 through its interference contribution is a possible discovery channel in lepton colliders, there is no equally compelling case for New-Gauge-Boson Processes W^+-/W'^+- interference effects being of importance for discovery, and such interference has therefore not been implemented for now. Related to this, a New-Gauge-Boson Processes Z'^0 could appear on its own in a new New-Gauge-Boson Processes U(1) group, while New-Gauge-Boson Processes W'^+- would have to sit in a New-Gauge-Boson Processes SU(2) group and thus have a New-Gauge-Boson Processes Z'^0 partner that is likely to be found first. Only one process is implemented but, like for the New-Gauge-Boson Processes W^+- , the ISR showers contain automatic matching to the New-Gauge-Boson Processes W'^+- + 1 jet matrix elements. New-Gauge-Boson Processes The couplings of the New-Gauge-Boson Processes W'^+- are here assumed universal, i.e. the same for all generations. One may set vector and axial couplings freely, separately for the New-Gauge-Boson Processes q qbar' and the New-Gauge-Boson Processes l nu_l decay channels. The defaults correspond to the New-Gauge-Boson Processes V - A structure and normalization of the Standard Model New-Gauge-Boson Processes W^+- , but can be changed to simulate a wide selection of models. One limitation is that, for simplicity, the same Cabibbo--Kobayashi--Maskawa quark mixing matrix is assumed as for the standard New-Gauge-Boson Processes W^+-. Depending on your assumed neutrino nature you may want to restrict your freedom in the lepton sector, but no limitations are enforced by the program. New-Gauge-Boson Processes The coupling to the decay channel New-Gauge-Boson Processes W'^+- &rarr; W^+- Z^0 is more model-dependent, like for New-Gauge-Boson Processes Z'^0 &rarr; W^+ W^- described above. By default it is therefore off, but can be switched on as follows. Furthermore, we have left some amount of freedom in the choice of decay angular correlations in this channel, but obviously alternative shapes could be imagined. New-Gauge-Boson Processes A massive New-Gauge-Boson Processes W'^+- is also likely to decay into Higgs bosons and potentially into other now unknown particles. Such possibilities clearly are quite model-dependent, and have not been included for now. New-Gauge-Boson Processes New-Gauge-Boson Processes R^0 The New-Gauge-Boson Processes R^0 boson (particle code 41) represents one possible scenario for a horizontal gauge boson, i.e. a gauge boson that couples between the generations, inducing processes like New-Gauge-Boson Processes s dbar &rarr; R^0 &rarr; mu^- e^+. Experimental limits on flavour-changing neutral currents forces such a boson to be fairly heavy. In spite of being neutral the antiparticle is distinct from the particle: one carries a net positive generation number and the other a negative one. This particular model has no new parameters beyond the New-Gauge-Boson Processes R^0 mass. Decays are assumed isotropic. For further details see New-Gauge-Boson Processes Ben85."},{"name":"NLO Merging","link":"NLOMerging.html","text":"NLO Merging NLO Merging NLO Merging Pythia offers two NLO merging approaches. Both of these methods have been presented in NLO Merging Lon13. The goal of NLO merging is to extend tree-level multi-jet merging methods to next-to-leading order accuracy in QCD, for every available jet multiplicity. If for example NLO calculations for Higgs + 0 jet, Higgs + 1 jet and Higgs + 2 jets were available, NLO merging allows to simultaneously describe 0-, 1- and 2-jet observables with NLO accuracy. Further jets can, depending on additional tree-level input, be described by additional tree-level matrix elements. In the example, it would be possible to achieve NLO accuracy for 0-, 1- and 2-jet observables, tree-level accuracy for 3-, 4- and 5-jet configurations, and use the parton shower approximation for events with more than five jets. NLO Merging The two NLO merging methods implemented in Pythia are called NL NLO Merging 3 (for Nils Lavesson + Leif L&ouml;nnblad) and UNLOPS (for unitarised NLO+PS merging). Both of these schemes require Les Houches Event File input that is generated by tree-level or NLO matrix element generators. Currently, Pythia requires NLO input generated within the POWHEG framework. The generation of sensible input will be discussed below. The two NLO merging methods are illustrated in the sample main programs NLO Merging main87.cc (introducing NL NLO Merging 3 ) and NLO Merging main88.cc (introducing UNLOPS). Before describing these programs, we would like to outline the differences between the two approaches. NLO Merging NL NLO Merging 3 is a generalisation of NLO Merging CKKW-L tree-level merging. The main idea of NL NLO Merging 3 is to start from CKKW-L-reweighted multi-jet merging, and replace the NLO Merging &alpha; NLO Merging s NLO Merging n+0 - and NLO Merging &alpha; NLO Merging s NLO Merging n+1 -terms by the NLO result of POWHEG. This 'replacement' means that we subtract the NLO Merging &alpha; NLO Merging s NLO Merging n+0 - and NLO Merging &alpha; NLO Merging s NLO Merging n+1 -terms from the CKKW-L-reweighted tree-level samples, and add another sample -- the POWHEG input. All 'higher orders' are unchanged w.r.t. CKKW-L. We have implemented the 'inclusive' scheme of NLO Merging Lon13 in Pythia. This means that the POWHEG input will contain contributions for hard, resolved real emission jets, which are already taken care of by higher-multiplicity samples in CKKW-L. Thus, explicit phase space subtractions are also included. The sample program NLO Merging main87.cc , together with the input file NLO Merging main87.cmnd , illustrates the procedure. NLO Merging UNLOPS is a generalisation of the NLO Merging UMEPS multi-jet merging scheme. Since UMEPS is already slightly more complicated than CKKW-L, this makes UNLOPS more complicated than NL NLO Merging 3. The basic idea however remains the same: Start from a tree-level merging scheme (in this case UMEPS), remove all undesirable NLO Merging &alpha; NLO Merging s NLO Merging n+0 - and NLO Merging &alpha; NLO Merging s NLO Merging n+1 -terms from this result, and add back the 'correct' description via POWHEG input samples. Again, since the 'inclusive' scheme of NLO Merging Lon13 was implemented in Pythia, it is necessary to handle explicit phase space subtractions. Similar to UMEPS, UNLOPS further ensures that the lowest-multiplicity cross section is given by the NLO result. This means that the UMEPS philosophy of 'subtract what you add' needs to be extended to multi-leg NLO inputs. NLO Merging UNLOPS is a theoretically more appealing definition of NLO merging than NL NLO Merging 3 , and should thus be considered the preferred choice. However, we believe it valuable to include both methods into Pythia, so that the variation of NLO merged results due to different NLO merging schemes can be studied in situ. Furthermore, NLO merging can be outlined more pedagogically when starting from NL NLO Merging 3. The two NLO merging methods share parts of code with CKKW-L and UMEPS, and correspondingly share many input settings with these schemes. In particular, NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( NLO Merging Merging:Process ) needs to be defined exactly as in CKKW-L (see NLO Merging Defining the hard process in the NLO Merging CKKW-L documentation ). NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( NLO Merging Merging:TMS ) has to be set. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons in tree-level events ( NLO Merging Merging:nJetMax ) has to be set. NLO Merging All settings listed under the sections ' NLO Merging Matrix element merging and HepMC output for RIVET ' and ' NLO Merging Further variables ' in  the NLO Merging CKKW-L documentation can be accessed in NLO merging as well. Furthermore, the NLO Merging Merging:nRecluster switch (see the NLO Merging UMEPS documentation ) is important.  Also, all NLO Merging MergingHooks routines that allow for user interference in CKKW-L merging are also usable for NLO merging -- with the exception of a user-defined merging scale. The NLO merging schemes currently implemented in Pythia do not allow for a merging scale definition that differs from the parton shower evolution variable. Since this merging scale definition is not completely obvious, the NLO merging schemes also share the NLO Merging Merging:enforceCutOnLHE switch with CKKW-L. In this way, it is possible to use LHE files that are regularised only with weak cuts as input, while the merging machinery imposes the stronger merging scale cut automatically. This means that no merging scale implementation is required from the user side, but also means that it is the user's responsibility to ensure that the cuts used for generating input LHE files are always looser than the cut given by the merging scale value NLO Merging Merging:TMS. This will lead to warnings of the form ' NLO Merging Les Houches Event fails merging scale cut. Cut by rejecting event '. These warning should rather be regarded as information. An example of inclusive matrix element generation cuts would be NLO Merging pT NLO Merging jet = 5 GeV , NLO Merging &Delta;R NLO Merging jetA jetB = 0.01 and NLO Merging Q NLO Merging jetA jetB = 5 GeV , if NLO merging with a desired merging scale value of NLO Merging Merging:TMS = 15 is attempted for Higgs + jets events at the LHC. NLO Merging In the following, we will first describe the generation of NLO input samples, and list input settings for NLO merging in Pythia. Then, we will examine the sample main programs NLO Merging main87.cc and NLO Merging main88.cc , which implement NL NLO Merging 3 and UNLOPS merging, respectively. NLO Merging NLO Merging NLO Merging NLO Merging Inputs for NLO merging The NLO merging schemes in Pythia currently require Les Houches Event File input. To perform a merging with up to NLO Merging M additional partons described by tree-level matrix elements, and with up to NLO Merging N &le; M-1 additional partons at NLO accuracy, the user needs to supply NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; LHE files for NLO Merging 0... M additional partons, taken from a tree-level matrix element generator, and NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; LHE files for NLO Merging 0... N additional partons, taken from a POWHEG NLO generator. NLO Merging All input files need to be regularised, if they contain additional partons. Large files with fairly inclusive (i.e. loose) cuts are recommended. The input LHE files should further be generated with fixed renormalisation and factorisation scales. (In the POWHEG-BOX program, this means using the settings NLO Merging runningscales 0, btlscalereal 1, btlscalect 1, ckkwscalup 0. Some older processes in the POWHEG-BOX program need the input NLO Merging runningscale 0 instead of NLO Merging runningscales 0 .) NLO Merging When attempting NLO merging, the following Pythia settings are relevant. NLO Merging All further settings will be discussed while examining the sample main programs. NLO Merging NLO Merging NLO Merging NLO Merging NL NLO Merging 3 merging with main87.cc NL NLO Merging 3 -style NLO merging in Pythia is illustrated by the sample main program NLO Merging main87.cc. This program works together with an input file (e.g. NLO Merging main87.cmnd ) for Pythia settings, and requires LHE input files that follow the naming convention NLO Merging name_tree_#nAdditionalJets.lhe (tree-level samples) and NLO Merging name_powheg_#nAdditionalJets.lhe (POWHEG NLO samples). NLO Merging main87.cc produces HepMC event output NLO Merging Dob01 , which can be used for analysis (e.g. using RIVET NLO Merging Buc10 ), or as input for detector simulations. For users not familiar with HepMC output, it is of course possible remove the HepMC code in the sample program, and use Pythia's histogramming routines instead. Histograms should then be filled as indicated for the NLO Merging histPTFirstSum histograms in NLO Merging main84.cc , i.e. using NLO Merging weightNLO*normhepmc. NLO Merging If the user only wants to change the number of requested events ( NLO Merging Main:numberOfEvents ), the hard process ( NLO Merging Merging:Process ), the merging scale value ( NLO Merging Merging:TMS ) and the maximal number of additional tree-level or NLO-accuracte jets ( NLO Merging Merging:nJetMax and NLO Merging Merging:nJetMaxNLO , respectively), and HepMC output is desired, then there is no need to change the NLO Merging main87.cc code. The input LHE files are also part of the (command line) input for NLO Merging main87.exe. The default settings in NLO Merging main87.cmnd are intended to work with the (very short) sample LHEF inputs ( NLO Merging w_production_tree_0.lhe , NLO Merging w_production_tree_1.lhe , NLO Merging w_production_tree_2.lhe and NLO Merging w_production_powheg_0.lhe , NLO Merging w_production_powheg_1.lhe ). For these input files, the NLO Merging main87.exe executable can be run with the command NLO Merging NLO Merging ./main87.exe main87.cmnd w_production myhepmc.hepmc NLO Merging to produce a file myhepmc.hepmc of NLO merged HepMC event output. All mandatory Pythia input settngs have been outlined earlier. Please refrain from adding input switches than invoke any other merging scheme (e.g. e.g. NLO Merging Merging:doKTMerging ) into the input file that you want to use in conjunction with NLO Merging main87.cc. NLO Merging In the following, we will explain NLO Merging main87.cc in depth. Users who are willing to accept the default choices do not need to know all details, but are still encouraged to read further. NLO Merging Program flow NLO Merging main87.cc can be divided into four steps: NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 1. Estimate the cross section for tree-level and NLO samples NLO Merging after the merging scale cut. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2. Produce reweighted tree-level    events, which do not contain NLO Merging &alpha; NLO Merging s NLO Merging 0 -    and NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3. Add POWHEG NLO events. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 4. Subtract phase space points with an    extra (real-emission) jet above the merging scale from the POWHEG result,    since such configurations have already been taken into account by    processing other samples. NLO Merging The first step is necessary to produce the correct weights for HepMC output events. The estimation of tree-level cross sections after the merging scale cut is generated by invoking the switch NLO Merging Merging:doXSectionEstimate together with NLO Merging Merging:doNL3Tree. In this configuration, the latter switch will only act to define the merging scale.  After the tree-level cross sections have been estimated, NLO Merging main87.cc estimates the NLO cross sections after application of the merging scale cut, by inferring NLO Merging Merging:doXSectionEstimate together with NLO Merging Merging:doNL3Loop. Again, in this configuration, the latter switch only acts as the merging scale definition. When generating the estimates, all showering, multiparton interactions and hadronisation is turned off to not unnecessarily waste processor time. For all estimates, is further NLO Merging mandatory to set the value of NLO Merging Merging:nRequested to the jet multiplicity of the current event sample (e.g. to '2' for a sample containing W + 2 jet events). This is necessary in order to correctly apply the merging scale cut. POWHEG NLO input files for W + 1 jet e.g. contain W + 1 jet and W + 2 jet (i.e. real emission) kinematics. However, the merging scale cut aims at regularising the 'underlying Born' configuration (i.e. the W + 1 states in our example). Setting NLO Merging Merging:nRequested = 1 for the  W + 1 jet POWHEG sample ensures that even for real-emission (W + 2 jet) kinematics, the merging scale cut is applied to W + 1 jet states. NLO Merging After the cross section estimation step, NLO Merging main87.cc proceeds to perform the actual merging. Before explaining this part, we would like to make some comments about K-factors. NLO Merging NLO Merging main87.cc is prepared to use fixed K-factors to rescale the weight of tree-level events. This rescaling does not affect the NLO accuracy of the method, and was investigated in NLO Merging Lon13. By default, NLO Merging main87.cc does not use K-factors. However, if the user wants to include K-factors, this can be done by using the following input settings. NLO Merging If the variables NLO Merging k0, k1, k2 in NLO Merging main87.cc are set to non-unity values, K-factors will be applied. The K-factor of highest jet multiplicity will then be used to also rescale tree-level samples with a number of additional jets beyond the number of the highest-multiplicity real-emission sample. If we, for example, attempt an NLO merging of NLO Merging W+0 jet and NLO Merging W+1 jet at NLO accuracy, and with NLO Merging W+&le;4 jets at tree-level accuracy, then NLO Merging Merging:kFactor2j is used to rescale the NLO Merging W+2 jet , NLO Merging W+3 jets and NLO Merging W+4 jets tree-level samples. We recommend to not include a K-factor rescaling of the tree-level samples. NLO Merging Let us turn to the production of NLO merged events. The first step in the procedure is to generate reweighted tree-level samples. This is implemented by using the following switch. NLO Merging The weight of tree-level events can be accessed by calling the function NLO Merging double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, should be used as event weight (or weight of histogram bins). For NLO Merging Merging:doNL3Tree = on , the weight NLO Merging double Info::mergingWeightNLO() contains the CKKW-L weight, subtracted, if necessary, by NLO Merging &alpha; NLO Merging s NLO Merging 0 - and NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms. This weight can become negative. As an example, imagine we attempt an NLO merging of W + 0 jet and W + 1 jet at NLO accuracy, and with  W + 2 jets at tree-level accuracy. This weight will then be NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = CKKW-L-weight for zero jets  - NLO Merging &alpha; NLO Merging s NLO Merging 0 -terms  - NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms for events in the zero-jet sample, NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = CKKW-L-weight for one jet  - NLO Merging &alpha; NLO Merging s NLO Merging 0 -terms  - NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms for events in the one-jet sample, and NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = CKKW-L-weight for two jets for events in the two-jet sample. NLO Merging After the tree-level events have been reweighted, NLO Merging main87.cc will move on to process the POWHEG NLO input. This is done by switching to the following flag. NLO Merging Also in this case, the NLO merging weight of the events can be accessed by calling the function NLO Merging double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For NLO Merging Merging:doNL3Loop = on , the weight NLO Merging double Info::mergingWeightNLO() is either one or zero (see Appendix E in NLO Merging Lon13 ).  After the processing of POWHEG NLO events, NLO Merging main87.cc continues by generating explicit phase space subtractions. This is facilitated by the following switch. NLO Merging These contributions are necessary because we have implemented the 'inclusive scheme' of NLO Merging Lon13 in Pythia. The benefit of this scheme is the user does not have to intrusively change the POWHEG-BOX program to implement very particular cuts. Let us explain this comment with an example (a more detailed explanation of the idea is given in Appendix A.2 of NLO Merging Lon13 ). When generating W + 0 jet events with the POWHEG-BOX program, the output LHE files will contain W  + 1 jet real emission events. Some of these events will contain a jet above the merging scale. However, in NLO merging methods, such configurations have already been included by a separate W + 1 jet sample. Thus, to avoid counting such events twice, we have to remove the configurations from the POWHEG-BOX output. We choose to remove such events by explicit subtraction. NLO Merging As always, the NLO merging weight of the events can be accessed by calling the function NLO Merging double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For NLO Merging Merging:doNL3Subt = on , the weight NLO Merging double Info::mergingWeightNLO() is either one or zero (see Appendix E in NLO Merging Lon13 ). NLO Merging After these steps, all necessary events for NL NLO Merging 3 merging have been produced. NLO Merging main87.cc finishes by returning the NL NLO Merging 3 -merged total cross section. NLO Merging NLO Merging NLO Merging NLO Merging UNLOPS merging with main88.cc UNLOPS-style NLO merging in Pythia is illustrated by the sample main program NLO Merging main88.cc , which relies on an input file (e.g. NLO Merging main88.cmnd ) for Pythia settings. As for all merging methods in Pythia, NLO Merging main88.cc requires LHE input files. To use NLO Merging main88.cc without any changes, these input files should follow the naming convention NLO Merging name_tree_#nAdditionalJets.lhe (for tree-level samples) and NLO Merging name_powheg_#nAdditionalJets.lhe (for POWHEG NLO samples). NLO Merging main88.cc produces HepMC event output, which can e.g. be analysed with RIVET, or used as input for detector simulations. For users not familiar with HepMC output, it is of course possible remove the HepMC code in the sample program, and use Pythia's histogramming routines instead. Histograms should then be filled as indicated for the NLO Merging histPTFirstSum histograms in NLO Merging main84.cc , i.e. using NLO Merging weightNLO*normhepmc. NLO Merging As for NL NLO Merging 3 , it is not necessary to change NLO Merging main88.cc if the user is only interested in changing standard settings. Thus, if the user only wants to change the number of requested events ( NLO Merging Main:numberOfEvents ), the hard process ( NLO Merging Merging:Process ), the merging scale value ( NLO Merging Merging:TMS ) and the maximal number of additional tree-level or NLO-accuracte jets ( NLO Merging Merging:nJetMax and NLO Merging Merging:nJetMaxNLO , respectively), and HepMC output is desired, then there is no need to change the NLO Merging main88.cc code. The input LHE files are also part of the (command line) input for NLO Merging main88.exe. The default settings in NLO Merging main88.cmnd are intended to work with the (very short) sample LHEF inputs ( NLO Merging w_production_tree_0.lhe , NLO Merging w_production_tree_1.lhe , NLO Merging w_production_tree_2.lhe and NLO Merging w_production_powheg_0.lhe , NLO Merging w_production_powheg_1.lhe ). For these input files, the NLO Merging main88.exe executable can be run with the command NLO Merging NLO Merging ./main88.exe main88.cmnd w_production myhepmc.hepmc NLO Merging to produce a file myhepmc.hepmc of UNLOPS merged HepMC event output. Please refrain from adding input switches than invoke any other merging scheme (e.g. NLO Merging Merging:doKTMerging ) into the input file that you want to use in conjunction with NLO Merging main88.cc. NLO Merging In the following, we will explain NLO Merging main88.cc in depth. To not be overly repetitive, we will at times refer to the relevant parts in the discussion of NLO Merging main87.cc. Users who are willing to accept the default choices do not need to know all details, but are still encouraged to read further. NLO Merging Program flow NLO Merging main88.cc can be divided into five steps: NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 1. Estimate the cross section for tree-level and NLO samples NLO Merging after the merging scale cut. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2. Produce reweighted tree-level    events, which do not contain NLO Merging &alpha; NLO Merging s NLO Merging 0 -    and NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3. Add POWHEG NLO events. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 4. Subtract integrated, reweighted    tree-level events, to ensure that the inclusive NLO cross section remains    intact upon inclusion of multi-jet tree-level events. NLO Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 5. Subtract integrated POWHEG NLO    events, to ensure that the inclusive NLO cross section remains    intact upon inclusion of multi-jet tree-level events. NLO Merging The estimation of cross sections after the application of the merging scale cut is nearly identical to the first step in NLO Merging main87.cc , and we refer to the first paragraph of the 'Program flow' discussion for NLO Merging main87.cc for details. For NLO Merging main88.cc , the flags NLO Merging Merging:doUNLOPSTree or NLO Merging Merging:doUNLOPSLoop supply the merging scale definition used in the cross section estimation. NLO Merging After the cross section estimation step, NLO Merging main88.cc proceeds to perform the actual NLO merging. The discussion of K-factors given in the NL NLO Merging 3 section (i.e. of NLO Merging Merging:kFactor0j , NLO Merging Merging:kFactor1j and NLO Merging Merging:kFactor2j ) also applies to NLO Merging main88.cc. Although UNLOPS is considerably more stable than NL NLO Merging 3 upon changing the K-factors, we do not recommend the use of K-factors. NLO Merging The production of UNLOPS-merged events with NLO Merging main88.cc starts by generating reweighted tree-level events. The processing of tree-level events can be invoked by setting the following flag. NLO Merging The weight of tree-level events is returned by the function NLO Merging double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, should be used as event weight (or weight of histogram bins). For NLO Merging Merging:doUNLOPSTree = on , the weight NLO Merging double Info::mergingWeightNLO() contains the UMEPS weight, subtracted, if necessary, by NLO Merging &alpha; NLO Merging s NLO Merging 0 - and NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms. This weight can become negative. As an example, assume that we attempt an UNLOPS merging of W + 0 jet and W + 1 jet at NLO accuracy, and with  W + 2 jets at tree-level accuracy. This weight will then be NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = UMEPS-weight for one jet  - NLO Merging &alpha; NLO Merging s NLO Merging 0 -terms  - NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms for events in the one-jet sample, and NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = UMEPS-weight for two jets for events in the two-jet sample. NLO Merging After reweighted tree-level events have been generated, NLO Merging main88.cc processes the POWHEG NLO input files. This is facilitated by the following switch. NLO Merging The NLO merging weight of the events can be accessed by calling the function NLO Merging double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For NLO Merging Merging:doUNLOPSLoop = on , the weight NLO Merging double Info::mergingWeightNLO() is either one or zero (see Appendix E in NLO Merging Lon13 ). NLO Merging After processing the POWHEG NLO events, NLO Merging main88.cc continues by generating the reweighted subtraction terms of UMEPS. This part is implemented by setting the following flag. NLO Merging By using this switch, NLO Merging main88.cc ensures that the inclusive cross section is preserved. At variance with UMEPS however, the event weight contains the UMEPS weight, subtracted, if necessary, by NLO Merging &alpha; NLO Merging s NLO Merging +0 - and NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms. Otherwise, NLO Merging &alpha; NLO Merging s NLO Merging n+0 - and NLO Merging &alpha; NLO Merging s NLO Merging n+1 -terms of the UMEPS procedure would be introduced, although our goal is to describe all NLO Merging &alpha; NLO Merging s NLO Merging n+0 - and NLO Merging &alpha; NLO Merging s NLO Merging n+1 -terms by n-jet POWHEG input. The weight of these integrated, subtractive tree-level events is, as always, returned by the function NLO Merging double Info::mergingWeightNLO(). When printing (or histogramming) NLO merged events, this weight, multiplied with the estimated cross section of the current event sample, and with NLO Merging -1 , should be used as event weight (or weight of histogram bins). As for the case of tree-level events in UNLOPS, this weight can become negative. For the example given before, i.e. attempting an UNLOPS merging of W + 0 jet and  W + 1 jet at NLO accuracy, and with W + 2 jets at tree-level accuracy, this weight will be NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = UMEPS-weight for the integrated  one-jet sample - NLO Merging &alpha; NLO Merging s NLO Merging 0 -terms  - NLO Merging &alpha; NLO Merging s NLO Merging 1 -terms for events in the integrated one-jet sample, and NLO Merging &nbsp; NLO Merging Info::mergingWeightNLO() = UMEPS-weight for the integrated  two-jet sample for events in the integrated two-jet sample. NLO Merging This choice of weights already incorporates the fact that we have implemented the 'inclusive scheme' of NLO Merging Lon13 , meaning that the 'explicit phase space subtractions' of NL NLO Merging 3 are (partially) included though these weights. NLO Merging To ensure that the NLO inclusive cross section is unchanged, UNLOPS further requires the introduction of another sample. If POWHEG NLO events with one or more jets are included, it is necessary to subtract these samples in an integrated form. In NLO Merging main88.cc , this is done by setting the following flag. NLO Merging This sample also provides some 'explicit phase space subtractions' of NL NLO Merging 3 , which are necessary because we implemented the 'inclusive scheme' of NLO Merging Lon13. Let us again look at the example of UNLOPS merging of W + 0 jet and W + 1 jet at NLO accuracy. The integrated  W + 1 jet NLO events, which are produced by the setting NLO Merging Merging:doUNLOPSSubtNLO = on , contain a tree-level part. This part will exactly cancel the real-emission events with one jet above the merging scale in the  W + 0 jet NLO events. NLO Merging The NLO merging weight of these 'integrated' events can be accessed by calling the function NLO Merging double Info::mergingWeightNLO(). This weight should also be used when printing (or histogramming) events. For NLO Merging Merging:doUNLOPSSubtNLO = on , the weight NLO Merging double Info::mergingWeightNLO() is either one or zero (see Appendix E in NLO Merging Lon13 ). NLO Merging After these five steps (estimation of cross sections, tree-level processing, POWHEG processing, integrated tree-level processing, integrated POWHEG processing) we have produced a UNLOPS-merged HepMC event file. NLO Merging main88.cc finishes by returning the UNLOPS-merged total cross section. NLO Merging NLO Merging NLO Merging NLO Merging NLO merging and 'exclusive' NLO inputs Currently, both sample main programs for NLO merging ( NLO Merging main87.cc and NLO Merging main88.cc ) are intended for 'inclusive' POWHEG input. Inclusive input means that all real emission phase space points are included in the POWHEG output files. In order to avoid double counting with higher-multiplicity matrix elements, it is then necessary remove phase space points with too many jets from the real-emission configurations. This can be done by introducing explicit phase space subtractions. Another way of removing the undesired configurations is by implementing a cut in the NLO generator. This is not a completely trivial task, since it is necessary to ensure numerical stability and the correct cancellation of (finite) dipole regularisation terms. One way of producing such exclusive NLO output is by setting the (tree-level) real-emission matrix element in the NLO generator to zero if the real-emission phase space point contains too many jets above the merging scale. This will however not be numerically stable for too low merging scale values. NLO Merging NLO Merging We should be very clear that using exclusive NLO input is not recommended, since it requires hacking the NLO generator.  Only for the expert user, we briefly summarise the necessary changes for using exclusive NLO input. NLO Merging For the moment, assume that the NLO input has been produced in an 'exclusive' way. This input can then be processed by some trivial changes in NLO Merging main87.cc : estimate the cross section for tree-level and NLO samples NLO Merging after the merging scale cut, still using inclusive NLO samples, remove the last part of NLO Merging main87.cc , i.e. the part that produces explicit phase space subtractions, and use the exclusive NLO files as input files for the processing of 'POWHEG NLO files'. NLO Merging The changes to NLO Merging main88.cc (implementing UNLOPS) are slightly more complicated. This is the case because the weights of integrated tree-level samples change when using exclusive input, as can be seen in Appendix D in NLO Merging Lon13. The correct weights can be produced by Pythia by using the following flag. NLO Merging Then, it is necessary to add code for processing another sample to NLO Merging main88.cc , since when using exclusive inputs, it is also necessary to enforce two integrations on tree-level events (the '&uarr;'-contributions in Appendix D of NLO Merging Lon13 ). This can be achieved by adding the following code at the end of NLO Merging main88.cc. NLO Merging NLO Merging cout << endl << endl << endl;  cout << 'Shower subtractive events' << endl;   // Switch on processing of counter-events.  pythia.settings.flag('Merging:doUNLOPSTree',false);  pythia.settings.flag('Merging:doUNLOPSLoop',false);  pythia.settings.flag('Merging:doUNLOPSSubt',true);  pythia.settings.flag('Merging:doUNLOPSSubtNLO',false);  pythia.settings.mode('Merging:nRecluster',2);   nMaxCT      = nMaxNLO+1;  njetcounterCT  = nMaxCT;  iPathSubt    = iPath + '_tree';   while(njetcounterCT >= 2){    // From njet, choose LHE file    stringstream in;    in  << '_' << njetcounterCT << '.lhe';    string LHEfile = iPathSubt + in.str();    cout << endl << endl << endl       << 'Start subtractive treatment for ' << njetcounterCT << ' jets\n'       << 'Recluster at least 2 times' << endl;    pythia.readString('Beams:frameType = 4');    pythia.settings.word('Beams:LHEF', LHEfile);    pythia.settings.mode('Merging:nRequested', njetcounterCT);    pythia.init();    // Remember position in vector of cross section estimates.    int iNow = sizeLO-1-njetcounterCT;    // Start generation loop    for( int iEvent=0; iEvent < nEvent; ++iEvent ){      // Generate next event     if( !pythia.next() ) {      if( pythia.info.atEndOfFile() ) break;      else continue;     }      // Get event weight(s).     double weightNLO  = pythia.info.mergingWeightNLO();     double evtweight  = pythia.info.weight();     weightNLO      *= evtweight;     // Do not print zero-weight events.     if ( weightNLO == 0. ) continue;      // Construct new empty HepMC event.     HepMC::GenEvent* hepmcevt = new HepMC::GenEvent();     // Get correct cross section from previous estimate.     double normhepmc = -1*xsecLO[iNow] / nAcceptLO[iNow];     // Set hepmc event weight.     hepmcevt->weights().push_back(weightNLO*normhepmc);     // Fill HepMC event.     ToHepMC.fill_next_event( pythia, hepmcevt );     // Add the weight of the current event to the cross section.     sigmaTotal += weightNLO*normhepmc;     errorTotal += pow2(weightNLO*normhepmc);     // Report cross section to hepmc.     HepMC::GenCrossSection xsec;     xsec.set_cross_section( sigmaTotal*1e9, pythia.info.sigmaErr()*1e9 );     hepmcevt->set_cross_section( xsec );     // Write the HepMC event to file. Done with it.     ascii_io << hepmcevt;     delete hepmcevt;    } // end loop over events to generate    // print cross section, errors    pythia.stat();    // Restart with ME of a reduced the number of jets    if( njetcounterCT > 2 )     njetcounterCT--;    else     break;   } NLO Merging NLO Merging NLO Merging Further variables More advanced manipulations of the merging machinery are of course possible, and additional switches can be found at the end of the NLO Merging CKKW-L tree-level merging documentation. Here, we only document switches that NLO Merging only apply to NLO merging."},{"name":"Onia Processes","link":"OniaProcesses.html","text":"Onia Processes Onia Processes Onia Processes Production of any Onia Processes 3S1 , Onia Processes 3PJ , and Onia Processes 3DJ charmonium and bottomonium states via the colour-singlet and colour-octet mechanisms. This includes by default, but is not limited to, production of the Onia Processes 3S1 Onia Processes J/psi and Onia Processes Upsilon and their radially excited states, as well as the Onia Processes 3PJ Onia Processes chi states and the Onia Processes 3D1 Onia Processes psi(3770). In each process the heavy quark content, either Onia Processes ccbar or Onia Processes bbbar , is followed by a round-bracketed expression which specifies the physical state in spectroscopic notation, Onia Processes (2S+1) L J. Proceding this is a square-bracketed expression, also in spectroscopic notation, which specifies the Fock state through which the process occurs, where Onia Processes (1) indicates a colour-singlet state and Onia Processes (8) a colour-octet state. Onia Processes The unphysical colour-octet states follow the Onia Processes id scheme of Onia Processes 99 n_q n_s n_r n_L n_J where Onia Processes n_q is the quark flavour of the state and Onia Processes n_s is the colour-octet state type. Here Onia Processes 0 is Onia Processes 3S1 , Onia Processes 1 is Onia Processes 1S0 , and Onia Processes 2 is Onia Processes 3PJ. All remaining numbers follow the standard PDG numbering scheme. If a physical state is requested without a corresponding colour-octet state, a colour-octet state is automatically added to the Onia Processes ParticleData when a colour-octet process is selected. The colour-octet state is created with a mass given by the mass of the physical state plus the singlet-octet mass splitting parameter Onia Processes Onia:massSplit , which is by default set at 200 MeV, and decays exclusively to a gluon and the physical state. If the user wishes to manually set the mass splitting for each colour-octet state individually then Onia Processes Onia:forceMassSplit can be set to Onia Processes off. By default the widths of the octet states are set to vanish. This is not realistic, given their presumably rather rapid decay, but a nonvanishing width is not likely to have any measurable consequences that go beyond what comes from viewing the singlet-octet mass splitting as an effective parameter. Onia Processes The original Fortran code for these processes has been contributed by Stefan Wolf [unpublished]. For the C++ version only the unpolarized expressions are retained, since the theoretical predictions of the colour-octet model anyway do not agree with the experimental observations. Furthermore, the polarization effects are modest, so isotropic decay is not a bad starting point. Such an event sample can afterwards be reweighted at will by the user, to test various assumptions. The expressions for the colour-singlet production of the Onia Processes 3S1 and Onia Processes 3PJ states can be found in Onia Processes Bai83 and Onia Processes Gas87. Colour-octet expressions can be found in Onia Processes Cho96 for the Onia Processes 1S0 , Onia Processes 3S1 , and Onia Processes 3PJ states, and the matrix elements for the Onia Processes 3DJ states are taken from Onia Processes Yua98. Onia Processes The implementation of charmonium and bottomonium production, including the colour-octet production mechanism, requires information on long-distance NRQCD matrix elements for the various wavefunctions involved. Default values for these are encoded in the Onia Processes O parameters and are taken from Onia Processes Nas00 ; see also Onia Processes Bar07. The Onia Processes 3DJ long-distance matrix elements are extracted from Onia Processes Yua98. Onia Processes Note that states that differ only by the radial excitation number Onia Processes n_r share the same short-distance matrix elements. The program has therefore been written such that further radial excitations can be easily added by editing this file, without requiring a recompilation of the code. All related arrays must be expanded in exactly the same way, however, i.e. the code of the colour singlet state, the long-distance matrix elements and the individual process on/off switches. Onia Processes Double production of charmonium and bottomonium Onia Processes 3S1 states is also available, but with only the colour-singlet processes included. The short-distance matrix elements for these processes can be found in Onia Processes Hum83 and Onia Processes Qia02. Arrays seperate to those used for single charmonium and bottomonium production set the long-distance NRQCD matrix elements. For consistency these values should be the same as those provided for single charmonium and bottomonium production, but are seperated to allow further control by the user if needed. Onia Processes The description of Onia Processes final-state radiation is in this case based on some further model assumptions. Onia Processes Most of the processes below are divergent in the limit Onia Processes pT &rarr; 0 , and therefore a Onia Processes pTmin scale should be set. Comparisons with data indicate that this divergence can be tamed the same way as for the normal QCD Onia Processes 2 &rarr; 2 cross sections Onia Processes Bar07,Kra08 , which makes sense, since they are all dominated by the same kind of Onia Processes t -channel gluon exchange. It is therefore possible to use the Onia Processes SuppressSmallPT user hook to impose a reweighting that cancels the low- Onia Processes pT divergence. Onia Processes An eikonalized description of these processes, excluding double onia production, is included in the multiparton-interactions framework. Here the low- Onia Processes pT damping is automatic, and additionally the framework is more consistent (e.g. with respect to energy-momentum constraints and the impact-parameter description) for events where the onium production is not the hardest subprocess, as would often be the case in the low- Onia Processes pT limit. Onia Processes Charmonium 3S1 States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Charmonium 3PJ States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Charmonium 3DJ States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Double Charmonium 3S1 States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Bottomonium 3S1 States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Bottomonium 3PJ States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Bottomonium 3DJ States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list. Onia Processes Double Bottomonium 3S1 States Onia Processes Warning : changed Onia Processes fvec , Onia Processes mvec or Onia Processes pvec values must be provided as a comma-separated list with the right number of elements, without any blanks inside the list."},{"name":"Particle Data","link":"ParticleData.html","text":"Particle Data Particle Data Particle Data The structure and operation of the particle data table is described Particle Data here. That page also describes how default data properties can be changed. The current page provides the actual default values. Particle Data Main settings Apart from the data itself, the particle data table only contains a few aspects that are available to change: Particle Data Since running masses are only calculated for the six quark flavours, e.g. to obtain couplings to the Higgs boson(s), there is not an entry in the normal tables for each particles, but only the six MSbar mass values below, used as starting point for the running. In addition you can pick an Particle Data alpha_s(M_Z) , which is converted into a first-order five-flavour Lambda that is used to determine the rate of the running. (Without any match to four flavours below Particle Data m_b ; if desired, this can be fixed by slightly shifted default mass values, since the routines never should be called below the Particle Data m_b scale anyway.) Particle Data Comments on the data Much of the current data has been updated based on the 2012 Review of Particle Physics Particle Data Ber12 , while some is still based on the 2006 RPP Particle Data Yao06. All known particle masses, widths and lifetimes have been set accordingly, while most not-yet-measured particles are kept at their values from PYTHIA 6. Decay channels and their branching ratios remain a major worry: many particles do not have one single solidly measured branching ratio, and many further do not have known branching ratios that add up to (the neighbourhood of) unity. Particle Data Uncertainties are especially big for the scalar, pseudovector and tensor Particle Data L = 1 multiplets available in PYTHIA. We note that some distributions become better described when these multiplets are included in the generation, while others become worse. It is tempting to associate this lackluster performance with the primitive knowledge. Not even the multiplets themselves are particularly well known. It used to be that the Particle Data a_0(980) and Particle Data f_0(980) were considered to be members of the scalar multiplet. Nowadays they are commonly assumed to be either four-quark states or of some other exotic character. This means that the PYTHIA 8 PDG particle codes have been changed for these particles, relative to what was used in PYTHIA 6 based on previous PDG editions. Specifically their numbers are now in the 9000000 series, and they have been replaced in the scalar multiplet by Particle Data a_0(1450) and Particle Data f_0(1370). Particle Data For charm and bottom mesons the jungle of partial measurements makes it very difficult to construct fully consistent sets of decay channels. This part of the program has not yet been brought up to date to the 2006 RPP. Instead the LHCb decay tables (for EvtGen, but without using the EvtGen matrix-element machinery) and the DELPHI tune for PYTHIA 6 is being used. (This also includes a few non-c/b hadrons that only occur in the c/b decay tables.) This has the advantage that many tests have been made for consistency, but the disadvantage that it is not always in agreement with the latest measurements of some specific decay channels. The decays based on the LHCb tables (with some modifications) are 411, 421, 431, 441, 445, 511, 521, 531, 541, 3124, 4122, 4124, 5122, 10441, 10443, 13122, 14122, 20443, 23122, 30313, 30323, 30443, 33122, 100113, 100213, 100441, 100443, 100553, 9000111, 9000211. Correspondingly the decays based on the DELPHI tables are 415, 425, 435, 515, 525, 535, 4132, 4232, 4332, 5132, 5232 and 5332. Particle Data The data itself Here comes the default particle data used in the program. Do not touch. The meaning of the various properties and the format used are explained Particle Data here and the Particle Data meMode codes Particle Data here."},{"name":"Particle Decays","link":"ParticleDecays.html","text":"Particle Decays Particle Decays Particle Decays The Particle Decays ParticleDecays class performs the sequential decays of all unstable hadrons produced in the string fragmentation stage, i.e. up to and including Particle Decays b hadrons and their decay products, such as the Particle Decays tau lepton. It is not to be used for the decay of more massive Particle Decays resonances , such as top, Particle Decays Z^0 or SUSY, where decays must be performed already at the Particle Decays ProcessLevel of the event generation. Particle Decays The decay description essentially copies the one present in PYTHIA since many years, but with some improvements, e.g. in the decay tables and the number of decay models available. Recently a more sophisticated handling of Particle Decays tau decays has also been introduced. Some issues may need further polishing. Particle Decays Variables determining whether a particle decays Before a particle is actually decayed, a number of checks are made. Particle Decays (i) Decay modes must have been defined for the particle kind; tested by the Particle Decays canDecay() method of Particle Decays Event (and Particle Decays ParticleData ). Particle Decays (ii) The main switch for allowing this particle kind to decay must be on; tested by the Particle Decays mayDecay() method of Particle Decays Event (and Particle Decays ParticleData ). By default this is defined as true for all particles with Particle Decays tau0 below 1000 mm, and false for ones above, see the Particle Decays Particle Data Scheme. This means that Particle Decays mu^+- , Particle Decays pi^+- , Particle Decays K^+- , Particle Decays K^0_L and Particle Decays n/nbar always remain stable unless decays are explicity switched on, e.g. Particle Decays 211:mayDecay  = true. Particle Decays (iii) Particles may be requested to have a nominal proper lifetime Particle Decays tau0 below a threshold. Particle Decays (iv) Particles may be requested to have an actual proper lifetime Particle Decays tau below a threshold. Particle Decays (v) Particles may be requested to decay within a given distance of the origin. Particle Decays (vi) Particles may be requested to decay within a given cylindrical volume around the origin. Particle Decays Mixing Particle Decays Tau decays Decays of Particle Decays tau leptons can be performed using helicity information from the Particle Decays tau production process and with the hadronic current of the Particle Decays tau decay modelled using form factors fit to data. The Particle Decays tau decay framework is largely based on the corresponding Herwig++ implementation Particle Decays Gre07 , with some input from Tauola Particle Decays Jad90. A short summary can be found in Particle Decays Ilt12 , while the complete writeup is in Particle Decays Ilt14. Particle Decays The decays of Particle Decays tau leptons are categorized as Particle Decays correlated , where a Particle Decays tau pair is produced from a single process, or Particle Decays uncorrelated , where only one Particle Decays tau is produced. Currently internally supported Particle Decays tau production mechanisms include correlated decays from Particle Decays gamma , Particle Decays Z^0 , Particle Decays Z'^0 , Particle Decays gamma^*/Z^0/Z'^0 , and Higgs bosons (CP-even, odd, or mixed) and uncorrelated decays from Particle Decays W^+- , Particle Decays W'^+- , Particle Decays B/D hadrons, and charged Higgs bosons. For all mechanisms except Particle Decays B/D hadrons, both the full process, e.g. Particle Decays q qbar &rarr; Z^0 &rarr; tau^+ tau^- , as well as just the decay of the boson with a given initial polarization, e.g. Particle Decays Z^0 &rarr; tau^+ tau^- , can be handled. The axial and vector couplings of the Particle Decays Z'^0 and Particle Decays W'^0 are set from the relevant parameters in Particle Decays New Gauge Boson Processes. Note that the CP of the various Higgs bosons can be set with the options Particle Decays HiggsX:parity , Particle Decays HiggsX:etaParity , and Particle Decays HiggsX:phiParity as described in Particle Decays Higgs Processes where Particle Decays X is either Particle Decays H1 , Particle Decays H2 , or Particle Decays A3. Particle Decays The Particle Decays tau polarization and Particle Decays tau decay correlation mechanism can be determined either using Particle Decays internal matrix elements or Particle Decays external SPINUP information provided in the event, e.g. via Les Houches Event Files (LHEF). For internal determination any Particle Decays tau pair or single Particle Decays tau from the processes of the previous list can be handeled. For external determination of a single uncorrelated Particle Decays tau , its polarization is set to its SPINUP information. When the SPINUP for the Particle Decays tau is not valid, e.g. when FSR is applied, the SPINUP for the first copy of that Particle Decays tau is used instead unless also invalid. For the external determination of a correlated Particle Decays tau pair the following options are available. Particle Decays A default behaviour is defined when the polarization and decay mechanism cannot be determined using either the internal or external methods. If the Particle Decays tau is known to be produced from a Particle Decays W^+- , Particle Decays gamma , or Particle Decays Z^0 , the Particle Decays tau or Particle Decays tau pair is assumed to be produced from an unpolarized boson of this type. If the mediator is unknown but there is a correlated Particle Decays tau pair, the pair is assumed to be produced from an unpolarized photon and a warning is issued. Finally, if the Particle Decays tau is uncorrelated, an unpolarized and uncorrelated decay is performed and a warning is issued. Particle Decays Both the internal and external determination have advantages and disadvantages. For example, if an LHEF Particle Decays Z^0 &rarr; tau^+ tau^- event is passed with SPINUP provided for both Particle Decays tau s but without SPINUP for the Particle Decays Z^0 then with Particle Decays TauDecays:externalTau set to Particle Decays 0 the decays of the Particle Decays tau s will be uncorrelated. Using Particle Decays 1 instead will result in correlations, assuming an unpolarized Particle Decays Z^0. If using internal determination, then the correlation and polarization will be fully calculated using the correct production mechanism for the Particle Decays Z^0. Consequently, a variety of options on how to determine polarization and correlation are available, with a sensible default in place which should catch most everything. Particle Decays QED radiation So far PYTHIA does not have any generic machinery for handling QED radiation in normal particle decays. In order to include this, a program like Photos Particle Decays Bar94, Dav10 could be used as an afterburner. In a few cases, however, the existing shower machinery can be used also here: for two-body decays to a lepton pair ( Particle Decays l^+ l^- or Particle Decays l^+- nu_l ). Such decays are mediated by Particle Decays gamma^*/Z^0/W^+- exchange, for which PYTHIA does have an existing machinery that can be applied, including first-order matrix-element corrections for the first (hardest) photon emission. Particle Decays Other variables Particle Decays When a decay mode is defined in terms of a partonic content, a random multiplicity (and a random flavour set) of hadrons is to be picked, especially for some charm and bottom decays. This is done according to a Poissonian distribution, for Particle Decays n_p normal particles and Particle Decays n_q quarks the average value is chosen as Particle Decays n_p/ 2 + n_q/4 + multIncrease * ln ( mDiff / multRefMass) with Particle Decays mDiff the difference between the decaying particle mass and the sum of the normal-particle masses and the constituent quark masses. For gluon systems Particle Decays multGoffset offers and optional additional term to the multiplicity. The lowest possible multiplicity is Particle Decays n_p + n_q/2 (but at least 2) and the highest possible 10. If the picked hadrons have a summed mass above that of the mother a new try is made, including a new multiplicity. These constraints imply that the actual average multiplicity does not quite agree with the formula above. Particle Decays Modes for Matrix Element Processing Some decays can be treated better than what pure phase space allows, by reweighting with appropriate matrix elements. In others a partonic content has to be converted to a set of hadrons. The presence of such corrections is signaled by a nonvanishing Particle Decays meMode() value for a decay mode in the Particle Decays particle data table. The list of allowed possibilities almost agrees with the PYTHIA 6 ones, but several obsolete choices have been removed, a few new introduced, and most have been moved for better consistency. Here is the list of currently allowed Particle Decays meMode() codes: Particle Decays Particle Decays 0 : pure phase space of produced particles ('default'); input of partons is allowed and then the partonic content is converted into the minimal number of hadrons (i.e. one per parton pair, but at least two particles in total) Particle Decays 1 : Particle Decays omega and Particle Decays phi &rarr; pi+ pi- pi0 Particle Decays 2 : polarization in Particle Decays V &rarr; PS + PS ( Particle Decays V = vector, Particle Decays PS = pseudoscalar), when Particle Decays V is produced by Particle Decays PS &rarr; PS + V or Particle Decays PS &rarr; gamma + V Particle Decays 11 : Dalitz decay into one particle, in addition to the lepton pair (also allowed to specify a quark-antiquark pair that should collapse to a single hadron) Particle Decays 12 : Dalitz decay into two or more particles in addition to the lepton pair Particle Decays 13 : double Dalitz decay into two lepton pairs Particle Decays 21 : decay to phase space, but weight up Particle Decays neutrino_tau spectrum in Particle Decays tau decay Particle Decays 22 : weak decay; if there is a quark spectator system it collapses to one hadron; for leptonic/semileptonic decays the Particle Decays V-A matrix element is used, for hadronic decays simple phase space Particle Decays 23 : as 22, but require at least three particles in decay Particle Decays 31 : decays of type B &rarr; gamma X, very primitive simulation where X is given in terms of its flavour content, the X multiplicity is picked according to a geometrical distribution with average number 2, and the photon energy spectrum is weighted up relative to pure phase space Particle Decays 42 - 50 : turn partons into a random number of hadrons, picked according to a Poissonian with average value as described above, but at least Particle Decays code - 40 and at most 10, and then distribute then in pure phase space; make a new try with another multiplicity if the sum of daughter masses exceed the mother one Particle Decays 52 - 60 : as 42 - 50, with multiplicity between Particle Decays code - 50 and 10, but avoid already explicitly listed non-partonic channels Particle Decays 62 - 70 : as 42 - 50, but fixed multiplicity Particle Decays code - 60 Particle Decays 72 - 80 : as 42 - 50, but fixed multiplicity Particle Decays code - 70, and avoid already explicitly listed non-partonic channels Particle Decays 91 : decay to Particle Decays q qbar or Particle Decays g g , which should shower and hadronize Particle Decays 92 : decay onium to Particle Decays g g g or Particle Decays g g gamma (with matrix element), which should shower and hadronize Particle Decays 93 : decay of colour singlet to Particle Decays q qbar plus another singlet, flat in phase space (and arbitrarily ordered), where the Particle Decays q qbar pair should shower and hadronize Particle Decays 94 : same as 93, but weighted with Particle Decays V-A weak matrix element if the decay chain is of the type Particle Decays neutrino \rarr; dbar u lepton in that order Particle Decays 100 - : reserved for the description of partial widths of Particle Decays resonances Three special decay product identity codes are defined. Particle Decays Particle Decays 81: remnant flavour. Used for weak decays of c and b hadrons, where the c or b quark decays and the other quarks are considered as a spectator remnant in this decay. In practice only used for baryons with multiple c and b quarks, which presumably would never be used, but have simple (copied) just-in-case decay tables. Assumed to be last decay product. Particle Decays 82: random flavour, picked by the standard fragmentation flavour machinery, used to start a sequence of hadrons, for matrix element codes in 41 - 80. Assumed to be first decay product, with -82 as second and last. Where multiplicity is free to be picked it is selected as for normal quarkonic systems. Currently unused. Particle Decays 83: as for 82, with matched pair 83, -83 of decay products. The difference is that here the pair is supposed to come from a closed gluon loop (e.g. Particle Decays eta_c &rarr; g g ) and so have a somewhat higher average multiplicity than the simple string assumed for 82, see the Particle Decays ParticleDecays:multGoffset parameter above."},{"name":"Particle Properties","link":"ParticleProperties.html","text":"Particle Properties Particle Properties Particle Properties A Particle Properties Particle corresponds to one entry/slot in the event record. Its properties therefore is a mix of ones belonging to a particle-as-such, like its identity code or four-momentum, and ones related to the event-as-a-whole, like which mother it has. Recall that energies, momenta and masses are all given in GeV, and space-time coordinates all in mm, i.e. units are chosen such that the speed of light Particle Properties c is unity. In particular, times are also in mm, Particle Properties not in seconds. Particle Properties What is stored for each particle is Particle Properties Particle Properties the identity code, Particle Properties the status code, Particle Properties two mother indices, Particle Properties two daughter indices, Particle Properties a colour and an anticolour index, Particle Properties the four-momentum and mass, Particle Properties the scale at which the particle was produced (optional), Particle Properties the polarization/spin/helicity of the particle (optional), Particle Properties the production vertex and proper lifetime (optional), Particle Properties a pointer to the particle kind in the particle data table, and Particle Properties a pointer to the event the particle belongs to. From these, a number of further quantities may be derived. Particle Properties Basic output methods The following member functions can be used to extract the most important information: Particle Properties Input methods The same method names as above are also overloaded in versions that set values. These have an input argument of the same type as the respective output above, and are of type Particle Properties void. Particle Properties There are also a few alternative methods for input: Particle Properties Further output methods In addition, a number of derived quantities can easily be obtained, but cannot be set, such as: Particle Properties Not part of the Particle Properties Particle class proper, but obviously tightly linked, are the two methods Particle Properties Properties of the particle species Each Particle contains a pointer to the respective Particle Properties ParticleDataEntry object in the Particle Properties particle data tables. This gives access to properties of the particle species as such. It is there mainly for convenience, and should be thrown if an event is written to disk, to avoid any problems of object persistency. Should an event later be read back in, the pointer will be recreated from the Particle Properties id code if the normal input methods are used. (Use the Particle Properties Particle Properties Event::restorePtrs() method if your persistency scheme bypasses the normal methods.) This pointer is used by the following member functions: Particle Properties Methods that may access the event the particle belongs to A particle can be created on its own. When inserted into an event record, it obtains a pointer to that event-as-a-whole. It is then possible to use methods that do not make sense for a particle in isolation. These methods are listed below. Whenever the pointer to the event is not defined, these will return an appropriate 'null' value, this being -1 for an integer, false for a bool, and empty for a vector, unless otherwise specified. Particle Properties Methods that perform operations There are some further methods, some of them inherited from Particle Properties Vec4 , to modify the properties of a particle. They are of little interest to the normal user. Particle Properties Constructors and operators Normally a user would not need to create new particles. However, if necessary, the following constructors and methods may be of interest."},{"name":"Parton Distributions","link":"PartonDistributions.html","text":"Parton Distributions Parton Distributions Parton Distributions The parton distributions file contains the Parton Distributions PDF class. Parton Distributions PDF is the base class, from which specific Parton Distributions PDF classes are derived. Parton Distributions The choice of which PDF to use is made by settings in the Parton Distributions Pythia class, see Parton Distributions here. These settings also allow to access all the proton PDF's available in the LHAPDF library Parton Distributions Wha05,Buc15. Thus there is no need for a normal user to study the Parton Distributions PDF class. The structure must only be understood when interfacing new PDF's, e.g. ones not yet found in LHAPDF. Parton Distributions The PDF base class Parton Distributions PDF defines the interface that all PDF classes should respect. The constructor requires the incoming beam species to be given: even if used for a proton PDF, one needs to know whether the beam is actually an antiproton. This is one of the reasons why Parton Distributions Pythia always defines two PDF objects in an event, one for each beam. Parton Distributions Once a Parton Distributions PDF object has been constructed, call it Parton Distributions pdf , the main method is Parton Distributions pdf.xf( id, x, Q2) , which returns Parton Distributions x*f_id(x, Q2) , properly taking into account whether the beam is an antiparticle or not. Parton Distributions Whenever the Parton Distributions xf member is called with a new flavour, Parton Distributions x or Parton Distributions Q^2 , the Parton Distributions xfUpdate member is called to do the actual updating. This routine may either update that particular flavour or all flavours at this Parton Distributions (x, Q^2) point. (In the latter case the saved Parton Distributions id value Parton Distributions idSav should be set to 9.) The choice is to be made by the producer of a given set, based on what he/she deems most effective, given that sometimes only one flavour need be evaluated, and about equally often all flavours are needed at the same Parton Distributions x and Parton Distributions Q^2. Anyway, the latest value is always kept in memory. This is the other reason why Parton Distributions Pythia has one separate Parton Distributions PDF object for each beam, so that values at different Parton Distributions x can be kept in memory. Parton Distributions Two further public methods are Parton Distributions xfVal( id, x, Q2) and Parton Distributions xfSea( id, x, Q2). These are simple variants whereby the quark distributions can be subdivided into a valence and a sea part. If these are not directly accessible in the parametrization, one can make the simplified choices Parton Distributions u_sea = ubar_sea, u_val = u_tot - u_sea , and correspondingly for Parton Distributions d. (Positivity will always be guaranteed at output.) The Parton Distributions xfUpdate method should also take care of updating this information. Parton Distributions A method Parton Distributions setExtrapolate(bool) allows you to switch between freezing parametrizations  at the low- Parton Distributions x boundary ( Parton Distributions false ) or extrapolate them outside the boundary ( Parton Distributions true ). This method works both for LHAPDF 5, LHAPDF6 and modern internal PDFs. (For some older PDFs the behaviour implemented by the original authors is maintained.) In either case the PDFs are frozen at Parton Distributions Q_min and Parton Distributions Q_max. (And also at Parton Distributions x_max , but this is irrelevant when Parton Distributions x_max = 1 .) Parton Distributions With Parton Distributions insideBounds(double x, double Q2) you can probe whether an Parton Distributions (x, Q^2) pair falls inside the fit region or not. The Parton Distributions alphaS(double Q2) method returns the Parton Distributions alpha_s of the PDF at the given Parton Distributions Q^2 scale, while Parton Distributions mQuarkPDF(int id) returns the quark masses used to set flavour thresholds. Currently these three methods are only implemented for LHAPDF6. Parton Distributions Derived classes There is only one pure virtual method, Parton Distributions xfUpdate , that therefore must be implemented in any derived class. A reasonable number of such classes come with the program: Parton Distributions For protons: Parton Distributions Parton Distributions Parton Distributions LHAPDF provides a plugin interface class to the LHAPDF library Parton Distributions Wha05,Buc15. It loads either the Parton Distributions LHAPDF5 or Parton Distributions LHAPDF6 class. Parton Distributions Parton Distributions GRV94L gives the GRV 94 L parametrization Parton Distributions Glu95. Parton Distributions Parton Distributions CTEQ5L gives the CTEQ 5 L parametrization Parton Distributions Lai00. Parton Distributions Parton Distributions MSTWpdf gives the four distributions of the MRST/MSTW group that have been implemented. Parton Distributions Parton Distributions CTEQ6pdf gives the six distributions of the CTEQ/CT group that have been implemented. Parton Distributions Parton Distributions NNPDF gives four distributions from the NNPDF 2.3 QCD+QED sets that have been implemented. Parton Distributions Parton Distributions LHAGrid1 can read and use files in the LHAPDF6 lhagrid1 format, assuming that the same x grid is used for all Q subgrids. Results are not exactly identical with LHAPDF6, owing to different interpolation. Parton Distributions Parton Distributions nPDF, Isospin, EPS09 three classes allowing to introduce nuclear modifications to a specified proton PDF. The first is base class for the other two, where Parton Distributions Isospin only provides the appropriate mix of protons and isospin-conjugate neutrons, while Parton Distributions EPS09 also contains nuclear modification factors Parton Distributions Esk09. The current default is NNPDF 2.3. Parton Distributions For charged pions: Parton Distributions Parton Distributions Parton Distributions GRVpiL gives the GRV 1992 pi+ parametrization. Parton Distributions For Pomerons (used to describe diffraction): Parton Distributions Parton Distributions Parton Distributions PomFix gives a simple but flexible Parton Distributions Q2 -independent parametrization. Parton Distributions Parton Distributions PomH1FitAB gives the H1 2006 Fit A and Fit B parametrizations. Parton Distributions Parton Distributions PomH1Jets gives the H1 2007 Jets parametrization. Parton Distributions For photons: Parton Distributions Parton Distributions Parton Distributions CJKL gives the CJKL parametrization Parton Distributions Cor03. Parton Distributions Parton Distributions GammaPoint gives the trivial distribution of a pointlike (i.e. unresolved) photon. Parton Distributions For charged leptons (e, mu, tau) and the proton: Parton Distributions Parton Distributions Parton Distributions Lepton gives a QED parametrization Parton Distributions Kle89. In QED there are not so many ambiguities, so here one set should be enough. On the other hand, there is the problem that the lepton-inside-lepton pdf is integrably divergent for Parton Distributions x &rarr; 1 , which gives numerical problems. Like in PYTHIA 6, the pdf is therefore made to vanish for Parton Distributions x > 1 - 10^{-10} , and scaled up in the range Parton Distributions 1 - 10^{-7} < x < 1 - 10^{-10} in such a way that the total area under the pdf is preserved. Parton Distributions Parton Distributions LeptonPoint gives the trivial distribution of a pointlike (i.e. unresolved) charged lepton. Parton Distributions Parton Distributions EPAexternal provides an external photon flux to study photoproduction with different fluxes. Still optimized for lepton beams, but also other fluxes can be studied. Parton Distributions Parton Distributions Lepton2gamma gives the convolution between photon flux from leptons and photon PDFs. Parton Distributions Parton Distributions ProtonPoint gives the equivalent photon spectrum of an unresolved proton. Parton Distributions For neutrinos: Parton Distributions Parton Distributions Parton Distributions NeutrinoPoint is the only method, so there is no choice. Analogously to Parton Distributions LeptonPoint it gives the distribution of a pointlike (i.e. unresolved) neutrino. A difference, however, is that neutrinos always are lefthanded, so there is no need to average over incoming spin states. Since the PYTHIA formalism assumes unpolarized beams, and thus implicitly includes a 1/2 for incoming fermions, the Parton Distributions NeutrinoPoint PDF is normalized to 2 rather than 1 to compensate for this. Parton Distributions There is another method, Parton Distributions isSetup() , that returns the base-class boolean variable Parton Distributions isSet. This variable is initially Parton Distributions true , but could be set Parton Distributions false if the setup procedure of a PDF failed, e.g. if the user has chosen an unknown PDF set. Parton Distributions The MRST/MSTW, CTEQ/CT, NNPDF and H1 PDF routines are based on the interpolation in Parton Distributions (x, Q) grids. The grid files are stored in the Parton Distributions xmldoc subdirectory, like settings and particle data. Only PDF sets that will be used are read in during the initialization stage. Just as input streams can be used to initialize the settings and particle data, so can the individual PDFs be constructed.  See the header files for explicit constructor descriptions."},{"name":"PDF Selection","link":"PDFSelection.html","text":"PDF Selection PDF Selection PDF Selection This page contains several subsections. The first deals with how to pick the parton distribution set for protons, including from LHAPDF, to be used for all proton and antiproton beams. The second is a special option that allows a separate PDF set to be used for the hard process only, while the first choice would still apply to everything else. The third introduces the possibility of nuclear modifications. Further sections give access to pion, Pomeron and photon PDF's, respectively, the second being used to describe diffractive systems. Towards the end comes the possibility to switch off the lepton 'parton density', and photons from lepton beams. More information on PDF classes is found PDF Selection here. PDF Selection Parton densities for protons PYTHIA comes with a reasonably complete list of recent LO fits built-in, both ones within the normal LO context and ones with modifications for better matching to event generators. In addition two older sets are included for backwards reference (most studies to date are based on CTEQ 5L). Therefore there is no real need to link any external PDF sets. PDF Selection If the internal PDF sets are not sufficient, the PDF Selection LHAPDF library PDF Selection Wha05,Buc15 gives you access to a much wider selection. PDF Selection Warning 1: owing to previous problems with the behaviour of PDF's beyond the PDF Selection x and PDF Selection Q^2 boundaries of a set, you should only use LHAPDF PDF Selection version 5.3.0 or later. PDF Selection Warning 2: the behaviour of the LHAPDF sets need not be identical with the implementation found in PYTHIA. Specifically we are aware of the following points that may influence a comparison. PDF Selection (a) CTEQ 5L in PYTHIA is the parametrization, in LHAPDF the grid interpolation. PDF Selection (b) MRST LO* and LO** in PYTHIA is based on an updated edition, where one makes use of the expanded MSTW grid format, while LHAPDF is based on the original smaller grid. PDF Selection (c) The CTEQ 6 and CT09MC sets in PYTHIA are frozen at the boundaries of the grid, by recommendation of the authors, while LHAPDF also offers an option with a smooth extrapolation outside the grid boundaries. PDF Selection If you do not want to install LHAPDF, it is possible to use LHAPDF6 data grids natively in PYTHIA. This is based on a simplified implementation of interpolation in a PDF Selection .dat 'lhagrid1' file, and so does not give fully identical results, and also is not foolproof. PDF Selection The selection of parton densities is made once and then is propagated through the program. It is essential to make an informed choice, for several reasons PDF Selection Kas10 : PDF Selection Warning 1: the choice of PDF set affects a number of properties of events. A change of PDF therefore requires a complete retuning e.g.  of the multiparton-interactions model for minimum-bias and underlying events. Conversely, the PDF Selection pp physics tunes are all made for a specific PDF tune, and the chosen (or default) tune will therefore overwrite the PDF Selection PDF:pSet default value described below. If you want to set PDF Selection PDF:pSet differently it should be done PDF Selection after the PDF Selection Tune:pp value, if any, has been set. PDF Selection Warning 2: People often underestimate the differences between different sets on the market. The sets for the same order are constructed to behave more or less similarly at large PDF Selection x and PDF Selection Q^2 , while the multiparton interactions are dominated by the behaviour in the region of small PDF Selection x and PDF Selection Q^2. A good PDF parametrization ought to be sensible down to PDF Selection x = 10^-6 ( PDF Selection x = 10^-7 ) and PDF Selection Q^2 = 1 GeV^2 for Tevatron (LHC) applications. Unfortunately there are distributions on the market that completely derail in that region. The PDF Selection main51.cc and PDF Selection main52.cc programs in the PDF Selection examples subdirectory provide some examples of absolutely minimal sanity checks before a new PDF set is put in production. PDF Selection Warning 3: NLO and LO sets tend to have quite different behaviours, e.g. NLO ones have less gluons at small x, which then is compensated by positive corrections in the NLO matrix elements. Therefore do not blindly assume that an NLO tune has to be better than an LO one when combined with the LO matrix elements in PYTHIA. There are explicit examples where such thinking can lead you down the wrong alley, especially if you study low- PDF Selection pT physics. A longer discussion on this point can be found in PDF Selection this note. In the list below you should therefore be extra cautious when using set 6 or set 9. PDF Selection If you want to use PDF's not found in LHAPDF, or you want to interface LHAPDF another way, you have full freedom to use the more generic PDF Selection interface options. PDF Selection Parton densities for protons in the hard process The above options provides a PDF set that will be used everywhere: for the hard process, the parton showers and the multiparton interactions alike. As already mentioned, therefore a change of PDF should be accompanied by a PDF Selection complete retuning of the whole MPI framework, and maybe more. There are cases where one may want to explore different PDF options for the hard process, but would not want to touch the rest. If several different sets are to be compared, a simple reweighting based on the PDF Selection originally used flavour, PDF Selection x , PDF Selection Q^2 and PDF values may offer the best route. The options in this section allow a choice of the PDF set for the hard process alone, while the choice made in the previous section would still be used for everything else. The hardest interaction of the minimum-bias process is part of the multiparton-interactions framework and so does not count as a hard process here. PDF Selection Of course it is inconsistent to use different PDF's in different parts of an event, but if the PDF Selection x and PDF Selection Q^2 ranges mainly accessed by the components are rather different then the contradiction would not be too glaring. Furthermore, since standard PDF's are one-particle-inclusive we anyway have to 'invent' our own PDF modifications to handle configurations where more than one parton is kicked out of the proton PDF Selection Sjo04. PDF Selection The PDF choices that can be made are the same as above, so we do not repeat the detailed discussion. PDF Selection Nuclear modifications of parton densities PDF Selection Nuclear modifications of the PDFs are implemented for the hard-process generation only. The final PDF value is calculated for an average nucleon within given nucleus, i.e. PDF Selection f_i^A(x,Q^2) = (Z/A)*f_i^(p/A) + ((A-Z)/A)*f_i^(n/A) , where PDF Selection A is the nuclear mass number and PDF Selection Z the number of protons, set using the PDG code for nucleus. The neutron PDFs are obtained by applying isospin symmetry, e.g. PDF Selection f_u^(n/A)(x,Q^2) = f_d^(p/A)(x,Q^2). The nuclear PDFs implemented provide only the nuclear modification so the full PDF is calculated by multiplying the selected free proton PDF with the modification. PDF Selection PDF Selection Parton densities for pions The parton densities of the pion are considerably less well known than those of the proton. There are only rather few sets on the market, and none particularly recent. Only one comes built-in, but others can be accessed from LHAPDF. Input parametrizations are for the PDF Selection pi+. >From this the PDF Selection pi- is obtained by charge conjugation and the PDF Selection pi0 from averaging (half the pions have PDF Selection d dbar valence quark content, half PDF Selection u ubar. PDF Selection Much of the switches are taken over from the proton case, with obvious modifications; therefore the description is briefer. Currently we have not seen the need to allow separate parton densities for hard processes. When using LHAPDF the PDF Selection PDF:extrapolateLHAPDF switch of the proton also applies to pions. PDF Selection Parton densities for Pomerons The Pomeron is introduced in the description of diffractive events, i.e. a diffractive system is viewed as a Pomeron-proton collision at a reduced CM energy. Here the PDF's are even less well known. Most experimental parametrizations are NLO, which makes them less well suited for Monte Carlo applications. Furthermore note that the momentum sum is arbitrarily normalized to a non-unity value. PDF Selection Parton densities for photons Photon PDFs describe the partonic content of the resolved photons and can be used to generate any process initiated by quarks and gluons. PDF Selection There are several PDF sets available for photons, although there have not been much activity recently. Currently one internal set is included, but more sets are available from LHAPDF5. The sets from LHAPDF5 can only be used as PDFs in the hard process (see PDF Selection PDF:GammaHardSet below). In case of photons the parton shower and beam remnant generation require additional methods that are provided only for internal sets. Currently no photon PDFs have been included in LHAPDF6. PDF Selection Parton densities for leptons For electrons/muons/taus there is no need to choose between different parametrizations, since only one implementation is available, and should be rather uncontroversial (apart from some technical details). However, insofar as e.g. PDF Selection e^+ e^- data often are corrected back to a world without any initial-state photon radiation, it is useful to have a corresponding option available here. PDF Selection Neutrinos are always taken pointlike. Do note that the phase space selection machinery currently does not allow one resolved and one unresolved lepton beam. For lepton-neutrino collisions to work you must therefore set PDF Selection PDF:lepton = off. PDF Selection Photons from lepton beams Lepton beams can emit photons and therefore may have partonic content. The PDFs describing these can be obtained by convoluting the photon flux with the selected photon PDFs. The photon flux is modelled according to equivalent photon approximation (EPA) which gives the flux of bremsstrahlung photons. PDF Selection Incoming parton selection There is one useful degree of freedom to restrict the set of incoming quark flavours for hard processes. It does not change the PDF's as such, only which quarks are allowed to contribute to the hard-process cross sections. Note that separate but similarly named modes are available for multiparton interactions and spacelike showers."},{"name":"Phase Space Cuts","link":"PhaseSpaceCuts.html","text":"Phase Space Cuts Phase Space Cuts Phase Space Cuts Phase Space Cuts PhaseSpace is base class for all hard-process phase-space generators, either generic Phase Space Cuts 2 &rarr; 1 or Phase Space Cuts 2 &rarr; 2 ones, or specialized ones like for elastic and diffractive scattering. Phase Space Cuts In it, it is possible to constrain the kinematics of most processes. (Exceptions are 'soft physics', i.e. minimum bias, elastic and diffractive processes. The Coulomb singularity for elastic scatterings, if simulated, is Phase Space Cuts handled separately .) These constraints apply in the rest frame of the hard subprocess, and topologies normally would be changed e.g. by subsequent showering activity. The cross section of a process is adjusted to only correspond to the allowed phase space. Phase Space Cuts The more particles in the final state, the more cuts could be applied. Here we have tried to remain with the useful minimum, however. More generic possibilities could be handled by the Phase Space Cuts user hooks facility. Phase Space Cuts Cuts in all processes Phase Space Cuts Cuts in Phase Space Cuts 2 &rarr; 1 processes When a resonance Phase Space Cuts id is produced, the Phase Space Cuts Phase Space Cuts mMin(id) and Phase Space Cuts Phase Space Cuts mMax(id) methods restrict the allowed mass range of this resonance. Therefore the allowed range is chosen to be the overlap of this range and the Phase Space Cuts mHatMin to Phase Space Cuts mHatMax range above. Most resonances by default have no upper mass limit, so effects mainly concern the lower limit. Should there be no overlap between the two ranges then the process will be switched off. Phase Space Cuts Cuts in Phase Space Cuts 2 &rarr; 2 processes Phase Space Cuts For a particle with a Breit-Wigner shape selected, according to the rules above and to the rules of the particle species itself, the Phase Space Cuts Phase Space Cuts mMin(id) and Phase Space Cuts Phase Space Cuts mMax(id) methods restrict the allowed mass range of the particle, just like for the Phase Space Cuts 2 &rarr; 1 processes. Phase Space Cuts Cuts in Phase Space Cuts 2 &rarr; 3 processes There are two main classes of Phase Space Cuts 2 &rarr; 3 processes. One is the processes such as Phase Space Cuts WW/ZZ -fusion Higgs production, i.e. Phase Space Cuts q q &rarr; q q H , where there are no special singularities associated with two partons in the final state being collinear, or even for Phase Space Cuts pT &rarr; 0. For this class, no further cuts have been introduced than those already available for Phase Space Cuts 2 &rarr; 2 processes. Specifically, for now all three are restricted exactly the same way by Phase Space Cuts pTHatMin and Phase Space Cuts pTHatMax. As above, Breit-Wigner mass ranges can be restricted. Phase Space Cuts The other Phase Space Cuts 2 &rarr; 3 event class is QCD processes, such as Phase Space Cuts g g &rarr; g g g. Here the soft and collinear singularities play a major role, and the phase space generation and cuts have been adapted to this. For this class, an alternative set of cuts is used, as outlined in the following. First of all the three outgoing partons are ordered in falling Phase Space Cuts pT , i.e. Phase Space Cuts pT_3 > pT_4 > pT_5 (where the labeling 3, 4, 5 of the outgoing partons is random, i.e. unrelated to the order specified in the process name). The allowed ranges of Phase Space Cuts pT_3 and Phase Space Cuts pT_5 can be specified, but obviously Phase Space Cuts pT_3max >= pT_5max and Phase Space Cuts pT_3min >= pT_5min. The Phase Space Cuts pT_4 is not constrained explicitly, but is constructed from the vector sum of Phase Space Cuts pT_3 and Phase Space Cuts pT_5 , subject to the constraint that it has to lie between the two in magnitude. While the Phase Space Cuts pT cuts take care of singularities collinear with the incoming beams, it is also necessary to handle final-state singularities, when two outgoing partons become collinear. This is done by requiring a minimal separation in Phase Space Cuts R , where Phase Space Cuts R^2 = (Delta eta)^2 + (Delta phi)^2. Finally, a note about efficiency. The QCD Phase Space Cuts 2 &rarr; 3 phase space is not set up to explicitly include Phase Space Cuts mHat as one of the basic variables. Such a cut is only done after a phase space point is already selected, which means that a narrow mass choice will slow down the program appreciably. Also narrow Phase Space Cuts pT_3 and Phase Space Cuts pT_5 bins are likely to give inefficient generation, if it gives rise to significant indirect restrictions on Phase Space Cuts pT_4. Phase Space Cuts Cuts for a second hard process If you use the machinery that allows the generation of a specified Phase Space Cuts second hard process then, by default, the same phase space cuts will be used for it as listed above. Optionally, however, you may use a second set of cuts, as described here. In this context 'first' and 'second' is merely a technical distinction; you are welcome e.g. to pick Phase Space Cuts pT ranges such that the second interaction always has a larger Phase Space Cuts pT than the first. Phase Space Cuts Generation strategy and documentation During the initialization stage a simplified function is found, that is intended to be above the true cross-section behaviour over the whole of phase space. It is chosen to be easily integrable and invertible. That way a trial phase space point can be selected according this simple function, and then be accepted by the ratio of true to the simple function. For a good efficiency the ratio should be close to unity,  yet never above it. This constrains the absolute normalization of the simple function. The initial search may fail to find the phase space point where the true-to-simple ratio is maximal, however. This then can lead to subsequent maximum violations, where the ratio is above unity. Two alternative strategies are implemented to handle such situations, see below. Phase Space Cuts Reweighting of Phase Space Cuts 2 &rarr; 2 processes Events normally come with unit weight, i.e. are distributed across the allowed phase space region according to the appropriate differential cross sections. Sometimes it may be convenient to have an uneven distribution of events. The classical example here is that many cross sections drop off with transverse momentum Phase Space Cuts pT , such that few events are generated at large Phase Space Cuts pT scales. If one wants to plot the Phase Space Cuts pT cross section, and all that comes with it, the statistical error will then degrade with increasing Phase Space Cuts pT where fewer events end up. Phase Space Cuts One solution is to split the full Phase Space Cuts pT range into several separate subranges, where the events of each subsample obtains a different overall normalization. Specifically, if you generate a comparable number of events in each Phase Space Cuts pT bin, such that larger Phase Space Cuts pT bins are oversampled, these bins come with a correspondingly reduced overall weight, that needs to be taken into account when the bins are combined. The other is to have a continuously increasing oversampling of events at larger Phase Space Cuts pT scales, which is compensated by a continuously decreasing weight for the event. Phase Space Cuts Both of these solutions are supported. Specifically, for Phase Space Cuts 2 &rarr; 2 processes, the Phase Space Cuts pTHat scale offers a convenient classification of the event. (Of course, two events starting out from the same Phase Space Cuts pTHat scale will experience different parton shower evolutions, etc., and may therefore look quite different at the end.) The two cuts Phase Space Cuts PhaseSpace:pTHatMin and Phase Space Cuts PhaseSpace:pTHatMax therefore offers a way to slice a Phase Space Cuts pT range into subranges, see e.g. Phase Space Cuts main08.cc. Alternatively the Phase Space Cuts User Hooks machinery offers the possibility for you to define your own reweighting of phase space sampling, with a corresponding event weight, with Phase Space Cuts UserHooks::canBiasSelection and related methods. Phase Space Cuts As a simplified option, we here offer the possibility to bias the Phase Space Cuts 2 &rarr; 2 sampling by a power of Phase Space Cuts pTHat , then with events having a weight the inverse of this. This fast track will only work under a number of strict conditions, implemented to reduce the risk of abuse. (Whereas a Phase Space Cuts UserHooks setup can be more flexible.) Specifically it will work if only high- Phase Space Cuts pT Phase Space Cuts 2 &rarr; 2 processes already implemented in PYTHIA are requested, notably the Phase Space Cuts HardQCD ones. That is, you cannot mix with Phase Space Cuts 2 &rarr; 1 or Phase Space Cuts 2 &rarr; 3 processes, nor with external processes (notably Les Houches input) or Phase Space Cuts SoftQCD ones, and  you cannot use the option to define a Phase Space Cuts second hard process in the same event. Furthermore you have to be careful about the choice of Phase Space Cuts PhaseSpace:pTHatMin , since a Phase Space Cuts pTHat = 0 event would come with an infinite weight."},{"name":"Photoproduction","link":"Photoproduction.html","text":"Photoproduction Photoproduction Photoproduction Photoproduction Interactions involving one or two photons, either in photon-photon or photon-hadron collision or photons emitted from lepton beams. Includes both direct and resolved contributions and also soft QCD and MPIs for events with resolved photons. Only (quasi-)real photons are considered so virtuality of the photons is restricted. The PDF set for resolved photons is selected in the Photoproduction PDF selection. This page describes some of the special features related to these collisions and introduces the relevant parameters. Photoproduction Types of photon processes Photoproduction Photons can be either resolved or act as point-like particles (direct). Therefore for a photon-photon interaction there are four different contributions, resolved-resolved, resolved-direct, direct-resolved and direct-direct. In case of photon-hadron collisions there are two contributions. With the default value of the parameter below, a mix of relevant contributions is generated but each process type can also be generated individually. Note that for photon-hadron collisions the code for direct contribution depends on which of the beams is photon. The sample main program Photoproduction main69.cc demonstrates different possibilities. Photoproduction The type of the generated process can be obtained from Photoproduction Info class with method Photoproduction int Info::photonMode() which follows the conventions above. Photoproduction Resolved photon Photoproduction Photons can either interact directly as an unresolved particle or as a hadronic state ('Vector Meson Dominance'). In the latter case the hard process can be simulated using PDFs to describe the partonic structure of the resolved photon. The evolution equations for photons include an additional term that corresponds to Photoproduction gamma &rarr; q qbar splittings. Due to this, the PDFs are somewhat different for photons than for hadrons and some parts of event generation need special attention. Photoproduction Process-level generation Photoproduction Due to the additional term in the evolution equations the quarks in a resolved photon may carry a very large fraction Photoproduction (x~1) of the photon momentum. In these cases it may happen that, after the hard process, there is no energy left to construct the beam remnants. This is true especially if a heavy quark is taken out from the beam and a corresponding massive antiquark needs to be added to the remnant system to conserve flavour. Even though these events are allowed based on the PDFs alone, they are not physical and should be rejected. Therefore some amount of errors can be expected when generating events close to the edge of phase space, e.g. when collision energy is low. Photoproduction Spacelike showers Photoproduction The parton showers are generated according to the DGLAP evolution equations. Due to the Photoproduction gamma &rarr; q qbar splitting in the photon evolution, a few modifications are needed for the ISR algorithm. Photoproduction Photoproduction The additional term corresponds to a possibility to find the original beam photon during the backwards evolution, which is added to the QED part of the spacelike shower evolution. If this splitting happens there is no need to construct the beam remnants for the given beam. Photoproduction The heavy quark production threshold with photon beams is handled in a similar manner as for hadrons, but now the splitting that is forced to happen is Photoproduction gamma &rarr; Q Qbar. Photoproduction As the splittings in backwards evolution increases the Photoproduction x of the parton taken from the beam, the splittings can lead to a situation where there is no room left for massive beam remnants. To make sure that the required  remnants can be constructed, splittings that would not leave room for the beam remnants are not allowed. Photoproduction MPIs with photon beams Photoproduction Multiparton interactions with resolved photon beams are generated as with hadron beams. The only difference follows again from the additional Photoproduction gamma &rarr; q qbar splittings where the beam photon becomes unresolved. If this splitting happens during the interleaved evolution for either of the photon beams no further MPIs below the branching scale Photoproduction pT are allowed since the photon is not resolved anymore. Photoproduction If there have been multiple interactions and a Photoproduction gamma &rarr; q qbar splitting occur, the kinematics of this branching are not constructed in the spacelike shower. Instead the Photoproduction pT scale of the branching is stored and the relevant momenta are then fixed in the beam remnant handling. Therefore the status codes for the partons related to this splitting actually refer to beam remnants. Photoproduction If there are no MPIs before the Photoproduction gamma &rarr; q qbar splitting, this splitting is constructed in the spacelike shower in the usual way, but the mother beam photon is not added to the event record, since a copy of it already exists at the top of the event record. This is unlike the documentation of other ISR splittings, where the mother of the branching is shown, but consistent with the photon not being added (a second time) for events that contain several MPIs. Optionally the photon can be shown, using the following flag. Photoproduction Based on comparisons with charged hadron production in photon-photon collision data from LEP, the default MPI parametrization tuned to proton-(anti)proton collisions produces too much hadrons from the additional interactions. Such differences are not surprising, given that the photon is less hadron-like than the proton, e.g. with less well developed PDFs, leaving less room for MPIs. Therefore a different parametrization for Photoproduction pT0(eCM) is used in case of photon-photon collisions, where the default values are tuned to the LEP data (a reference to this study will be added later). By default, a logarithmic dependence on Photoproduction eCM is used. Photoproduction Note: These parameters override the choices made in Photoproduction Multiparton Interactions when photon-photon collisions are generated. Photoproduction Alternatively, or in combination, a sharp cut can be used. Photoproduction A similar study for photon-hadron collisions will follow, current recommendation is to use value Photoproduction pT0Ref = 3.0 GeV set in Photoproduction Multiparton Interactions page. Photoproduction The total cross section for photon-photon collisions is paramerized as in Photoproduction Sch97. Approximate diffractive cross sections have been defined according to the assumed VMD contribution. Photoproduction Beam Remnants Photoproduction To construct the beam remnants, one should know whether the parton taken from the beam is a valence parton or not. The valence partons of a photon includes the partons that originate from Photoproduction gamma &rarr; q qbar splittings of the original beam photon and the valence partons from the hadron-like part of the PDF. In either case, the flavour of the valence quarks can fluctuate. Unfortunately the decomposition to the different components are typically not provided in the PDF sets and some further assumptions are needed to decide the valence content. Photoproduction When ISR is applied for photon beams it is possible to end up to the original beam photon during the evolution. Therefore there are three possibilities for the remnants: Photoproduction Photoproduction Remnants need to be constructed for both beams. Photoproduction Remnants are constructed only for one side. Photoproduction No need for remnants on either side. The last case is the simplest as all the partons in the event are already generated by the parton showers. In the first case the remnants and primordial Photoproduction kT are constructed similarly as for normal hadronic interactions Photoproduction Sjo04. For the second case the momenta of the remnant partons can not be balanced between the two beams as the kinematics of the other side are already fixed. In these cases the momenta are balanced between the scattered system and the remnants. Photoproduction Since the primordial Photoproduction kT increases the invariant mass of the remnants and the scattered system, it may again happen that there is no room for the remnant partons after Photoproduction kT is added, so the kinematics can not be constructed. In this case new values for Photoproduction kT are sampled. If this does not work, a new shower is generated and in some rare cases the parton-level generation fails and the hard process is rejected. The inclusion of additional MPIs increases the invariant mass of the remnants and takes more momentum from the beam particles. Even though the MPIs that would not leave enough room for the remnants are rejected, these can still lead to a situation where the kinematics cannot be constructed due to the added primordial Photoproduction kT. This may cause some amount of errors especially when the invariant mass of Photoproduction gamma-gamma system is small. Photoproduction Photons from lepton beams Photoproduction Interaction of photons from leptons including photon-photon interactions in lepton-lepton collisions and photon-hadron lepton-hadron collisions can be set up as described in Photoproduction PDF selection. Since the current framework can handle only (quasi-)real photons, a upper limit for the photon virtuality needs to be set. This can be done with the parameter Photoproduction Photon:Q2max. The upper limit for virtuality will set also the upper limit for the Photoproduction k_T of the photon, which in turn will be the same as the Photoproduction k_T of the scattered lepton. Also some other cuts can be imposed. Photoproduction MPIs with lepton beams Photoproduction The invariant mass of Photoproduction gamma-gamma or Photoproduction gamma-hadron system from lepton beams will vary. Therefore, to generate MPIs and non-diffractive events in Photoproduction gamma-gamma and Photoproduction gamma-hadron collisions from lepton beams, the MPI framework is initialized with five values of Photoproduction W from Photoproduction Photon:Wmin to Photoproduction Photon:Wmax. The parameter values are then interpolated for the sampled Photoproduction W."},{"name":"POWHEG Merging","link":"POWHEGMerging.html","text":"POWHEG Merging POWHEG Merging POWHEG Merging POWHEG POWHEG Merging Nas04 in its character is very much like a parton shower, with a Sudakov factor arising from the ordering of emissions. Both POWHEG-BOX POWHEG Merging Ali10 and PYTHIA are based on a combined evolution of ISR and FSR in POWHEG Merging pT -related 'hardness' variables, and thus are kindred spirits. The hardness definitions differ, however. Frequently we will therefore need to distinguish between POWHEG-hardness and PYTHIA-hardness in the following. POWHEG Merging The simplest merging solution, of continuing the PYTHIA shower at the LHA POWHEG Merging scale hardness where POWHEG leaves off, is obtained if you set POWHEG Merging SpaceShower:pTmaxMatch = 1 and POWHEG Merging TimeShower:pTmaxMatch = 1. But then mismatches are bound to happen: some regions may be doublecounted, while others may not be counted at all. Depending on the choice of hardness, such mismatches might be small. POWHEG Merging There are no guarantees, however, so a (hopefully) more accurate merging scheme is coded up in the POWHEG Merging include/Pythia8Plugins/PowHegHooks.h file, with a realistic user example in the POWHEG Merging examples/main31 files. Here we would like to discuss the (POWHEG-specific) input settings for POWHEG Merging main31.cc , see POWHEG Merging main31.cmnd , and attempt to give some recommendations on how to use the main program to perform a matching of POWHEG-BOX with PYTHIA 8. POWHEG Merging POWHEG-BOX inputs contain Born-like events (with no resolved emission) and Real-type events (containing an additional parton). The mismatch between POWHEG-hardness and PYTHIA-hardness can be minimised if the PYTHIA shower knows POWHEG Merging a) The POWHEG-hardness criterion (through which the separation of Born- and Real-like events is defined), and POWHEG Merging b) The POWHEG-hardness value (which separates Born- and Real-like events). POWHEG Merging If these definitions are known, then PYTHIA can fill missing phase space regions through vetoed showering: let the shower sweep over the full phase space, using its PYTHIA-hardness ordering, and use the POWHEG-hardness to veto those emissions that POWHEG should already have covered. This is only possible since the POWHEG-hardness criterion and the shower ordering criterion are very similar. In the more general case a truncated showering would be needed POWHEG Merging Nas04. POWHEG Merging For vetoed showering, it is necessary to define the POWHEG-hardness criterion. In the presence of multiple partons, the definition quickly becomes complicated, and allows for different choices. Similar decisions have already been made in the implementation of POWHEG, one example being the choice in defining which 'hardness value' is transferred as POWHEG-hardness, e.g. by deciding if the 'singular regions' of the FKS or the CS approach are used. If the POWHEG-hardness definition were to be changed, or extended to more objects, the POWHEG Merging PowhegHooks.h code would need to be modified accordingly. POWHEG Merging The merging code is designed to be very flexible, and allows access to many possible choices. However, this flexibility means that many parameters can be changed, potentially leading to confusion. Thus, recommendations might prove helpful. All mistakes and inaccuracies rest with the author. POWHEG Merging We recommend the usage of vetoed showers. This means using POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:veto = 1 POWHEG Merging This means that PYTHIA will sweep over the full phase space, and apply a veto on parton shower emissions for which the POWHEG-hardness separation between radiator and emission is above the POWHEG-hardness value of the current input event. The variation POWHEG Merging POWHEG:veto = 0 can be used to assess how much phase space is under- or double-counted. POWHEG Merging To define the POWHEG-hardness criterion, use POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:pTdef = 1 POWHEG Merging Other values can be used by experts to assess variations. POWHEG Merging Both POWHEG-BOX and PYTHIA 8 generate emissions through a parton shower step, meaning that both programs have a clear definition of a radiator that emits particles, which is very similar (if not identical). To fix the ambiguity if the radiator or the emitted particle should be called 'the emission', use POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:emitted = 0 POWHEG Merging More complicated choices can be used by experts. For instance, use POWHEG Merging POWHEG:emitted = 2 to check the POWHEG-hardness of both radiator and emitted. POWHEG Merging To exhaustively fix the criterion by which to veto parton shower emissions, it is important to decide which partons/parton pairs are used to calculate the POWHEG hardness of a PYTHIA 8 emission. The minimal and recommended choice is POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:pTemt = 0 POWHEG Merging This means that only the POWHEG hardness with respect to the radiating leg is checked, and recoil effects are neglected. This prescription should be very similar to how a hardness value is assigned to a Real-type event in the POWHEG-BOX, since in the (implementation of FKS in the) POWHEG-BOX, initial state splittings only have singular regions with the radiating initial state parton, and final state splittings only have singular regions with respect to the radiating final state line. Other choices of POWHEG Merging POWHEG:pTemt are available. A warning is that the impact of changes can be huge, particularly for inputs with many jets. Other choices therefore should only be made by experts, and a high degree of caution is advised. POWHEG Merging It is furthermore necessary to decide on a value of the hardness criterion. POWHEG-BOX transfers this value in the POWHEG Merging SCALUP member of Les Houches Events, and we recommend using this value by setting POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:pThard = 0 POWHEG Merging As a variation, in order to estimate the uncertainty due this choice of POWHEG-hardness definition, it can be useful to also check POWHEG Merging POWHEG:pThard = 2. This will recalculate the POWHEG-hardness value as promoted in POWHEG Merging Ole12. POWHEG Merging You need to decide how many emissions the vetoed shower should check after an allowed emission has been constructed. If the hardness definitions in POWHEG-BOX and PYTHIA 8 where identical, all checking could be stopped after the first allowed PS emission. To be prudent, we recommend setting POWHEG Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; POWHEG Merging POWHEG:vetoCount = 3 POWHEG Merging which will then check up to three allowed emissions. Higher values of POWHEG Merging POWHEG:vetoCount have not lead to visible differences for the processes which have been tested. POWHEG Merging Finally, for many POWHEG processes, the Sudakov effects from electroweak emissions (here we are concerned mainly with photon emissions, but this could apply also to W/Z emissions) are not included. This effect can be investigated using POWHEG Merging POWHEG:QEDveto = 0,1, or POWHEG Merging 2. For the default  value of POWHEG Merging POWHEG:pTemt = 0 , only POWHEG Merging POWHEG:QEDveto = 2 has any effect. For this choice, a hard photon and subsequent QCD radiation is retained. In many cases, particularly when the Born contributions are small, the choice has little effect. POWHEG Merging The modes Note that the modes have generally been defined with several default values below corresponding to the 'off' state, and thus do not agree with the recommended values described above."},{"name":"Process Selection","link":"ProcessSelection.html","text":"Process Selection Process Selection Process Selection There is no way PYTHIA could contain all processes of interest, neither in terms of potential physics topics nor in terms of high-multiplicity final states. What exists is a reasonably complete setup of all Process Selection 2 &rarr; 1 and Process Selection 2 &rarr; 2 processes within the Standard Model, plus some examples of processes beyond that, again for low multiplicities. Combined with the PYTHIA parton showers, this should be enough to get a flying start in the study of many physics scenarios. Other processes could be fed in via the Process Selection Les Houches Accord or be implemented as a Process Selection Semi-Internal Process. In the latter case the existing processes would act as obvious templates. Process Selection By default all processes are switched off. You should switch on those you want to simulate. This may be done at two (occasionally three) levels, either for each individual process or for a group of processes. That is, a process is going to be generated either if its own flag or its group flag is on. There is no built-in construction to switch on a group and then switch off a few of its members. Process Selection Each process is assigned an integer code. This code is not used in the internal administration of events (so having the same code for two completely different processes would not be a problem), but only intended to allow a simpler user separation of different processes. Also the process name is available, as a string. Process Selection To ease navigation, the list of processes has been split into several separate pages, by main topic. The classification is hopefully intuitive, but by no means unambiguous. For instance, essentially all processes involve QCD, so the 'QCD processes' are the ones that only involve QCD. (And also that is not completely true, once one includes all that may happen in multiparton interactions.) On these separate pages also appear the settings that are completely local to that particular process class, but not the ones that have a broader usage. Process Selection Process Selection QCD Processes QCD processes fall in two main categories: soft and hard. The soft ones contain elastic, diffractive and 'minimum-bias' events, together covering the total cross section. Hard processes are the normal Process Selection 2 &rarr; 2 ones, including charm and bottom production. Process Selection Reserved code range: 101 - 199. Process Selection Process Selection Electroweak Processes Prompt-photon, Process Selection gamma^*/Z^0 and Process Selection W^+- production, plus a few processes with Process Selection t -channel boson exchange. Process Selection Reserved code range: 201 - 299. Process Selection Process Selection Onia Processes Colour singlet and octet production of charmonium and bottomonium. Process Selection Reserved code range: 401 - 499 for charmonium and 501 - 599 for bottomonium. Process Selection Process Selection Top Processes Top production, singly or doubly. Process Selection Reserved code range: 601 - 699. Process Selection Process Selection Fourth-Generation Processes Production of hypothetical fourth-generation fermions. Process Selection Reserved code range: 801 - 899. Process Selection Process Selection Higgs Processes Higgs production, within or beyond the Standard Model. See section on Left-Right-Symmetry processes for doubly charged Higgs bosons. Process Selection Reserved code range: 901 - 999 for a Standard Model Higgs and 1001 - 1199 for MSSM Higgs bosons. Process Selection Process Selection SUSY Processes Production of supersymmetric particles, currently barely begun. Process Selection Reserved code range: 1001 - 2999. (Whereof 1001 - 1199 for Higgs bosons; see above.) Process Selection Process Selection New-Gauge-Boson Processes Production of new gauge bosons such as Process Selection Z' and Process Selection W'. Process Selection Reserved code range: 3001 - 3099. Process Selection Process Selection Left-Right-Symmetry Processes Production of righthanded Process Selection Z_R and Process Selection W_R bosons and of doubly charged Higgs bosons. Process Selection Reserved code range: 3101 - 3199. Process Selection Process Selection Leptoquark Processes Production of a simple scalar leptoquark state. Process Selection Reserved code range: 3201 - 3299. Process Selection Process Selection Compositeness Processes Production of excited fermion states and contact-interaction modification to interactions between fermions (excluding technicolor; see below). Process Selection Reserved code range: 4001 - 4099. Process Selection Technicolor Processes Production of technicolor particles and modifications of QCD processes by technicolor interactions. Does not exist yet. Process Selection Reserved code range: 4101 - 4199. Process Selection Process Selection Hidden Valley Processes A scenario for the pair production of new particles with couplings under a new gauge group, with invisible gauge bosons. Radiation of these gauge bosons is included in the standard final-state parton shower. Process Selection Reserved code range: 4901 - 4999. Process Selection Process Selection Extra-Dimensional Processes A vast area, here represented by the production of a Randall-Sundrum excited graviton state and a Kaluza-Klein gluon, a Kaluza-Klein tower of Process Selection gamma/Z^0 excitations in one TeV^- sized extra dimension, several Large Extra Dimension processes, and a few related Unparticle processes. Process Selection Reserved code range: 5001 - 5099. Process Selection Process Selection Dark Matter Processes An area of increasing interest. Currently only represented by a few basic processes. Process Selection Reserved code range: 6001 - 6099."},{"name":"Program Flow","link":"ProgramFlow.html","text":"Program Flow Program Flow Program Flow Recall that, to first order, the event generation process can be subdivided into three stages: Program Flow Program Flow Initializaion. Program Flow The event loop. Program Flow Finishing. This is reflected in how the top-level Program Flow Pythia class should be used in the user-supplied main program, further outlined in the following. Since the nature of the run is defined at the initialization stage, this is where most of the PYTHIA user code has to be written. So as not to confuse the reader unduly, the description of initialization options has been subdivided into what would normally be used and what is intended for more special applications. Program Flow At the bottom of this webpage is a complete survey of all public Program Flow Pythia methods and data members, in a more formal style than the task-oriented descriptions found in the preceding sections. This offers complementary information. Program Flow Normal usage Program Flow Initialization Program Flow Program Flow Already at the top of the main program file, you need to include the proper header file Program Flow #include 'Pythia8/Pythia.h' To simplify typing, it also makes sense to declare Program Flow using namespace Pythia8; Program Flow Program Flow The first step is to create a generator object, e.g. with Program Flow Pythia pythia; It is this object that we will use from now on. Normally a run will only contain one Program Flow Pythia object. (But you can use several Program Flow Pythia objects, which then will be independent of each other.) Program Flow By default all output from Program Flow Pythia will be on the Program Flow cout stream, but a few methods do allow output to alternative streams or files. Program Flow Program Flow You next want to set up the character of the run. The pages under the 'Setup Run Tasks' heading in the index describe all the options available (with some very few exceptions, found on the other pages). The default values and your modifications are stored in two databases, one for Program Flow generic settings and one for Program Flow particle data. Both of these are initialized with their default values by the Program Flow Pythia constructor. The default values can then be changed, primarily by one of the two ways below, or by a combination of them. Program Flow a) You can use the Program Flow pythia.readString(string); method repeatedly to do a change of a property at a time. The information in the string is case-insensitive, but upper- and lowercase can be combined for clarity. The rules are that Program Flow (i) if the first nonblank character of the string is a letter it is assumed to contain a setting, and is sent on to Program Flow pythia.settings.readString(string) ; Program Flow (ii) if instead the string begins with a digit it is assumed to contain particle data updates, and so sent on to Program Flow pythia.particleData.readString(string) ; Program Flow (iii) if none of the above, the string is assumed to be a comment, i.e. nothing will be done. Program Flow In the former two cases, a warning is issued whenever a string cannot be recognized (maybe because of a spelling mistake). Program Flow Some examples would be Program Flow pythia.readString('TimeShower:pTmin = 1.0');    pythia.readString('111:mayDecay = false'); The Program Flow readString(string) method is intended primarily for a few changes. It can also be useful if you want to construct a parser for input files that contain commands both to PYTHIA and to other libraries. Program Flow Program Flow b) You can read in a file containing a list of those variables you want to see changed, with a Program Flow pythia.readFile(fileName); Each line in this file with be processes by the Program Flow readString(string) method introduced above. You can thus freely mix comment lines and lines handed on to Program Flow Settings or to Program Flow ParticleData. Program Flow This approach is better suited for more extensive changes than a direct usage of Program Flow readString(string) , and can also avoid having to recompile and relink your main program between runs. Program Flow It is also possible to read input from an Program Flow istream , by default Program Flow cin , rather than from a file. This may be convenient if information is generated on-the-fly, within the same run. Program Flow Changes are made sequentially in the order the commands are encountered during execution, meaning that if a parameter is changed several times it is the last one that counts. The two special Program Flow Program Flow Tune:ee and Program Flow Program Flow Tune:pp modes are expanded to change several settings in one go, but these obey the same ordering rules. Program Flow Program Flow Program Flow Next comes the initialization stage, where all remaining details of the generation are to be specified. There is one standard method to use for this Program Flow Program Flow pythia.init(); Program Flow with no arguments will read all relevant information from the Program Flow Program Flow Settings and Program Flow Program Flow ParticleData databases. Specifically the setup of incoming beams and energies is governed by the the beam parameters from the Program Flow Program Flow Beams group of variables. If you don't change any of those you will default to proton-proton collisions at 14 TeV, i.e. the nominal LHC values. Program Flow Program Flow If you want to have a list of the generator and particle data used, either only what has been changed or everything, you can use Program Flow pythia.settings.listChanged();    pythia.settings.listAll();    pythia.particleData.listChanged();    pythia.particleData.listAll(); Program Flow The event loop Program Flow Program Flow Inside the event generation loop you generate the next event using the Program Flow next() method, Program Flow pythia.next(); This method takes no arguments; everything has already been specified. It does return a bool value, however, Program Flow false when the generation failed. This can be a 'programmed death' when the supply of input parton-level configurations on file is exhausted. It can alternatively signal a failure of Program Flow Pythia to generate an event, or unphysical features in the event record at the end of the generation step. It makes sense to allow a few Program Flow false values before a run is aborted, so long as the related faulty events are skipped. Program Flow Program Flow The generated event is now stored in the Program Flow event object, of type Program Flow Program Flow Event , which is a public member of Program Flow pythia. You therefore have access to all the tools described on the pages under the 'Study Output' header in the index. For instance, an event can be listed with Program Flow pythia.event.list() , the identity of the Program Flow i 'th Program Flow particle is given by Program Flow pythia.event[i].id() , and so on. Program Flow The hard process - roughly the information normally stored in the Les Houches Accord event record - is available as a second object, Program Flow process , also of type Program Flow Event. Program Flow A third useful public object is Program Flow Program Flow info , which offers a set of one-of-a kind pieces of information about the most recent event. Program Flow Finishing Program Flow Program Flow At the end of the generation process, you can call Program Flow pythia.stat(); to get some run statistics, on cross sections and the number of errors and warnings encountered. Program Flow Advanced usage, mainly for initialization A) Necessary data are automatically loaded when you use the default PYTHIA installation directory structure and run the main programs in the Program Flow examples subdirectory. However, in the general case, you must provide the path of the Program Flow xmldoc directory, where default settings and particle data are found. This can be done in several ways. Program Flow Program Flow You can set the environment variable Program Flow PYTHIA8DATA to contain the location of the Program Flow xmldoc directory. In the Program Flow csh and Program Flow tcsh shells this could e.g. be Program Flow setenv PYTHIA8DATA /home/myname/pythia82xx/share/Pythia8/xmldoc while in other shells it could be Program Flow export PYTHIA8DATA=/home/myname/pythia82xx/share/Pythia8/xmldoc where xx is the subversion number. Program Flow Recall that environment variables set locally are only defined in the current instance of the shell. The above lines should go into your Program Flow .cshrc and Program Flow .bashrc files, respectively, if you want a more permanent assignment. Program Flow Program Flow You can provide the path as argument to the Program Flow Pythia constructor, e.g. Program Flow Pythia pythia('/home/myname/pythia82xx/share/Pythia8/xmldoc'); where again xx is the subversion number. Program Flow When Program Flow PYTHIA8DATA is set it takes precedence, else the path in the constructor is used, else one defaults to the Program Flow ../share/Pythia8/xmldoc directory. Program Flow You can provide references to existing Settings and ParticleData (useful if several identical copies of Pythia8 are constructed): Program Flow Pythia(Settings& settingsIn, ParticleData& particleDataIn); Program Flow You can take input from streams of Settings and ParticleData information (which requires the user to create the streams with the appropriate information): Program Flow Pythia(istream& settingsStrings, istream& particleDataStrings); Program Flow B) You can override the default behaviour of PYTHIA not only by the settings and particle data, but also by replacing some of the PYTHIA standard routines by ones of your own. Of course, this is only possible if your routines fit into the general PYTHIA framework. Therefore they must be coded according to the the rules relevant in each case, as a derived class of a PYTHIA base class, and a pointer to such an object must be handed in by one of the methods below. These calls must be made before the Program Flow pythia.init() call. Program Flow Program Flow If you are not satisfied with the list of parton density functions that are implemented internally or available via the LHAPDF interface (see the Program Flow PDF Selection page), you can supply your own by a call to the Program Flow setPDFPtr(...) method Program Flow pythia.setPDFptr( pdfAPtr, pdfBPtr); where Program Flow pdfAPtr and Program Flow pdfBPtr are pointers to two Program Flow Pythia Program Flow PDF objects. Note that Program Flow pdfAPtr and Program Flow pdfBPtr cannot point to the same object; even if the PDF set is the same, two copies are needed to keep track of two separate sets of Program Flow x and density values. Program Flow If you further wish to use separate PDF's for the hard process of an event than the ones being used for everything else, the extended form Program Flow pythia.setPDFptr( pdfAPtr, pdfBPtr, pdfHardAPtr, pdfHardBPtr); allows you to specify those separately, and then the first two sets would only be used for the showers and for multiparton interactions. Program Flow There is a further method to set photon fluxes in a similar spirit. Program Flow Program Flow If you want to link to an external generator that feeds in events in the LHA format, you can call the Program Flow setLHAupPtr(...) method Program Flow pythia.setLHAupPtr( lhaUpPtr); where the Program Flow lhaUpPtr derives from the Program Flow LHAup base class. Program Flow Program Flow If you want to perform some particle decays with an external generator, you can call the Program Flow setDecayPtr(...) method Program Flow pythia.setDecayPtr( decayHandlePtr, particles); where the Program Flow decayHandlePtr derives from the Program Flow Program Flow DecayHandler base class and Program Flow particles is a vector of particle codes to be handled. Program Flow Program Flow If you want to use an external random number generator, you can call the Program Flow setRndmEnginePtr(...) method Program Flow pythia.setRndmEnginePtr( rndmEnginePtr); where Program Flow rndmEnginePtr derives from the Program Flow Program Flow RndmEngine base class. The Program Flow Pythia default random number generator is perfectly good, so this is only intended for consistency in bigger frameworks. Program Flow Program Flow If you want to interrupt the evolution at various stages, to interrogate the event and possibly veto it, or you want to reweight the cross section, you can use Program Flow pythia.setUserHooksPtr( userHooksPtr); where Program Flow userHooksPtr derives from the Program Flow Program Flow UserHooks base class. Program Flow Program Flow If you want to use your own merging scale definition for matrix element + parton shower merging, you can call Program Flow pythia.setMergingHooksPtr( mergingHooksPtr); where Program Flow mergingHooksPtr derives from the Program Flow Program Flow MergingHooks base class. Program Flow Program Flow If you want to use your own parametrization of beam momentum spread and interaction vertex, rather than the provided simple Gaussian parametrization (off by default), you can call Program Flow pythia.setBeamShapePtr( beamShapePtr); where Program Flow beamShapePtr derives from the Program Flow Program Flow BeamShape base class. Program Flow Program Flow If you want to implement a cross section of your own, you can use Program Flow pythia.setSigmaPtr( sigmaPtr ); or, optionally, Program Flow pythia.setSigmaPtr( sigmaPtr, phaseSpacePtr ); where Program Flow sigmaPtr is of type Program Flow SigmaProcess* and Program Flow phaseSpacePtr is of type Program Flow PhaseSpace*. When only the cross-section expression is provided, the built-in phase-space selection machinery will be used. Then Program Flow sigmaPtr must be an instance of a class derived from one of the Program Flow Sigma1Process , Program Flow Sigma2Process and Program Flow Sigma3Process classes for 1-, 2- and 3- particle production, in their turn derived from Program Flow Program Flow SigmaProcess. When you supply your own phase-space generator there is no fundamental limit on the complexity of the process. This call can be used repeatedly to hand in several different processes, mixing ones with and ones without their own phase-space generators. Program Flow Program Flow If your cross section contains the production of a new resonance with known analytical expression for all the relevant partial widths, you can make this resonance available to the program with Program Flow pythia.setResonancePtr( resonancePtr); where Program Flow resonancePtr of type Program Flow ResonanceWidths* is an instance of a class derived from the Program Flow Program Flow ResonanceWidths base class. In addition you need to add the particle to the normal Program Flow particle and decay database. This procedure can be used repeatedly to hand in several different resonances. Program Flow Program Flow If you are a real expert and want to Program Flow replace the PYTHIA initial- and final-state showers , you can use Program Flow pythia.setShowerPtr( timesDecPtr, timesPtr, spacePtr); where Program Flow timesDecPtr and Program Flow timesPtr derive from the Program Flow TimeShower base class, and Program Flow spacePtr from Program Flow SpaceShower. Program Flow Program Flow With even bigger expertise you can plug in your own Program Flow Heavy Ions generator, to replace the default Angantyr one, with Program Flow pythia.setHeavyIonsPtr( heavyIonsPtr); Maybe more useful is the possibility to get back a pointer to the generator used, e.g. to probe various quantities that are not available with the normal Pythia methods: Program Flow pythia.getHeavyIonsPtr(); Program Flow C) Some comments on collecting several tasks in the same run. Program Flow Program Flow PYTHIA has not been written for threadsafe execution on multicore processors. If you want to use all cores, the most efficient way presumably is to start correspondingly many jobs, with different random number seeds, and add the statistics at the end. However, note that several instances  can be set up in the same main program, since instances are completely independent of each other, so each instance could be run inside a separate thread. Program Flow Program Flow In some cases it is convenient to use more than one Program Flow Pythia object. The key example would be the simultaneous generation of signal and pileup events, see Program Flow main19.cc. The two objects are then set up and initialized separately, and generate events completely independently of each other. It is only afterwards that the event records are combined into one single super-event per beam crossing. Program Flow Program Flow When time is not an issue, it may be that you want to perform several separate subruns sequentially inside a run, e.g. to combine results for several kinematical regions or to compare results for some different tunes of the underlying event. One way to go is to create (and destroy) one Program Flow pythia object for each subrun, in which case they are completely separate. You can also use the same Program Flow pythia object, only doing a new Program Flow init() call for each subrun. In that case, the settings and particle databases remain as they were in the previous subrun, only affected by the specific changes you introduced in the meantime. You can put those changes in the main program, with Program Flow pythia.readString(string) , using your own logic to decide which ones to execute in which subrun. A corresponding possibility exists with Program Flow pythia.readFile(fileName, subrun) (or an Program Flow istream instead of a Program Flow fileName ), which as second argument can take a non-negative subrun number. Then only those sections of the file before any Program Flow Main:subrun = ... line or with matching Program Flow subrun number will be read. That is, the file could have a structure like Program Flow ( lines always read, i.e. 'default values' always (re)set )    Main:subrun = 1    ( lines only read with readFile(fileName, 1) )    Main:subrun = 2    ( lines only read with readFile(fileName, 2) ) Both of these possibilities are illustrated in Program Flow main08.cc. Program Flow Program Flow When working with Les Houches Event Files, it may well be that your intended input event sample is spread over several files, that you all want to turn into complete events in one and the same run. There is no problem with looping over several subruns, where each new subrun is initialized with a new file, with name set in Program Flow Beams:LHEF. However, in that case you will do a complete re-initialization each time around. If you want to avoid this, note that the flag Program Flow Beams:newLHEFsameInit = true can be set for the second and subsequent subruns. Then the new file will be simulated with the same initialization data as already set in a previous Program Flow pythia.init() call. The burden rests on you to ensure that this is indeed correct, e.g. that the two event samples have not been generated for different beam energies. Also note that cross sections for processes will be based on the information in the first-read file, when the full initialization is performed. Program Flow Program Flow Program Flow The Pythia class methods and members Here follows the complete survey of all public Program Flow Pythia methods and data members. Program Flow Constructors and destructor Program Flow Set up run Program Flow Initialize At the initialization stage all the information provided above is processed, and the stage is set up for the subsequent generation of events. Currently only one Program Flow init method is available for this stage. Program Flow Generate events The Program Flow next() method is the main one to generate events. In this section we also put a few other specialized methods that may be useful in some circumstances. Program Flow Finalize There is no required finalization step; you can stop generating events when and how you want. It is still recommended that you make it a routine to call the following method at the end. A second method provides a deprecated alternative. Program Flow Interrogate settings Normally settings are used in the setup and initialization stages to determine the character of a run, e.g. read from a file with the above-described Program Flow Pythia::readFile(...) method. There is no strict need for a user to interact with the Program Flow Settings database in any other way. However, as an option, some settings variables have been left free for the user to set in such a file, and then use in the main program to directly affect the performance of that program, see Program Flow here. A typical example would be the number of events to generate. For such applications the following shortcuts to some Program Flow Settings methods may be convenient. Program Flow Get a PDF set Program Flow Pythia contains an number of parton density sets internally, plus an interface to LHAPDF (5 or 6). With the method below, this machinery is also made available for external usage. Program Flow Data members The Program Flow Pythia class contains a few public data members, several of which play a central role. We list them here, with links to the places where they are further described."},{"name":"ProMC files","link":"ProMCFiles.html","text":"ProMC files ProMC files ProMC Files ProMC files ProMC ProMC files Che14 is a library for the storage of Monte Carlo event records, or other data, in a very compact binary form. It provides routines for fast input to and output from these compact data files. It uses 'varints' as a way to store and compress an integer using a variable number of bytes, based on Google's platform- and language-neutral Protocol Buffers. Real numbers are converted to integers, e.g. by specifying a smallest unit of energy, momentum and length. Thereby a low-energy particle can be represented by a smaller number of bytes. ProMC files The current PYTHIA linking and interface is based on ProMC version 1.5; earlier version will not do. Once you have to installed the ProMC library, you should configure PYTHIA with ProMC files ./configure --with-promc=/path/to/ProMC and recompile the PYTHIA library. As usual more fine-grained options are available to set paths to binaries, libraries and headers separately, if need be. ProMC files The ProMC files examples/main46.cc sample program illustrates how to write PYTHIA events onto a ProMC file."},{"name":"QCD Processes","link":"QCDProcesses.html","text":"QCD Processes QCD Processes QCD Processes This section is subdivided into soft and hard QCD processes, with open charm and bottom production set aside as a special part of the latter, and three-jet topologies as a special subset. Kindly note that there is a considerable amount of overlap between the soft and hard process classes, so that you are likely to double-count if you include both in a run. QCD Processes Soft QCD processes As a rule, the processes in this class should not be mixed with the simulation of other processes. All by themselves, they are intended to represent the total cross section of hadron collisions, with the exception of the 'rare processes' that one wishes to study separately. In particular, jet physics at all scales occurs as part of the minimum-bias description. QCD Processes We here use the 'minimum bias' expression as a shorthand for inelastic, nondiffractive events. Strictly speaking, 'minimum bias' represents an experimental procedure of accepting 'everything', with some non-universal cuts to exclude elastic and diffractive topologies. In practice, the experimental minimum-bias sample may then contain some contamination of what is in PYTHIA classified as diffractive, especially (high-mass) double diffractive. QCD Processes Some options to modify these cross sections are found on the QCD Processes Total Cross Sections page. QCD Processes Hard QCD processes This group contains the processes for QCD jet production above some minimum QCD Processes pT threshold. The QCD Processes pT_min cut cannot be put too low, or else unreasonably large jet cross sections will be obtained. This is because the divergent perturbative QCD cross section is used in this process group, without any regularization modifications. An eikonalized description, intended to be valid at all QCD Processes pT , is instead included as part of the multiparton-interactions framework, specifically in QCD Processes SoftQCD:nonDiffractive above. QCD Processes Warning 1 : you QCD Processes must remember to set the QCD Processes PhaseSpace:pTHatMin value if you use any of these processes; there is no sensible default. QCD Processes Warning 2 : you QCD Processes must not mix processes from the QCD Processes SoftQCD and QCD Processes HardQCD process groups, since this is likely to lead to double-counting. QCD Processes Hard QCD processes: heavy-flavour subset These processes form a natural part of the above class, but can also be generated separately. Formally the heavy-quark mass makes these matrix elements finite in the QCD Processes pT &rarr; 0 limit, but at high energies one may still question the validity of the expressions at low QCD Processes pT values, like for the other hard-QCD processes. Also as above, an eikonalized description, intended to be valid at all QCD Processes pT , is included as part of the multiparton-interactions framework. QCD Processes Note that the processes below only represent the 'tip of the iceberg' of charm and bottom production at high energies, where flavour excitation and shower branchings provide major additional sources. All these sources come together in the descriptions offered by QCD Processes SoftQCD:nonDiffractive and QCD Processes HardQCD:all. QCD Processes Hard QCD three-parton processes Three-parton final states are generated by showers off two-parton processes. Topologies then cannot be specified beforehand, beyond what is provided by the two-parton hard process. For some checks it may be convenient to have access to the dedicated three-parton final states, which is what this set of processes allows. Cross sections have been taken from QCD Processes Ber81. QCD Processes Note that the processes in this section are QCD Processes not affected by the QCD Processes HardQCD:all switch. In fact, it would be double-counting to include both the QCD Processes HardQCD:all and the QCD Processes HardQCD:3parton processes in a run or study. QCD Processes QCD Processes Warning: this section is still incomplete, e.g. the selection of colour flow is very simple, and so it should only be used with caution."},{"name":"R-hadrons","link":"RHadrons.html","text":"R-hadrons R-hadrons R-hadrons When a coloured SUSY particle is longer-lived than typical hadronization scales, i.e. around c*tau > 1 fm, or equivalently width Gamma < 0.2 GeV, it will have time to hadronize into a colour singlet hadronic state, a R-hadron. Currently a set of such R-hadrons have been implemented for the case of a long-lived gluino, stop or sbottom. Needless to say, the normal case would be that only one of them will be long-lived enough to form R-hadrons. R-hadrons For simplicity all gluino-mesons are assumed to have light-flavour spin 1, since those are the lightest and favoured by spin-state counting. Further, all gluino-baryons are bookkept as having light-flavour spin 3/2, and flavours are listed in descending order. This is more for convenience of notation, however, since the normal baryon octet e.g. has no uuu = 'p++' state. When a diquark is extracted, a mixture of spin 0 and spin 1 is allowed. Names and codes are essentially in agreement with the PDG conventions, e.g. R-hadrons 1000993 R-hadrons R0(~g g) (or gluinoball) R-hadrons 1009213 R-hadrons R+(~g u dbar) (or gluino-rho+) R-hadrons 1092214 R-hadrons R+(~g uud) (or gluino-Delta+) R-hadrons For internal bookkeeping of momenta, the code 1009002, R-hadrons Rtemp(~g q) , is used to denote the intermediate state formed when only one of the two string pieces attached to the gluino has broken. R-hadrons For the stop- and sbottom-hadrons the spin counting is simpler, since it is entirely given by the constituent quark or diquark spin. Again names and codes follow PDG conventions, e.g. R-hadrons 1000612 R-hadrons R+(~t dbar) R-hadrons 1006211 R-hadrons R+(~t ud0) R-hadrons The spin and electromagnetic charge of the new particle plays only a minor role in the hadronization process, that can be neglected to first approximation. Therefore it is possible to use the same R-hadrons framework instead for other BSM scenarios with long-lived coloured particles, e.g. with massive extra-dimensions copies of gluons and quarks, or with leptoquarks. This can be regulated by the switches below. Note that the codes and names of the R-hadrons is not changed when the heavy particle involved is switched, for reasons of administrative simplicity. R-hadron mass spectra and other relevant particle data is automatically updated to reflect the change, however."},{"name":"Random Numbers","link":"RandomNumbers.html","text":"Random Numbers Random Numbers Random Numbers This page describes the random-number generator in PYTHIA and how it can be replaced by an external one. Random Numbers Internal random numbers The Random Numbers Rndm class generates random numbers, using the Marsaglia-Zaman-Tsang algorithm Random Numbers Mar90. Random Numbers Random numbers Random Numbers R uniformly distributed in Random Numbers 0 < R < 1 are obtained with Random Numbers Rndm::flat(); There are also methods to generate according to an exponential, to Random Numbers x * exp(-x) , to a Gaussian, or picked among a set of possibilities, which make use of Random Numbers flat(). Random Numbers If the random number generator is not initialized before, it will be so the first time it is asked to generate a random number, and then with the default seed, 19780503. This means that, by default, all runs will use identically the same random number sequence. This is convenient for debugging purposes, but dangerous if you intend to run several 'identical' jobs to boost statistics. You can initialize, or reinitialize, with your own choice of seed with a Random Numbers Rndm::init(seed); Here values Random Numbers 0 < seed < 900 000 000 gives so many different random number sequences, while Random Numbers seed = 0 will call the Random Numbers Stdlib time(0) function to provide a 'random' Random Numbers seed , and Random Numbers seed < 0 will revert back to the default Random Numbers seed. Random Numbers The Random Numbers Pythia class defines Random Numbers a flag and a mode , that allows the Random Numbers seed to be set in the Random Numbers Pythia::init call. That would be the standard way for a user to pick the random number sequence in a run. Random Numbers External random numbers Random Numbers RndmEngine is a base class for the external handling of random-number generation. The user-written derived class is called if a pointer to it has been handed in with the Random Numbers pythia.rndmEnginePtr() method. Since the default Marsaglia-Zaman-Tsang algorithm is quite good, chances are that any replacement would be a step down, but this may still be required by consistency with other program elements in big experimental frameworks. Random Numbers There is only one pure virtual method in Random Numbers RndmEngine , to generate one random number flat in the range between 0 and 1: Random Numbers virtual double flat() = 0; Note that methods for initialization are not provided in the base class, in part since input parameters may be specific to the generator used, in part since initialization can as well be taken care of externally to the Random Numbers Pythia code. Random Numbers An example illustrating how to run with an external random number generator is provided in Random Numbers main23.cc. Random Numbers MIXMAX random numbers The MIXMAX class of random number generators utilizes matrix-recursion based on Anosov-Kolmogorov C-K systems, with the ability to create a large number of statistically independent sequences of random numbers based on different initial seeds. This is particularly advantageous in creating statistically independent samples when running a large number of parallel jobs, each with a different initial seed. In the plugin header Random Numbers Pythia8Plugins/MixMax.h an implementation of a MIXMAX random number generator is provided Random Numbers Sav91,Sav15 , courtesy of Konstantin Savvidy, as well as a PYTHIA interface through the Random Numbers MixMaxRndm class.  In this implementation a dimensionality of 17 is used, as this has been found to provide faster access to large numbers of independent sequences. A timing comparison between the external MIXMAX random number generator, and the default internal PYTHIA random number generator is provided in the example Random Numbers main23.cc. The MIXMAX random number generator is found to be comparable in speed to the default generator. The primary methods of the Random Numbers MixMaxRndm class are given here. Random Numbers The methods We here collect a more complete and formal overview of the Random Numbers Rndm class methods."},{"name":"Random-Number Seed","link":"RandomNumberSeed.html","text":"Random-Number Seed Random-Number Seed Random-Number Seed The seed of the random number generator can be set as follows: Random-Number Seed For more on random numbers see Random-Number Seed here. This includes methods to save and restore the state of the generator, and some preprogrammed methods to generate non-uniform random numbers."},{"name":"Resonance Decays","link":"ResonanceDecays.html","text":"Resonance Decays Resonance Decays Resonance Decays The Resonance Decays ResonanceDecays class performs the sequential decays of all resonances formed in the hard process. Note the important distinction between 'resonances' and other 'particles' made in PYTHIA. Resonance Decays Resonance Decays The list of resonances contains Resonance Decays gamma^*/Z^0 , Resonance Decays W^+- , top, the Higgs, and essentially all new particles of Beyond-the-Standard-Model physics: further Higgs bosons, sfermions, gauginos, techniparticles, and so on. The partial widths to different decay channels are perturbatively calculable, given the parameters of the respective model, and branching ratios may be allowed to vary across a (reasonably broad) resonance peak. Usually resonances are short-lived, and therefore it makes sense to consider their decays immediately after the primary hard process has been set up. Furthermore, in several cases the decay angular distributions are encoded as part of the specific process, e.g. the Resonance Decays W decays differently in Resonance Decays f fbar &rarr; W^+- , Resonance Decays f fbar &rarr; W^+ W^- and Resonance Decays h^0 &rarr; W^+ W^-. All of these particles are (in PYTHIA) only produced as part of the hard process itself, i.e. they are not produced in showers or hadronization processes. Therefore the restriction to specific decay channels can be consistently taken into account as a corresponding reduction in the cross section of a process. Finally, note that all of these resonances have an on-shell mass above 20 GeV, with the exception of some hypothetical weakly interacting and stable particles such as the gravitino. Resonance Decays The other particles include normal hadrons and the Standard-Model leptons, including the Resonance Decays tau^+-. These can be produced in the normal hadronization and decay description, which involve unknown nonperturbative parameters and multistep chains that cannot be predicted beforehand: a hard process like Resonance Decays g g &rarr; g g can develop a shower with a Resonance Decays g &rarr; b bbar branching, where the Resonance Decays b hadronizes to a Resonance Decays B^0bar that oscillates to a Resonance Decays B^0 that decays to a Resonance Decays tau^+. Therefore any change of branching ratios - most of which are determined from data rather than from first principles anyway - will not be taken into account in the cross section of a process. Exceptions exist, but most particles in this class are made to decay isotropically. Finally, note that all of these particles have a mass below 20 GeV. There is one ambiguous case in this classification, namely the photon. The Resonance Decays gamma^*/Z^0 combination contains a low-mass peak when produced in a hard process. On the other hand, photons can participate in shower evolution, and therefore a photon originally assumed massless can be assigned an arbitrarily high mass when it is allowed to branch into a fermion pair. In some cases this could lead to double-counting, e.g. between processes such as Resonance Decays f fbar &rarr; (gamma^*/Z^0) (gamma^*/Z^0) , Resonance Decays f fbar &rarr; (gamma^*/Z^0) gamma and Resonance Decays f fbar &rarr; gamma gamma. Here it make sense to limit the lower mass allowed for the Resonance Decays gamma^*/Z^0 combination, in Resonance Decays 23:mMin , to be the same as the upper limit allowed for an off-shell photon in the shower evolution, in Resonance Decays TimeShower:mMaxGamma. By default this matching is done at 10 GeV. Resonance Decays In spite of the above-mentioned differences, the resonances and the other particles are all stored in one common Resonance Decays particle data table , so as to offer a uniform interface to Resonance Decays setting and getting properties such as name, mass, charge and decay modes, also for the Resonance Decays particle properties in the event record. Some methods are specific to resonances, however, in particular for the calculation of partial widths and thereby of branching ratio. For resonances these can be calculated dynamically, set up at initialization for the nominal mass and then updated to the current mass when these are picked according to a Breit-Wigner resonance shape. Resonance Decays Resonance Decays and Cross Sections As already hinted above, you have the possibility to set the allowed decay channels of resonances, see Resonance Decays Particle Data Scheme description. For instance, if you study the process Resonance Decays q qbar &rarr; H^0 Z^0 you could specify that the Resonance Decays Z^0 should decay only to lepton pairs, the Resonance Decays H^0 only to Resonance Decays W^+ W^- , the Resonance Decays W^+ only to a muon and a neutrino, while the Resonance Decays W^- can decay to anything. Unfortunately there are limits to the flexibility: you cannot set a resonance to have different properties in different places of a process, e.g. if instead Resonance Decays H^0 &rarr; Z^0 Z^0 in the above process then the three Resonance Decays Z^0 's would all obey the same rules. Resonance Decays The restrictions on the allowed final states of a process is directly reflected in the cross section of it. That is, if some final states are excluded then the cross section is reduced accordingly. Such restrictions are built up recursively in cases of sequential decay chains. The restrictions are also reflected in the compositions of those events that actually do get to be generated. For instance, the relative rates of Resonance Decays H^0 &rarr; W^+ W^- and Resonance Decays H^0 &rarr; Z^0 Z^0 are shifted when the allowed sets of Resonance Decays W^+- and Resonance Decays Z^0 decay channels are changed. Resonance Decays We remind that only those particles that Pythia treat as resonances enjoy this property, and only those that are considered as part of the hard process and its associated resonance decays. Resonance Decays There is one key restriction on resonances: Resonance Decays In spite of this technical parameter choice, it is possible to set a lifetime for a resonance, and thereby to obtain displaced vertices. If a resonance is allowed to decay it will do so, irrespective of the location of the decay vertex. This is unlike Resonance Decays normal particle decays , where it is possible to define some region around the primary vertex within which all decays should happen, with particles leaving that region considered stable. The logic is that resonances as a rule are too short-lived for secondary vertices, so if you pick a scenario with a long-lived but unstable resonance it is because you Resonance Decays want to study secondary vertices. How to interface those decays to a detector simulation program then is another story, to be solved separately. Do note that a special treatment is needed for coloured long-lived resonances, that form Resonance Decays R-hadrons , and where charge and flavour may change between the production and decay vertices. Resonance Decays Special properties and methods for resonances The method Resonance Decays ParticleData::isResonance(id) allows you to query whether a given particle species is considered a resonance or not. You can also change the default value of this flag in the normal way, e.g. Resonance Decays pythia.readString('id:isResonance = true'). Resonance Decays Resonances come in two kinds. Resonance Decays Resonance Decays The standard built-in ones include Resonance Decays Z^0 , Resonance Decays W^+- , Resonance Decays t , Resonance Decays h^0 , and many more. These have explicit decay-widths formulae encoded, in classes derived from the Resonance Decays Resonance Decays ResonanceWidths base class. The formulae are used, e.g., to calculate all the partial widths as a function of the resonance masses you choose, and at initialization the existing total width values are overwritten. This is especially convenient for hypothetical states, like a Resonance Decays Z' , where the mass is not known and therefore routinely changed. Often the partial widths are associated with parameters that can be changed by the user, e.g. for MSSM Higgs states. Resonance Decays If a resonance does not have a class of its own, with hardcoded equations for all relevant partial widths, then a simpler object will be created at initialization. This object will take the total width and branching ratios as is (with the optional variations explained in the next section). When you set a particle to be a resonance, and do not provide any class to go with its width calculations, this is where it will end up. Sometimes experimentalists want to modify the physical width of a resonance, to understand how sensitive analyses are to this width, if at all. For the second, simpler kind of resonances, the Resonance Decays id:mWidth can be changed right away, but for the first kind any change will be overwritten at initialization. To circumvent this problem, the Resonance Decays id:doForceWidth flag can be changed from the default Resonance Decays off to Resonance Decays on. Then the width stored in Resonance Decays id:mWidth is strictly used to describe the Breit-Wigner of the resonance. Partial widths are still recalculated to set the mass-dependent branching ratios, but then uniformly rescaled to the requested total width. The width can also run across the lineshape, so that it deviates from the nominal one in the wings of the Breit-Wigner. Resonance Decays For processes that contain interference terms between resonances, notably Resonance Decays gamma^*/Z^0 or Resonance Decays gamma^*/Z^0/Z'^0 , it is not obvious how these contributions should be modified consistently. Therefore it is necessary to set Resonance Decays WeakZ0:gmZmode = 2 or Resonance Decays Zprime:gmZmode = 3 , to have a pure Resonance Decays Z^0 or Resonance Decays Z'^0 , respectively, for width forcing to be allowed in these cases. Resonance Decays A warning is that the different processes have cross sections that rescale in different ways when the resonance width is varied. This depends on them not having been implemented in a guaranteed uniform way. To illustrate the point, consider the case of an Resonance Decays s -channel resonance, where the cross section dependence on the width can be written as Resonance Decays sigmaHat(sHat) = constant * Gamma_in * Gamma_out / ((sHat - m^2)^2 + m^2 * Gamma^2) Here the Resonance Decays doForceWidth = on option ensures that the Resonance Decays Gamma in the denominator is rescaled by some factor Resonance Decays k relative to the natural width, but does not guarantee that Resonance Decays Gamma_in and Resonance Decays Gamma_out are rescaled as well. If all three are rescaled by the same factor Resonance Decays k , as they should, then the integrated cross section also scales like Resonance Decays k , assuming that the peak is reasonably narrow, so that the variation of PDF's across the Breit-Wigner can be neglected. This is the case for some processes. But in others either or both of the production and decay vertices can have been hardcoded, based on the coupling structure, and thus not scale with Resonance Decays k. If only Resonance Decays Gamma_out scales with Resonance Decays k , say,  the cross section remains (approximately) constant, and if neither scales the cross section will even go like Resonance Decays 1/k. Such obvious normalization imperfections have to be corrected by hand. Resonance Decays Mainly for internal usage, the Resonance Decays Resonance Decays ParticleData contain some special methods that are only meaningful for resonances: Resonance Decays Resonance Decays Resonance Decays resInit(...) to initialize a resonance, possibly including a recalculation of the nominal width to match the nominal mass; Resonance Decays Resonance Decays resWidth(...) to calculate the partial and total widths at the currently selected mass; Resonance Decays Resonance Decays resWidthOpen(...) to calculate the partial and total widths of those channels left open by user switches, at the currently selected mass; Resonance Decays Resonance Decays resWidthStore(...) to calculate the partial and total widths of those channels left open by user switches, at the currently selected mass, and store those as input for a subsequent selection of decay channel; Resonance Decays Resonance Decays resOpenFrac(...) to return the fraction of the total width that is open by the decay channel selection made by users (based on the choice of Resonance Decays Resonance Decays onMode for the various decay channels, recursively calculated for sequential decays); Resonance Decays Resonance Decays resWidthRescaleFactor(...) returns the factor by which the internally calculated PYTHIA width has to be rescaled to give the user-enforced width; Resonance Decays Resonance Decays resWidthChan(...) to return the width for one particular channel (currently only used for Higgs decays, to obtain instate coupling from outstate width). These methods actually provide an interface to the classes derived from the Resonance Decays ResonanceWidths base class, to describe various resonances. Resonance Decays Modes for Matrix Element Processing The Resonance Decays meMode() value for a decay mode is used to specify Resonance Decays nonisotropic decays or the conversion of a parton list into a set of hadrons in some channels of normal particles. For resonances it can also take a third function, namely to describe how the branching ratios and widths of a resonance should be rescaled as a function of the current mass of the decaying resonance. The rules are especially useful when new channels are added to an existing particle, or a completely new resonance added. Resonance Decays Resonance Decays 0 : channels for which hardcoded partial-width expressions are expected to exist in the derived class of the respective resonance. Should no such code exist then the partial width defaults to zero. Resonance Decays 1 - 99 : same as 0, but normally not used for resonances. Resonance Decays 100 : calculate the partial width of the channel from its stored branching ratio times the stored total width. This value remains unchanged when the resonance fluctuates in mass. Specifically there are no threshold corrections. That is, if the resonance fluctuates down in mass, to below the nominal threshold, it is assumed that one of the daughters could also fluctuate down to keep the channel open. (If not, there may be problems later on.) Resonance Decays 101 : calculate the partial width of the channel from its stored branching ratio times the stored total width. Multiply by a step threshold, i.e. the channel is switched off when the sum of the daughter on-shell masses is above the current mother mass. Resonance Decays 102 : calculate the partial width of the channel from its stored branching ratio times the stored total width. Multiply by a smooth threshold factor Resonance Decays beta = sqrt( (1 - m_1^2/m_2 - m_2^2/m^2)^2 - 4 m_1^2 m_2^2/m^4) for two-body decays and Resonance Decays sqrt(1 - Sum_i m_i / m) for multibody ones. The former correctly encodes the size of the phase space but misses out on any nontrivial matrix-element behaviour, while the latter obviously is a very crude simplification of the correct phase-space expression. Specifically, it is thereby assumed that the stored branching ratio and total width did not take into account such a factor. Resonance Decays 103 : use the same kind of behaviour and threshold factor as for 102 above, but assume that such a threshold factor has been used when the default branching ratio and total width were calculated, so that one should additionally divide by the on-shell threshold factor. Specifically, this will give back the stored branching ratios for on-shell mass, unlike the 102 option. To avoid division by zero, or in general unreasonably big rescaling factors, a lower limit Resonance Decays minThreshold (see below) on the value of the on-shell threshold factor is imposed. (In cases where a big rescaling is intentional, code 102 would be more appropriate.) Resonance Decays All of these Resonance Decays meMode 's may coexist for the same resonance. This would be the case e.g. if you want to add a few new channels to an already existing resonance, where the old partial widths come hardcoded while the new ones are read in from an external file. The typical example would be an MSSM Higgs sector, where partial widths to SM particles are already encoded, Resonance Decays meMode = 0 , while decay rates to sparticles are read in from some external calculation and maybe would be best approximated by using Resonance Decays meMode = 103. Indeed the default particle table in PYTHIA uses 103 for all channels that are expected to be provided by external input. Resonance Decays Some further clarification may be useful. At initialization the existing total width and on-shell branching ratios will be updated. For channels with Resonance Decays meMode < 100 the originally stored branching ratios are irrelevant, since the existing code will anyway be used to calculate the partial widths from scratch. For channels with Resonance Decays meMode = 100 or bigger, instead the stored branching ratio is used together with the originally stored total width to define the correct on-shell partial width. The sum of partial widths then gives the new total width, and from there new branching ratios are defined. Resonance Decays In these operations the original sum of branching ratios need not be normalized to unity. For instance, you may at input have a stored total width of 1 GeV and a sum of branching ratios of 2. After initialization the width will then have been changed to 2 GeV and the sum of branching ratios rescaled to unity. This might happen e.g. if you add a few channels to an existing resonance, without changing the branching ratios of the existing channels or the total width of the resonance. Resonance Decays In order to simulate the Breit-Wigner shape correctly, it is important that all channels that contribute to the total width are included in the above operations. This must be kept separate from the issue of which channels you want to have switched on for a particular study, to be considered next. Resonance Decays In the event-generation process, when an off-shell resonance mass has been selected, the width and branching ratios are re-evaluated for this new mass. At this stage also the effects of restrictions on allowed decay modes are taken into account, as set by the Resonance Decays onMode switch for each separate decay channel. Thus a channel may be on or off, with different choices of open channels between the particle and its antiparticle. In addition, even when a channel is on, the decay may be into another resonance with its selection of allowed channels. It is these kinds of restrictions that lead to the Resonance Decays Gamma_out possibly being smaller than Resonance Decays Gamma_tot.  As a reminder, the Breit-Wigner for decays behaves like Resonance Decays Gamma_out / ((s - m^2)^2 + s * Gamma_tot^2) , where the width in the numerator is only to those channels being studied, but the one in the denominator to all channels of the particle. These ever-changing numbers are not directly visible to the user, but are only stored in a work area."},{"name":"RIVET usage","link":"RIVETusage.html","text":"RIVET usage RIVET usage RIVET usage RIVET usage RIVET is a toolkit for the validation of Monte Carlo event generators RIVET usage Buc10. It contains the results of many experimental analyses, so that generator output can easily be compared to data, as well as providing a framework to implement your own analyses.  Although using PYTHIA with RIVET is not officially supported, some helpful hints are given below. The full RIVET manual is available RIVET usage online. RIVET usage RIVET usage RIVET usage Using PYTHIA with RIVET The following assumes that you already have RIVET installed. Instructions for this may be found RIVET usage here. RIVET usage RIVET usage Events are passed from PYTHIA to RIVET using the HepMC format. PYTHIA must be compiled with HepMC support, using the same version of HepMC used when compiling RIVET. This is setup through the PYTHIA RIVET usage configure script e.g. RIVET usage ./configure --with-hepmc=/path/to/HepMC --with-hepmcversion=HepMC.version.number The PYTHIA library itself does not need to be recompiled. RIVET usage RIVET usage The RIVET usage examples/main42.cc sample program can then be used to generate events in HepMC format (which RIVET usage examples/main43.cc extends by allowing subruns). When in the RIVET usage examples directory, the main program can be built and used as follows RIVET usage make main42  ./main42 main42.cmnd main42.hepmc The first argument is the input file which provides the options for event generation, while the second is the output file where the HepMC events should be written. RIVET usage RIVET usage This HepMC file may now be read and processed by RIVET RIVET usage rivet --analysis=ANALYSIS_NAME main42.hepmc where RIVET usage ANALYSIS_NAME is a RIVET usage built-in RIVET analysis , or one you have created yourself. The output of RIVET is in the form of RIVET usage .aida files, containing the histograms for the analysis, which can be processed further with RIVET (see the RIVET usage RIVET documentation for more details). RIVET usage RIVET usage The above examples requires that (potentially large) HepMC events are stored to disk before being read by RIVET. It is possible, instead, to pass the events directly to RIVET as they are produced by using a RIVET usage FIFO pipe. This is done with the RIVET usage mkfifo command RIVET usage mkfifo my_fifo  ./main42.exe main42.cmnd my_fifo &  rivet --analysis=ANALYSIS_NAME my_fifo Note that RIVET usage main42 is run in the background. RIVET usage Compiling PYTHIA with RIVET It is also possible to compile a PYTHIA main program together with the RIVET library. To facilitate this, there is a header file called RIVET usage Pythia8Plugins/Pythia8Rivet.h defining a helper class called RIVET usage Pythia8::Pythia8Rivet. To use this class, a main program needs to be modified as follows: RIVET usage #include 'Pythia8/Pythia.h'   // Include the Pythia8Rivet header file.  #include 'Pythia8Plugins/Pythia8Rivet.h'   int main() {    Pythia pythia;    // Setup the run by reading strings or a command file.    pythia.init();    // Create a Pythia8Rivet object and add (one or several) analyses.    Pythia8Rivet rivet(pythia, 'outputfile.yoda');    rivet.addAnalysis('AnalysisName');    rivet.addAnalysis('AnotherAnalysisName');    for (int iEvent = 0; iEvent < 100; ++iEvent) {     if (!pythia.next()) continue;      // Push event to Rivet.     rivet();      // Maybe do other non-Rivet analysis.    }    // Tell Rivet to finalise the run.    rivet.done();   } To compile the program, information about where Rivet and YODA are installed is needed. Hence the compile flag RIVET usage -I/path/to/rivet/installation/include is needed, as well as the link flag RIVET usage -L/path/to/rivet/installation/lib -lRivet -lYODA. (Further information about how to compile and link Rivet can be found using the RIVET usage rivet-config script distributed with Rivet.) RIVET usage The example program RIVET usage main111.cc includes optional analysis with RIVET usage Pythia8::Pythia8Rivet. To use it, compile the program with the flags above and add RIVET usage -DUSE_PYTHIA8_RIVET. RIVET usage The most common user case (run PYTHIA with a run card, using one or several RIVET analyses) is implemented in the example RIVET usage main93. The sample command file RIVET usage main93.cmnd provides a good starting point. The lines: RIVET usage Main:runRivet = on    Main:analyses = ATLAS_2010_S8817804,ALICE_2010_S8625980,CMS_2011_S8957746    Main:writeHepMC = on provides the switch to run RIVET, and gives the user the possibility to add any number of (installed) RIVET analyses to the run, as a comma separated list. The last line is the switch needed to write a HepMC file. The example is run with: RIVET usage ./main93 -c main93.cmnd and a .yoda file (the RIVET output) is then written.  There are several other useful command line options to RIVET usage main93. They are all displayed by running RIVET usage ./main93 -h."},{"name":"ROOT usage","link":"ROOTusage.html","text":"ROOT usage ROOT usage ROOT usage Many PYTHIA users wish to use ROOT usage ROOT to produce histograms, or even to run PYTHIA as a plugin to ROOT. This is possible. It is not a task supported by the PYTHIA team, however. All issues involving ROOT usage should be directed to the ROOT team, or to the local support team of your collaboration. Below some helpful hints have been collected. The text is based on contributions by Rene Brun, Andreas Morsch and Axel Naumann. Another example may be found in the ROOT usage VINCIA add-on program for parton showers, but this should also work for a PYTHIA standalone run. ROOT usage ROOT usage Note that in all that follows, a Linux-type system with a Bash shell and GNU Make is assumed. In particular, for Mac OS X, the ROOT usage LD_LIBRARY_PATH should be replaced with ROOT usage DYLD_LIBRARY_PATH and the extension for shared libraries ROOT usage .so should be replaced with ROOT usage .dylib. ROOT usage ROOT usage ROOT usage ROOT usage Standalone usage One can perform the generation and analysis of events in a completely standalone fashion, and only use ROOT to process the completed events. Two example programs are provided in the ROOT usage examples directory, with details provided below.  The examples assume that ROOT is installed, that you have run ROOT usage ./configure --with-root=root-installation-directory where you have to specify which is the ROOT installation directory, and subsequently run ROOT usage make. More fine-grained options are available with ROOT usage configure , if need be. ROOT usage Histogramming with ROOT An example of histogramming with ROOT is provided in ROOT usage examples/main91.cc. It may be compiled and run just like the other example programs. After PYTHIA has run, a ROOT histogram of the charged multiplicity in the events will be shown. This is now stored in the ROOT usage hist.root file. If you can make this example work, the road should be open to do the same for all other histogramming needs. Specifically, you need to edit the ROOT usage examples/Makefile file to add the other programs to link as ROOT usage main91.cc currently does. ROOT usage Storing PYTHIA events in ROOT trees Instead of only generating histograms, it is possible to store entire PYTHIA events in ROOT trees. The ROOT usage examples/main92 code provides an example of this and is comprised of the following files: ROOT usage ROOT usage ROOT usage main92.cc is the main example program showing how  PYTHIA events can be stored in ROOT trees; ROOT usage ROOT usage main92LinkDef.h is used by Makefile to generate the  dictionary for all PYTHIA classes involved in the IO, as needed for  the example; and ROOT usage ROOT usage main92.h is a small include declaring the ROOT usage Pythia8 namespace as default. ROOT usage The example may be compiled and run with as usual. Afterwards, the new ROOT usage pytree.root file will contain the PYTHIA events. Note that files can become quite large when many events are generated. To open these files within the ROOT interpreter the PYTHIA class dictionary must be loaded, ROOT usage .L main92.so. In compiled code, the PYTHIA class dictionary ROOT usage main92.so must be linked against, to either read or write PYTHIA events to a ROOT file. ROOT usage Error notice It appears that ROOTCINT cannot handle the ROOT usage dlfcn.h header in the current ROOT version. If you run into this problem with your ROOT installation, you could try to insert the following lines in your ROOT usage PythiaStdlib.h file: ROOT usage // Stdlib header file for dynamic library loading.   #ifndef __CINT__   #define dlsym __   #include <dlfcn.h>   #undef dlsym   #endif ROOT usage ROOT usage ROOT usage Storing partial PYTHIA events in ROOT trees Instead of storing full PYTHIA events in ROOT trees, a common user case is to store only track information relevant to a particular analysis. The resulting ROOT trees will then be what is often referred to as 'n-tuples'. The advantage of this over the above method is a significant reduction of disk space used, as well as the possibility to construct trees resembling those familiar from the experiments' central MC production.  The ROOT usage examples/main93 example provides this - among other - functionality. As for the above example, it is split up in several files. ROOT usage ROOT usage ROOT usage main93.cc is the main example program; ROOT usage ROOT usage main93.cmnd is a sample input command file; ROOT usage ROOT usage main93LinkDef.h is used by Makefile to generate the  dictionary for only the used PYTHIA classes involved in the IO, for  the example; and ROOT usage ROOT usage main93.h defines a 'track' and an 'event' class where  relevant event -and track information is defined. ROOT usage Compiling the example The ROOT usage main93 example is compatible with ROOT v.6 and above. One should have a working installation of ROOT, and then configure PYTHIA with: ROOT usage ./configure --with-root=root-installation-directory One can then compile ROOT usage main93 with the usual: ROOT usage make main93 provided that all ROOT paths are set correctly by eg. running: ROOT usage source root-installation-directory/bin/thisroot.sh ROOT usage Running the example The ROOT usage main93 example can be run with several command line options. Running: ROOT usage ./main93 -h will display a help text showing these options. To produce events, the user needs to supply a command file with option ROOT usage -c COMMAND-FILE.cmnd. The example command file ROOT usage main93.cmnd is a good starting point. The crucial command to output ROOT trees is to set ROOT usage Main:writeROOT = on.  The ROOT file will be named ROOT usage pythia.root per default. This can be changed by appending ROOT usage -o ONAME on the command line. ROOT usage Changing the event information The header file ROOT usage main93.h defines a simple event class and track class, which in turn defines the information stored to the tree. If a user wants to change this, either by adding more track information or imposing cuts corresponding to detector acceptance (thus reducing the file size), this can be done directly in this header file. Both the track class and the event class has ROOT usage init functions returning a boolean value, and by returning ROOT usage false , the track/event is rejected. The ROOT usage main93 example must be recompiled after making any changes to the header file. ROOT usage ROOT usage ROOT usage ROOT usage PYTHIA as a plugin to ROOT In more ROOT-centric applications, PYTHIA can be run as a ROOT plug-in. This requires a version of ROOT that has been ROOT usage installed from source. The reason is that the interfaces depend on PYTHIA header files that are not distributed with ROOT. Installing ROOT is not more difficult than the PYTHIA installation, and some guidelines are provided below. ROOT usage Installation To be run as a plugin, PYTHIA must be compiled as a shared library. This is achieved by running the PYTHIA ROOT usage configure script with the ROOT usage --enable-shared option before ROOT usage make is run. ROOT usage ROOT usage Define an environment variable for the path to your PYTHIA installation directory ROOT usage export PYTHIA8=path_to_PYTHIA8_installation Before compiling ROOT, ROOT usage configure ROOT by running the ROOT usage configure command including the following options ROOT usage --enable-pythia8    --with-pythia8-incdir=$PYTHIA8/include/Pythia8    --with-pythia8-libdir=$PYTHIA8/lib In case ROOT has already been compiled before, it will only recompile the PYTHIA module and build the library ROOT usage libEGPythia8. ROOT usage Interfaces When running PYTHIA as a plugin, the exact interface structure becomes very relevant. ROOT provides two simple interfaces (wrappers) for PYTHIA 8. The code for these interfaces are located in ROOT usage path_to_ROOT_source/montecarlo/pythia8 ROOT usage The two interfaces are ROOT usage ROOT usage ROOT usage ROOT usage TPythia8 is an implementation of the ROOT usage ROOT usage TGenerator interface for PYTHIA 8. ROOT usage It allows you to use PYTHIA within a ROOT macro or as a plug-in  for a general-purpose particle generator based on this interface. The  main methods of the interface are ROOT usage ROOT usage ROOT usage GenerateEvent() which triggers the    generation of the next event, and ROOT usage ROOT usage ImportParticles(TClonesArray* particles) which copies the native PYTHIA stack into a ROOT usage ROOT usage TClonesArray of ROOT usage ROOT usage TParticles. In addition, some methods that are directly related to corresponding  PYTHIA methods are implemented ROOT usage ROOT usage ROOT usage ReadString(const char* string) &rarr; ROOT usage readString(...) ROOT usage ROOT usage ReadConfigFile(const char* string) &rarr; ROOT usage readFile(...) ROOT usage ROOT usage Initialize(int idAin, int idBin, double ecms) &rarr; ROOT usage init() ROOT usage Warning: this method will have to be updated for the 8.2 version! ROOT usage ROOT usage EventListing() &rarr; ROOT usage event.list() ROOT usage ROOT usage PrintStatistic() &rarr; ROOT usage stat() ROOT usage ROOT usage Warning: this method will have to be updated for    the 8.2 version! These methods provide already the basic PYTHIA functionality  interactively from the ROOT command line. However, this does not mean  that the usage of PYTHIA from within ROOT is restricted to these methods.  In compiled code, one can always obtain a pointer to the ROOT usage Pythia instance e.g. ROOT usage TPythia8      *tp = new TPythia8();    Pythia8::Pythia *p  = tp->Pythia8(); giving access to the full PYTHIA functionality. To access this  functionality in the CINT interpreter see the 'Advanced usage'  section below. ROOT usage ROOT usage ROOT usage TPythia8Decayer is an implementation of the ROOT usage ROOT usage TVirtualMCDecayer interface. ROOT usage It allows you to use PYTHIA as a plug-in decayer for simulation  frameworks based on the Virtual Monte Carlo  ( ROOT usage VMC ) interface  classes. The main methods of the interface are ROOT usage ROOT usage ROOT usage TPythia8Decayer::Init() for initialisation, ROOT usage ROOT usage TPythia8Decayer::Decay(Int_t pdg, TLorentzVector* p) to decay a particle with PDG code ROOT usage pdg and ROOT usage 4-momentum ROOT usage p , and ROOT usage ROOT usage ImportParticles(TClonesArray* particles) to retrieve the decay products as ROOT usage ROOT usage TParticles in the ROOT usage ROOT usage TClonesArray particles. ROOT usage An example A ROOT usage basic example for generating minimum-bias events with PYTHIA 8 inside a ROOT macro, and filling some histograms with the kinematics of the final-state particles is provided in either of the locations below ROOT usage /path_to_ROOT_source/tutorials/pythia/pythia8.C    /path_to_ROOT_installation/share/doc/root/tutorials/pythia/pythia8.C ROOT usage Note that before executing this script ROOT usage ROOT usage the environment variables ROOT usage PYTHIA8 and ROOT usage PYTHIA8DATA must be setup correctly e.g. ROOT usage export PYTHIA8=/path_to_PYTHIA_installation    export PYTHIA8DATA=$PYTHIA8/share/Pythia8/xmldoc ROOT usage your LD_LIBRARY_PATH must contain the location of the  PYTHIA 8 shared library, e.g. ROOT usage export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:path_to_PYTHIA8_installation/lib The script can then be run with ROOT ROOT usage root pythia8.C After execution, ROOT will display some histograms from the event generation. ROOT usage Advanced usage To access the full PYTHIA functionality from the CINT interpreter, a ROOT dictionary must be created. Currently that option has not been implemented as a standard option for PYTHIA 8.2, but it should be in the same spirit as what can be found in the 8.1 ROOT usage rootexamples directory. Also note that one dictionary is found in the ROOT usage examples/main92LinkDef.h file.  This may then be loaded in ROOT giving full access to the full PYTHIA 8 functionality, e.g. in an interactive session ROOT usage gSystem->Load('path_to_PYTHIA8_installation/rootexamples/pythiaDict');    Pythia8::Pythia *p = new Pythia8::Pythia();    p->readString('SoftQCD:nonDiffractive = on');"},{"name":"Rope Hadronization","link":"RopeHadronization.html","text":"Rope Hadronization Rope Hadronization Rope Hadronization In collisions of protons, there are often tens of multiparton interactions, all producing Lund strings occupying the same area in transverse space of Rope Hadronization ~1 fm Rope Hadronization ^2. The Rope Hadronization framework describes the interactions between such overlapping strings, by (a) allowing nearby strings to shove each other with an interaction potential derived from the colour superconductor analogy Rope Hadronization Bie16b , Rope Hadronization Bie17 and (b) at hadronization time, colour charges at string endpoints and in gluon 'kinks' can act together coherently to form a 'rope', which is hadronized with a larger, effective string tension Rope Hadronization Bie14. The latter has noticeable effects on the flavour composition of the hadronic final state Rope Hadronization Bie15 , and this effect is denoted 'flavour ropes' below. Rope Hadronization Since both models deal with string overlaps in transverse space, it is necessary to provide such information, as it is not present in the Pythia MPI model. The information is provided through the Rope Hadronization Parton Vertex methods. The string shoving mechanism is exemplified in the Rope Hadronization main101 example, and the flavour ropes in Rope Hadronization main102. A simpler version of flavour composition ropes exist Rope Hadronization Bie16c , which do not require vertex information. This can be enabled by a switch. Rope Hadronization Main settings The main settings are common for both the string shoving and the flavour rope models. Rope Hadronization String shoving The string shoving mechanism allows strings to push each other, before hadronization, as described in Rope Hadronization Bie16b. Rope Hadronization String shoving divides the event up in many small rapidity slices (in the lab frame), and all string pieces in all slices are allowed to push each other with a force: Rope Hadronization f(d_\perp) = \frac{g_A \kappa d_\perp}{R^2} \exp\left(-\frac{d^2_\perp }{4R^2}\right), where Rope Hadronization d_\perp is the distance in transverse space between two string pieces, calculated dynamically using Rope Hadronization Vertex Information. Model parameters are Rope Hadronization g_A , the amplitude of the shoving force, Rope Hadronization R , the string radius, and Rope Hadronization g_E , a parameter dividing the equilibrium string radius to account for the effect of strings starting out with a vanishing string radius. Rope Hadronization The model should be used with some caution. Simply switching it on, one will not retain full description of single particle observables in minimum bias pp collisions, as the excitation gluons will increase multiplicity. Besides normal tuning, one can use the parameter Rope Hadronization FragmentationSystems:mJoin to join the excitation gluons together, in order to recover single particle observables. Rope Hadronization Flavour Ropes The Flavour Ropes mechanism allows strings situated close in impact parameter space to interact coherently, forming a rope, which hadronizes with a larger, effective string tension. The model is described in ref. Rope Hadronization Bie14 , building on an older idea by Biro et al. Rope Hadronization Bir84. Rope Hadronization In the flavour rope formalism, a rope is described as an SU(3) multiplet, characterized uniquely by two quantum numbers Rope Hadronization p and Rope Hadronization q. The quantum numbers are calculated, following ref. Rope Hadronization Bir84 , by a random walk procedure in colour space, taking Rope Hadronization m, n steps, where Rope Hadronization m and Rope Hadronization n signify the number of overlapping strings which are respectively parallel or anti-parallel to the hadronizing string. Rope Hadronization When the rope quantum numbers have been determined, the effective string tension is calculated per individual breaking, using a lattice QCD determination of the string tension Rope Hadronization Bal00. The effective string tension is then used to rescale the hadronization parameters described in the section on Rope Hadronization String Fragmentation. One point to note regarding the rescaling is the fragmentation parameter Rope Hadronization StringFlav:probQQtoQ , describing baryon relative to meson production. Baryon production is, as suggested by eg. the popcorn hadronization model Rope Hadronization Ede97 , more complicated than meson production. The current modelling of this in the flavour ropes framework is limited, but intended to be extended in the future."},{"name":"Sample Main Programs","link":"SampleMainPrograms.html","text":"Sample Main Programs Sample Main Programs Sample Main Programs Descriptions of available classes, methods and settings are all very good and useful. Ultimately they are necessary for you to be able to fine-tune your runs to the task at hand. To get going, however, nothing helps like having explicit examples to study. This is what is provided in the Sample Main Programs examples subdirectory, along with instructions how they should be run: Sample Main Programs Sample Main Programs Sample Main Programs main00.cc : does not exist, but it has been defined in the Sample Main Programs Makefile , so this name could be used for a simple first test run. Sample Main Programs Sample Main Programs main01.cc : a simple study of the charged multiplicity for jet events at the LHC. (Brief example fitting on one slide.) Sample Main Programs Sample Main Programs main01.py : a Python interface equivalent of Sample Main Programs main01.cc. Sample Main Programs Sample Main Programs main02.cc : a simple study of the Sample Main Programs pT spectrum of Z bosons at the Tevatron. (Brief example fitting on one slide.) Sample Main Programs Sample Main Programs main03.cc : a simple study of several different kinds of events, with the choice to be made in the Sample Main Programs main03.cmnd 'cards file'. Also shows how to plot histograms using the Python/Matplotlib/Pyplot solution. Sample Main Programs Sample Main Programs main04.cc : tests of cross sections, multiplicities and average transverse momenta for elastic, diffractive and nondiffractive topologies, using Sample Main Programs main04.cmnd to pick processes. For photoproduction  one can use the alternative Sample Main Programs main04_photons.cmnd input. Sample Main Programs Sample Main Programs main05.cc : generation of QCD jet events at the LHC, with jet analysis using the Sample Main Programs SlowJet inclusive anti- Sample Main Programs kT sequential-recombination finder and the Sample Main Programs CellJet cone-jet finder. Sample Main Programs Sample Main Programs main06.cc : generation of LEP1 hadronic events, i.e. Sample Main Programs e^+e^- &rarr; gamma*/Z^0 &rarr; q qbar , with charged multiplicity, sphericity, thrust and jet analysis. Sample Main Programs Sample Main Programs main07.cc : set up a fictitious production process to a generic resonance, where you easily can compose your own list of (two-body) decay modes to a variety of final states. Also traces decay chains down to truly stable particles: gamma, e+-, p/pbar and neutrinos. Suitable for astroparticle applications, like neutralino pair annihilation, where cross sections are calculated separately in another program.  Also shows how to plot histograms using the Python/Matplotlib/Pyplot solution. Sample Main Programs Sample Main Programs main08.cc : generation of the QCD jet cross section biased towards higher pT values, by two different techniques. Firstly, by splitting the run into subruns, each in its own Sample Main Programs pT bin, and adding the results properly reweighted. Two suboptions, with limits set either in the main program or by subrun specification in the Sample Main Programs main08.cmnd file. Secondly, by a continuous reweighting with a Sample Main Programs pT^4 bias in the selection, compensated by a Sample Main Programs 1/pT^4 event weight. Also inclusion of soft processes is illustrated, with subruns and weighted events. Sample Main Programs Sample Main Programs main09.cc : generation of two predetermined hard interactions in each event. Sample Main Programs Sample Main Programs main10.cc : illustration how userHooks can be used interact directly with the event-generation process. Sample Main Programs Sample Main Programs main10.py : a Python interface equivalent of Sample Main Programs main10.cc. Provides an example of how to derive PYTHIA classes in Python. Sample Main Programs Sample Main Programs main11.cc : a study of top events, fed in from the Les Houches Event File Sample Main Programs ttbar.lhe , here generated by PYTHIA 6.4. This file currently only contains 100 events so as not to make the distributed PYTHIA package too big, and so serves mainly as a demonstration of the principles involved. Sample Main Programs Sample Main Programs main12.cc : a more sophisticated variant of Sample Main Programs main11.cc , where two Les Houches Event Files ( Sample Main Programs ttbar.lhe and Sample Main Programs ttbar2.lhe ) successively are used as input. Also illustrating some other aspects, like the capability to mix in internally generated events. Sample Main Programs Sample Main Programs main13.cc : a streamlined version of Sample Main Programs main12.cc , where two Les Houches Event Files ( Sample Main Programs ttbar.lhe and Sample Main Programs ttbar2.lhe ) successively are used as input in Sample Main Programs main13.cmnd file. Sample Main Programs Sample Main Programs main14.cc : a systematic comparison of several cross section values with their corresponding values in PYTHIA 6.4, the latter available as a table in the code. Sample Main Programs Sample Main Programs main15.cc : loop over several tries, either to redo B decays only or to redo the complete hadronization chain of an event. Since much of the generation process is only made once this is a way to increase efficiency. Sample Main Programs Sample Main Programs main16.cc : put all user analysis code into a class of its own, separate from the main program; provide the 'cards file' name as a command-line argument. Also exemplifies how Higgs mass, width and branching ratios can be set by hand. Sample Main Programs Sample Main Programs main17.cc : shows (a) how to use UserHooks to regularize onium cross section for pT &rarr; 0, and (b) how decays could be handled externally. Sample Main Programs Sample Main Programs main18.cc : shows how to write an event filter class, where you keep a vector of pointers to the subset of particles you want to study further. The event record itself remains unchanged. Sample Main Programs Sample Main Programs main19.cc : use several instances of Pythia, one for signal events and others for a variable number of pileup and 'beam-gas' events, combined into one common event record. Illustrates how new Pythia instances can copy existing settings and particle data. Sample Main Programs Sample Main Programs main20.cc : shows how PYTHIA 8 can write a Les Houches Event File, using facilities potentially useful also for other programs to write an LHEF. See also Sample Main Programs main64.cc. Sample Main Programs Sample Main Programs main21.cc : an example how a single particle or various parton-level configurations can be input directly for hadronization, without being tied to the full process-generation machinery, e.g. to study the hadronization of junction topologies. Can also be used for single-resonance decays, with showers. Sample Main Programs Sample Main Programs main22.cc : shows how an external resonance can be implemented as a new class derived from a PYTHIA base class, and be used in an external process, both of them handed in for generation as with normal internal classes. Sample Main Programs Sample Main Programs main23.cc : shows how to write external classes, derived from PYTHIA base classes, that can be handed to PYTHIA for internal generation. The MIXMAX random number generator is this way compared with the default PYTHIA one. Explicit implementations are included for the generation of external beam momentum spread and vertex location, and for a simple scaling external parton distribution set. Sample Main Programs Sample Main Programs main24.cc : tests of internally implemented cross sections for Supersymmetric particle production, with SUSY spectrum defined in Sample Main Programs slha2-example.spc and settings in Sample Main Programs main24.cmnd. For illustration, an alternative example spectrum is also available, Sample Main Programs sps1aWithDecays.spc , which contains a decay table in SLHA format. Sample Main Programs Sample Main Programs main25.cc : input RPV-SUSY events from an LHEF file that contains an SLHA spectrum inside its header. The event file, Sample Main Programs main25.lhe , contains a sample events that illustrate how to arrange color tags in the presence of the color-space epsilon tensors that accompany baryon number violating event topologies. Sample Main Programs Sample Main Programs main26.cc : test program for processes in scenarios with large extra dimensions or unparticles. Sample Main Programs Sample Main Programs main27.cc : production of Kaluza-Klein Sample Main Programs gamma/Z states in TeV-sized extra dimensions. Sample Main Programs Sample Main Programs main28.cc : production of long-lived R-hadrons, that are forced to decay at a separate vertices and possibly with changed momenta. Sample Main Programs Sample Main Programs main29.cc : colour reconnection models studied for top production. Illustrates how to set up the user hooks in Sample Main Programs include/Pythia8Plugins/ColourReconnectionHooks.h , with several models not found in the standard PYTHIA library. Sample Main Programs Sample Main Programs main30.cc : example how to create a tailormade copy of the ordinary event record, here with hard-process history tracing closer to the PYTHIA 6 conventions. Sample Main Programs Sample Main Programs main31.cc : exemplifies an improved matching of parton showers to LHEF-style input based on the Sample Main Programs POWHEG approach. The Sample Main Programs main31.cmnd allows to switch between several different matching options. It also allows to select input process, in this case either for the POWHEG-hvq program applied to top pair production Sample Main Programs Cor10 or for QCD 2+3-jet events. The small samples of input events are stored in the Sample Main Programs powheg-hvq.lhe and Sample Main Programs powheg-dijets.lhe files, respectively. Sample Main Programs Sample Main Programs main32.cc : exemplifies MLM merging, either in the ALPGEN variant or in the Madgraph one, and with input events either from ALPGEN or from Madgraph, with relevant control cards stored in Sample Main Programs main32.cmnd. See Sample Main Programs Jet Matching for further details. Traditionally the ALPGEN output is split into one file with events and another with parameters and cross sections (unlike in LHEF). Here a sample of Sample Main Programs W + 3 jets events is stored in Sample Main Programs main32.unw and the parameters to go with it in Sample Main Programs main32_unw.par. Madgraph events are taken from the Sample Main Programs w+_production_lhc_2.lhe file in this case. Sample Main Programs Sample Main Programs main33.cc : demonstrates how to link the POWHEGBOX matrix element programs dynamically, bypassing the need for intermediate LHE files. Two special files are used in this option: Sample Main Programs include/Pythia8Plugins/LHAPowheg.h contains the LHAup class wrapper used to build the POWHEG plugin libraries, and Sample Main Programs include/Pythia8Plugins/PowhegProcs.h the simple class that facilitates loading the POWHEG plugins. In addition Sample Main Programs main33.cmnd contains the commands needed for POWHEGBOX to run the example. Sample Main Programs Sample Main Programs main34.cc : demonstrates how Madgraph5_aMC\@NLO can be run 'from within' Pythia, making use of the Sample Main Programs LHAupMadgraph wrapper/interface of Madgraph5_aMC\@NLO and the Pythia jet matching facilities. Sample Main Programs Sample Main Programs main34.py : a Python interface equivalent of Sample Main Programs main34.cc. Demonstrates usage of a PYTHIA plugin within the Python interface. Sample Main Programs Sample Main Programs main35.cc : demonstrates how to generate quarkonia events with the external HelacOnia package interfaced to Pythia, and compare results with the internal implementation. Sample Main Programs Sample Main Programs main36.cc : demonstrates how to generate Deeply Inelastic Scattering events, e.g. in a HERA configuration. Sample Main Programs Sample Main Programs main37.cc : shows how LHEF version 3.0 files can be read and used to fill several histograms of the same property, but with different event weights. Sample Main Programs Sample Main Programs main38.cc : an extended version of Sample Main Programs main37.cc , where additionally it is shown how to extract many different kinds of LHEF version 3.0 information. Sample Main Programs Sample Main Programs main41.cc : similar to Sample Main Programs main01 , except that the event record is output in the HepMC event record format. Requires that HepMC is properly linked. Note that the Sample Main Programs hepmcout41.dat output file can become quite big; so no example is included in this distribution. Sample Main Programs Sample Main Programs main42.cc : a streamlined version for the generation of events that are then stored in HepMC format, without any event analysis. That is, all physics studies will have to be done afterwards. The name of the input 'cards file' (e.g. Sample Main Programs main42.cmnd ) and output HepMC event file (e.g. Sample Main Programs hepmcout42.dat ) are to be provided as command-line arguments. Requires that HepMC is properly linked. Note that the HepMC output file can become quite big; so no example is included in this distribution. Sample Main Programs Sample Main Programs main43.cc : a further extension of Sample Main Programs main42.cc , where subruns are used to process several consecutive LHEF, as in Sample Main Programs main13.cc , with information stored e.g in Sample Main Programs main43.cmnd. Other comments as for Sample Main Programs main42.cc. Sample Main Programs Sample Main Programs main46.cc : illustrated how the ProMC library can be used to store Pythia events in a compact format. Sample Main Programs Sample Main Programs main48.cc : demonstrates how to use the Sample Main Programs EvtGenDecays class provided by Sample Main Programs include/Pythia8Plugins/EvtGen.h to perform decays with the Sample Main Programs EvtGen package. The Sample Main Programs main48.cc header contains special instructions how to configure PYTHIA for use with Sample Main Programs EvtGen. Sample Main Programs Sample Main Programs main51.cc : a test of the shape of parton densities, as a check prior to using a given PDF set in a generator.  Requires that LHAPDF is properly linked. Also shows how to plot histograms (with logarithmic Sample Main Programs x scale) using the Python/Matplotlib/Pyplot solution. Sample Main Programs Sample Main Programs main52.cc : compares the charged multiplicity distribution, and a few other minimum-bias physics aspects, between default PYTHIA PDF and another one. Requires that LHAPDF is properly linked. Sample Main Programs Sample Main Programs main53.cc : tests the possibility to do backwards evolution from an incoming photon at the hard interaction. Requires that you link to a LHAPDF set that includes the photon PDF. Sample Main Programs Sample Main Programs main54.cc : compares the internal and LHAPDF implementations of the NNPDF 2.3 QCD+QED sets, for results and for timing. Requires that LHAPDF is properly linked. Sample Main Programs Sample Main Programs main55.cc : exemplifies how you can use the internal implementation of interpolation in an lhagrid1 .dat file, without linking LHAPDF6. Also illustrates the topical issue of associated event properties for an intermediate spinless resonance in Sample Main Programs &gamma; + &gamma; &rarr; &gamma; + &gamma; at 750 GeV. Sample Main Programs Sample Main Programs main61.cc : exemplifies the generation of hard diffractive processes. Sample Main Programs Sample Main Programs main62.cc : illustrates how a user hook can be made to steer the angular distribution selection in resonance decays. The prime example would be if LHEF input, e.g. from Madgraph, contains undecayed resonances with helicity information. These would then be decayed isotropically by PYTHIA, but this example shows how one could do better. Some input in Sample Main Programs main62.cmnd. Sample Main Programs Sample Main Programs main63.cc : exemplifies how a user hook can be used to enhance the rate of rare emissions in the shower. Sample Main Programs Sample Main Programs main64.cc : examplifies how LHEF version 3 events can be written on an external file. Sample Main Programs Sample Main Programs main68.cc : examplifies hard diffraction in the context of a photon-inside-lepton beam, like a HERA. Sample Main Programs Sample Main Programs main69.cc : examplifies how to generate all relevant contributions for charged particle spectra in photon-photon and photon-proton collisions. Sample Main Programs Sample Main Programs main70.cc : examplifies how to provide an external photon flux for photo-production processes. Sample Main Programs Sample Main Programs main71.cc : an example how the FastJet jet finding package can be linked to allow an analysis of the final state, in this case for a study of W + jet production. Sample Main Programs Sample Main Programs main72.cc : a comparison of SlowJet and FastJet jet finding, showing that they find the same jets if run under identical conditions, in this case for QCD jets. Sample Main Programs Sample Main Programs main73.cc : a comparison of jet properties on the parton and the hadron level, illustrating possibilities for larger control of which particles are used in the jet analyses. Sample Main Programs Sample Main Programs main74.cc : exemplifies how to use one of the contributed add-ons to the FastJet package. In this case the modified Mass Drop Tagger is used to improve the mass reconstruction of a boosted hadronically decaying Sample Main Programs Z^0. Sample Main Programs Sample Main Programs main75.cc : setup (in Sample Main Programs main75.cmnd ) for Dark Matter production via an Sample Main Programs s -channel mediator, where a mono-jet Sample Main Programs pT spectrum is found with the FastJet package. Sample Main Programs Sample Main Programs main76.cc : simple setup for Dark Matter production in several different scenarios, as specified in Sample Main Programs main76.cmnd , notably with long-lived particle signatures. Sample Main Programs Sample Main Programs main77.cc : example how double parton scattering events can be reweighted according to a different model than default in Pythia. Contributed by Boris Blok and Paolo Gunnellini. Sample Main Programs Sample Main Programs main80.cc : do CKKW-L merging with a merging scale defined in Sample Main Programs kT. Input is provided by the Sample Main Programs main80.cmnd file and input LHE files. Very basic and pedagogical setup, suitable for tutorials. Sample Main Programs Sample Main Programs main81.cc : do CKKW-L merging with a merging scale defined in Sample Main Programs kT. Input is provided by the Sample Main Programs main81.cmnd file and the three data files Sample Main Programs w+_production_lhc_0.lhe , Sample Main Programs w+_production_lhc_1.lhe and Sample Main Programs w+_production_lhc_2.lhe. Sample Main Programs Sample Main Programs main82.cc : do CKKW-L merging with a user-defined merging scale function. Input is provided by the Sample Main Programs main82.cmnd file and the three data files Sample Main Programs w+_production_lhc_0.lhe , Sample Main Programs w+_production_lhc_1.lhe and Sample Main Programs w+_production_lhc_2.lhe. Sample Main Programs Sample Main Programs main83.cc : as Sample Main Programs main82.cc but with an additional cut on the lowest multiplicity allowed for the reclustered state. The same input as for Sample Main Programs main82.cc can be used. Sample Main Programs Sample Main Programs main84.cc : do CKKW-L merging with output in such a way that it can be used in subsequent RIVET analyses. Input is provided by the Sample Main Programs main84.cmnd file and the three data files Sample Main Programs w+_production_lhc_0.lhe , Sample Main Programs w+_production_lhc_1.lhe and Sample Main Programs w+_production_lhc_2.lhe. Sample Main Programs Sample Main Programs main85.cc : do CKKW-L merging, with HepMC event output. Input settings are provided by the Sample Main Programs main85.cmnd file. This example program allows the use of input Les Houches events that are regularised with only very minimal cuts, and on which Pythia itself should enforce the more restrictive merging scale cut. The example program can be used with the input files Sample Main Programs w_production_tree_0.lhe , Sample Main Programs w_production_tree_1.lhe and Sample Main Programs w_production_tree_2.lhe. Sample Main Programs Sample Main Programs main86.cc : do unitarised ME+PS (UMEPS) merging, with HepMC event output. Input settings are provided by the Sample Main Programs main86.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to Sample Main Programs main85.cc. The example program can be used with the input files Sample Main Programs w_production_tree_0.lhe , Sample Main Programs w_production_tree_1.lhe and Sample Main Programs w_production_tree_2.lhe. The program will produce positively and negatively weighted events. See Sample Main Programs UMEPS Merging for further details. Sample Main Programs Sample Main Programs main87.cc : do NL Sample Main Programs 3 NLO merging, with inclusive NLO input, and with HepMC event output. Input settings are provided by the Sample Main Programs main87.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to Sample Main Programs main85.cc. The example program can be used with the tree-level input files Sample Main Programs w_production_tree_0.lhe , Sample Main Programs w_production_tree_1.lhe , Sample Main Programs w_production_tree_2.lhe and the inclusive POWHEG input files Sample Main Programs w_production_powheg_0.lhe , Sample Main Programs w_production_powheg_1.lhe. The program will produce positively and negatively weighted events. See Sample Main Programs NLO Merging (NL Sample Main Programs 3 section) for further details. Sample Main Programs Sample Main Programs main88.cc : do unitarised NLO+PS (UNLOPS) merging, with inclusive NLO input, and with HepMC event output. Input settings are provided by the Sample Main Programs main88.cmnd file. This example program allows the consistent use of input Les Houches events that are regularised with only very minimal cuts, similar to Sample Main Programs main85.cc. The example program can be used with the tree-level input files Sample Main Programs w_production_tree_0.lhe , Sample Main Programs w_production_tree_1.lhe , Sample Main Programs w_production_tree_2.lhe and the inclusive POWHEG input files Sample Main Programs w_production_powheg_0.lhe , Sample Main Programs w_production_powheg_1.lhe. The program will produce positively and negatively weighted events. See Sample Main Programs NLO Merging (UNLOPS section) for further details. Sample Main Programs Sample Main Programs main89.cc : do matching/merging according to five alternative methods, simply by choosing which Sample Main Programs .cmnd file to read: Sample Main Programs main89ckkwl.cmnd for CKKW-L, Sample Main Programs main89fxfx.cmnd for FxFx, Sample Main Programs main89mlm.cmnd for MLM, Sample Main Programs main89umeps.cmnd for UMEPS, and Sample Main Programs main89unlops.cmnd for UNLOPS. Sample Main Programs Sample Main Programs main91.cc : shows how ROOT can be used for histogramming in a program that for the rest is structured like a normal PYTHIA run. Sample Main Programs Sample Main Programs main92.cc : shows how PYTHIA events can be stored as ROOT trees. Sample Main Programs Sample Main Programs main93.cc : stremlined event generation with possibility to output ROOT files, output HepMC files and run RIVET analyses, all by specifying output modes in a cmnd file, where also the event generator settings are specified. The example is run with command line options, run Sample Main Programs ./main93 -h to see a full list. See Sample Main Programs ROOT Usage for information about ROOT output, Sample Main Programs RIVET Usage for information about RIVET and Sample Main Programs HepMC Interface for information about HepMC. Sample Main Programs Sample Main Programs main101.cc : shows how the string shoving mechanism, part of the rope hadronization framework, can be set up and used to generate ridge effects. Sample Main Programs Sample Main Programs main102.cc : shows how flavour production is changed in the rope hadronization framework. Sample Main Programs Sample Main Programs main111.cc : simple pp collisions as in Sample Main Programs main01.cc , but using the Angantyr model for Heavy Ion collisions. Also shows how Rivet analyses can be set up easily using a special interface. Sample Main Programs Sample Main Programs main112.cc : p-Pb collisions at LHC energies, using the Angantyr model for Heavy Ion collisions, and analyzing events by centrality bins. Sample Main Programs Sample Main Programs main113.cc : Pb-Pb collisions at LHC energies, using the Angantyr model for Heavy Ion collisions, and analyzing events by centrality bins. Sample Main Programs Sample Main Programs main121.cc : set up automatic uncertainty band variations to PDFs and factorization and renormalization scales."},{"name":"Semi-Internal Processes","link":"SemiInternalProcesses.html","text":"Semi-Internal Processes Semi-Internal Processes Semi-Internal Processes Normally users are expected to implement new processes via the Semi-Internal Processes Les Houches Accord. Then you do all flavour, colour and phase-space selection externally, before your process-level events are input for further processing by PYTHIA. However, it is also possible to implement a new process in exactly the same way as the internal PYTHIA ones, thus making use of the internal phase space selection machinery to sample an externally provided cross-section expression. The MadGraph5 program Semi-Internal Processes Alw11 allows you to do exactly that, i.e. it can be used to generate C++ code that can be linked into the existing PYTHIA framework, see Semi-Internal Processes here. Semi-Internal Processes Should you decide to go ahead on your own, this page gives a brief summary how to do that. If you additionally want to introduce a new resonance species, with its own internal width calculations, you will find further instructions Semi-Internal Processes here. It is strongly recommended to shop around for a similar process that has already been implemented, and to use that existing code as a template. Look for processes with the same combinations of incoming flavours and colour flows, rather than the shape of the cross section itself. With a reasonable such match the task should be of medium difficulty, without it more demanding. Semi-Internal Processes PYTHIA's internal phase-space generators are rather good at handling the phase space of Semi-Internal Processes 2 &rarr; 1 and Semi-Internal Processes 2 &rarr; 2 processes, are more primitive for Semi-Internal Processes 2 &rarr; 3 ones and do not at all address higher multiplicities. An option is therefore also provided for external phase-space generators to be used, which must then be encapsulated to inherit from PYTHIA's Semi-Internal Processes PhaseSpace base class (or one of its derivatives). The set of processes that can be implemented in this framework is therefore in principle unlimited, though the user must supply external phase-space generators for non-trivial Semi-Internal Processes 2 &rarr; 3 processes and all higher Semi-Internal Processes 2 &rarr; n multiplicities. Note, however, that the produced particles may be resonances, so it is possible to end up with bigger 'final' multiplicities through sequential decays, also with the internal phase-space generators, and to include further matrix-element weighting in those decays. Semi-Internal Processes For processes using PYTHIA's internal phase-space generators, there are three steps involved in implementing a process: Semi-Internal Processes Semi-Internal Processes making use of the PYTHIA-provided kinematics information to calculate the relevant cross section, Semi-Internal Processes writing a new class,  where the matrix elements are implemented, including information on incoming and outgoing flavours and colours, and Semi-Internal Processes making the process available. We consider these aspects in turn. An example where it all comes together is found in Semi-Internal Processes main22.cc. Semi-Internal Processes For processes for which an external phase-space generator will be used, step 1 above changes to writing a new class, where the phase-space generator is implemented, and making use of that to calculate the relevant cross section. There are no example programs illustrating how to do this yet, but the methodology is described below, under 'Implementing an external phase-space generator'. Semi-Internal Processes The Cross Section Calculation The key method for the cross section calculation is Semi-Internal Processes SigmaProcess::sigmaHat() , described below. At the point when it is called, the kinematics has already been set up, and from these phase space variables the differential cross section is to be calculated. Semi-Internal Processes For a Semi-Internal Processes 2 &rarr; 1 process, the returned value should be Semi-Internal Processes sigmaHat(sHat) , where Semi-Internal Processes mH (= Semi-Internal Processes mHat ), Semi-Internal Processes sH (= Semi-Internal Processes sHat ) and Semi-Internal Processes sH2 (= Semi-Internal Processes sHat^2 ) are available to be used. Incoming partons are massless. Overload the Semi-Internal Processes convertM2() method below if you instead plan to return Semi-Internal Processes |M|^2. Semi-Internal Processes For a Semi-Internal Processes 2 &rarr; 2 process, instead Semi-Internal Processes d(sigmaHat)/d(tHat) should be returned, based on provided Semi-Internal Processes mH, sH, sH2, tH, tH2, uH, uH2, m3, s3, m4, s4 and Semi-Internal Processes pT2 values ( Semi-Internal Processes s3 = m3*m3 etc.). Incoming partons are massless. Overload the Semi-Internal Processes convertM2() method below if you instead plan to return Semi-Internal Processes |M|^2. Semi-Internal Processes For a Semi-Internal Processes 2 &rarr; 3 process, instead Semi-Internal Processes |M|^2 should be returned, with normalization such that Semi-Internal Processes |M|^2 / (2 sHat) integrated over the three-body phase space gives the cross section. Here no standard set of Mandelstam-style variables exists. Instead the obvious ones, Semi-Internal Processes mH, sH, m3, s3, m4, s4, m5, s5 , are complemented by the four-vectors Semi-Internal Processes p3cm, p4cm, p5cm , from which further invariants may be calculated. The four-vectors are defined in the CM frame of the subcollision, with massless incoming partons along the Semi-Internal Processes +-z axis. Semi-Internal Processes In either case, Semi-Internal Processes alpha_s and Semi-Internal Processes alpha_em have already been calculated, and are stored in Semi-Internal Processes alpS and Semi-Internal Processes alpEM. Also other standard variables may be used, like Semi-Internal Processes CoupEW::sin2thetaW() , and related flavour-dependent vector and axial couplings in Semi-Internal Processes CoupEW and CKM combinations in Semi-Internal Processes VCKM. Semi-Internal Processes In case some of the final-state particles are resonances, their squared masses have already been selected according to a Breit-Wigner with a linearly running width Semi-Internal Processes Gamma(m) = Gamma(m_0) * m / m_0. More precisely, the mass spectrum is weighted according to Semi-Internal Processes w_BW(m^2) d(m^2) , where Semi-Internal Processes w_BW(m^2) = (1/pi) * (m * Gamma(m)) / ( (m^2 - m_0^2)^2 + (m * Gamma(m))^2 ). If you would like to have another expression, the above weights are stored in Semi-Internal Processes runBW3 , Semi-Internal Processes runBW4 and Semi-Internal Processes runBW5 , respectively. If you divide out one of these factors, you just remain with a phase space selection Semi-Internal Processes d(m^2) for this particle, and can multiply on your desired shape factor instead. Unfortunately, the Monte Carlo efficiency will drop if your new mass distribution differs dramatically from the input one. Therefore it does make sense to adjust the database value of the width to be slightly (but not too much) broader than the distribution you have in mind. Also note that, already by default, the wings of the Breit-Wigner are oversampled (with a compensating lower internal weight) by partly sampling like Semi-Internal Processes (a + b/m^2 + c/m^4) d(m^2) , where the last term is only used for Semi-Internal Processes gamma^*/Z^0. Semi-Internal Processes As alternative to the kinematics variables defined above, also the two arrays Semi-Internal Processes mME[5] and Semi-Internal Processes pME[5] , for masses and four-momenta, respectively, can be used for cross-section calculations. Here indices 0 and 1 are the two incoming beams, and 2 and onwards the outgoing particles. Note that this differs by one step from the normal internal labeling, where slot 0 is left empty. The four-momenta are defined in the rest frame of the subcollision, with the incoming partons along the Semi-Internal Processes +-z direction. The kinematics need not agree with the 'correct' one stored in the event record, for three reasons. Semi-Internal Processes 1) Gauge invariance forces matrix-element calculations to use the same masses for incoming as outgoing legs of a particle species, say Semi-Internal Processes b quarks. Therefore the kinematics of the two incoming partons is recalculated, relative to the normal event record, to put the partons on the mass shell. (Note that initial masses is a technical issue, not the correct physics picture: the incoming partons are likely to be spacelike virtual rather than on the mass shell.) Semi-Internal Processes 2) In principle each fermion flavour has to be treated separately, owing to a different mass. However, in many cases fermions can be assumed massless, which speeds up the calculations, and further gains occur if then different flavours can use the same cross-section expression. In MadGraph the default is that fermions up to and including the Semi-Internal Processes c quark and the Semi-Internal Processes mu lepton are considered massless, while the Semi-Internal Processes b quark and the Semi-Internal Processes tau lepton are considered massive. This can be modified however, and below we provide four flags that can be used to consider the 'borderline' fermions either as massless or as massive when matrix elements are evaluated, to match the assumptions made for the matrix elements themselves. Semi-Internal Processes 3) For Semi-Internal Processes 2 &rarr; 2 and Semi-Internal Processes 2 &rarr; 3 processes of massive identical particles (or antiparticles) in the final state, such as Semi-Internal Processes t tbar or Semi-Internal Processes W^+ W^- , the kinematics is here adjusted so that the two or three particles have the same mass, formed as a suitable average of the actual Breit-Wigner-distributed masses. This allows the evaluation of matrix-element expressions that only have meaning if the two/three have the same mass. Semi-Internal Processes Thus the mass array Semi-Internal Processes mME[5] and the four-momentum array Semi-Internal Processes pME[5] present values both for initial- and final-state particles based on these mass principles suited for matrix-element input. Note that these variables therefore differ from the kinematics stored in the event record proper, where incoming fermions are always massless and outgoing resonances have independent Breit-Wigner mass distributions. Semi-Internal Processes The conversion from the normal to the special kinematics is done by calling the Semi-Internal Processes setupForME() method. This you have to do yourself in the Semi-Internal Processes SigmaHat() member of your derived class. Alternatively it could be done in Semi-Internal Processes SigmaKin() , i.e. before the loop over incoming flavours, but then these would be considered massless. The identity of final-state particles is obtained from the Semi-Internal Processes id3Mass() , Semi-Internal Processes id4Mass() and Semi-Internal Processes id5Mass() methods. Should the conversion to Semi-Internal Processes mME[5] and Semi-Internal Processes pME[5] not work, Semi-Internal Processes setupForME() will return Semi-Internal Processes false , and then the cross section should be put zero. Semi-Internal Processes The Cross Section Class The matrix-element information has to be encoded in a new class. The relevant code could either be put before the main program in the same file, or be stored separately, e.g. in a matched pair of Semi-Internal Processes .h and Semi-Internal Processes .cc files. The latter may be more convenient, in particular if the cross sections are lengthy, or if you intend to build up your own little process library, but of course requires that these additional files are correctly compiled and linked. Semi-Internal Processes The class has to be derived either from Semi-Internal Processes Sigma1Process , for Semi-Internal Processes 2 &rarr; 1 processes, from Semi-Internal Processes Sigma2Process , for Semi-Internal Processes 2 &rarr; 2 ones, or from Semi-Internal Processes Sigma3Process , for Semi-Internal Processes 2 &rarr; 3 ones. (The Semi-Internal Processes Sigma0Process class is used for elastic, diffractive and minimum-bias events, and is not recommended for use beyond that.) These are in their turn derived from the Semi-Internal Processes SigmaProcess base class. Semi-Internal Processes The class can implement a number of methods. Some of these are compulsory, others strongly recommended, and the rest are to be used only when the need arises to override the default behaviour. The methods are: Semi-Internal Processes A Semi-Internal Processes constructor for the derived class obviously must be available. Here you are quite free to allow a list of arguments, to set the parameters of your model, or even to create a set of closely related but distinct processes. For instance, Semi-Internal Processes g g &rarr; Q Qbar , Semi-Internal Processes Q = c or Semi-Internal Processes b , is only coded once, and then the constructor takes the quark code (4 or 5)  as argument, to allow the proper amount of differentiation. Semi-Internal Processes A Semi-Internal Processes destructor is only needed if you plan to delete the process before the natural end of the run, and require some special behaviour at that point. If you call such a destructor you will leave a pointer dangling inside the Semi-Internal Processes Pythia object you gave it in to, if that still exists. Semi-Internal Processes Access to a process Once you have implemented a class, it is straightforward to make use of it in a run. Assume you have written a new class Semi-Internal Processes MySigma , which inherits from Semi-Internal Processes Sigma1Process , Semi-Internal Processes Sigma2Process or Semi-Internal Processes Sigma3Process , which in their turn inherit from Semi-Internal Processes SigmaProcess. You then create an instance of this class and hand it in to a Semi-Internal Processes pythia object with Semi-Internal Processes SigmaProcess* mySigma = new MySigma();     pythia.setSigmaPtr( mySigma); If an external phase-space generator should be used for this process (see 'Implementing an external phase-space generator' below), this should be specified as a second argument in the call to Semi-Internal Processes setSigmaPtr() , as in: Semi-Internal Processes pythia.setSigmaPtr( new mySigma(), new myPhaseSpaceGenerator() ); If you have several processes you can repeat the procedure any number of times. When Semi-Internal Processes pythia.init() is called these processes are initialized along with any internal processes you may have switched on, and treated in exactly the same manner. The Semi-Internal Processes pythia.next() will therefore generate a mix of the different kinds of processes without distinction. See also the Semi-Internal Processes Program Flow description. Semi-Internal Processes If the code should be of good quality and general usefulness, it would be simple to include it as a permanently available process in the standard program distribution. The final step of that integration ought to be left for the PYTHIA authors, but here is a description of what is required. Semi-Internal Processes A flag has to be defined, that allows the process to be switched on; by default it should always be off. The name of the flag should be chosen of the type Semi-Internal Processes model:process. Here the Semi-Internal Processes model would be related to the general scenario considered, e.g. Semi-Internal Processes Compositeness , while Semi-Internal Processes process would specify instate and outstate, separated by a 2 (= to), e.g. Semi-Internal Processes ug2u*g. When several processes are implemented and 'belong together' it is also useful to define a Semi-Internal Processes model:all switch that affects all the separate processes. Semi-Internal Processes The flags should normally be stored in the Semi-Internal Processes ProcessSelection.xml file or one of its daughters for a specific kind of processes. This is to make them easily found by users. You could create and use your own Semi-Internal Processes .xml file, so long as you then add that name to the list of files in the Semi-Internal Processes Index.xml file. (If not, the flags would never be created and the program would not work.) Semi-Internal Processes In the Semi-Internal Processes ProcessContainer.c file, the Semi-Internal Processes SetupContainers::init() method needs to be expanded to create instances of the processes switched on. This code is fairly repetitive, and should be easy to copy and modify from the code already there. The basic structure is Semi-Internal Processes (i) check whether a process is requested by the user and, if so, Semi-Internal Processes (ii) create an instance of the matrix-element class, Semi-Internal Processes (iii)create a container for the matrix element and its associated phase-space handling, and Semi-Internal Processes (iv) add the container to the existing process list. Semi-Internal Processes Two minor variations are possible. One is that a set of related processes are lumped inside the the same initial check, i.e. are switched on all together. The second is that the matrix-element constructor may take arguments, as specified by you (see above). If so, the same basic matrix element may be recycled for a set of related processes, e.g. one for a composite Semi-Internal Processes u and one for a composite Semi-Internal Processes d. Obviously these variations may be combined. Semi-Internal Processes Implementing an external phase-space generator An external phase-space generator can be interfaced by encapsulating it within a class inheriting from PYTHIA's Semi-Internal Processes PhaseSpace base class. The following three virtual methods must be defined: Semi-Internal Processes // Determine how phase space should be sampled.     virtual bool setupSampling();     // Select a trial event kinematics.     virtual bool trialKin(bool inEvent = true, bool repeatSame = false);     // Construct final (accepted) event kinematics.     virtual bool finalKin(); Optionally, a further virtual method is available to specify whether beam particles are resolved in partons or scatter directly, Semi-Internal Processes // Inform whether beam particles are resolved or scatter directly.     virtual bool isResolved(); with default return value Semi-Internal Processes true. Semi-Internal Processes In the Semi-Internal Processes setupSampling() step the main point is to determine the upper estimate of the cross section integrated over the allowed phase space regions, and this should be stored in Semi-Internal Processes sigmaMx. The ratio between the correct cross section and its upper estimate is a measure of the phase-space selection efficiency, and the purpose of this step is to optimize the sampling accordingly. To this end any convenient set of phase-space variables may be chosen. The Semi-Internal Processes x1H and Semi-Internal Processes x2H varables should be used to denote the incoming parton momentum fractions, however, to be used in PDF evaluations. Semi-Internal Processes In the Semi-Internal Processes trialKin() intermediate step the same set of internal variables can be used, and fed into the Semi-Internal Processes SigmaProcess code to evaluate the cross section in the given phase space point, multiplied by the integrated cross section. This value is to be stored in Semi-Internal Processes sigmaNw , and the ratio Semi-Internal Processes sigmaNw/sigmaMx will be used to determine whether the trial event is accepted or not. Semi-Internal Processes In the Semi-Internal Processes finalKin() step the output is more standardized. The key values are the ones stored in the Semi-Internal Processes mH[] and Semi-Internal Processes pH[] arrays, the former for masses and the latter for four-momenta. Here the first two slots represent the two incoming partons and the subsequent ones up to ten outgoing particles. Other particle properties, like the number of final-state particles, their identities and colours, and more, are defined by the Semi-Internal Processes SigmaProcess class. Semi-Internal Processes A tailor-made Semi-Internal Processes 2 &rarr; 3 generator could be defined, e.g., by starting from the code for PYTHIA's internal Semi-Internal Processes PhaseSpace2to3tauycyl base class, which provides a specific representation of 3-parton phase space, used for generic Semi-Internal Processes 2 &rarr; 3 processes in PYTHIA. The virtual functions described could then be redefined to generate a different sampling of 3-parton phase space. One example of this is provided by the existing Semi-Internal Processes PhaseSpace2to3yyycyl class, which PYTHIA uses for massless QCD processes. Note the interplay between the phase-space variables, generated and saved here, and how they are used by the matrix-element codes. For general processes, the user can define samplings in terms of their own phase-space parametrizations, as long as the corresponding matrix elements use the same variables to evaluate the cross-section expressions."},{"name":"Semi-Internal Resonances","link":"SemiInternalResonances.html","text":"Semi-Internal Resonances Semi-Internal Resonances Semi-Internal Resonances The introduction of a new Semi-Internal Resonances semi-internal process may also involve a new particle, not currently implemented in PYTHIA. Often it is then enough to use the Semi-Internal Resonances standard machinery to introduce a new particle ( Semi-Internal Resonances id:all = ... ) and new decay channels ( Semi-Internal Resonances id:addChannel = ... ). By default this only allows you to define a fixed total width and fixed branching ratios. Using Semi-Internal Resonances Semi-Internal Resonances meMode values 100 or bigger provides the possibility of a very simple threshold behaviour. Semi-Internal Resonances If you want to have complete freedom, however, there are two ways to go. One is that you make the resonance decay part of the hard process itself, either using the Semi-Internal Resonances Les Houches interface or a semi-internal process. The other is for you to create a new Semi-Internal Resonances ResonanceWidths object, where you write the code needed for a calculation of the partial width of a particular channel. Semi-Internal Resonances Here we will explain what is involved in setting up a resonance. Should you actually go ahead with this, it is strongly recommended to use an existing resonance as a template, to get the correct structure. There also exists a sample main program, Semi-Internal Resonances main22.cc , that illustrates how you could combine a new process and a new resonance. Semi-Internal Resonances There are three steps involved in implementing a new resonance: Semi-Internal Resonances 1) providing the standard particle information, as already outlined above ( Semi-Internal Resonances id:all = ... , Semi-Internal Resonances id:addChannel = ... ), except that now branching ratios need not be specified, since they anyway will be overwritten by the dynamically calculated values. Semi-Internal Resonances 2) writing the class that calculates the partial widths. Semi-Internal Resonances 3) handing in a pointer to an instance of this class to PYTHIA. Semi-Internal Resonances We consider the latter two aspects in turn. Semi-Internal Resonances The ResonanceWidths Class The resonance-width calculation has to be encoded in a new class. The relevant code could either be put before the main program in the same file, or be stored separately, e.g. in a matched pair of Semi-Internal Resonances .h and Semi-Internal Resonances .cc files. The latter may be more convenient, in particular if the calculations are lengthy, or likely to be used in many different runs, but of course requires that these additional files are correctly compiled and linked. Semi-Internal Resonances The class has to be derived  from the Semi-Internal Resonances ResonanceWidths base class. It can implement a number of methods. The constructor and the Semi-Internal Resonances calcWidth ones are always needed, while others are for convenience. Much of the administrative machinery is handled by methods in the base class. Semi-Internal Resonances Thus, in particular, you must implement expressions for all possible final states, whether switched on in the current run or not, since all contribute to the total width needed in the denominator of the Breit-Wigner expression. Then the methods in the base class take care of selecting only allowed channels where that is required, and also of including effects of closed channels in secondary decays. These methods can be accessed indirectly via the Semi-Internal Resonances Semi-Internal Resonances res... methods of the normal Semi-Internal Resonances Semi-Internal Resonances particle database. Semi-Internal Resonances A Semi-Internal Resonances constructor for the derived class obviously must be available. Here you are quite free to allow a list of arguments, to set the parameters of your model. The constructor must call the base-class Semi-Internal Resonances initBasic(idResIn) method, where the argument Semi-Internal Resonances idResIn is the PDG-style identity code you have chosen for the new resonance. When you create several related resonances as instances of the same class you would naturally make Semi-Internal Resonances idResIn an argument of the constructor; for the PYTHIA classes this convention is used also in cases when it is not needed. Semi-Internal Resonances The Semi-Internal Resonances initBasic(...) method will hook up the Semi-Internal Resonances ResonanceWidths object with the corresponding entry in the generic particle database, i.e. with the normal particle information you set up in point 1) above. It will store, in base-class member variables, a number of quantities that you later may find useful: Semi-Internal Resonances Semi-Internal Resonances idRes : the identity code you provide; Semi-Internal Resonances Semi-Internal Resonances hasAntiRes : whether there is an antiparticle; Semi-Internal Resonances Semi-Internal Resonances mRes : resonance mass; Semi-Internal Resonances Semi-Internal Resonances GammaRes resonance width; Semi-Internal Resonances Semi-Internal Resonances m2Res : the squared mass; Semi-Internal Resonances Semi-Internal Resonances GamMRat : the ratio of width to mass. Semi-Internal Resonances A Semi-Internal Resonances destructor is only needed if you plan to delete the resonance before the natural end of the run, and require some special behaviour at that point. If you call such a destructor you will leave a pointer dangling inside the Semi-Internal Resonances Pythia object you gave it in to, if that still exists. Semi-Internal Resonances Access to resonance widths Once you have implemented a class, it is straightforward to make use of it in a run. Assume you have written a new class Semi-Internal Resonances MyResonance , which inherits from Semi-Internal Resonances ResonanceWidths. You then create an instance of this class and hand it in to a Semi-Internal Resonances pythia object with Semi-Internal Resonances ResonanceWidths* myResonance = new MyResonance();     pythia.setResonancePtr( myResonance); If you have several resonances you can repeat the procedure any number of times. When Semi-Internal Resonances pythia.init() is called these resonances are initialized along with all the internal resonances, and treated in exactly the same manner. See also the Semi-Internal Resonances Program Flow description. Semi-Internal Resonances If the code should be of good quality and general usefulness, it would be simple to include it as a permanently available process in the standard program distribution. The final step of that integration ought to be left for the PYTHIA authors, but basically all that is needed is to add one line in Semi-Internal Resonances ParticleData::initResonances , where one creates an instance of the resonance in the same way as for the resonances already there. In addition, the particle data and decay table for the new resonance has to be added to the permanent Semi-Internal Resonances particle database , and the code itself to Semi-Internal Resonances include/ResonanceWidths.h and Semi-Internal Resonances src/ResonanceWidths.cc."},{"name":"Simple Showers","link":"SimpleShowers.html","text":"Simple Showers Simple Showers Simple Showers Simple Showers Overview of recent changes PYTHIA comes with a complete parton-shower machinery, but also allows external shower programs to be linked in to it, see the Simple Showers Implement New Showers page. Notably the VINCIA and DIRE codes have been structured to make use of this functionality. Currently these codes are distributed separately, but the intention is to integrate them into the PYTHIA distribution in the future. Simple Showers Originally the Simple Showers TimeShower and Simple Showers SpaceShower classes implemented the default PYTHIA showers, but also acted as base classes from which the external showers derived. This has some disadvantages, so the two aspects are now split. The Simple Showers TimeShower and Simple Showers SpaceShower classes remain as simple base classes from which the actual showers are derived. The physics code has been moved to the new derived Simple Showers SimpleTimeShower and Simple Showers SimpleSpaceShower. An external shower that does not use any of the existing shower algorithms will therefore work as before, which would be the normal case, but alternatively a shower could of course derive from the new classes and then reuse relevant code in them. Simple Showers Settings names have been retained, again for reasons of backwards compatibility of user code, e.g. in command files. Thus setting names beginning with Simple Showers TimeShower: , Simple Showers SpaceShower: , Simple Showers WeakShower: or Simple Showers UncertaintyBands: refer uniquely to the current baseline 'simple' ones. In the future some of them may become common with VINCIA and DIRE, notably the uncertainty bands ones, whereas ones specific to those two programs will have names that spell it out. Simple Showers The prepending of 'Simple' was a minimalistic choice under the circumstances; more fancy names could have been chosen. What it refers to is that showers like VINCIA and DIRE aim higher, in striving to achieve full NLL accuracy, whereas the Simple ones operate in an improved LL approximation. In other respects the Simple showers can do more different physics than the other two, at least currently. Some examples of the broad approach are Simple Showers Simple Showers Matrix elements corrections for the first ('hardest') gluon emission in most two-body resonance decays, effectively making the FSR in these decays NLO accurate. Simple Showers There is no corresponding NLO accuracy for ISR in any processes, but several examples where reasonably accurate kinematics spectra are available over the full phase space, by input of partial higher-order information. Simple Showers The default dipole-recoil scheme for FSR can be switched to a global-recoil option for the first few emissions, in order to simplify matching and merging to higher-order calculations. Simple Showers The default global-recoil scheme for ISR can be replaced by a dipole-recoil scheme, where the other colour dipole end may be in the final state. Simple Showers Showers off massive objects, within and beyond the Standard Model, including e.g. octet onium states. Simple Showers Showers interleaved with multiparton interactions, and set up to handle Simple Showers two predefined hard interactions. Simple Showers QED showers, where photons can be emitted and then branch into fermion pairs that shower further. Simple Showers Weak radiation of Simple Showers W^+- and Simple Showers Z^0 off fermions. Simple Showers Radiation also in some hadronic decays. Simple Showers Possibility to handle both abelian and nonabelian showers in a hidden valley sector, where relevant fully interleaved with normal QCD and QED radiation. Simple Showers A wide selection of further switches and parameters to vary shower assumptions: running of Simple Showers alpha_s , Simple Showers p_Tmin value, scale choices, gluon polarization effects, mass effects in Simple Showers g &rarr; q qbar , etc. Simple Showers Shower components The Simple Showers Master Switches for ISR and FSR in general, and a switch for QED radiation in Simple Showers Particle Decays to leptons, are intended to be common for all shower programs, where applicable. Simple Showers The full description of settings in the Simple Shower framework is spread across several pages: Simple Showers Simple Showers The final-state Simple Showers Timelike Showers cover all aspects of QCD and QED FSR. Simple Showers The initial-state Simple Showers Spacelike Showers cover all aspects of QCD and QED ISR. Simple Showers While the main switches for weak radiation of Simple Showers W^+- and Simple Showers Z^0 are found in the two previous FSR and ISR pages, there also a few common technical Simple Showers Weak Showers settings. Simple Showers There is a special framework to produce uncertainty bands from Simple Showers Automated Variations of basic parameters, such as factorization and renormalization scales, or choice of parton distributions. Simple Showers The settings for final-state showers in a Simple Showers Hidden Valleys are stored along with the switches for such hard processes. Simple Showers There is a wide selection of Simple Showers Matching and Merging approaches that have been implemented so as to work well with these showers. Simple Showers Tunes that include ISR and FSR parameters are described on the Simple Showers Tunes page. Simple Showers The shower evolution can be interrupted or modified with the help of Simple Showers User Hooks."},{"name":"Spacelike Showers","link":"SpacelikeShowers.html","text":"Spacelike Showers Spacelike Showers Spacelike Showers The PYTHIA algorithm for spacelike initial-state showers is based on the article Spacelike Showers Sjo05 , where a transverse-momentum-ordered backwards evolution scheme is introduced, with the extension to fully interleaved evolution covered in Spacelike Showers Cor10a. This algorithm is a further development of the virtuality-ordered one presented in Spacelike Showers Sjo85 , with matching to first-order matrix element for Spacelike Showers Z^0 , Spacelike Showers W^+- and Higgs (in the Spacelike Showers m_t &rarr; infinity limit) production as introduced in Spacelike Showers Miu99. Spacelike Showers The normal user is not expected to call Spacelike Showers SpaceShower directly, but only have it called from Spacelike Showers Pythia , via Spacelike Showers PartonLevel. Nonetheless, some of the parameters below, in particular Spacelike Showers SpaceShower:alphaSvalue , would be of interest for uncertainty estimates and tuning exercises. Note that PYTHIA also incorporates an Spacelike Showers automated framework for shower uncertainty variations. Spacelike Showers Main variables The maximum Spacelike Showers pT to be allowed in the shower evolution is related to the nature of the hard process itself. It involves a delicate balance between not double-counting and not leaving any gaps in the coverage. The best procedure may depend on information only the user has: how the events were generated and mixed (e.g. with Les Houches Accord external input), and how they are intended to be used. Therefore a few options are available, with a sensible default behaviour. Spacelike Showers The amount of QCD radiation in the shower is determined by Spacelike Showers The actual value is then regulated by the running to the scale Spacelike Showers pT^2 , at which it is evaluated Spacelike Showers The CMW rescaling of Spacelike Showers Lambda_QCD (see the section on Spacelike Showers StandardModelParameters ) can be applied to the Spacelike Showers alpha_strong values used for spacelike showers. Note that tunes using this option need lower values of Spacelike Showers alpha_strong(m_Z^2) than tunes that do not. Spacelike Showers QED radiation is regulated by the Spacelike Showers alpha_electromagnetic value at the Spacelike Showers pT^2 scale of a branching. Spacelike Showers The natural scale for couplings and PDFs is Spacelike Showers pT^2. To explore uncertainties it is possibly to vary around this value, however, in analogy with what can be done for Spacelike Showers hard processes. (Note that there is also an Spacelike Showers automated framework for shower uncertainties.) Spacelike Showers There are two complementary ways of regularizing the small- Spacelike Showers pT divergence, a sharp cutoff and a smooth dampening. These can be combined as desired but it makes sense to coordinate with how the same issue is handled in multiparton interactions. Spacelike Showers The actual Spacelike Showers pT0 parameter used at a given CM energy scale, Spacelike Showers ecmNow , is obtained from a power law or a logarithmic parametrization. The former is default with hadron beams and the latter for photon-photon collisions. Spacelike Showers Dipole showers By default the recoil of an ISR emission is taken by the whole final state. The option below gives an alternative approach with local recoils, where only one final-state parton takes the recoil of an emission. See Spacelike Showers Cab17 for further details on the philosophy and implementation. Spacelike Showers The existing initial-initial global recoil scheme is maintained for an emission off a colour line that stretches through the hard process, so it is the handling of initial-final dipole ends that is changed. Here the single recoiler is picked based on the colour flow of the hard process. Additionally the description unifies the emission of a gluon from the initial-final and final-initial dipole ends, and handles both as part of the ISR framework. Therefore the separation into ISR and FSR is not a meaningful classification, and either both should be simulated or none. Spacelike Showers Note that this option should not be combined with the global option for FSR, Spacelike Showers TimeShower:globalRecoil. Furthermore some settings are neglected internally to ensure the same behaviour as obtained for Spacelike Showers TimeShower:allowBeamRecoil = on , Spacelike Showers TimeShower:dampenBeamRecoil = off , and Spacelike Showers SpaceShower:phiIntAsym = off. Spacelike Showers The dipole recoil option for the first time allows the simulation of Deeply Inelastic Scattering processes in PYTHIA 8, see the Spacelike Showers main36.cc example. Note that the simultaneous emission of photons off the lepton leg has not yet been implemented, so you need to set Spacelike Showers PDF:lepton = off and Spacelike Showers TimeShower:QEDshowerByL = off. You are further recommended to set Spacelike Showers SpaceShower:pTmaxMatch = 2 to fill the whole phase space with parton showers. This is allowed since the shower and matrix-element behaviours match well over the whole phase space (at least for the first emission). Spacelike Showers Weak showers The emission of weak gauge bosons is an integrated part of the initial- and final-state radiation, see Spacelike Showers Weak Showers. The following settings are those specifically related to the initial-state weak radiation, while common settings are found in the Spacelike Showers Weak Showers description. Spacelike Showers Further variables These should normally not be touched. Their only function is for cross-checks. Spacelike Showers There are three flags you can use to switch on or off selected branchings in the shower: Spacelike Showers There are some further possibilities to modify the shower: Spacelike Showers Technical notes Almost everything is equivalent to the algorithm in Spacelike Showers Sjo05,Cor10a. Minor changes are as follows. Spacelike Showers Spacelike Showers It is now possible to have a second-order running Spacelike Showers alpha_s , in addition to fixed or first-order running. Spacelike Showers The description of heavy flavour production in the threshold region has been modified, so as to be more forgiving about mismatches between the Spacelike Showers c/b masses used in Pythia relative to those used in a respective PDF parametrization. The basic idea is that, in the threshold region of a heavy quark Spacelike Showers Q , Spacelike Showers Q = c/b , the effect of subsequent Spacelike Showers Q &rarr; Q g branchings is negligible. If so, then Spacelike Showers f_Q(x, pT2) = integral_mQ2^pT2  dpT'2/pT'2 * alpha_s(pT'2)/2pi     * integral P(z) g(x', pT'2) delta(x - z x') so use this to select the Spacelike Showers pT2 of the Spacelike Showers g &rarr; Q Qbar branching. In the old formalism the same kind of behaviour should be obtained, but by a cancellation of a Spacelike Showers 1/f_Q that diverges at the threshold and a Sudakov that vanishes. Spacelike Showers The strategy therefore is that, once Spacelike Showers pT2 < f * mQ2 , with Spacelike Showers f a parameter of the order of 2, a Spacelike Showers pT2 is chosen like Spacelike Showers dpT2/pT2 between Spacelike Showers mQ2 and Spacelike Showers f * mQ2 , a nd a Spacelike Showers z flat in the allowed range. Thereafter acceptance is based on the product of three factors, representing the running of Spacelike Showers alpha_strong , the splitting kernel (including the mass term) and the gluon density weight. At failure, a new Spacelike Showers pT2 is chosen in the same  range, i.e. is not required to be lower since no Sudakov is involved. Spacelike Showers The QED algorithm now allows for hadron beams with non-zero photon content. The backwards-evolution of a photon in a hadron is identical to that of a gluon, with Spacelike Showers CF &rarr; eq^2 and Spacelike Showers CA &rarr; 0. Note that this will only work in conjunction with parton distributions that explicitly include photons as part of the hadron structure, such as the NNPDF2.3 QCD+QED sets. The possibility of a fermion backwards-evolving to a photon has not yet been included, nor has photon backwards-evolution in lepton beams."},{"name":"Standard-Model Parameters","link":"StandardModelParameters.html","text":"Standard-Model Parameters Standard-Model Parameters Standard-Model Parameters Standard-Model Parameters The strong coupling The Standard-Model Parameters AlphaStrong class is used to provide a first- or second-order running Standard-Model Parameters alpha_strong (or, trivially, a zeroth-order fixed one). Formulae are the standard ones found in Standard-Model Parameters Yao06. The second-order expression used, eq. (9.5), may be somewhat different in other approaches (with differences formally of higher order), so do not necessarily expect perfect agreement, especially not at small Standard-Model Parameters Q^2 scales. The starting Standard-Model Parameters alpha_strong value is defined at the Standard-Model Parameters M_Z mass scale. The Standard-Model Parameters Lambda values are matched at the Standard-Model Parameters c , Standard-Model Parameters b and Standard-Model Parameters t flavour thresholds, such that Standard-Model Parameters alpha_strong is continuous. For second-order matching an approximate iterative method is used. Standard-Model Parameters For backwards compatibility, the following global switch determines whether 5- or 6-flavour running will be used above the Standard-Model Parameters t threshold: Standard-Model Parameters Since we allow Standard-Model Parameters alpha_strong to vary separately for hard processes, timelike showers, spacelike showers and  multiparton interactions, all other relevant values are set in each of these classes. The default behaviour is everywhere first-order running. Standard-Model Parameters The Standard-Model Parameters alpha_strong calculation is initialized by Standard-Model Parameters init( value, order, nfmax) , where Standard-Model Parameters value is the Standard-Model Parameters alpha_strong value at Standard-Model Parameters M_Z , Standard-Model Parameters order is the order of the running, 0, 1 or 2, and Standard-Model Parameters nfmax is the highest number of flavours to include in the running. Thereafter the value can be calculated by Standard-Model Parameters alphaS(scale2) , where Standard-Model Parameters scale2 is the Standard-Model Parameters Q^2 scale in GeV^2. Standard-Model Parameters By default the charm, bottom and top threshold-matching mass values are chosen to be 1.5, 4.8 and 171 GeV, respectively. The Standard-Model Parameters setThresholds(double mc, double mb, double mt) method can be invoked to select other values. To take effect, this must be done before the Standard-Model Parameters AlphaStrong::init() method is called, since this is where the flavour-dependent Standard-Model Parameters Lambda_i values are calculated and stored. If in doubt, better call it once again. Standard-Model Parameters For applications inside shower programs, a second-order Standard-Model Parameters alpha_s value can be obtained as the product of the two functions Standard-Model Parameters alphaS1Ord(scale2) and Standard-Model Parameters alphaS2OrdCorr(scale2) , where the first gives a simple first-order running (but with the second-order Standard-Model Parameters Lambda ) and the second the correction factor, below unity, for the second-order terms. This allows a compact handling of evolution equations. Standard-Model Parameters Resummation arguments Standard-Model Parameters Cat91 show that a set of universal QCD corrections can be absorbed in coherent parton showers by applying the so-called CMW rescaling of the MSbar value of Standard-Model Parameters Lambda_QCD. This can be accomplished via a fourth (optional) boolean argument to Standard-Model Parameters init( value, order, nfmax, useCMW) , with default value Standard-Model Parameters useCMW = false. When set to Standard-Model Parameters true , the translation amounts to an Standard-Model Parameters N_F -dependent rescaling of Standard-Model Parameters Lambda_QCD , relative to its MSbar value, by a factor 1.661 for NF=3, 1.618 for NF=4, 1.569 for NF=5, and 1.513 for NF=6. When using this option, be aware that the original CMW arguments were derived using two-loop running and that the CMW rescaling may need be taken into account in the context of matrix-element matching. Note also that this option has only been made available for timelike and spacelike showers, not for hard processes. Standard-Model Parameters The electromagnetic coupling The Standard-Model Parameters AlphaEM class is used to generate a running Standard-Model Parameters alpha_em. The input Standard-Model Parameters StandardModel:alphaEMmZ value at the Standard-Model Parameters M_Z mass is matched to a low-energy behaviour with running starting at the electron mass threshold. The matching is done by fitting an effective running coefficient in the region between the light-quark threshold and the charm/tau threshold. This procedure is approximate, but good enough for our purposes. Standard-Model Parameters Since we allow Standard-Model Parameters alpha_em to vary separately for hard processes, timelike showers, spacelike showers and  multiparton interactions, the choice between using a fixed or a running Standard-Model Parameters alpha_em can be made in each of these classes. The default behaviour is everywhere first-order running. The actual values assumed at zero momentum transfer and at Standard-Model Parameters M_Z are only set here, however. Standard-Model Parameters The Standard-Model Parameters alpha_em calculation is initialized by Standard-Model Parameters init(order) , where Standard-Model Parameters order is the order of the running, 0 or 1, with -1 a special option to use the fix value provided at Standard-Model Parameters M_Z.   Thereafter the value can be calculated by Standard-Model Parameters alphaEM(scale2) , where Standard-Model Parameters scale2 is the Standard-Model Parameters Q^2 scale in GeV^2. Standard-Model Parameters The electroweak couplings There are two degrees of freedom that can be set, related to the electroweak mixing angle: Standard-Model Parameters The Fermi constant is not much used in the currently coded matrix elements, since it is redundant, but it is available: Standard-Model Parameters The quark weak-mixing matrix The absolute values of the Cabibbo-Kobayashi-Maskawa matrix elements are set by the following nine real values taken from Standard-Model Parameters Yao06 - currently the CP-violating phase is not taken into account in this parametrization. It is up to the user to pick a consistent unitary set of new values whenever changes are made. Standard-Model Parameters The CoupSM class The Standard-Model Parameters Standard-Model Parameters Pythia class contains a public instance Standard-Model Parameters coupSM of the Standard-Model Parameters CoupSM class. This class contains one instance each of the Standard-Model Parameters AlphaStrong and Standard-Model Parameters AlphaEM classes, and additionally stores the weak couplings and the quark mixing matrix mentioned above. This class is used especially in the calculation of cross sections and resonance widths, but could also be used elsewhere. Specifically, as already mentioned, there are separate Standard-Model Parameters AlphaStrong and Standard-Model Parameters AlphaEM instances for timelike and spacelike showers and for multiparton interactions, while weak couplings and the quark mixing matrix are only stored here. With the exception of the first two methods below, which are for internal use, the subsequent ones could also be used externally."},{"name":"SUSY Les Houches Accord","link":"SUSYLesHouchesAccord.html","text":"SUSY Les Houches Accord SUSY Les Houches Accord SUSY Les Houches Accord The PYTHIA 8 program does not contain an internal spectrum calculator (a.k.a. RGE package) to provide supersymmetric couplings, mixing angles, masses and branching ratios. Thus the SUSY Les Houches Accord (SLHA) SUSY Les Houches Accord Ska04 SUSY Les Houches Accord All08 is the only way of inputting SUSY models, and SUSY processes (see the SUSY Les Houches Accord SUSYProcesses page) cannot be run unless such an input has taken place. SUSY Les Houches Accord The SLHA input format can also be extended for use with more general BSM models, beyond SUSY. Information specific to  how to use the SLHA interface for generic BSM models is collected below, under SUSY Les Houches Accord Using SLHA for generic BSM Models , with more elaborate explanations and examples in SUSY Les Houches Accord Des11. SUSY Les Houches Accord Most of the SUSY implementation in PYTHIA 8 is compatible with both the SLHA1 SUSY Les Houches Accord Ska04 and SLHA2 SUSY Les Houches Accord All08 conventions (with some limitations for the NMSSM in the latter case). Internally, PYTHIA 8 uses the SLHA2 conventions and translates SLHA1 input to these when necessary. See the section on SUSY Processes and SUSY Les Houches Accord Des11 for more information. Note that PYTHIA assumes that a spectrum is either fully SHLA1 or fully SLHA2 compliant. Mixing of the two standards is discouraged, as this can lead to ambiguities and inconsistencies. SUSY Les Houches Accord When reading LHEF files, Pythia automatically looks for SLHA information between SUSY Les Houches Accord <slha>...</slha> tags in the header of such files. When running Pythia without LHEF input (or if reading an LHEF file that does not contain SLHA information in the header), a separate file containing SLHA information may be specified using SUSY Les Houches Accord SLHA:file (see below). SUSY Les Houches Accord Normally the LHEF would be in uncompressed format, and thus human-readable if opened in a text editor. A possibility to read gzipped files has been added, based on the Boost and zlib libraries, which therefore have to be linked appropriately in order for this option to work. See the SUSY Les Houches Accord README file in the main directory for details on how to do this. SUSY Les Houches Accord Finally, the SLHA input capability can of course also be used to input SLHA-formatted SUSY Les Houches Accord MASS and SUSY Les Houches Accord DECAY tables for other particles, such as the Higgs boson, furnishing a less sophisticated but more universal complement to the standard PYTHIA 8-specific methods for inputting such information (for the latter, see the section on SUSY Les Houches Accord Particle Data and the SUSY Les Houches Accord scheme to modify it). This may at times not be desirable, so a few options can be used to curb the right of SLHA to overwrite particle data. Conversely, it is sometimes useful to allow the user to modify eg a mass parameter relative to its value in the SLHA spectrum. This is normally not permitted (the SLHA spectrum is normally self-consistent and should not be modified), but an option for allowing it is provided. SUSY Les Houches Accord The reading-in of information from SLHA or LHEF files is handled by the SUSY Les Houches Accord SusyLesHouches class, while the subsequent calculation of derived quantities of direct application to SUSY processes is done in the SUSY Les Houches Accord CoupSUSY , SUSY Les Houches Accord SigmaSUSY , and SUSY Les Houches Accord SUSYResonanceWidths classes. SUSY Les Houches Accord Sanity Checks As an aid for basic validation, some checks and ranges are imposed  on SLHA input during initialization, as follows: SUSY Les Houches Accord SUSY Les Houches Accord Several parameters ( SUSY Les Houches Accord SLHA:keepSM , SUSY Les Houches Accord minMassSM , and SUSY Les Houches Accord SLHA:allowUserOverride ) provide some safety against unintentionally overwriting PYTHIA's Standard-Model information. These parameters can be altered to hand over more or less control to the SLHA interface. In particular, a lot of mass and decay-table information may be included by default in some SLHA files, without it being the explicit intention of the user to overwrite the corresponding PYTHIA information. The default values of the SLHA safety parameters have been chosen so as to eliminate at least the most obvious causes of Garbage In Garbage Out. (E.g., there is usually no reason to modify the masses of well-measured SM particles, like the W and Z bosons, nor to replace their sophisticated internal decay treatments by the simplified isotropic treatment used for SLHA DECAY tables.) SUSY Les Houches Accord For SLHA SUSY spectra, the interface checks  the mass-ordering of the Higgs, Neutralino, and  Chargino sectors, and the unitarity/orthogonality of the mixing matrices. It also performs some additional self-consistency checks on whether the correct SLHA BLOCKs for the given SUSY model have been included, and whether all required entries have been defined. SUSY Les Houches Accord If MASS or DECAY information for a particle has been changed by SLHA input, the following sanity checks will be carried out. The particle will be declared stable unless there is at least one on-shell decay channel open (regardless of the presence of any DECAY information). In particular, massless particles will always be declared stable. A lower cutoff is imposed on the Breit-Wigner shape of the particle, requiring its mass to remain above the sum of masses for the lightest decay channel. Subject to that constraint, the SUSY Les Houches Accord mMin and SUSY Les Houches Accord mMax cutoffs will normally be placed at 5 times the width or the on-shell mass divided by two, whichever is smaller, so that the default gives a decent sampling of the shape without straying too far from the on-shell value. The user is allowed to use the SUSY Les Houches Accord mMin and SUSY Les Houches Accord mMax parameters to choose a different sampling range if so desired (still subject to the constraint of at least one decay channel remaining open for on-shell decay products). SUSY Les Houches Accord For each decay channel in an SLHA DECAY table, PYTHIA will checks the available phase space. If the channel is on shell (sum of daughter masses is less than mass of decaying particle), then the threshold dependence is given by SUSY Les Houches Accord SLHA:meMode. If the channel is off shell, then an SUSY Les Houches Accord meMode of 100 is always used. As a further protection against GIGO, if the channel appears to be physically impossible (defined as requiring fluctuations of more than more than 100 times the effective combined widths), it is switched of and a warning message is printed. SUSY Les Houches Accord DECAY table branching fractions are always interpreted as positive. However, a negative sign for one or more channels can be given, and will then be interpreted to mean that the corresponding channel(s) should be switched off for the current run. This furnishes a simple way to switch SLHA DECAY channels on and off while preserving the sum of branching fractions equal to unity. Note that these sanity checks will not catch all possible cases of Garbage In Garbage Out, so human verification of the input files is always a good idea, as is taking a look at any warnings or error messages printed by the SLHA interface during initialization. It is ultimately up to the user to ensure that sensible input is being given. SUSY Les Houches Accord SLHA Switches and Parameters SUSY Les Houches Accord SLHA DECAY Tables In addition to SUSY spectra, the SLHA also defines a set of conventions for decay tables. These are not restricted to SUSY models, but can be used for arbitrary particles, either in combination with or independently of the SUSY parts of the Accord. The settings in this section control whether and how PYTHIA will make use of such tables. See also the comments under sanity checks above. SUSY Les Houches Accord Note : the PYTHIA SLHA interface is limited to at most SUSY Les Houches Accord 1&rarr;8 decays. SUSY Les Houches Accord Internal SLHA Variables SUSY Les Houches Accord Using SLHA for generic BSM Models SUSY Les Houches Accord Using the SUSY Les Houches Accord QNUMBERS extension SUSY Les Houches Accord Alw07 , the SLHA can also be used to define new particles, with arbitrary quantum numbers. This already serves as a useful way to introduce new particles and can be combined with SUSY Les Houches Accord MASS and SUSY Les Houches Accord DECAY tables in the usual way, to generate isotropically distributed decays or even chains of such decays. (If you want something better than isotropic, sorry, you'll have to do some actual work ...) SUSY Les Houches Accord A more advanced further option is to make use of the possibility in the SLHA to include user-defined blocks with arbitrary names and contents. Obviously, standalone PYTHIA 8 does not know what to do with such information. However, it does not throw it away either, but instead stores the contents of user blocks as strings, which can be read back later, with the user having full control over the format used to read the individual entries. SUSY Les Houches Accord The contents of both standard and user-defined SLHA blocks can be accessed in any class inheriting from PYTHIA 8's SUSY Les Houches Accord SigmaProcess class (i.e., in particular, from any semi-internal process written by a user), through its SLHA pointer, SUSY Les Houches Accord slhaPtr , by using the following methods: SUSY Les Houches Accord bool slhaPtr->getEntry(string blockName, double& val); bool slhaPtr->getEntry(string blockName, int indx, double& val); bool slhaPtr->getEntry(string blockName, int indx, int jndx, double& val); bool slhaPtr->getEntry(string blockName, int indx, int jndx, int kndx, double& val); SUSY Les Houches Accord This particular example assumes that the user wants to read the entries (without index, indexed, matrix-indexed, or 3-tensor-indexed, respectively) in the user-defined block SUSY Les Houches Accord blockName , and that it should be interpreted as a SUSY Les Houches Accord double. The last argument is templated, and hence if anything other than a SUSY Les Houches Accord double is desired to be read, the user has only to give the last argument a different type. If anything went wrong (i.e., the block doesn't exist, or it doesn't have an entry with that index, or that entry can't be read as a double), the method returns false; true otherwise. This effectively allows to input completely arbitrary parameters using the SLHA machinery, with the user having full control over names and conventions. Of course, it is then the user's responsibility to ensure complete consistency between the names and conventions used in the SLHA input, and those assumed in any user-written semi-internal process code. SUSY Les Houches Accord Note that PYTHIA 8 always initializes at least the SLHA blocks MASS and SMINPUTS, starting from its internal SM parameters and particle data table values (updated to take into account user modifications). These blocks can therefore be accessed using the SUSY Les Houches Accord slhaPtr->getEntry() methods even in the absence of SLHA input. Note: in the SMINPUTS block, PYTHIA outputs physically correct (i.e., measured) values of SUSY Les Houches Accord GF , SUSY Les Houches Accord m_Z , and SUSY Les Houches Accord alpha_EM(m_Z). However, if one attempts to compute, e.g., the W mass, at one loop from these quantities, a value of 79 GeV results, with a corresponding value for the weak mixing angle. We advise to instead take the physically measured W mass from block MASS, and recompute the EW parameters as best suited for the application at hand."},{"name":"SUSY Processes","link":"SUSYProcesses.html","text":"SUSY Processes SUSY Processes SUSY SUSY Processes Here is collected processes involving supersymmetric particle production, with the exception of the (extended) Higgs sector. Since the number of separate but closely related processes is so big, there will not be switches for each separate process but only for a reasonable set of subgroups. However, the general switches SUSY Processes SUSY:idA and SUSY Processes SUSY:idB ,valternatively vectors SUSY Processes SUSY:idVecA and SUSY Processes SUSY:idVecB , may be used in conjunction with any of these groups to provide some additional flexibility to concentrate on processes involving only specific (s)particle final states, see below. SUSY Processes Most of the SUSY implementation in PYTHIA 8 has been written by N. Desai and is documented in SUSY Processes Des11. Please give due credit to external contributions to PYTHIA 8, such as this one, by including the original work in your list of references when using this implementation. The cross section formulae are mostly taken from SUSY Processes Boz07 and SUSY Processes Fuk11. SUSY Processes Since the implementation of SUSY processes was only recently completed SUSY Processes Des11 , case-by-case validations against other codes are still recommended. A set of default validations have already been carried out by the authors, comparing to the PYTHIA 6 SUSY implementation and to the XSUSY code, using an sps1a spectrum. Explicit validations of the non-trivial SLHA2-specific extensions have generally not been carried out yet, with the exception of the R-parity violating single-sparticle production cross sections. Please report the results of any user validations you may carry out to the authors. SUSY Processes Important Note on SLHA: In order to simulate SUSY processes it is required to read in the couplings and masses relevant for the scenario to be studied. This is done with the help of the SUSY Les Houches Accord (SLHA), including the SLHA2 extensions and generalizations. (Internally, the SLHA2 conventions are used. SLHA1 spectra are automatically translated into SLHA2 notation during initialization.) The reading of a relevant SLHA file SUSY Processes must be set up, as described on SUSY Processes the SLHA page. Attempting to generate SUSY processes without a properly initialized SLHA spectrum is strongly discouraged and may lead to unexpected results. Always check for warnings and errors reported by the SLHA reader during the initialization stage. SUSY Processes SUSY Processes SUSY Processes Note 1: Decays of SUSY particles are described separately SUSY Processes below. SUSY Processes Note 2: One special possibility is that the gluino or some squark(s) are sufficiently long-lived to hadronize. See SUSY Processes the R-hadrons page for further details. SUSY Processes Note 3: lepton- and photon-initial states are not yet available. Only quark/gluon-initiated SUSY Processes 2 &rarr; 2 and SUSY Processes 2 &rarr; 1 (RPV) processes have been implemented. SUSY Processes Note 4: cross sections will be correctly folded with open branching fractions of cascade decays, but at present any difference between particle and antiparticle decay tables is not taken into account. This possibility will be included in a future update. SUSY Processes Gluino Pair Production SUSY Processes Associated Squark-Gluino Production SUSY Processes Squark Pair Production SUSY Processes Neutralino and Chargino Pair Production SUSY Processes Associated Neutralino/Chargino + Squark/Gluino Production SUSY Processes Slepton Production SUSY Processes R-parity violating squark production SUSY Processes Decays of SUSY Particles Based on the parameters read in from the SLHA, PYTHIA 8 will normally compute the decay modes of SUSY particles automatically, using the SUSY Processes SusyResonanceDecays class(es). Essentially all tree-level 2-body decays in the MSSM have been implemented this way, excepting so far only those involving Higgs bosons (either in the in- or out-state) or gravitinos. Available channels so far include: SUSY Processes SUSY Processes ~q &rarr; q + ~chi SUSY Processes ~q &rarr; ~q + W/Z SUSY Processes ~q &rarr; q + q (RPV UDD) SUSY Processes ~q &rarr; l + q (RPV LQD) SUSY Processes ~g &rarr; ~q + q SUSY Processes ~chi &rarr; ~chi + Z/W SUSY Processes ~chi &rarr; ~q + q SUSY Processes ~chi &rarr; ~l/~nu + l/nu SUSY Processes ~chi0 &rarr; q + q + q (RPV UDD) SUSY Processes ~l/~nu &rarr; l/nu + ~chi SUSY Processes ~l/~nu &rarr; ~l/~nu + W/Z All channels are still undergoing validation, so this implementation should be considered preliminary. Still missing but to be included in a forthcoming update are: 3-body decays of charginos (via RPV), and 2-body decays of squarks and gauginos with Higgs as one of the decay products.  Some 3-body decays have been implemented with Matrix Element weighting. In particular, those for a neutralino to a lighter neutralino and a fermion pair can be enabled."},{"name":"The Event Record","link":"EventRecord.html","text":"The Event Record The Event Record The Event Record A The Event Record Pythia instance contains two members of the The Event Record Event class. The one called The Event Record process provides a brief summary of the main steps of the hard process, while the one called The Event Record event contains the full history. The user would normally interact mainly with the second one, so we will exemplify primarily with that one. The Event Record The The Event Record Event class to first approximation is a vector of The Event Record Particle s, so that it can expand to fit the current event size. The index operator is overloaded, so that e.g. The Event Record event[i] corresponds to the The Event Record i 'th particle of the object The Event Record event. Thus The Event Record event[i].id() returns the identity of the The Event Record i 'th particle, and so on. Therefore the methods of the The Event Record The Event Record Particle class are at least as essential as those of the The Event Record Event class itself. The Event Record As used inside PYTHIA, some conventions are imposed on the structure of the event record. Entry 0 of the The Event Record vector<Particle> is used to represent the event as a whole, with its total four-momentum and invariant mass, but does not form part of the event history. Lines 1 and 2 contains the two incoming beams, and only from here on history tracing works as could be expected. That way unassigned mother and daughter indices can be put 0 without ambiguity. Depending on the task at hand, a loop may therefore start at index 1 rather than 0 without any loss. Specifically, for translation to other event record formats such as HepMC The Event Record Dob01 , where the first index is 1, the Pythia entry 0 definitely ought to be skipped in order to minimize the danger of indexing errors. The Event Record In the following we will list the methods available. Only a few of them have a function to fill in normal user code. The Event Record Basic output methods Some methods are available to read out information on the current event record: The Event Record i 'th or last particle in the event record, as an alternative to the methods above. The Event Record Further output methods Many event properties are accessible via the The Event Record Info class, The Event Record see here. Since they are used directly in the event generation, a few are stored directly in the The Event Record Event class, however. The Event Record One data member in an The Event Record Event object is used to keep track of the largest The Event Record col() or The Event Record acol() colour tag set so far, so that new ones do not clash. The Event Record Constructors and modifications of the event record Although you would not normally need to create your own The Event Record Event instance, there may be times where that could be convenient. The typical example would be if you want to create a new event record that is the sum of a few different ones, e.g. if you want to simulate pileup events. There may also be cases where you want to add one or a few particles to an existing event record. The Event Record A few methods exist to rotate and boost events. These derive from the The Event Record Vec4 methods, and affect both the momentum and the vertex (position) components of all particles. The Event Record The Junction Class The event record also contains a vector of junctions, which often is empty or else contains only a very few per event. Methods are available to add further junctions or query the current junction list. This is only for the expert user, however, and is not discussed further here, but only the main points. The Event Record A junction stores the properties associated with a baryon number that is fully resolved, i.e. where three different colour indices are involved. There are two main applications, The Event Record The Event Record baryon beams, where at least two valence quarks are kicked out, and so the motion of the baryon number is nontrivial; The Event Record baryon-number violating processes, e.g. in SUSY with broken The Event Record R -parity. Information on junctions is set, partly in the process generation, partly in the beam remnants machinery, and used by the fragmentation routines, but the normal user does not have to know the details. The Event Record For each junction, information is stored on the kind of junction, and on the three (anti)colour indices that are involved in the junction. The possibilities foreseen are: The Event Record The Event Record The Event Record kind = 1 : incoming colourless particle to three outgoing colours (e.g. baryon beam remnant or The Event Record neutralino &rarr; q q q ); The Event Record The Event Record kind = 2 : incoming colourless particle to three outgoing anticolours; The Event Record The Event Record kind = 3 : one incoming anticolour (stored first) and two outgoing  colours (e.g. antisquark decaying to two quarks, or  gluino decay to three quarks); The Event Record The Event Record kind = 4 : one incoming colour (stored first) and two outgoing anticolours (e.g. squark decaying to two antiquarks, or  gluino decaying to three antiquarks); The Event Record The Event Record kind = 5 : two incoming anticolours (stored first) and one outgoing colour (e.g. resonant squark production through RPV); The Event Record The Event Record kind = 6 : two incoming colours (stored first) and one outgoing anticolour (e.g. resonant antisquark production  through RPV); The odd (even) The Event Record kind codes corresponds to a +1 (-1) change in baryon number across the junction. The Event Record The kind and colour information in the list of junctions can be set or read with methods of the The Event Record Event class, but are not of common interest and so not described here. The Event Record A listing of current junctions can be obtained with the The Event Record listJunctions() method. The Event Record Subsystems Separate from the event record as such, but closely tied to it is the The Event Record The Event Record PartonSystems class, which mainly stores the parton indices of incoming and outgoing partons, classified by collision subsystem. Such information is needed to interleave multiparton interactions, initial-state showers and final-state showers, and append beam remnants. It could also be used in other places. It is intended to be accessed only by experts, such as implementors of The Event Record new showering models."},{"name":"The Particle Data Scheme","link":"ParticleDataScheme.html","text":"The Particle Data Scheme The Particle Data Scheme The Particle Data Scheme The particle data scheme may take somewhat longer to understand than the settings one. In particular the set of methods to access information is rather more varied, to allow better functionality for advanced usage. However, PYTHIA does come with a sensible default set of particle properties and decay tables. Thus there is no need to learn any of the methods on this page to get going. Only when you perceive a specific need does it make sense to learn the basics. The Particle Data Scheme The central section on this page is the Operation one. The preceding sections are there mainly to introduce the basic structure and the set of properties that can be accessed. The subsequent sections provide a complete listing of the existing public methods, which most users probably will have little interaction with. The Particle Data Scheme Databases The management of particle data is based on three classes: The Particle Data Scheme The Particle Data Scheme The Particle Data Scheme ParticleData , which is the top-level class, with methods that can be used to interrogate all particle data. It contains a map of PDG particle identity numbers The Particle Data Scheme Yao06 onto the relevant The Particle Data Scheme ParticleDataEntry objects, The Particle Data Scheme The Particle Data Scheme ParticleDataEntry , which stores the relevant information on an individual particle species, and The Particle Data Scheme The Particle Data Scheme DecayChannel , which stores info on one particular decay mode of a particle. The objects of these classes together form a database that is continuously being used as the program has to assign particle masses, select decay modes, etc. The Particle Data Scheme Each The Particle Data Scheme Pythia object has a public member The Particle Data Scheme particleData of the The Particle Data Scheme ParticleData class. Therefore you access the particle data methods as The Particle Data Scheme pythia.particleData.command(argument) , assuming that The Particle Data Scheme pythia is an instance of the The Particle Data Scheme Pythia class. Further, for some of the most frequent user tasks, The Particle Data Scheme Pythia methods have been defined, so that The Particle Data Scheme pythia.command(argument) would work, see further below. The Particle Data Scheme A fundamental difference between the particle data classes and the settings ones is that the former are accessed regularly during the event generation process, as a new particle is produced and its mass need to be set, e.g., while the latter are mainly/only used at the initialization stage. Nevertheless, it is not a good idea to change data in either of them in mid-run, since this may lead to inconsistencies. The Particle Data Scheme Stored properties for particles The main properties stored for each particle are as follows. Different ways to set and get these properties will be described further down. The Particle Data Scheme The Particle Data Scheme The Particle Data Scheme name : a character string with the name of the particle. Particle and antiparticle names are stored separately, with The Particle Data Scheme void returned when no antiparticle exists. The Particle Data Scheme The Particle Data Scheme spinType : the spin type, of the form The Particle Data Scheme 2 s + 1 , with special code 0 for entries of unknown or indeterminate spin. The Particle Data Scheme The Particle Data Scheme chargeType : three times the charge (to make it an integer). The Particle Data Scheme The Particle Data Scheme colType : the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 octet. (A preliminary implementation of colour  sextets, available since version 8.150, further uses 3 for a sextet  and -3 for an antisextet.) The Particle Data Scheme The Particle Data Scheme m0 : the nominal mass The Particle Data Scheme m_0 (in GeV). The Particle Data Scheme The Particle Data Scheme mWidth : the width The Particle Data Scheme Gamma of the Breit-Wigner distribution (in GeV). The Particle Data Scheme The Particle Data Scheme mMin : the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there. The Particle Data Scheme The Particle Data Scheme mMax : the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If The Particle Data Scheme mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there. The Particle Data Scheme The Particle Data Scheme tau0 : the nominal proper lifetime The Particle Data Scheme tau_0 (in mm/c). The Particle Data Scheme The Particle Data Scheme isResonance : a flag telling whether a particle species is considered as a resonance or not. Here The Particle Data Scheme 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the The Particle Data Scheme b bbar bound systems in mass, i.e. for The Particle Data Scheme W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with The Particle Data Scheme m0 above 20 GeV are by default initialized to be considered as resonances. The Particle Data Scheme The Particle Data Scheme mayDecay : a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for The Particle Data Scheme particle decays (or The Particle Data Scheme resonance decays ). All particles with The Particle Data Scheme tau0 below 1000 mm are by default initialized to allow decays. The Particle Data Scheme The Particle Data Scheme doExternalDecays : a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the The Particle Data Scheme The Particle Data Scheme Pythia::decayPtr(...) method should be provided with the list of relevant particles. The Particle Data Scheme The Particle Data Scheme isVisible : a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector. The Particle Data Scheme The Particle Data Scheme doForceWidth : a flag applicable only for resonances (see The Particle Data Scheme isResonance above), whereby it is possible to force resonances to retain their assigned width, whatever that is, see The Particle Data Scheme Resonance Decays for details. The Particle Data Scheme Stored properties for decays An unstable particle has a decay table consisting of one or more decay channel. The following properties are stored for each such channel. Again different ways to set and get these properties will be described further down. The Particle Data Scheme The Particle Data Scheme The Particle Data Scheme onMode : integer code for use or not of channel, The Particle Data Scheme 0 if a channel is off, The Particle Data Scheme 1 if on, The Particle Data Scheme 2 if on for a particle but off for an antiparticle, The Particle Data Scheme 3 if on for an antiparticle but off for a particle. The Particle Data Scheme If a particle is its own antiparticle then 2 is on and 3 off but, of course, for such particles it is much simpler and safer to use only 1 and 0. The Particle Data Scheme The 2 and 3 options can be used e.g. to encode CP violation in B decays, or to let the The Particle Data Scheme W 's in a The Particle Data Scheme q qbar &rarr; W^+ W^- process decay in different channels. The Particle Data Scheme The Particle Data Scheme bRatio : the branching ratio of the channel (with some reservations for resonances, see The Particle Data Scheme meMode below). The Particle Data Scheme The Particle Data Scheme meMode : the mode of processing this channel, possibly with matrix elements; see the The Particle Data Scheme particle decays and The Particle Data Scheme resonance decays descriptions for the list of possibilities. Notably the default code 0 for a particle means pure phase space decays according to the given branching ratios, while for a resonance it means that code exists for the dynamic calculations of partial widths and thereby branching ratios as a function of the resonance mass (which is done e.g. at initialization based on the mass set by the user). Then codes 1 - 99 are reserved for various matrix-element-improved ordinary particle decays, and 100 - 103 for resonances where the partial width of a given channel is calculated from the total width and the stored branching ratio. Thus, to enforce a new branching ratio for a resonance channel (with its own partial-width calculation code) it is not sufficient only to change the The Particle Data Scheme bRatio but also to set e.g. The Particle Data Scheme meMode = 100. The Particle Data Scheme The Particle Data Scheme multiplicity : the number of decay products of the channel. Can be at most 8. The Particle Data Scheme The Particle Data Scheme product(i) : the identity code of the decay products, where The Particle Data Scheme i runs between The Particle Data Scheme 0 and The Particle Data Scheme multiplicity - 1. Trailing positions are filled with 0. The Particle Data Scheme Operation The normal flow of the particle data operations is: The Particle Data Scheme The Particle Data Scheme When a The Particle Data Scheme Pythia object The Particle Data Scheme pythia is created, the The Particle Data Scheme pythia.particleData member is asked to scan the The Particle Data Scheme ParticleData.xml file. The Particle Data Scheme All lines beginning with The Particle Data Scheme <particle are scanned for information on a particle species, and all lines beginning with The Particle Data Scheme <channel are assumed to contain a decay channel of the enclosing particle. In both cases XML syntax is used, with attributes used to identify the stored properties, and with omitted properties defaulting back to 0 where meaningful. The particle and channel information may be split over several lines, up to the > endtoken. The format of a The Particle Data Scheme <particle tag is: The Particle Data Scheme <particle id='...' name='...' antiName='...' spinType='...' chargeType='...' colType='...'      m0='...' mWidth='...' mMin='...' mMax='...' tau0='...'>    </particle> where the fields are the properties already introduced above. Note that The Particle Data Scheme isResonance , The Particle Data Scheme mayDecay , The Particle Data Scheme doExternalDecay , The Particle Data Scheme isVisible and The Particle Data Scheme doForceWidth are not set here, but are provided with default values by the rules described above. Once initialized, also these latter properties can be changed, see below. The Particle Data Scheme The format of  a The Particle Data Scheme <channel> tag is: The Particle Data Scheme <channel onMode='...' bRatio='...' meMode='...' products='...' /> again see properties above. The products are given as a blank-separated list of The Particle Data Scheme id codes. The Particle Data Scheme Important : the values in the The Particle Data Scheme .xml file should not be changed, except by the PYTHIA authors. Any changes should be done with the help of the methods described below. The Particle Data Scheme The Particle Data Scheme Between the creation of the The Particle Data Scheme Pythia object and the The Particle Data Scheme init call for it, you may use the methods of the The Particle Data Scheme ParticleData class to modify some of the default values. Several different approaches can be chosen for this. The Particle Data Scheme a) Inside your main program you can directly set values with The Particle Data Scheme pythia.readString(string); where both the variable name and the value are contained inside the character string, separated by blanks and/or a =, e.g. The Particle Data Scheme pythia.readString('111:mayDecay = off'); switches off the decays of the The Particle Data Scheme pi^0. The Particle Data Scheme The particle id (> 0) and the property to be changed must be given, separated by a colon. The Particle Data Scheme The allowed properties are: The Particle Data Scheme name , The Particle Data Scheme antiName , The Particle Data Scheme spinType , The Particle Data Scheme chargeType , The Particle Data Scheme colType , The Particle Data Scheme m0 , The Particle Data Scheme mWidth , The Particle Data Scheme mMin , The Particle Data Scheme mMax , The Particle Data Scheme tau0 , The Particle Data Scheme isResonance , The Particle Data Scheme mayDecay , The Particle Data Scheme doExternalDecay , The Particle Data Scheme isVisible and The Particle Data Scheme doForceWidth. All of these names are case-insensitive. Names that do not match an existing variable are ignored. The Particle Data Scheme Strings beginning with a non-alphanumeric character, like # or !, are assumed to be comments and are not processed at all. For The Particle Data Scheme bool values, the following notation may be used interchangeably: The Particle Data Scheme true = on = yes = ok = 1 , while everything else gives The Particle Data Scheme false (including but not limited to The Particle Data Scheme false , The Particle Data Scheme off , The Particle Data Scheme no and The Particle Data Scheme 0 ). The Particle Data Scheme Particle data often comes in sets of closely related information. Therefore some properties expect the value to consist of several numbers. These can then be separated by blanks (or by commas). A simple example is The Particle Data Scheme names , which expects both the name and antiname to be given. A more interesting one is the The Particle Data Scheme all property, The Particle Data Scheme id:all = name antiName spinType chargeType colType m0 mWidth mMin mMax tau0 where all the current information on the particle itself is replaced, but any decay channels are kept unchanged. Using The Particle Data Scheme new instead of The Particle Data Scheme all also removes any previous decay channels. If the string contains fewer fields than expected the trailing properties are set to vanish ('void', 0 or 0.). Note that such a truncated string should not be followed by a comment, since this comment would then be read in as if it contained the missing properties. The truncation can be done anywhere, specifically a string with only The Particle Data Scheme id:new defines a new 'empty' particle. As before, The Particle Data Scheme isResonance , The Particle Data Scheme mayDecay , The Particle Data Scheme doExternalDecay , The Particle Data Scheme isVisible and The Particle Data Scheme doForceWidth are (re)set to their default values, and would have to be changed separately if required. The Particle Data Scheme A further command is The Particle Data Scheme rescaleBR , which rescales each of the existing branching ratios with a common factor, such that their new sum is the provided value. This may be a first step towards adding new decay channels, see further below. The Particle Data Scheme Alternatively the The Particle Data Scheme id code may be followed by another integer, which then gives the decay channel number. This then has to be followed by the property specific to this channel, either The Particle Data Scheme onMode , The Particle Data Scheme bRatio , The Particle Data Scheme meMode or The Particle Data Scheme products. In the latter case all the products of the channel should be given: The Particle Data Scheme id:channel:products =  product1 product2 .... The line will be scanned until the end of the line, or until a non-number word is encountered, or until the maximum allowed number of eight products is encountered, whichever happens first. (Thus the multiplicity of a decay channel need not be input; it is automatically calculated from the products list.) It is also possible to replace all the properties of a channel in a similar way: The Particle Data Scheme id:channel:all = onMode bRatio meMode product1 product2 .... To add a new channel at the end, use The Particle Data Scheme id:addChannel = onMode bRatio meMode product1 product2 .... The Particle Data Scheme It is currently not possible to remove a channel selectively, but setting its branching ratio vanishing is as effective. If you want to remove all existing channels and force decays into one new channel you can use The Particle Data Scheme id:oneChannel = onMode bRatio meMode product1 product2 .... A first The Particle Data Scheme oneChannel command could be followed by several subsequent The Particle Data Scheme addChannel ones, to build up a completely new decay table for an existing particle. The Particle Data Scheme When adding new channels or changing branching ratios in general, note that, once a particle is to be decayed, the sum of branching ratios is always rescaled to unity. Beforehand, The Particle Data Scheme rescaleBR may be used to rescale an existing branching ratio by the given factor. The Particle Data Scheme There are a few commands that will study all the decay channels of the given particle, to switch them on or off as desired. The The Particle Data Scheme id:onMode = onMode will set the The Particle Data Scheme onMode property of all channels to the desired value. The The Particle Data Scheme id:offIfAny  = product1 product2 ....    id:onIfAny   = product1 product2 ....    id:onPosIfAny = product1 product2 ....    id:onNegIfAny = product1 product2 .... will set the The Particle Data Scheme onMode 0, 1, 2 or 3, respectively, for all channels which contain any of the enumerated products, where the matching to these products is done without distinction of particles and antiparticles. Note that ' The Particle Data Scheme Pos ' and ' The Particle Data Scheme Neg ' are slightly misleading since it refers to the particle and antiparticle of the The Particle Data Scheme id species rather than charge, but should still be simpler to remember and understand than alternative notations. Correspondingly The Particle Data Scheme id:offIfAll  = product1 product2 ....    id:onIfAll   = product1 product2 ....    id:onPosIfAll = product1 product2 ....    id:onNegIfAll = product1 product2 .... will set the The Particle Data Scheme onMode 0, 1, 2 or 3, respectively, for all channels which contain all of the enumerated products, again without distinction of particles and antiparticles. If the same product appears twice in the list it must also appear twice in the decay channel, and so on. The decay channel is allowed to contain further particles, beyond the product list. By contrast, The Particle Data Scheme id:offIfMatch  = product1 product2 ....    id:onIfMatch   = product1 product2 ....    id:onPosIfMatch = product1 product2 ....    id:onNegIfMatch = product1 product2 .... requires the decay-channel multiplicity to agree with that of the product list, but otherwise works as the The Particle Data Scheme onIfAll/offIfAll methods. The Particle Data Scheme Note that the action of several of the commands depends on the order in which they are executed, as one would logically expect. For instance, The Particle Data Scheme id:oneChannel removes all decay channels of The Particle Data Scheme id and thus all previous changes in this decay table, while subsequent additions or changes would still take effect. Another example would be that The Particle Data Scheme 23:onMode = off followed by The Particle Data Scheme 23:onIfAny = 1 2 3 4 5 would let the The Particle Data Scheme Z^0 decay to quarks, while no decays would be allowed if the order were to be reversed. The Particle Data Scheme b) The The Particle Data Scheme Pythia The Particle Data Scheme readString(string) method actually does not do changes itself, but sends on the string either to the The Particle Data Scheme ParticleData class or to the The Particle Data Scheme Settings one, depending on whether the string begins with a digit or a letter. If desired, it is possible to communicate directly with the corresponding The Particle Data Scheme ParticleData method: The Particle Data Scheme pythia.particleData.readString('111:mayDecay = off');    pythia.particleData.readString('15:2:products = 16 -211'); In this case, changes intended for The Particle Data Scheme Settings would not be understood. The Particle Data Scheme c) Underlying this are commands for all the individual properties in the The Particle Data Scheme ParticleData class, one for each. These are further described below. Thus, an example now reads The Particle Data Scheme pythia.particleData.mayDecay(111, false); Boolean values should here be given as The Particle Data Scheme true or The Particle Data Scheme false. The Particle Data Scheme d) A simpler and more useful way is to collect all your changes in a separate file, with one line per change, e.g. The Particle Data Scheme 111:mayDecay = off The file can be read by the The Particle Data Scheme pythia.readFile(fileName); method, where The Particle Data Scheme fileName is a string, e.g. The Particle Data Scheme pythia.readFile('main.cmnd') (or an The Particle Data Scheme istream instead of a The Particle Data Scheme fileName ). Each line is processed as described for the string in 2a). This file can freely mix commands to the The Particle Data Scheme Settings and The Particle Data Scheme ParticleData classes. The Particle Data Scheme The Particle Data Scheme A routine The Particle Data Scheme reInit(fileName) is provided, and can be used to zero the particle data table and reinitialize it from scratch. Such a call might be useful if several subruns are to be made with widely different particle data - normally the maps are only built from scratch once, namely when the The Particle Data Scheme Pythia() object is created. Also, there is no other possibility to restore the default values, unlike for the settings. The Particle Data Scheme The Particle Data Scheme You may at any time obtain a listing of all the particle data by calling The Particle Data Scheme pythia.particleData.listAll(); The listing is by increasing The Particle Data Scheme id number. It shows the basic quantities introduced above. Some are abbreviated in the header to fit on the lines: The Particle Data Scheme spn = spinType , The Particle Data Scheme chg = chargeType , The Particle Data Scheme col = colType , The Particle Data Scheme res = isResonance , The Particle Data Scheme dec = mayDecay && canDecay (the latter checks that decay channels have been defined), The Particle Data Scheme ext = doExternalDecay , The Particle Data Scheme vis = isVisible and The Particle Data Scheme wid = doForceWidth. The Particle Data Scheme To list only those particles that were changed (one way or another, the listing will not tell what property or decay channel was changed), instead use The Particle Data Scheme pythia.particleData.listChanged(); (This info is based on a further The Particle Data Scheme hasChanged flag of a particle or a channel, set The Particle Data Scheme true whenever any of the changing methods are used. It is possible to manipulate this value, but this is not recommended.) By default the internal initialization of the widths of resonances such as The Particle Data Scheme gamma^*/Z^0, W^+-, t/tbar, H^0 do not count as changes; if you want to list also those changes instead call The Particle Data Scheme listChanged(true). The Particle Data Scheme To list only one particle, give its The Particle Data Scheme id code as argument to the The Particle Data Scheme list(...) function.. To list a restricted set of particles, give in their The Particle Data Scheme id codes to The Particle Data Scheme list(...) as a The Particle Data Scheme vector<int>. The Particle Data Scheme The Particle Data Scheme For wholesale changes of particle properties all available data can be written out, edited, and then read back in again. These methods are mainly intended for expert users. You can choose between two alternative syntaxes. The Particle Data Scheme a) XML syntax, using the The Particle Data Scheme <particle and The Particle Data Scheme <channel lines already described. You use the method The Particle Data Scheme particleData.listXML(fileName) to produce such an XML file and The Particle Data Scheme particleData.readXML(fileName) to read it back in after editing. The Particle Data Scheme b) Fixed/free format, using exactly the same information as illustrated for the The Particle Data Scheme <particle and The Particle Data Scheme <channel lines above, but now without any tags. This means that all information fields must be provided (if there is no antiparticle then write The Particle Data Scheme void ), in the correct order (while the order is irrelevant with XML syntax), and all on one line. Information is written out in properly lined-up columns, but the reading is done using free format, so fields need only be separated by at least one blank. Each new particle is supposed to be separated by (at least) one blank line, whereas no blank lines are allowed between the particle line and the subsequent decay channel lines, if any.  You use the method The Particle Data Scheme particleData.listFF(fileName) to produce such a fixed/free file and The Particle Data Scheme particleData.readFF(fileName) to read it back in after editing. The Particle Data Scheme As an alternative to the The Particle Data Scheme readXML and The Particle Data Scheme readFF methods you can also use the The Particle Data Scheme particleData.reInit(fileName, xmlFormat) method, where The Particle Data Scheme xmlFormat = true (default) corresponds to reading an XML file and The Particle Data Scheme xmlFormat = false to a fixed/free format one. The Particle Data Scheme To check that the new particle and decay tables makes sense, you can use the The Particle Data Scheme particleData.checkTable() method, either directly or by switching it on among the standard The Particle Data Scheme error checks. The Particle Data Scheme The Particle Data Scheme The Particle Data Scheme The public methods In the following we present briefly the public methods in the three classes used to build up the particle database. The order is top-down, i.e from the full table of all particles to a single particle to a single channel. Note that these methods usually are less elegant and safe than the input methods outlined above. If you use any of these methods, it is likely to be the ones in the full database, i.e. the first ones to be covered in the following. The Particle Data Scheme For convenience, we have grouped related input and output methods together. It should be obvious from the context which is which: the input is of type The Particle Data Scheme void and has an extra last argument, namely is the input value, while the output method returns a quantity of the expected type. The Particle Data Scheme The ParticleData methods The Particle Data Scheme The ParticleDataEntry methods Most of the methods that can be applied to a single The Particle Data Scheme ParticleDataEntry object are almost identical with those used above for the The Particle Data Scheme ParticleData , except that the The Particle Data Scheme id argument is no longer needed to find the right entry in the table. By and large, this makes direct access to the The Particle Data Scheme ParticleDataEntry methods superfluous. There are a few methods that are unique to each class, however. Furthermore, to avoid some naming ambiguities, many methods that set values begin with The Particle Data Scheme set. The Particle Data Scheme The DecayChannel methods The properties stored in an individual decay channel can be set or get by the methods in this section."},{"name":"The Settings Scheme","link":"SettingsScheme.html","text":"The Settings Scheme The Settings Scheme The Settings Scheme The The Settings Scheme Settings class keeps track of all the flags, modes, parameters and words used during the event generation. As such, it serves all the The Settings Scheme Pythia program elements from one central repository. Accessing it allows the user to modify the generator behaviour. The Settings Scheme Each The Settings Scheme Pythia object has a public member The Settings Scheme settings of the The Settings Scheme Settings class. Therefore you access the settings methods as The Settings Scheme pythia.settings.command(argument) , assuming that The Settings Scheme pythia is an instance of the The Settings Scheme Pythia class. Further, for the most frequent user tasks, The Settings Scheme Pythia methods have been defined, so that The Settings Scheme pythia.command(argument) would work, see further below. The Settings Scheme The central section on this page is the Operation one. The preceding concepts section is there mainly to introduce the basic structure and the set of properties that can be accessed. The subsequent sections provide a complete listing of the existing public methods, which most users probably will have little interaction with. The Settings Scheme Concepts We distinguish eight kinds of user-modifiable variables, by the way they have to be stored: The Settings Scheme The Settings Scheme Flags are on/off switches, and are stored as The Settings Scheme bool. The Settings Scheme Modes corresponds to a finite enumeration of separate options, and are stored as The Settings Scheme int. The Settings Scheme Parameters take a continuum of values, and are stored as The Settings Scheme double. The shorthand notation parm is used in the C++ code and XML tags. The Settings Scheme Words are simple character strings and are stored as The Settings Scheme string. No double quotation marks &quot; or braces { } may appear inside a word, and commas , will take a spcial role next so should also be avoided. Normally the input string is expected not to contain any blanks or equal signs, but if it does it must be enclosed in braces { }. The Settings Scheme Vectors of flags take a variable length, and are stored as The Settings Scheme vector<bool>. The shorthand notation fvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. The Settings Scheme Vectors of modes take a variable length, and are stored as The Settings Scheme vector<int>. The shorthand notation mvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. The Settings Scheme Vectors of parameters take a variable length and for each element a continuum of values, and are stored as The Settings Scheme vector<double>. The shorthand notation pvec is used in the C++ code and XML tag. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. The Settings Scheme Vectors of words take a variable length, and are stored as The Settings Scheme vector<string>. The shorthand notation wvec is used in the C++ code and XML tags. When the vector is input as a string it should be given as a comma-separated list, either containing no blanks or else enclosed in braces { }. Note the special role played by the braces { } to enclose words or lists that are allowed to contain blanks and equal signs, and of commas , to separate the fields of the list, in analogy with how C++ arrays can be initialized. You should not be using these three characters for any other purposes. Input of a vector can be split across several lines, until a close brace } is found that matches the open brace {. If no such is found the program will abort, so beware. The double quotation mark &quot; is avoided since it is already used for other purposes. Also note that all shorthands have been chosen four letters long. The Settings Scheme In general, each variable stored in The Settings Scheme Settings is associated with four kinds of information: The Settings Scheme The Settings Scheme The variable name, of the form The Settings Scheme class:name (or The Settings Scheme file:name , usually these agree), e.g. The Settings Scheme TimeShower:pTmin. The class/file part usually identifies the The Settings Scheme .xml file where the variable is defined, and the part of the program where it is used, but such a connection cannot be strictly upheld, since e.g. the same variable may be used in a few different cases (even if most of them are not). The Settings Scheme The default value, set in the original declaration, and intended to represent a reasonable choice. The Settings Scheme The current value, which differs from the default when the user so requests. The Settings Scheme An allowed range of values, represented by meaningful minimum and maximum values. This has no sense for a The Settings Scheme flag , an The Settings Scheme fvec a The Settings Scheme word or a The Settings Scheme wvec (and is not used there), is usually rather well-defined for a The Settings Scheme mode or The Settings Scheme mvec , but less so for a The Settings Scheme parm or The Settings Scheme pvec. Often the allowed range exaggerates the degree of our current knowledge, so as not to restrict too much what the user can do. One may choose not to set the lower or upper limit, in which case the range is open-ended. The Settings Scheme Normally input values outside the allowed range are changed to the be at nearest limit. For The Settings Scheme mode s only, a further boolean is stored to tell whether this should be allowed, or whether out-of-range inputs should be forbidden, to the extent that the whole PYTHIA initialization would abort. The latter applies to those modes that have been defined with the The Settings Scheme modepick label in the The Settings Scheme xmldoc/*.xml files, and where maximal and minimal values have been specified. Such labels are used to represent a discrete set of options, and so any value outside the allowed range is just plain wrong. Also attempts to change The Settings Scheme modefix fixed-value The Settings Scheme mode s lead to aborts. By contrast those defined with The Settings Scheme mode or The Settings Scheme modeopen follow the normal rules of being reset to fall into the allowed range, without any warnings. The Settings Scheme Technically, the The Settings Scheme Settings class is implemented with the help of eight separate maps, one for each kind of variable, with the variable The Settings Scheme name used as key. The Settings Scheme Operation The normal flow of setting values is: The Settings Scheme The Settings Scheme The Settings Scheme When a The Settings Scheme Pythia object The Settings Scheme pythia is created, the member The Settings Scheme pythia.settings is asked to scan the files listed in the The Settings Scheme Index.xml file in the The Settings Scheme xmldoc subdirectory. The Settings Scheme In all of the files scanned, lines beginning with The Settings Scheme <flag , The Settings Scheme <mode , The Settings Scheme <parm , The Settings Scheme <word , The Settings Scheme <fvec , The Settings Scheme <mvec , The Settings Scheme <pvec or The Settings Scheme <wvec are identified, and the information on such a line is used to define a new flag, mode, parameter, word, or vector of flags, modes or parameters. To exemplify, consider a line The Settings Scheme <parm name='TimeShower:pTmin' default='0.5' min='0.1' max='2.0'> which appears in the The Settings Scheme TimeShower.xml file, and there defines a parameter The Settings Scheme TimeShower:pTmin with default value 0.5 GeV and allowed variation in the range 0.1 - 2.0 GeV. The min and max values are optional. The Settings Scheme Important: the values in the The Settings Scheme .xml files should not be changed, except by the PYTHIA authors. Any changes should be done with the help of the methods described below. The Settings Scheme The Settings Scheme Between the creation of the The Settings Scheme Pythia object and the The Settings Scheme init call for it, you may use several alternative methods to modify some of the default values. The same variable can be changed several times. If so, it is the last read value that counts. The two special The Settings Scheme The Settings Scheme Tune:ee and The Settings Scheme The Settings Scheme Tune:pp modes and the The Settings Scheme The Settings Scheme Print:quiet flag are expanded to change several settings in one go, but these obey the same ordering rules. The Settings Scheme a) Inside your main program you can directly set values with The Settings Scheme pythia.readString(string) where both the variable name and the value are contained inside the character string, separated by blanks and/or a =, e.g. The Settings Scheme pythia.readString('TimeShower:pTmin = 1.0'); The match of the name to the database is case-insensitive. Names that do not match an existing variable are ignored. A warning is printed, however. Strings beginning with a non-alphanumeric character, like # or !, are assumed to be comments and are not processed at all. Values below the minimum or above the maximum are set at the respective border. In extreme cases, where it is necessary to go outside the allowed range, ' The Settings Scheme FORCE= ' can replace the normal ' The Settings Scheme = ' separator to force the requested value, at own responsibility. For The Settings Scheme bool values, the following notation may be used interchangeably: The Settings Scheme true = on = yes = ok = 1 , while everything else gives The Settings Scheme false (including but not limited to The Settings Scheme false , The Settings Scheme off , The Settings Scheme no and 0). The Settings Scheme The Settings Scheme b) The The Settings Scheme Pythia The Settings Scheme readString(string) method actually does not do changes itself, but sends on the string either to the The Settings Scheme Settings class or to The Settings Scheme ParticleData. The former holds if the string begins with a letter, the latter if it begins with a digit. (The exception is if an input list has been begun by an open brace { but no matching close brace } was present; then all subsequent non-empty input is directed to The Settings Scheme Settings until the close brace is found.) If desired, it is possible to communicate directly with the corresponding The Settings Scheme Settings method: The Settings Scheme pythia.settings.readString('TimeShower:pTmin = 1.0'); In this case, changes intended for The Settings Scheme ParticleData would not be understood. The Settings Scheme c) Underlying the The Settings Scheme settings.readString(string) method are the settings-type-sensitive commands in the The Settings Scheme Settings , that are split by names containing The Settings Scheme flag , The Settings Scheme mode , The Settings Scheme parm or The Settings Scheme word. Thus, the example now reads The Settings Scheme pythia.settings.parm('TimeShower:pTmin', 1.0); Such a form could be convenient e.g. if a parameter is calculated at the beginning of the main program, and thus is available as a variable rather than as a character string. Note that Boolean values must here be given as The Settings Scheme true or The Settings Scheme false i.e. there is less flexibility than with the previous methods. The Settings Scheme At the same level, there are several different methods available. These are included in the full description below, but normally the user should have no need for them. The Settings Scheme d) A simpler and more useful way is to collect all your changes in a separate file, with one line per change, e.g. The Settings Scheme TimeShower:pTmin = 1.0 Each line is read in as a string and processed with the methods already introduced.  The file can be read by the The Settings Scheme pythia.readFile(fileName); method (or an The Settings Scheme istream instead of a The Settings Scheme fileName ). The file can freely mix commands to the The Settings Scheme Settings and The Settings Scheme ParticleData classes, and so is preferable. Lines with settings are handled by calls to the The Settings Scheme pythia.settings.readString(string) method. The Settings Scheme A file can make use of two extra features that are not available with the The Settings Scheme readString(...) method. One is the possibility to provide information for several distinct The Settings Scheme subruns. The other is the possibility to comment out a section of lines in the file. The first line of the commented section should then begin by The Settings Scheme /* and the last begin by The Settings Scheme */. This is reminiscent of the convention used in C++ and other languages, but is not as powerful, in that it is not possible to comment in or out parts of lines. It is only the first two non-blank characters of a line that are checked for a match, and a line beginning with The Settings Scheme */ is counted as part of the commented section. To avoid mistakes it is best to keep The Settings Scheme /* and The Settings Scheme */ on lines of their own, optionally followed by comments, but not by commands. The Settings Scheme The Settings Scheme In the The Settings Scheme pythia.init() call, many of the various other program elements are initialized, making use of the current values in the database. Once initialized, the common The Settings Scheme Settings database is likely not consulted again by these routines. It is therefore not productive to do further changes in mid-run: at best nothing changes, at worst you may set up inconsistencies. The Settings Scheme A routine The Settings Scheme reInit(fileName) is provided, and can be used to zero all the maps and reinitialize them from scratch. Such a call might be useful if several subruns are to be made with widely different parameter sets - normally the maps are only built from scratch once, namely when the The Settings Scheme Pythia() object is created. A more economical alternative is offered by The Settings Scheme resetAll() , however, which sets all variables back to their default values. The Settings Scheme The Settings Scheme You may at any time obtain a listing of all variables in the database by calling The Settings Scheme pythia.settings.listAll(); The listing is strictly alphabetical, which at least means that names from the same file are kept together, but otherwise may not be so well-structured: important and unimportant ones will appear mixed. A more relevant alternative is The Settings Scheme pythia.settings.listChanged(); where you will only get those variables that differ from their defaults. Or you can use The Settings Scheme pythia.settings.list('string'); where only those variables with names that contain the string (case-insensitive match) are listed. Thus, with a string The Settings Scheme shower , the shower-related variables would be shown. The Settings Scheme The method The Settings Scheme pythia.settings.output(key) can return the value of a variable as a string, convenient for output. In a The Settings Scheme readString or The Settings Scheme readFile command, the construction The Settings Scheme key =? will echo back the variable and its value, using this method. The Settings Scheme The Settings Scheme The above listings are in a tabular form that cannot be read back in. Assuming you want to save all changed settings (maybe because you read in changes from several files), you can do that by calling The Settings Scheme pythia.settings.writeFile(fileName); This file could then directly be read in by The Settings Scheme readFile(fileName) in a subsequent (identical) run. Some variants of this command are listed below. The Settings Scheme The Settings Scheme The Settings Scheme The public methods The complete list of methods and arguments is as follows. Most of the ones of interest to the user have already been mentioned above. Others can be used, but the same functionality is better achieved by higher-level routines. Some are part of the internal machinery, and should not be touched by user. The Settings Scheme Note that there is no The Settings Scheme Settings::readFile(...) method. The intention is that you should use The Settings Scheme Pythia::readFile(...). It parses and decides which individual lines should be sent on to The Settings Scheme Settings::readString(...)."},{"name":"Timelike Showers","link":"TimelikeShowers.html","text":"Timelike Showers Timelike Showers Timelike Showers The PYTHIA algorithm for timelike final-state showers is based on the article Timelike Showers Sjo05 , where a transverse-momentum-ordered evolution scheme is introduced, with the extension to fully interleaved evolution covered in Timelike Showers Cor10a. This algorithm is influenced by the previous mass-ordered algorithm in PYTHIA Timelike Showers Ben87 and by the dipole-emission formulation in Ariadne Timelike Showers Gus86. From the mass-ordered algorithm it inherits a merging procedure for first-order gluon-emission matrix elements in essentially all two-body decays in the standard model and its minimal supersymmetric extension Timelike Showers Nor01. Timelike Showers The normal user is not expected to call Timelike Showers TimeShower directly, but only have it called from Timelike Showers Pythia. Nonetheless, some of the parameters below, in particular Timelike Showers TimeShower:alphaSvalue , would be of interest for uncertainty estimates and tuning exercises. Note that PYTHIA also incorporates an Timelike Showers automated framework for shower uncertainty variations. Timelike Showers Main variables Often the maximum scale of the FSR shower evolution is understood from the context. For instance, in a resonance decay half the resonance mass sets an absolute upper limit. For a hard process in a hadronic collision the choice is not as unique. Here the Timelike Showers factorization scale has been chosen as the maximum evolution scale. This would be the Timelike Showers pT for a Timelike Showers 2 &rarr; 2 process, supplemented by mass terms for massive outgoing particles. For some special applications we do allow an alternative. Timelike Showers The amount of QCD radiation in the shower is determined by Timelike Showers The actual value is then regulated by the running to the scale Timelike Showers pT^2 , at which the shower evaluates Timelike Showers alpha_strong. Timelike Showers The CMW rescaling of Timelike Showers Lambda_QCD (see the section on Timelike Showers StandardModelParameters ) can be applied to the Timelike Showers alpha_strong values used for timelike showers. Note that tunes using this option need lower values of Timelike Showers alpha_strong(m_Z^2) than tunes that do not. Timelike Showers QED radiation is regulated by the Timelike Showers alpha_electromagnetic value at the Timelike Showers pT^2 scale of a branching. Timelike Showers The natural scale for couplings, and PDFs for dipoles stretching out to the beam remnants, is Timelike Showers pT^2. To explore uncertainties it is possibly to vary around this value, however, in analogy with what can be done for Timelike Showers hard processes. (Note that there is also an Timelike Showers automated framework for shower uncertainties.) Timelike Showers The rate of radiation if divergent in the Timelike Showers pT &rarr; 0 limit. Here, however, perturbation theory is expected to break down. Therefore an effective Timelike Showers pT_min cutoff parameter is introduced, below which no emissions are allowed. The cutoff may be different for QCD and QED radiation off quarks, and is mainly a technical parameter for QED radiation off leptons. Timelike Showers Shower branchings Timelike Showers gamma &rarr; f fbar , where Timelike Showers f is a quark or lepton, in part compete with the hard processes involving Timelike Showers gamma^*/Z^0 production. In order to avoid overlap it makes sense to correlate the maximum Timelike Showers gamma mass allowed in showers with the minimum Timelike Showers gamma^*/Z^0 mass allowed in hard processes. In addition, the shower contribution only contains the pure Timelike Showers gamma^* contribution, i.e. not the Timelike Showers Z^0 part, so the mass spectrum above 50 GeV or so would not be well described. Timelike Showers Interleaved evolution Multiparton interactions (MPI) and initial-state showers (ISR) are always interleaved, as follows. Starting from the hard interaction, the complete event is constructed by a set of steps. In each step the Timelike Showers pT scale of the previous step is used as starting scale for a downwards evolution. The MPI and ISR components each make their respective Monte Carlo choices for the next lower Timelike Showers pT value. The one with larger Timelike Showers pT is allowed to carry out its proposed action, thereby modifying the conditions for the next steps. This is relevant since the two components compete for the energy contained in the beam remnants: both an interaction and an emission take away some of the energy, leaving less for the future. The end result is a combined chain of decreasing Timelike Showers pT values, where ones associated with new interactions and ones with new emissions are interleaved. Timelike Showers There is no corresponding requirement for final-state radiation (FSR) to be interleaved. Such an FSR emission does not compete directly for beam energy (but see below), and also can be viewed as occurring after the other two components in some kind of time sense. Interleaving is allowed, however, since it can be argued that a high- Timelike Showers pT FSR occurs on shorter time scales than a low- Timelike Showers pT MPI, say. Backwards evolution of ISR is also an example that physical time is not the only possible ordering principle, but that one can work with conditional probabilities: given the partonic picture at a specific Timelike Showers pT resolution scale, what possibilities are open for a modified picture at a slightly lower Timelike Showers pT scale, either by MPI, ISR or FSR? Complete interleaving of the three components also offers advantages if one aims at matching to higher-order matrix elements above some given scale. Timelike Showers As an aside, it should be noted that such interleaving does not affect showering in resonance decays, such as a Timelike Showers Z^0. These decays are only introduced after the production process has been considered in full, and the subsequent FSR is carried out inside the resonance, with preserved resonance mass. Timelike Showers One aspect of FSR for a hard process in hadron collisions is that often colour dipoles are formed between a scattered parton and a beam remnant, or rather the hole left behind by an incoming partons. If such holes are allowed as dipole ends and take the recoil when the scattered parton undergoes a branching then this translates into the need to take some amount of remnant energy also in the case of FSR, i.e. the roles of ISR and FSR are not completely decoupled. The energy taken away is bookkept by increasing the Timelike Showers x value assigned to the incoming scattering parton, and a reweighting factor Timelike Showers x_new f(x_new, pT^2) / x_old f(x_old, pT^2) in the emission probability ensures that not unphysically large Timelike Showers x_new values are reached. Usually such Timelike Showers x changes are small, and they can be viewed as a higher-order effect beyond the accuracy of the leading-log initial-state showers. Timelike Showers This choice is not unique, however. As an alternative, if nothing else useful for cross-checks, one could imagine that the FSR is completely decoupled from the ISR and beam remnants. Timelike Showers When there is no interleaving, a number of MPIs may have been generated before FSR is considered. In principle there could be colour correlations between the MPIs, such that a final-state colour of one MPI could be matched by the corresponding final-state anticolour of another MPI. These thereby would form a colour dipole, but one that does not come out from a common vertex, and therefore presumably could not radiate in full. Currently the standard procedure is to match colours between MPIs only after FSR, so MPI systems would radiate independently, with recoils taken by the beam remnant, where necessary. This could change, however, and the following switch would then regulate the choice of behaviour. Timelike Showers Global recoil The final-state algorithm is based on dipole-style recoils, where one single parton takes the full recoil of a branching. This is unlike the initial-state algorithm, where the complete already-existing final state shares the recoil of each new emission. As an alternative, also the final-state algorithm contains an option where the recoil is shared between all partons in the final state. Thus the radiation pattern is unrelated to colour correlations. This is especially convenient for some matching algorithms, like MC\@NLO, where a full analytic knowledge of the shower radiation pattern is needed to avoid double-counting. (The Timelike Showers pT -ordered shower is described in Timelike Showers Sjo05 , and the corrections for massive radiator and recoiler in Timelike Showers Nor01 .) Timelike Showers Technically, the radiation pattern is most conveniently represented in the rest frame of the final state of the hard subprocess. Then, for each parton at a time, the rest of the final state can be viewed as a single effective parton. This 'parton' has a fixed invariant mass during the emission process, and takes the recoil without any changed direction of motion. The momenta of the individual new recoilers are then obtained by a simple common boost of the original ones. Timelike Showers This alternative approach will miss out on the colour coherence phenomena. Specifically, with the whole subcollision mass as 'dipole' mass, the phase space for subsequent emissions is larger than for the normal dipole algorithm. The phase space difference grows as more and more gluons are created, and thus leads to a way too steep multiplication of soft gluons. Therefore the main application is for the first one or few emissions of the shower, where a potential overestimate of the emission rate is to be corrected for anyway, by matching to the relevant matrix elements. Thereafter, subsequent emissions should be handled as before, i.e. with dipoles spanned between nearby partons. Furthermore, only the first (hardest) subcollision is handled with global recoils, since subsequent MPI's would not be subject to matrix element corrections anyway. Timelike Showers In order for the mid-shower switch from global to local recoils to work, colours are traced and bookkept just as for normal showers; it is only that this information is not used in those steps where a global recoil is requested. (Thus, e.g., a gluon is still bookkept as one colour and one anticolour dipole end, with half the charge each, but with global recoil those two ends radiate identically.) Timelike Showers Two variations of the scheme outlined above are also available, (motivated by comparative studies within aMC\@NLO). These studies indicate that global recoils should be used as sparsely as possible, in order to retain desirable features of the radiation pattern produced with the local recoil prescription. Timelike Showers The global-recoil machinery does not work well with rescattering in the MPI machinery, since then the recoiling system is not uniquely defined. Timelike Showers MultipartonInteractions:allowRescatter = off by default, so this is not a main issue. If both options are switched on, rescattering will only be allowed to kick in after the global recoil has ceased to be active, i.e. once the Timelike Showers nMaxGlobalRecoil limit has been exceeded. This should not be a major conflict, since rescattering is mainly of interest at later stages of the downwards Timelike Showers pT evolution. Timelike Showers Further, it is strongly recommended to set Timelike Showers TimeShower:MEcorrections = off (not default!), i.e. not to correct the emission probability to the internal matrix elements. The internal ME options do not cover any cases relevant for a multibody recoiler anyway, so no guarantees are given what prescription would come to be used. Instead, without ME corrections,  a process-independent emission rate is obtained, and Timelike Showers user hooks can provide the desired process-specific rejection factors. Timelike Showers Radiation off octet onium states In the current implementation, charmonium and bottomonium production can proceed either through colour singlet or colour octet mechanisms, both of them implemented in terms of Timelike Showers 2 &rarr; 2 hard processes such as Timelike Showers g g &rarr; (onium) g. In the former case the state does not radiate and the onium therefore is produced in isolation, up to normal underlying-event activity. In the latter case the situation is not so clear, but it is sensible to assume that a shower can evolve. (Assuming, of course, that the transverse momentum of the onium state is sufficiently high that radiation is of relevance.) Timelike Showers There could be two parts to such a shower. Firstly a gluon (or even a quark, though less likely) produced in a hard Timelike Showers 2 &rarr; 2 process can undergo showering into many gluons, whereof one branches into the heavy-quark pair. Secondly, once the pair has been produced, each quark can radiate further gluons. This latter kind of emission could easily break up a semibound quark pair, but might also create a new semibound state where before an unbound pair existed, and to some approximation these two effects should balance in the onium production rate. The showering 'off an onium state' as implemented here therefore should not be viewed as an accurate description of the emission history step by step, but rather as an effective approach to ensure that the octet onium produced 'in the hard process' is embedded in a realistic amount of jet activity. Of course both the isolated singlet and embedded octet are likely to be extremes, but hopefully the mix of the two will strike a reasonable balance. However, it is possible that some part of the octet production occurs in channels where it should not be accompanied by (hard) radiation. Therefore reducing the fraction of octet onium states allowed to radiate is a valid variation to explore uncertainties. Timelike Showers If an octet onium state is chosen to radiate, the simulation of branchings is based on the assumption that the full radiation is provided by an incoherent sum of radiation off the quark and off the antiquark of the onium state. Thus the splitting kernel is taken to be the normal Timelike Showers q &rarr; q g one, multiplied by a factor of two. Obviously this is a simplification of a more complex picture, averaging over factors pulling in different directions. Firstly, radiation off a gluon ought to be enhanced by a factor 9/4 relative to a quark rather than the 2 now used, but this is a minor difference. Secondly, our use of the Timelike Showers q &rarr; q g branching kernel is roughly equivalent to always following the harder gluon in a Timelike Showers g &rarr; g g branching. This could give us a bias towards producing too hard onia. A soft gluon would have little phase space to branch into a heavy-quark pair however, so the bias may not be as big as it would seem at first glance. Thirdly, once the gluon has branched into a quark pair, each quark carries roughly only half of the onium energy. The maximum energy per emitted gluon should then be roughly half the onium energy rather than the full, as it is now. Thereby the energy of radiated gluons is exaggerated, i.e. onia become too soft. So the second and the third points tend to cancel each other. Timelike Showers Finally, note that the lower cutoff scale of the shower evolution depends on the onium mass rather than on the quark mass, as it should be. Gluons below the octet-onium scale should only be part of the octet-to-singlet transition. Timelike Showers Weak showers The emission of weak gauge bosons is an integrated part of the initial- and final-state radiation, see Timelike Showers Weak Showers. The following settings are those specifically related to the final-state weak radiation, while common settings are found in the Timelike Showers Weak Showers description. Timelike Showers Further variables There are several possibilities you can use to switch on or off selected branching types in the shower, or in other respects simplify the shower. These should normally not be touched. Their main function is for cross-checks."},{"name":"Top Processes","link":"TopProcesses.html","text":"Top Processes Top Processes Top Processes Different ways to produce top quarks, singly or in pairs. Top Processes By default top always decays to a Top Processes W and a down-type quark. It is possible to switch on the Top Processes t &rarr; H+ b decay mode. Note that its partial width is calculated using the Top Processes tan(beta) value stored in Top Processes HiggsHchg:tanBeta , so that it can be used without having to read in a SUSY parameter file. For the Top Processes H+ to decay also Top Processes Higgs:useBSM = on is necessary."},{"name":"Total Cross Sections","link":"TotalCrossSections.html","text":"Total Cross Sections Total Cross Sections Total Cross Sections The Total Cross Sections SigmaTotal class returns the total, elastic, diffractive and nondiffractive cross sections in hadronic collisions. By implication it also has to provide differential elastic and diffractive cross sections, since many models start out from the differential expressions and then integrate to obtain more inclusive rates. In principle it would have been possible to decouple the overall normalization from the differential shape, however. Total Cross Sections The current page describes the options available for integrated and differential cross sections alike. The number of options is especially large for diffraction, reflecting the lack of a well-understood theory. Conversely, the wide spectrum of options should allow for detailed comparisons that eventually will improve our understanding. The Total Cross Sections Diffraction page contains those further parameters needed to describe the hadronization of a diffractive system, or at least those that set diffraction apart from the nondiffractive topologies. There are borderline cases, that could have been described in either place, such as the ones related to the pomeron-proton cross section, which mainly are relevant for the description of MPIs in diffractive systems, and therefore have been put on the Diffraction page. That page also contains the 'hard diffraction' framework, i.e. the modelling of diffractive events that contain a hard process. Total Cross Sections Several different parametrization options are available for Total Cross Sections p p and Total Cross Sections pbar p collisions, of special interest for hadron colliders, while the selection for other processes is considerably more limited. As a simple generalization, a neutron is assumed to have the same hadronic cross section as a proton. Total Cross Sections Historically most of the parametrizations used are from Total Cross Sections Sch94, Sch97 which borrows some of the total cross sections from Total Cross Sections Don92. A few parameters allow some possibility to vary the basic setup. The allowed combinations of incoming particles are Total Cross Sections p + p , Total Cross Sections pbar + p , Total Cross Sections pi+ + p , Total Cross Sections pi- + p , Total Cross Sections pi0/rho0 + p , Total Cross Sections phi + p , Total Cross Sections J/psi + p , Total Cross Sections rho + rho , Total Cross Sections rho + phi , Total Cross Sections rho + J/psi , Total Cross Sections phi + phi , Total Cross Sections phi + J/psi , Total Cross Sections J/psi + J/psi , Total Cross Sections Pomeron + p , Total Cross Sections gamma + gamma and Total Cross Sections gamma + p. The strong emphasis on vector mesons is related to the description of Total Cross Sections gamma + p and Total Cross Sections gamma + gamma interactions in a Vector Dominance Model framework (which is not explicitly used in the current implementation of photoproduction, but is retained for potential future applications). Total Cross Sections The other options available for total, elastic and diffractive cross sections are: Total Cross Sections Total Cross Sections A do-it-yourself selection of the main parameters. Total Cross Sections The MBR (Minimum Bias Rockefeller) model Total Cross Sections Cie12 , which is mainly intended for diffractive physics, but also parametrizes the total and elastic cross sections. Total Cross Sections The ABMST model Total Cross Sections App16 , which is based on a quite sophisticated Pomeron-inspired framework, and addresses total, elastic and single diffractive cross sections. The tuning to single diffractive data has mainly been performed at lower energies, so we also include variants that (hopefully) improves agreement with LHC data, and also introduce simple extensions to double and central diffraction. Total Cross Sections The RPP 2016 parametrization Total Cross Sections Pat16 , which is also Pomeron-inspired. It does not address diffractive cross sections. Total Cross Sections The elastic cross section is differential in the squared momentum transfer Total Cross Sections t. The single diffractive additionally is differential in the mass of the diffractive system, or in Total Cross Sections xi = x_Pom , where Total Cross Sections M^2_diff = xi * s. For double diffraction the two masses can accordingly be related to Total Cross Sections xi_1 and Total Cross Sections xi_2 values. For central diffraction Total Cross Sections M^2_diff = xi_1 * xi_2 * s , and additionally the cross section is differential in Total Cross Sections t_1 and Total Cross Sections t_2. Total Cross Sections Master switches The total and elastic cross sections are intimately connected via the optical theorem. Therefore the two should be calculated within a common setup. The diffractive cross sections are not as easily related, and can therefore be chosen separately, hence the two switches below. This allows different combinations to be tried out. Total Cross Sections Note that the total cross section subtracted by the elastic and various diffractive ones gives the inelastic nondiffractive cross section, which therefore is not set separately. However, since the nondiffractive inelastic cross section is what makes up the minimum-bias event class, and plays a major role in the description of multiparton interactions, it is important that a consistent set is used. Total Cross Sections In the following subsections all the parameters available for the various values of the master switches are described. A final subsection covers the possibility to include Coulomb corrections in elastic scattering, and is relevant for all scenarios. Total Cross Sections Set your own cross sections The following four parameters can be set for the Total Cross Sections SigmaTotal:mode = 0 option. The default values are in the right ballpark for LHC physics, but precise numbers depend on the energy used. Total Cross Sections The following four parameters can be set for the Total Cross Sections SigmaDiffractive:mode = 0 option. Again the default values are in the right ballpark for LHC physics, but with a considerable measure of uncertainty. Total Cross Sections The key parameter to set the differential shape of single diffraction is the Total Cross Sections SigmaDiffractive:PomFlux switch below. Seven different options are included, that provide the differential shape in diffractive mass and Total Cross Sections t of the scattered proton, based on the assumed Pomeron flux parametrizations. Only the SaS option contains a (published) extension to double diffraction, but the other alternatives have been extended in a minimal manner consistent with Pomeron phenomenology. These basic shapes can be further modified by the other settings below. Total Cross Sections In options 3, 4, 6, and 7 above, the Pomeron Regge trajectory is parametrized as Total Cross Sections alpha(t) = 1 + epsilon + alpha' t The Total Cross Sections epsilon and Total Cross Sections alpha' parameters can be set separately in options 3 and 4, and additionally Total Cross Sections alpha' is set in option 1, while values are fixed in options 6 and 7: Total Cross Sections The options above might give vanishing (or even negative) Total Cross Sections b slope values, and also do not enforce the presence of a rapidity gap. Furthermore the lowest allowed central diffractive mass is not well-defined; it would not be meaningful to go all the way down to the Total Cross Sections pi pi kinematical limit, since exclusive states are not modelled. Therefore the following parameters have been introduced to address such issues. Total Cross Sections Modify the SaS/DL cross sections The default description of total, elastic and diffractive interactions was parameterized and fit in Total Cross Sections Sch94, Sch97. There is no freedom for total and elastic cross sections, except that the Total Cross Sections rho parameter is not modelled but taken from the Total Cross Sections SigmaElastic:rho parameter above. Total Cross Sections The following three parameters allow for some modification of the mass distribution of the diffractive system, relative to the default setup. The parametrized cross sections explicitly depend on them, so that integrated diffractive cross section are changed acordingly. Total Cross Sections Central diffraction (CD) was not part of the framework in Total Cross Sections Sch94. It has now been added for Total Cross Sections p p or Total Cross Sections pbar p , but only for multiparticle states, i.e. excluding the low-mass resonance region below roughly 1 GeV, as well as other exclusive states. It uses the same proton-Pomeron vertex as in single diffraction, twice, to describe Total Cross Sections x_Pomeron and Total Cross Sections t spectra. This fixes the energy dependence, which has been integrated and parametrized. The absolute normalization has been left open, however. Furthermore, since CD has not been included in previous tunes to data, a special flag is available to reproduce the old behaviour (with due complications when one does not want to do this). Total Cross Sections LHC data have suggested that diffractive cross sections rise slower than predicted in the original studies. A likely reason is that unitarization effects may dampen the rise of diffractive cross sections relative to the default parametrizations. The settings here allows one way to introduce a dampening, which is used in some of the existing Total Cross Sections tunes. Total Cross Sections When Total Cross Sections SigmaDiffractive:dampen = on , the three diffractive cross sections are damped so that they never can exceed the respective values below. Specifically, if the standard parametrization gives the cross section Total Cross Sections sigma_old(s) and a fixed Total Cross Sections sigma_max is set, the actual cross section becomes Total Cross Sections sigma_new(s) = sigma_old(s) * sigma_max / (sigma_old(s) + sigma_max). This reduces to Total Cross Sections sigma_old(s) at low energies and to Total Cross Sections sigma_max at high ones. Note that the asymptotic value is approached quite slowly, however. Total Cross Sections As above, a reduced diffractive cross section automatically translates into an increased nondiffractive one, such that the total (and elastic) cross section remains fixed. Total Cross Sections Modify the MBR cross sections The MBR differential cross section also comes with a selection of parameters that can be changed from their default values, to modify diffractive event rates and shapes, while the total and elastic cross sections remain unaffected. These parameters are described in the following. Total Cross Sections Modify the ABMST cross sections The ABMST model provides a detailed description of the total, elastic and single diffractive cross sections. The former two components are accepted as is, while we have allowed alternative shapes for single diffraction, notably to enforce a rapidity gap. The ABMST model does not address double and central diffraction, so we have extended it on our own, as described below. Total Cross Sections Modify the RPP cross sections The RPP approach only addresses total and (differential) elastic cross sections, and there are no free parameters that can be changed. Total Cross Sections Coulomb corrections to elastic scattering By default there is no Coulomb-term contribution to the elastic (or total) cross section, which of course becomes infinite if this contribution is included in the collision between charged particles, owing to the Total Cross Sections 1/t^2 singularity of Total Cross Sections t -channel photon exchange. You can switch on Coulomb corrections below, however, including interference with the conventional strong-interaction term. The own, SaS/DL and MBR models share a common machinery to evaluate the interference Total Cross Sections Ber87 , while ABMST and RPP use a slighly different expression for the (poorly known) difference in phases between the hadronic and the electromagnetic amplitudes."},{"name":"Tunes","link":"Tunes.html","text":"Tunes Tunes Tunes Since some physics aspects cannot be derived from first principles, this program contains many parameters that represent a true uncertainty in our understanding of nature. Particularly afflicted are the areas of hadronization and multiparton interactions, which both involve nonperturbative QCD physics. Tunes Technically, PYTHIA  parameters can be varied independently of each other, but the physical requirement of a sensible description of a set of data leads to correlations and anticorrelations between the parameters. Hence the need to produce tunes, not of one parameter at a time, but simultaneously for a group of them. A well-known (separate) such example is parton densities, where combined tunes to a wide range of data have been produced, that can then be obtained prepackaged. Tunes Given the many PYTHIA parameters to be tuned, it is convenient to divide the task into subtasks. Firstly, if we assume jet universality, hadronization and final-state parton showers should be tuned to Tunes e^+e^- annihilation data, notably from LEP1, since this offers the cleanest environment. Secondly, with such parameters fixed, hadron collider data should be studied to pin down multiparton interactions and other further aspects, such as initial-state radiation. Ideally this would be done separately for diffractive and non-diffractive events, although it is not possible to have a clean separation. (Thirdly would come anything else, such as physics with photon beams, which involve further parameters, but that is beyond the current scope.) Tunes The first step was taken, with a tune to LEP1 data by Hendrik Hoeth, using the Rivet + Professor framework. Starting with version 8.125 it defined the default values for hadronization parameters and timelike showers. Tunes The situation is more complicated for hadronic interactions in general and multiparton interactions in particular, where PYTHIA 8 is more different from PYTHIA 6, and therefore more work is needed. Specifically, it is Tunes not possible to 'port' a PYTHIA 6 tune to PYTHIA 8. Tunes A first simple tune, appropriately called 'Tune 1', became default starting with version 8.127. It was noted, in particular by Hendrik Hoeth, that this tune had a tension between parameters needed to describe minimum-bias and underlying-event activity. Therefore some further physics features were introduced in the code itself Tunes Cor10a , which were made default as of 8.140. This version also included two new tunes, 2C and 2M, based on the CTEQ 6L1 and the MRST LO** PDF sets, respectively. These have been made by hand, as a prequel to complete Professor-style tunings. Tunes The very first data to come out of the LHC showed a higher rapidity plateau than predicted for current PYTHIA 6 tunes, also for the lower energies. This may suggest some tension in the data. Two alternatives, 3C and 3M, were produced by a few brute-force changes of 2C and 2M. These were introduced in 8.140, but discontinued in 8.145 in favour of the newer 4C tune, that is based on a more serious study of some early LHC data, see Tunes Cor10a. Following the comparative studies in Tunes Buc11 , which independently confirmed a reasonable agreement with LHC data, tune 4C was made the default from 8.150. A variant is tune 4Cx, where the Gaussian matter profile has an Tunes x -dependent width Tunes Cor11. Tunes Tune 4C was the basis for many subsequent LHC tunes. Several ATLAS tunes have been included here, obtained with different PDFs and with different emphasis on minimum-bias and underlying-event data Tunes ATL12. These typically require LHAPDF to be linked, but this can be avoided in cases where the same PDF set is implemented internally. Also two CMS underlying-event tunes are implemented Tunes CMS14. The ATLAS AZ tune Tunes ATL14 instead puts emphasis on the Tunes pT spectrum of the Tunes Z^/gamma^*0 boson. Tunes The Monash 2013 tune Tunes Ska14 is based on a larger set of LHC distributions. It starts out from a more careful comparison with and tuning to LEP data, and so involves several parameter changes. The PDF used is the NNPDF2.3 QCD+QED LO one with Tunes alpha_s(M_Z) = 0.130 , which includes more recent data than used in the previous default, and opens up for processes with incoming photons to the hard process. It is the default starting from 8.200. Tunes Recent tunes by the LHC collaborations are based on the Monash 2013 one. This includes the CMS tune MonashStar, or formally CUETP8M1-NNPDF2.3LO (currently unpublished). More significantly, ATLAS has produced and published a whole family for underlying-event tunes based on a major effort, including simultaneous fits of ten parameters Tunes ATL14a. This includes four central tunes, with four different PDF sets, and ten variations around the NNPDF2.3 QCD+QED LO central tune, grouped in five pairs of variations up and down. The publication Tunes ATL14a should be consulted for further details, like with what additional settings various processes have been generated, which should be respected to reap full benefit of the tunes. Tunes Central diffraction is a recent addition to the 'soft QCD' process palette, and is thus not yet included in tunes; indeed its cross section is actively zeroed. You can switch it back on Tunes after you have selected your tune, with Tunes SigmaTotal:zeroAXB = off. But note that, since the total cross section is assumed unchanged, the nondiffractive cross section is reduced and thus also the MPI machinery affected, even if effects should not be big (for a small central diffractive cross section). Tunes Note that comparisons with data also require that other aspects agree, such as that decay chains are stopped at an agreed-on level. For instance, in the ATLAS tunes all particles with a lifetime above 10 mm are considered stable, Tunes ParticleDecays:limitTau0 = on , Tunes ParticleDecays:tau0Max = 10. We have chosen not to include this as part of the tune settings itself, since the tune as such could still be used with any other choice of stable and unstable particles. Tunes Further comparisons have been posted on the Tunes MCPLOTS pages. They have been produced with help of the Tunes Rivet package Tunes Buc10. Tunes To simplify comparisons for the user, we propose to collect some of the tunes here, in a prepackaged form. Of course, in all cases it is a matter of setting values for parameters already defined elsewhere, so the tunes offer no new functionality, only a more convenient setup. Tunes You should be aware that the evolution of the program will not guarantee complete backwards compatibility between versions. Most obviously this concerns bug fixes. But also for some other major changes, like the introduction of the new diffractive machinery, the default behaviour of old tunes has been changed retroactively. (Which should be fine for diffraction, since previous tunes were not based on data strongly influenced by diffraction.) Tunes The setup of the tunes is special, in that the choice of a tune forces the change of several different flags, modes and parameters. Furthermore a design principle has been that it should be possible to start out from a tune and then change a few of its settings. This gives power and flexibility at the expense of requiring a more careful ordering of commands. We therefore here sketch the order in which operations are carried out. Tunes Tunes The constructor of a Tunes Pythia instance will read in all settings, and initialize them with their default values. Tunes At the end of this operation, the Tunes Tune:ee and Tunes Tune:pp modes (see further below) are checked. If either of them are positive the methods Tunes Settings::initTuneEE(...) and Tunes Settings::initTunePP(...) , respectively, are called to overwrite the whole collection of settings in the relevant tune. Zero (or negative) means that nothing will be done. Since most Tunes pp/ppbar tunes have been made in the context of an Tunes e^+e^- one, Tunes initTunePP(...) usually calls Tunes initTuneEE(...) to provide this synchronization. Tunes After the Tunes Pythia constructor all the relevant values for the default tune(s) have thus been set up. Tunes You as a user can now start to overwrite the values at will, using Tunes Pythia::readFile(...) to read a configuration file, or a list of Tunes Pythia::readString(...) commands, or the lower-level Tunes Settings methods. All changes are made in the order in which the commands are encountered during the execution. A given variable can be changed multiple times, but it is the latest change that sets the current value. Tunes The two Tunes Tune:ee and Tunes Tune:pp modes can also be changed in exactly the same way as described for all other settings above. Unique for them, however, is that when one of them is encountered it also initiates a call to the Tunes initTuneEE(...) or Tunes initTunePP(...) method, respectively. In such cases all settings affected by the Tunes e^+e^- or Tunes pp/ppbar tune are first reset to the default values (the Tunes -1 options) and thereafter the relevant tune is set up. Recall that Tunes initTunePP(...) in its turn is allowed to call Tunes initTuneEE(...). Tunes It is possible to mix commands of type 4 and 5 in any order; it is always the last change that counts. That is, any changes you have made to variables of a tune Tunes before a Tunes Tune:ee or Tunes Tune:pp command are overwritten by it, while variables you set Tunes after will overwrite the tune values. Further, the Tunes Tune:pp command usually implies an Tunes e^+e^- tune as well. Therefore Tunes Tune:ee would rarely be used for LHC applications. As a rule, instead, you want to begin with the Tunes Tune:pp choice, and thereafter modify only a small part of its settings. Tunes Needless to say, the flexibility can lead to unwanted setups if you do not exercise some discipline. It is therefore recommended that you always check the listing obtained with Tunes Pythia::settings.listChanged() to confirm that the final set of changes is the intended one."},{"name":"UMEPS Merging","link":"UMEPSMerging.html","text":"UMEPS Merging UMEPS Merging Unitarised Matrix Element + Parton Shower Merging Pythia offers the possibility to use the unitarised matrix element + parton shower merging scheme, as presented in UMEPS Merging Lon12. Unitarised ME+PS merging (UMEPS) allows for a consistent inclusion of tree-level multi-parton matrix elements into Pythia, and prevents potential changes in the inclusive production cross section. This makes it theoretically more appealing than CKKW-L merging. As in CKKW-L, UMEPS merging requires the user to supply Les Houches Event File input. UMEPS Merging UMEPS is different from other tree-level merging schemes in that it contains events with negative weights. These are generated by constructing parts of no-emission probabilities by reweighted higher-multiplicity samples UMEPS Merging Lon12. The main philosophy of UMEPS is 'subtract what you add', meaning that in order to ensure the stability of the inclusive cross section, one has to counter the inclusion of additional tree-level matrix elements by 'subtraction terms'. UMEPS Merging The scheme closely reflects how unitarity is achieved in a non-merged shower, and indeed explicitly enforces the cancellations that are implicitly happening in a non-merged shower. This makes very low merging scale values possible. UMEPS Merging The usage of UMEPS is illustrated in the sample main program UMEPS Merging main86.cc , together with the input file UMEPS Merging main86.cmnd. UMEPS Merging Unitarised merging is heavily indebted to CKKW-L merging, and shares many settings with CKKW-L. In particular, UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( UMEPS Merging Merging:Process )needs to be defined exactly as in CKKW-L (see UMEPS Merging Defining the hard process in the UMEPS Merging CKKW-L documentation ). UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( UMEPS Merging Merging:TMS ) has to be set. UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons UMEPS Merging Merging:nJetMax has to be set. UMEPS Merging UMEPS further shares the switches listed under the sections ' UMEPS Merging Matrix element merging and HepMC output for RIVET ' and ' UMEPS Merging Further variables ' in  the UMEPS Merging CKKW-L documentation with CKKW-L merging. Also, all UMEPS Merging MergingHooks routines that allow for user interference in CKKW-L merging are also usable for UMEPS -- with the exception of a user-defined merging scale. Currently, UMEPS is only implemented for a merging scale defined by the minimal Pythia evolution pT value between sets of radiator, emitted and recoiler partons. This is no fundamental limitation of the method, and will possibly be lifted in the future. Since this merging scale definition is not completely obvious, UMEPS also shares the UMEPS Merging Merging:enforceCutOnLHE switch with CKKW-L. In this way, it is possible to use LHE files that are regularised only with weak cuts as input, while the merging machinery imposes the stronger merging scale cut automatically. This means that no merging scale implementation is required from the user side, but also means that it is the user's responsibility to ensure that the cuts used for generating input LHE files are always looser than the cut given by the merging scale value UMEPS Merging Merging:TMS. UMEPS Merging UMEPS Merging UMEPS Merging UMEPS Merging UMEPS merging with main86.cc The UMEPS procedure is illustrated in the sample main program UMEPS Merging main86.cc (with the input card UMEPS Merging main86.cmnd ). This program produces HepMC events UMEPS Merging Dob01 , that can be histogrammed (e.g. using RIVET UMEPS Merging Buc10 ), or used as input for a detector simulation. If the user is not familiar with HepMC analysis tools, it is possible to instead use Pythia's histogramming routines. For this, remove the lines referring to HepMC, and histogram events as illustrated (for CKKW-L) for the histogram UMEPS Merging histPTFirstSum in UMEPS Merging main84.cc , i.e. using UMEPS Merging weight*normhepmc as weight. UMEPS Merging In principle, no changes to UMEPS Merging main86.cc are necessary. Instead, all settings can be transferred to UMEPS Merging main86.cc through an input file. The input LHE files are also part of the (command line) input of UMEPS Merging main86.cc. Note  that the sample program assumes that LHE file names are of the form UMEPS Merging name_tree_#nAdditionalJets.lhe. If you want to e.g. use the LHE files that are shipped with the Pythia distribution, you can execute UMEPS Merging main86.exe with the command UMEPS Merging UMEPS Merging ./main86.exe ./main86.cmnd ./w_production ./myhepmc.hepmc Since UMEPS Merging main86.cc is currently the 'front-end' for UMEPS merging, we will briefly discuss this sample program in the following. UMEPS Merging Inputs In its current form, UMEPS Merging main86.cc uses separate tree-level LHE files for different numbers of additional partons as input. If e.g. UMEPS merging for W-boson + up to two additional partons is to be performed, three LHE files (for W+zero, W+one, W+two partons) are required. The configurations in the input files should be regularised with inclusive (i.e. weak) cuts. The actual 'merging scale cut' will be handled internally. If e.g. UMEPS Merging Merging:TMS = 15 is the desired merging scale value, it is acceptable to regularise the matrix element calculation for Higgs+jets events at the LHC with the loose cuts UMEPS Merging pT UMEPS Merging jet = 5 GeV , UMEPS Merging &Delta;R UMEPS Merging jetA jetB = 0.01 and UMEPS Merging Q UMEPS Merging jetA jetB = 5 GeV. UMEPS Merging All input settings are handed to UMEPS Merging main86.cc in the form of an input file. This input file has to contain UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The number of desired events ( UMEPS Merging Main:numberOfEvents ) UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The hard process ( UMEPS Merging Merging:Process ) UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The merging scale value ( UMEPS Merging Merging:TMS ) UMEPS Merging &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; The maximal number of additional partons ( UMEPS Merging Merging:nJetMax ). UMEPS Merging Other settings are of course allowed. However, please refrain from adding switches that are used to invoke other merging schemes (e.g. UMEPS Merging Merging:doKTMerging ) into the input file, since this can cause problems. UMEPS Merging Program flow The sample program starts by estimating the cross section for samples with different jet multiplicities. For this, the switch UMEPS Merging Merging:doXSectionEstimate is invoked together with the merging scale definition of UMEPS Merging Merging:doUMEPSTree , which corresponds to the minimal Pythia evolution pT value. We will come back to the latter switch below. All showering, multiparton interactions and hadronisation is, for speed reasons, switched off when estimating the cross section, since the hard cross section estimate would not be influenced by the event evolution anyway. UMEPS Merging After the hard cross sections are known (including the application of the merging scale cut), the first part of the UMEPS events is generated by using the following switch. UMEPS Merging The weight generated by the UMEPS procedure can be accessed by using the function UMEPS Merging double Info::mergingWeight(). When printing (or histogramming) merged events, this weight, multiplied with the estimated cross section for the current sample, should be used as event weight (or to fill histogram bins). UMEPS Merging After this first part is complete, the outcome is an addition of reweighted tree-level samples. To restore the inclusive cross section (i.e. that the cross section after merging corresponds to the cross section of the hard process, without any additional jets), it is necessary to subtract samples. Parton shower unitarity leads to the conclusion that 'resolved' and 'unresolved' corrections always cancel between states that contain an additional resolved jet, and states in which we 'integrate over' the phase space of the additional jet. UMEPS Merging main86.cc makes this cancellation explicit by producing (correctly weighted) counter events by switching on UMEPS Merging The integration is achieved internally, and the number of desired integrations (which is always one for UMEPS counter events) is set by UMEPS Merging Again, the weight generated by the UMEPS procedure can be accessed by using the function UMEPS Merging double Info::mergingWeight(). This weight, multiplied with the cross section of the current sample, and multiplied by UMEPS Merging -1 , should then be used as event weight (or to fill histogram bins). UMEPS Merging Before returning, UMEPS Merging main86.cc prints the merged cross section after UMEPS merging."},{"name":"User Hooks","link":"UserHooks.html","text":"User Hooks User Hooks User Hooks Sometimes it may be convenient to step in during the generation process: to modify the built-in cross sections, to veto undesirable events or simply to collect statistics at various stages of the evolution. There is a base class User Hooks UserHooks that gives you this access at a few selected places. This class in itself does nothing; the idea is that you should write your own derived class for your task. One simple derived class ( User Hooks SuppressSmallPT ) comes with the program, mainly as illustration, and the User Hooks main10.cc program provides a complete (toy) example how a derived class could be set up and used. User Hooks There are ten sets of routines, that give you different kinds of freedom. They are, in no particular order: User Hooks (i) Ones that give you access to the event record in between the process-level and parton-level steps, or in between the parton-level and hadron-level ones. You can study the event record and decide whether to veto this event. User Hooks (ii) Ones that allow you to set a scale at which the combined parton-level MPI+ISR+FSR downwards evolution in User Hooks pT is temporarily interrupted, so the event can be studied and either vetoed or allowed to continue the evolution. User Hooks (iii) Ones that allow you to to study the event after the first few ISR/FSR emissions, or first few MPI, so the event can be vetoed or allowed to continue the evolution. User Hooks (iv) Ones that allow you to study the latest initial- or final-state emission and veto that emission, without vetoing the event as a whole. User Hooks (v) Ones that give you access to the properties of the trial hard process, so that you can modify the internal Pythia cross section, alternatively the phase space sampling, by your own correction factors. User Hooks (vi) Ones that allow you to reject the decay sequence of resonances at the process level. User Hooks (vii) Ones that let you set the scale of shower evolution, specifically for matching in resonance decays. User Hooks (viii) Ones that allow colour reconnection, notably in connection with resonance decays. User Hooks (ix) Ones that allow an enhanced rate of rare shower splittings. User Hooks (x) Ones that give you access to to hadronization parameters in each step in the hadronization process, and allows for a veto of individual hadrons. User Hooks They are described further in the following numbered subsections. User Hooks All the possibilities above can be combined freely and also be combined with the standard flags. An event would then survive only if it survived each of the possible veto methods. There are no hidden interdependencies in this game, but of course some combinations may not be particularly meaningful. For instance, if you set User Hooks PartonLevel:all = off then the User Hooks doVetoPT(...) and User Hooks doVetoPartonLevel(...) locations in the code are not even reached, so they would never be called. User Hooks Normally you would gather all your changes into one derived class. In some cases it may be more convenient to separate different functionalities. Therefore it is possible to hand in several user hooks. See the section on 'Multiple user hooks' at the bottom of this page for further information on this possibility. User Hooks The effect of the vetoes of types (i), (ii) and (iii) can be studied in the output of the User Hooks User Hooks Pythia::stat() method. The 'Selected' column represents the number of events that were found acceptable by the internal Pythia machinery, whereas the 'Accepted' one are the events that also survived the user cuts. The cross section is based on the latter number, and so is reduced by the amount associated by the vetoed events. Also type (v) modifies the cross section, while types (iv), (vi) and (vii) do not. User Hooks A warning. When you program your own derived class, do remember that you must exactly match the arguments of the base-class methods you overload. If not, your methods will be considered as completely new ones, and compile without any warnings, but not be used inside User Hooks Pythia. So, at the debug stage, do insert some suitable print statements to check that the new methods are called (and do what they should). User Hooks The basic components For a derived User Hooks UserHooks class to be called during the execution, a pointer to an object of this class should be handed in with the User Hooks User Hooks User Hooks Pythia::setUserHooksPtr( UserHooks*) User Hooks method. The first step therefore is to construct your own derived class, of course. This must contain a constructor and a destructor. The User Hooks initPtr method comes 'for free', and is set up without any intervention from you. User Hooks Next you overload the desired methods listed in the sections below. These often come in pairs or triplets, where the first must return true for the last method to be called. This latter method typically hands you a reference to the event record, which you then can use to decide whether or not to veto. Often the event record can be quite lengthy and difficult to overview. The following methods and data member can then come in handy. User Hooks (i) Interrupt between the main generation levels User Hooks (ii) Interrupt during the parton-level evolution, at a User Hooks pT scale During the parton-level evolution, multiparton interactions (MPI), initial-state radiation (ISR) and final-state radiation (FSR) are normally evolved downwards in one interleaved evolution sequence of decreasing User Hooks pT values. For some applications, e.g  matrix-element-matching approaches, it may be convenient to stop the evolution temporarily when the 'hard' emissions have been considered, but before continuing with the more time-consuming soft activity. Based on these hard partons one can make a decision whether the event at all falls in the intended event class, e.g. has the 'right' number of parton-level jets. If yes then, as for the methods above, the evolution will continue all the way up to a complete event. Also as above, if no, then the event will not be considered in the final cross section. User Hooks Recall that the new or modified partons resulting from a MPI, ISR or FSR step are always appended to the end of the then-current event record. Previously existing partons are not touched, except for the User Hooks status, mother and daughter values, which are updated to reflect the modified history. It is therefore straightforward to find the partons associated with the most recent occurrence. User Hooks An MPI results in four new partons being appended, two incoming and two outgoing ones. User Hooks An ISR results in the whole affected system being copied down, with one of the two incoming partons being replaced by a new one, and one more outgoing parton. User Hooks An FSR results in three new partons, two that come from the branching and one that takes the recoil. User Hooks The story becomes more messy when rescattering is allowed as part of the MPI machinery. Then there will not only be a new system, as outlined above, but additionally some existing systems will undergo cascade effects, and be copied down with changed kinematics. User Hooks In this subsection we outline the possibility to interrupt at a given User Hooks pT scale, in the next to interrupt after a given number of emissions. User Hooks (iii) Interrupt during the parton-level evolution, after a step These options are closely related to the ones above in section (ii), so we do not repeat the introduction, nor the possibilities to study the event record, also by using User Hooks subEvent(...) and User Hooks workEvent. What is different is that the methods in this section give access to the event as it looks like after each of the first few steps in the downwards evolution, irrespective of the User Hooks pT scales of these branchings. Furthermore, it is here assumed that the focus normally is on the hardest subprocess, so that ISR/FSR emissions associated with additional MPI's are not considered. For MPI studies, however, a separate simpler alternative is offered to consider the event after a given number of interactions. User Hooks (iv) Veto emissions The methods in this group are intended to allow the veto of an emission in ISR, FSR or MPI, without affecting the evolution in any other way. If an emission is vetoed, the event record is 'rolled back' to the way it was before the emission occurred, and the evolution in User Hooks pT is continued downwards from the rejected value. The decision can be based on full knowledge of the kinematics of the shower branching or MPI. User Hooks To identify where shower emissions originated, the ISR/FSR veto routines are passed the system from which the radiation occurred, according to the Parton Systems class (see User Hooks Advanced Usage ). Note, however, that inside the veto routines only the event record has been updated; all other information, including the Parton Systems, reflects the event before the shower branching or MPI has taken place. User Hooks (v) Modify cross-sections or phase space sampling This section addresses two related but different topics. In both cases the sampling of events in phase space is modified, so that some regions are more populated while others are depleted. In the first case, this is assumed to be because the physical cross section should be modified relative to the built-in Pythia form. Therefore not only the relative population of phase space is changed, but also the integrated cross section of the process. In the second case the repopulation is only to be viewed as a technical trick to sample some phase-space regions better, so as to reduce the statistical error. There each event instead obtains a compensating weight, the inverse of the differential cross section reweighting factor, in such a way that the integrated cross section is unchanged. Below these two cases are considered separately, but note that they share many points. User Hooks One derived class is supplied as an example how this facility can be used to reweight cross sections in the same spirit as is done with QCD cross sections for the minimum-bias/underlying-event description: User Hooks The second main case of the current section involves three methods, as follows. User Hooks (vi) Reject the decay sequence of resonances Resonance decays are performed already at the process level, as an integrated second step of the hard process itself. One reason is that the matrix element of many processes encode nontrivial decay angular distributions. Another is to have equivalence with Les Houches input, where resonance decays typically are provided from the onset. The methods in this section allow you to veto that decay sequence and try a new one. Unlike the veto of the whole process-level step, in point (i), the first step of the hard process is retained, i.e. where the resonances are produced. For this reason the cross section is not affected here but, depending on context, you may want to introduce your own counters to check how often a new set of decay modes and kinematics is selected, and correct accordingly. User Hooks The main method below is applied after all decays. For the production of a User Hooks t tbar pair this typically means after four decays, namely those of the User Hooks t , the User Hooks tbar , the User Hooks W+ and the User Hooks W-. If Les Houches events are processed, the rollback is to the level of the originally read events. For top, that might mean either to the tops, or to the User Hooks W bosons, or no rollback at all, depending on how the process generation was set up. User Hooks (vii) Modify scale in shower evolution The choice of maximum shower scale in resonance decays is normally not a big issue, since the shower here is expected to cover the full phase space. In some special cases a matching scheme is intended, where hard radiation is covered by matrix elements, and only softer by showers. The below two methods support such an approach. Note that the two methods are not used in the User Hooks TimeShower class itself, but when showers are called from the User Hooks PartonLevel generation. Thus user calls directly to User Hooks TimeShower are not affected. User Hooks (viii) Allow colour reconnection PYTHIA contains only a limites set of possibilities for User Hooks colour reconnection , and none of them are geared specifically towards rapidly decaying resonances. Notably, with the default User Hooks User Hooks PartonLevel:earlyResDec = off , resonances will only decay after colour reconnection has already been considered. Thus a coloured parton like the top may be reconnected but, apart from this external connection with the rest of the event, the top decay products undergo no colour reconnection. For User Hooks PartonLevel:earlyResDec = on the resonance will decay earlier, and thus the decay products may undergo reconnections, but not necessarily by models that are specifically geared towards this kind of events. For tryout purposes, a user hook can be called directly after the resonance decays, and there modify the colour flow. This holds whether the resonance decay is handled early or late, but is especially appropriate for the latter default possibility. While intended specifically for resonance decays, alternatively it is possible to switch off the built-in colour reconnection and here implement your own reconnection model for the whole event. User Hooks (ix) Enhanced rate of rare shower splittings PYTHIA also offers possibilities to enhance the frequency of rare splittings.  This is not a trivial task, since a simple 'upweighting' of splittings would produce a mismatch between emission and no-emission probabilities, leading to a violation of the principle that the parton shower should not change the inclusive (input) cross section. Nevertheless, a general algorithm that allows for increased emission probabilities, while keeping no-emission factors intact, was presented in User Hooks Lon13a. User Hooks In User Hooks Lon13a two types of enhancements are proposed: those of 'regular' shower emissions, and those of trial shower emissions, the latter as part of the mandatory Sudakov reweighting in ME+PS merging schemes. Both of these possibilities are accessible through User Hooks UserHooks , but cannot be used at the same time. User Hooks The price to pay for these enhancements is that events come with a compensatory weight. The advantages of obtaining higher statistics for rare branchings thus is mitigated, and the usefulness has to be evaluated case by case. User Hooks Currently enhancements of ISR and FSR branchings have been included. These enhancements are currently not phase-space dependent, i.e. emissions will be enhanced uniformly in phase space. It should also be noted that the threshold region for gluon branchings to a pair of heavy quarks, specifically User Hooks g &rarr; c + cbar and User Hooks g &rarr; b + bbar , are not enhanced in this algorithm. Technically it is because this case is handled separately in the code, but there also remain some physics issues to understand. User Hooks To increase statistics of rare emissions in the showers, e.g. QED or weak radiation, Pythia supplies the following functions implementing the strategy of section 4 in User Hooks Lon13a. User Hooks In the context of merging, it can be beneficial to allow for enhanced trial emissions. As discussed in section 3 of User Hooks Lon13a , this means that the Sudakov factors that are commonly generated by event vetoes based on trial emissions (see e.g. User Hooks Lon11 ) are instead given by small but non-vanishing event weights. This can have advantages, since all events of an input sample will be retained. Pythia allows users to enhance trial emissions by using the following functions. User Hooks Trial emission enhancements also necessitate corrective weights. These are handled internally, so that users only have to ensure that User Hooks Info::mergingWeight() or User Hooks Info::mergingWeightNLO() are correctly taken into account. User Hooks A simple example of enhanced regular emissions is provided in User Hooks main63.cc , whereas User Hooks main64.cc illustrates the usefulness of enhanced trial emissions for expert users. User Hooks (x) Modified hadronization The methods in this group are intended to allow for modifications of the string hadronization model, involving changes to hadronization parameters based on local properties of the string. Given information on the hadronization history of a single string,  parameters can be changed to control the selection of quark flavour, User Hooks z and User Hooks pT in string breaks. Furthermore there is a option to veto the creation of a hadron before it is added to the event record, thus repeating a step in the hadronization procedure. User Hooks Multiple user hooks In addition to the User Hooks User Hooks User Hooks Pythia::setUserHooksPtr( UserHooks*) User Hooks method there is a second User Hooks User Hooks User Hooks Pythia::addUserHooksPtr( UserHooks*) User Hooks method that works almost like the former, but it allows the addition of further user hooks. These are stored as a vector and all of them will be called consecutively at the respective locations where they are set up to be active. User Hooks If two or more of them are active at the same location it is up to the user to ensure that the joint action is the one intended. In cases where weights are assigned the net result will be a weight that is is the product of them. In cases where vetoes are involved, a veto will be returned if either hook wants to veto, i.e. the no-veto survival probability is combined multiplicatively. It is not meaningful to let two hooks set the resonance scale or change fragmentation parameters, so warnings will be issued if this occurs."},{"name":"Vertex Information","link":"VertexInformation.html","text":"Vertex Information Vertex Information Vertex Information While the setting of secondary production vertices of unstable hadrons and leptons is a standard part of the particle decay rotines, no corresponding standardized handling is in place for the evolution in the partonic or hadronization phases of the event generation. The intention is to provide such methods in due course. Vertex Information There are some cases where such information is needed already now, specifically for the Vertex Information Rope Hadronization framework. Therefore the beginning of a framework is available, that can be used to set vertices for partonic production by MPI, FSR and ISR. This is done in the Vertex Information PartonVertex class. This is a base class, with a default implementation, but the user can replace it with a derived class that does a more sophisticated handling. Vertex Information Note that currently the parton-level vertices are expressed in fm, unlike the normal mm scale. This will be fixed as the methods evolve. Also other improvements and extensions are likely to come. So, while people are welcome to write their own derived classes, it is likely that these may need to be modified in later PYTHIA versions. Vertex Information Rope Hadronization Parameters Currently the base class implements two alternative approaches to picking a partonic vertex, for use inside the rope hadronization framework. There are also some free parameters in the models. Vertex Information External models A derived class for setting parton vertex information can be provided to PYTHIA with the Vertex Information Vertex Information bool Pythia::setPartonVertexPtr( PartonVertex* partonVertexPtrIn) Vertex Information method. The methods in the derived Vertex Information PartonVertex class can then be used to add vertex information to produced particles, at creation time, in MPI, FSR and ISR. The assigned vertex information will afterwards be accessible as properties of the individual particles. Particles produced in other types of processes than the ones mentioned above will not have vertex information assigned (e.g. hard process, beam remnants etc.), neither will particles produced in the weak shower."},{"name":"Weak Showers","link":"WeakShowers.html","text":"Weak Showers Weak Showers Weak Showers The emission of Weak Showers W^+- and Weak Showers Z^0 gauge bosons off fermions is intended to be an integrated part of the initial- and final-state radiation frameworks, and is fully interleaved with QCD and QED emissions. It is a new and still not fully explored feature, however, and therefore it is off by default. The weak-emission machinery is described in detail in Weak Showers Chr14 ; here we only bring up some of the most relevant points for using this machinery. Weak Showers In QCD and QED showers the real and virtual corrections are directly related with each other, which means that the appropriate Sudakov factors can be directly obtained as a by-product of the real-emission evolution. This does not hold for Weak Showers W^+- , owing to the flavour-changing character of emissions, so-called Bloch-Nordsieck violations. These effects are not expected to be large, but they are not properly included, since our evolution framework makes no distinction in this respect between QCD, QED or weak emissions. Another restriction is that there is no simulation of the full Weak Showers gamma^*/Z^0 interference: at low masses the QED shower involves a pure Weak Showers gamma^* component, whereas the weak shower generates a pure Weak Showers Z^0. Weak Showers The non-negligible Weak Showers W/Z masses have a considerable impact both on the matrix elements and on the phase space for their emission. The shower on its own is not set up to handle those aspects with a particularly good accuracy. Therefore the weak shower emissions are always matched to the matrix element for emission off a Weak Showers f fbar weak dipole, or some other Weak Showers 2 &rarr; 3 matrix element that resembles the topology at hand. Even if the match may not be perfect, at least the main features should be caught that way. Notably, the correction procedure is used throughout the shower, not only for the emission closest to the hard Weak Showers 2 &rarr; 2 process. In such extended applications, emission rates are normalized to the invariant mass of the dipole at the time of the weak emission, i.e. discounting the energy change by previous QCD/QED emissions. Weak Showers Also the angular distribution in the subsequent Weak Showers V = W^+-/Z^0 decay is matched to the matrix element expression for Weak Showers f fbar &rarr; f fbar V &rarr; f fbar f' fbar' (FSR) and Weak Showers f fbar &rarr; g^* V &rarr; g^* f' fbar' (ISR). Afterwards the Weak Showers f' fbar' system undergoes showers and hadronization just like any Weak Showers W^+-/Z^0 decay products would. Weak Showers Special for the weak showers is that couplings are different for left- and righthanded fermions. With incoming unpolarized beams this should average out, at least so long as only one weak emission occurs. In the case of several weak emissions off the same fermion the correlation between them will carry a memory of the fermion helicity. Such a memory is retained for the affected dipole end, and is reflected in the Weak Showers Particle::pol() property, it being Weak Showers +1 ( Weak Showers -1 ) for fermions considered righthanded (lefthanded), and 0 for the bulk where no choice has been made. Weak Showers Most events will not contain a Weak Showers W^+-/Z^0 emission at all, which means that dedicated generator studies of weak emissions can become quite  inefficient. In a shower framework it is not straightforward to force  such emissions to happen without biasing the event sample in some respect. An option is available to enhance the emission rate artificially, but it is then the responsibility of the user to correct the cross section accordingly, and not to pick an enhancement so big that the probability for more than one emission is non-negligible. (It is not enough to assign an event weight Weak Showers 1/e^n where Weak Showers e is the enhancement factor and Weak Showers n is the number of emitted gauge bosons. This still misses to account for the change in phase space for late emissions by the effect of earlier ones, or equivalently for the unwanted change in the Sudakov form factor. See Weak Showers Lon13a for a detailed discussion and possible solutions.) Weak Showers Another enhancement probability is to only allow some specific Weak Showers W^+-/Z^0 decay modes. By default the shower is inclusive, since it should describe all that can happen with unit probability. This also holds even if the Weak Showers W^+- and Weak Showers Z^0 produced in the hard process have been restricted to specific decay channels. The trick that allows this is that two new 'aliases' have been produced, a Weak Showers Zcopy with identity code 93 and a Weak Showers Wcopy with code 94. These copies are used specifically to bookkeep decay channels open for Weak Showers W^+-/Z^0 bosons produced in the shower. For the rest they are invisible, i.e. you will not find these codes in event listings, but only the regular 23 and 24 ones. The identity code duplication allows the selection of specific decay modes for 93 and 94, i.e. for only the gauge bosons produced in the shower. As above it is here up to the user to reweight the event to compensate for the bias introduced, and to watch out for possible complications. In this case there is no kinematics bias, but one would miss out on topologies where a not-selected decay channel could be part of the background to the selected one, notably when more than one gauge boson is produced. Weak Showers Note that the common theme is that a bias leads to an event-specific weight, since each event is unique. It also means that the cross-section information obtained e.g. by Weak Showers Pythia::stat() is misleading, since it has not been corrected for such weights. This is different from biases in a predetermined hard process, where the net reduction in cross section can be calculated once and for all at initialization, and events generated with unit weight thereafter. Weak Showers The weak shower introduces a possible doublecounting problem. Namely that it is now possible to produce weak bosons in association with jets from two different channels, Drell-Yan weak production with QCD emissions and QCD hard process with a weak emission. A method, built on a classification of each event with the Weak Showers kT jet algorithm, is used to remove the doublecounting. Specifically, consider a tentative final state consisting of a Weak Showers W/Z and two jets. Based on the principle that the shower emission ought to be softer than the hard emission, the emission of a hard Weak Showers W/Z should be vetoed in a QCD event, and that of two hard jets in a Drell-Yan event. The dividing criterion is this whether the first clustering step involves the Weak Showers W/Z or not. It is suggested to turn this method on only if you simulate both Drell-Yan weak production and QCD hard production with a weak shower. Do not turn on the veto algorithm if you only intend to generate one of the two processes. Weak Showers Variables Below are listed the variables related to the weak shower and common to both the initial- and final-state radiation. For variables only related to the initial-state radiation (e.g. to turn the weak shower on for ISR) see Weak Showers Spacelike Showers and for final-state radiation see Weak Showers Timelike Showers."},{"name":"access","link":"Variations.html#anchor11","text":"access"},{"name":"Alpgen:file","link":"AlpgenEventInterface.html#anchor1","text":"Alpgen:file This option is used to read in ALPGEN format event files. Using this option overrides any previously set beam options inside PYTHIA. The path to the files, not including any file extension, should be provided e.g. for input files Alpgen:file input_unw.par and Alpgen:file input.unw , the value Alpgen:file input should be used."},{"name":"Alpgen:setHeavyMasses","link":"AlpgenEventInterface.html#anchor3","text":"Alpgen:setHeavyMasses When switched on, Alpgen:setHeavyMasses t , Alpgen:setHeavyMasses Z , Alpgen:setHeavyMasses W and Alpgen:setHeavyMasses H masses provided by ALPGEN are set in the PYTHIA Alpgen:setHeavyMasses particle database."},{"name":"Alpgen:setLightMasses","link":"AlpgenEventInterface.html#anchor2","text":"Alpgen:setLightMasses When switched on, Alpgen:setLightMasses c and Alpgen:setLightMasses b quark masses provided by ALPGEN are set in the PYTHIA Alpgen:setLightMasses particle database. Since ALPGEN may set these two masses to vanish, the parton shower programs have been provided with some protection, but other parts of the code may not be as fortunate. You should therefore only switch on this option if you know what you are doing."},{"name":"Alpgen:setMLM","link":"AlpgenEventInterface.html#anchor4","text":"Alpgen:setMLM When switched on, the merging parameters (see below) are set according to the ALPGEN hard process cuts: Alpgen:setMLM Alpgen:setMLM Alpgen:setMLM JetMatching:eTjetMin = min(ptjmin + 5., 1.2 * ptjmin) , Alpgen:setMLM Alpgen:setMLM JetMatching:coneRadius = drjmin , Alpgen:setMLM Alpgen:setMLM JetMatching:etaJetMax = etajmax. where the Alpgen:setMLM ptjmin , Alpgen:setMLM drjmin and Alpgen:setMLM etajmax are the incoming ALPGEN parameters. Note that any existing values of these parameters are overwritten."},{"name":"Alpgen:setNjet","link":"AlpgenEventInterface.html#anchor5","text":"Alpgen:setNjet When switched on, the Alpgen:setNjet JetMatching:nJet parameter (see below) is set to the incoming Alpgen:setNjet njet ALPGEN parameter. Note that any existing value of this parameter is overwritten."},{"name":"Angantyr","link":"HeavyIons.html#anchor9","text":"Angantyr Angantyr - the default heavy ion model"},{"name":"Angantyr:CollisionModel","link":"HeavyIons.html#anchor17","text":"Angantyr:CollisionModel The Angantyr model has a couple of option for the SubCollisionModel Angantyr:CollisionModel A simplified model with fixed nucleon radii. Angantyr:CollisionModel The default model with fluctuating radii and cross sections. Angantyr:CollisionModel Fluctuating radii and cross sections but different treatment of opacity. Angantyr:CollisionModel Black disks with no fluctuations, ie. no diffraction."},{"name":"Angantyr:GlauberOnly","link":"HeavyIons.html#anchor18","text":"Angantyr:GlauberOnly If switched on, the event generation will stop after SubCollisions has been determined, allowing the user to read out the nucleon configuration only."},{"name":"Angantyr:impactFudge","link":"HeavyIons.html#anchor21","text":"Angantyr:impactFudge Multiplicative factor used to compensate for the fact that the Angantyr:impactFudge SubColllisionModel in Angantyr may have a different impact parameter profile than what is assumed in the MPI overlap calculation in Pythia."},{"name":"Angantyr:impactMode","link":"HeavyIons.html#anchor20","text":"Angantyr:impactMode Determines how to bias non-diffractive minimum-bias sub-collisions in pythia to be appropriately central. Angantyr:impactMode If we have N pirmary sub-collisions and Na secondary sub-collisions, generate N+Na non-diffractive events and pick the N most central. Angantyr:impactMode Use UserHooks to force Pythia to produce events with a particular impact parameter for the N primary sub collisions according to the generated impact parameter in the SubCollisionModel. Angantyr:impactMode As for option Angantyr:impactMode 1 but also the secondary absorptive sub-collisions have their impact parameter set."},{"name":"Angantyr:SASDmode","link":"HeavyIons.html#anchor19","text":"Angantyr:SASDmode Determines how to generate single-diffraction events as secondary absorptive (SASD) sub-collisions. Angantyr:SASDmode Standard singel-diffraction events as speicfied by Angantyr:SASDmode HIDiffraction settings above. Angantyr:SASDmode Always use Angantyr:SASDmode HIPDF:PomSet = 11 and use the same initial Angantyr:SASDmode HIMultipartonInteractions:pT0Ref as for non-diffractive events for the total nucleon-nucleon collision energy, independent of the mass of the diffractive system. Angantyr:SASDmode (Experimental) As for option Angantyr:SASDmode 1 but also rescale the pomeron proton non-diffractive cross section to match the pp non-diffractive one. Angantyr:SASDmode (Experimental) As for option Angantyr:SASDmode 1 but use the full  nucleon-nucleon cross section for the non-diffractive nucleon-Pomeron in the  multiple interaction machinery. Also rescale the Pomeron PDF with the log of  the ratio of maximum and minimum Pomeron-nucleon collision energy. Angantyr:SASDmode As for option Angantyr:SASDmode 3 but no rescaling of the Pomeron  PDF."},{"name":"Angantyr:SDRecoil","link":"HeavyIons.html#anchor23","text":"Angantyr:SDRecoil Determines which particles in a primary sub-collision will take the recoil when adding single diffractive sub-collisions to other sub-collisions. The choice may be overridded by a user-defined Angantyr:SDRecoil HIUserHooks::findRecoilers function. Angantyr:SDRecoil Only elastically scattered nucleons and nucleon remnants will take recoil. Angantyr:SDRecoil All particles outside the added diffractive system's rapidity range are considered."},{"name":"Angantyr:SDTest","link":"HeavyIons.html#anchor24","text":"Angantyr:SDTest Used in conjunction with Angantyr:SDTest HeavyIon:mode = 2 and proton beams to generate single diffractive events that would be used as secondary non-diffractive scatterings in the Angantyr heavy ion model for the given nucleon energies. Used for tuning special Angantyr:SDTest HI -prefixed parameters of the secondary absorptive sub-collisions."},{"name":"Angantyr:SDTestB","link":"HeavyIons.html#anchor25","text":"Angantyr:SDTestB In conjunction with Angantyr:SDTestB Angantyr:SDTest = on and Angantyr:SDTestB Angantyr:impactMode = 2 only pick diffractive events with a particular impact parameter (as defined by the scaled value given in Angantyr:SDTestB Info::bMPI() ). If negative, the standard impact parameter distribution is used."},{"name":"Angantyr:SDTries","link":"HeavyIons.html#anchor22","text":"Angantyr:SDTries When adding single diffractive sub-collisions to other sub-collisions, there might not be enough energy for the diffractive mass. One option here is to  say that the diffractive sub-event simply fails, but setting this larger than unity allows for regenerating the single diffractive sub-event a number of times to see if a small enough diffractive system is produced."},{"name":"BeamRemnants:allowBeamJunction","link":"BeamRemnants.html#anchor21","text":"BeamRemnants:allowBeamJunction This parameter is only relevant if the new Beam remnant model is used. This parameter tells whether to allow the formation of junction structures in the colour configuration of the scattered partons."},{"name":"BeamRemnants:allowJunction","link":"BeamRemnants.html#anchor19","text":"BeamRemnants:allowJunction The BeamRemnants:allowJunction off option is intended for debug purposes only, as follows. When more than one valence quark is kicked out of a baryon beam, as part of the multiparton interactions scenario, the subsequent hadronization is described in terms of a junction string topology. This description involves a number of technical complications that may make the program more unstable. As an alternative, by switching this option off, junction configurations are rejected (which gives an error message that the remnant flavour setup failed), and the multiparton interactions and showers are redone until a junction-free topology is found."},{"name":"BeamRemnants:beamJunction","link":"BeamRemnants.html#anchor20","text":"BeamRemnants:beamJunction This parameter is only relevant if the new colour reconnection scheme is used. (see BeamRemnants:beamJunction colour reconnection ) This parameter tells whether to form a junction or a di-quark if more than two valence quarks are found in the beam remnants. If off a di-quark is formed and if on a junction will be formed."},{"name":"BeamRemnants:companionPower","link":"BeamRemnants.html#anchor12","text":"BeamRemnants:companionPower When a sea quark has been found, a companion antisea quark ought to be nearby in BeamRemnants:companionPower x. The shape of this distribution can be derived from the gluon mother distribution convoluted with the BeamRemnants:companionPower g &rarr; q qbar splitting kernel. In practice, simple solutions are only feasible if the gluon shape is assumed to be of the form BeamRemnants:companionPower g(x) ~ (1 - x)^p / x , where BeamRemnants:companionPower p is an integer power, the parameter above. Allowed values correspond to the cases programmed. BeamRemnants:companionPower Since the whole framework is approximate anyway, this should be good enough. Note that companions typically are found at small BeamRemnants:companionPower Q^2 , if at all, so the form is supposed to represent BeamRemnants:companionPower g(x) at small BeamRemnants:companionPower Q^2 scales, close to the lower cutoff for multiparton interactions."},{"name":"BeamRemnants:gluonPower","link":"BeamRemnants.html#anchor17","text":"BeamRemnants:gluonPower The abovementioned power for gluons."},{"name":"BeamRemnants:halfMassForKT","link":"BeamRemnants.html#anchor5","text":"BeamRemnants:halfMassForKT The scale BeamRemnants:halfMassForKT m_half in the equation above, defining the half-way point between low-mass and high-mass subsystems. (Kinematics construction can easily fail if a system is assigned a primordial BeamRemnants:halfMassForKT kT value higher than its mass, so the mass-dampening is intended to reduce some troubles later on.)"},{"name":"BeamRemnants:halfScaleForKT","link":"BeamRemnants.html#anchor4","text":"BeamRemnants:halfScaleForKT The scale BeamRemnants:halfScaleForKT Q_half in the equation above, defining the half-way point between hard and soft interactions."},{"name":"BeamRemnants:maxValQuark","link":"BeamRemnants.html#anchor11","text":"BeamRemnants:maxValQuark The maximum valence quark kind allowed in acceptable incoming beams, for which multiparton interactions are simulated. Default is that hadrons may contain BeamRemnants:maxValQuark u , BeamRemnants:maxValQuark d and BeamRemnants:maxValQuark s quarks, but not BeamRemnants:maxValQuark c and BeamRemnants:maxValQuark b ones, since sensible kinematics has not really been worked out for the latter."},{"name":"BeamRemnants:primordialKT","link":"BeamRemnants.html#anchor1","text":"BeamRemnants:primordialKT Allow or not selection of primordial BeamRemnants:primordialKT kT according to the parameter values below."},{"name":"BeamRemnants:primordialKThard","link":"BeamRemnants.html#anchor3","text":"BeamRemnants:primordialKThard The width BeamRemnants:primordialKThard sigma_hard in the above equation, assigned as a primordial BeamRemnants:primordialKThard kT to initiators in the hard-interaction limit."},{"name":"BeamRemnants:primordialKTremnant","link":"BeamRemnants.html#anchor7","text":"BeamRemnants:primordialKTremnant The width BeamRemnants:primordialKTremnant sigma_remn , assigned as a primordial BeamRemnants:primordialKTremnant kT to beam-remnant partons."},{"name":"BeamRemnants:primordialKTsoft","link":"BeamRemnants.html#anchor2","text":"BeamRemnants:primordialKTsoft The width BeamRemnants:primordialKTsoft sigma_soft in the above equation, assigned as a primordial BeamRemnants:primordialKTsoft kT to initiators in the soft-interaction limit."},{"name":"BeamRemnants:reducedKTatHighY","link":"BeamRemnants.html#anchor6","text":"BeamRemnants:reducedKTatHighY For a system of mass BeamRemnants:reducedKTatHighY m and energy BeamRemnants:reducedKTatHighY E the dampening factor BeamRemnants:reducedKTatHighY y_damp above is defined as BeamRemnants:reducedKTatHighY y_damp = pow( E/m, r_red) , where BeamRemnants:reducedKTatHighY r_red is the current parameter. The effect is to reduce the primordial BeamRemnants:reducedKTatHighY kT of low-mass systems extra much if they are at large rapidities (recall that BeamRemnants:reducedKTatHighY E/m = cosh(y) before BeamRemnants:reducedKTatHighY kT is added). The reason for this dampening is purely technical, and for reasonable values should not have dramatic consequences overall."},{"name":"BeamRemnants:remnantMode","link":"BeamRemnants.html#anchor9","text":"BeamRemnants:remnantMode Switch to choose between the two different colour models for the beam remnant. BeamRemnants:remnantMode The old beam remnant model. BeamRemnants:remnantMode The new beam remnant model."},{"name":"BeamRemnants:rescatterRestoreY","link":"BeamRemnants.html#anchor8","text":"BeamRemnants:rescatterRestoreY Is only relevant when BeamRemnants:rescatterRestoreY rescattering is switched on in the multiparton interactions scenario. For a normal interaction the rapidity and mass of a system is preserved when primordial BeamRemnants:rescatterRestoreY kT is introduced, by appropriate modification of the incoming parton momenta. Kinematics construction is more complicated for a rescattering, and two options are offered. Differences between these can be used to explore systematic uncertainties in the rescattering framework. BeamRemnants:rescatterRestoreY The default behaviour is to keep the incoming rescattered parton as is, but to modify the unrescattered incoming parton so as to preserve the invariant mass of the system. Thereby the rapidity of the rescattering is modified. BeamRemnants:rescatterRestoreY The alternative is to retain the rapidity (and mass) of the rescattered system when primordial BeamRemnants:rescatterRestoreY kT is introduced. This is made at the expense of a modified longitudinal momentum of the incoming rescattered parton, so that it does not agree with the momentum it ought to have had by the kinematics of the previous interaction. BeamRemnants:rescatterRestoreY For a double rescattering, when both incoming partons have already scattered, there is no obvious way to retain the invariant mass of the system in the first approach, so the second is always used."},{"name":"BeamRemnants:saturation","link":"BeamRemnants.html#anchor10","text":"BeamRemnants:saturation Controls the suppresion due to saturation in the new model. The exact formula used is BeamRemnants:saturation exp(-M / k) , where M is the multiplet size and k is this parameter. Thus a small number will result in a large saturation."},{"name":"BeamRemnants:unresolvedHadron","link":"BeamRemnants.html#anchor22","text":"BeamRemnants:unresolvedHadron Switch to to force either or both of the beam remnants to collapse to a single hadron, namely the original incoming one. Must only be used when this is physically meaningful, e.g. when a photon can be viewed as emitted from a proton that does not break up in the process. BeamRemnants:unresolvedHadron Both hadronic beams are resolved. BeamRemnants:unresolvedHadron Beam A is unresolved, beam B resolved. BeamRemnants:unresolvedHadron Beam A is resolved, beam B unresolved. BeamRemnants:unresolvedHadron Both hadronic beams are unresolved."},{"name":"BeamRemnants:valenceDiqEnhance","link":"BeamRemnants.html#anchor16","text":"BeamRemnants:valenceDiqEnhance Enhancement factor for valence diquarks in baryons, relative to the simple sum of the two constituent quarks."},{"name":"BeamRemnants:valencePowerDinP","link":"BeamRemnants.html#anchor15","text":"BeamRemnants:valencePowerDinP The abovementioned power for valence BeamRemnants:valencePowerDinP d quarks in protons."},{"name":"BeamRemnants:valencePowerMeson","link":"BeamRemnants.html#anchor13","text":"BeamRemnants:valencePowerMeson The abovementioned power for valence quarks in mesons."},{"name":"BeamRemnants:valencePowerUinP","link":"BeamRemnants.html#anchor14","text":"BeamRemnants:valencePowerUinP The abovementioned power for valence BeamRemnants:valencePowerUinP u quarks in protons."},{"name":"BeamRemnants:xGluonCutoff","link":"BeamRemnants.html#anchor18","text":"BeamRemnants:xGluonCutoff The gluon PDF is approximated with BeamRemnants:xGluonCutoff g(x) ~ (1 - x)^p / x , which integrates to infinity when integrated from 0 to 1. This cut-off is introduced as a minimum to avoid the problems with infinities."},{"name":"Beams:allowMomentumSpread","link":"BeamParameters.html#anchor26","text":"Beams:allowMomentumSpread Allow the beam momenta to be smeared around their initialization nominal values."},{"name":"Beams:allowVariableEnergy","link":"BeamParameters.html#anchor20","text":"Beams:allowVariableEnergy Master switch to allow collision energies below the initialization one, as described above."},{"name":"Beams:allowVertexSpread","link":"BeamParameters.html#anchor35","text":"Beams:allowVertexSpread Allow the interaction vertex of the two colliding beams to be smeared. If off, then the vertex is set to be the origin."},{"name":"Beams:eA","link":"BeamParameters.html#anchor5","text":"Beams:eA The energy of the first incoming particle, moving in the Beams:eA +z direction, to be set if Beams:eA Beams:frameType = 2. If the particle energy is smaller than its mass it is assumed to be at rest."},{"name":"Beams:eB","link":"BeamParameters.html#anchor6","text":"Beams:eB The energy of the second incoming particle, moving in the Beams:eB -z direction, to be set if Beams:eB Beams:frameType = 2. If the particle energy is smaller than its mass it is assumed to be at rest."},{"name":"Beams:eCM","link":"BeamParameters.html#anchor4","text":"Beams:eCM Collision CM energy, to be set if Beams:eCM Beams:frameType = 1."},{"name":"Beams:eMinPert","link":"BeamParameters.html#anchor21","text":"Beams:eMinPert The lowest CM energy that collisions are allowed to have. The highest is set by the full energy at initialization, as calculated in the respective options above. If you do not want to generate events with a higher collision energy than this you can save some initialization time by raising this number accordingly, so that fewer grid energies need to be used. You should not lower the value below the default one, however, since the perturbative MPI machinery cannot be made to work at lower energies. If you do want to generate events with lower energies, it is possible in a nonperturbative framework, see next."},{"name":"Beams:eWidthPert","link":"BeamParameters.html#anchor22","text":"Beams:eWidthPert A simpler low-mass description can be used for energies below the threshold energy Beams:eWidthPert e_min = Beams:eWidthPert eMinPert above, with only longitudinally stretched strings. A gradual switch-over between the simple low-energy and perturbative high-energy regimes is then natural. The probability for the latter picture is parametrized as Beams:eWidthPert P_pert = 1 - exp( (e_CM - e_min) / e_width ) which vanishes for the CM energy Beams:eWidthPert e_CM < e_min , and is Beams:eWidthPert 1 - 1/e = 0.632 for Beams:eWidthPert e_CM = e_min + e_width. The current parameter is this Beams:eWidthPert e_width."},{"name":"Beams:frameType","link":"BeamParameters.html#anchor3","text":"Beams:frameType Choice of frame for the two colliding particles. For options 1 - 3 the beam identities are specified above, while they are obtained by the Les Houches information for options 4 and 5. Beams:frameType the beams are colliding in their CM frame, and therefore only the CM energy needs to be provided, see Beams:frameType Beams:eCM below. Beams:frameType the beams are back-to-back, but with different energies, see Beams:frameType Beams:eA and Beams:frameType Beams:eB below. This option could also be used for fixed-target configurations. Beams:frameType the beams are not back-to-back, and therefore the three-momentum of each incoming particle needs to be specified, see Beams:frameType Beams:pxA through Beams:frameType Beams:pzB below. Beams:frameType the beam and event information is stored in a Beams:frameType Les Houches Event File , see Beams:frameType Beams:LHEF below. Beams:frameType the beam and event information is obtained by a pointer to an Beams:frameType Beams:frameType LHAup class instance."},{"name":"Beams:idA","link":"BeamParameters.html#anchor1","text":"Beams:idA The PDG Beams:idA id code for the first incoming particle. Allowed codes include Beams:idA Beams:idA 2212 = p , Beams:idA -2212 = pbar , Beams:idA Beams:idA 2112 = n , Beams:idA -2112 = nbar , Beams:idA Beams:idA 211 = pi^+ , Beams:idA -211 = pi^- , Beams:idA 111 = pi^0 , Beams:idA Beams:idA 990 = Pomeron (used in diffractive machinery; here mainly for debug purposes), Beams:idA Beams:idA 22 = gamma (for Beams:idA gamma-gamma and Beams:idA gamma-hadron interactions, more info Beams:idA here ), Beams:idA Beams:idA 11 = e^- , Beams:idA -11 = e^+ , Beams:idA Beams:idA 13 = mu^- , Beams:idA -13 = mu^+ , Beams:idA and a few more leptons/neutrinos in a few combinations. Beams:idA Recently Beams:idA heavy-ion collisions have been implemented in PYTHIA. Therefore a handful of nuclei have been added as allowed incoming beams, using PDG codes of the format Beams:idA 100ZZZAAAI : 1000020040 = Beams:idA 4 He , 1000030060 = Beams:idA 6 Li, 1000060120 = Beams:idA 12 C, 1000080160 = Beams:idA 16 O, 1000290630 = Beams:idA 63 Cu, 1000791970 = Beams:idA 197 Au, and 1000822080 = Beams:idA 208 Pb. More can be added using the function Beams:idA ParticleData::addParticle."},{"name":"Beams:idB","link":"BeamParameters.html#anchor2","text":"Beams:idB The PDG Beams:idB id code for the second incoming particle."},{"name":"Beams:LHEF","link":"BeamParameters.html#anchor13","text":"Beams:LHEF The name of a Les Houches Event File, to be set if Beams:LHEF Beams:frameType = 4."},{"name":"Beams:LHEFheader","link":"BeamParameters.html#anchor14","text":"Beams:LHEFheader As some information in a Les Houches Event File init block is only known at the end of generation, some programs choose to output this as a separate file. If Beams:LHEFheader Beams:LHEFheader is given, information up till the end of the init block is read from this file, with the events themselves read as usual from the file given in Beams:LHEFheader Beams:LHEF."},{"name":"Beams:maxDevA","link":"BeamParameters.html#anchor30","text":"Beams:maxDevA The triply Gaussian distribution Beams:maxDevA (p_x, p_y, p_z) is restricted to a maximal total deviation from the nominal values Beams:maxDevA (p_x0, p_y0, p_z0) for the first incoming particle, like Beams:maxDevA (p_x - p_x0)^2/sigma_px^2 + (p_y - p_y0)^2/sigma_py^2 + (p_z - p_z0)^2/sigma_pz^2 < maxDev^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick Beams:maxDevA (p_x, p_y, p_z) .)"},{"name":"Beams:maxDevB","link":"BeamParameters.html#anchor34","text":"Beams:maxDevB The triply Gaussian distribution Beams:maxDevB (p_x, p_y, p_z) is restricted to a maximal total deviation from the nominal values Beams:maxDevB (p_x0, p_y0, p_z0) , for the second incoming particle, like Beams:maxDevB (p_x - p_x0)^2/sigma_px^2 + (p_y - p_y0)^2/sigma_py^2 + (p_z - p_z0)^2/sigma_pz^2 < maxDev^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick Beams:maxDevB (p_x, p_y, p_z) .)"},{"name":"Beams:maxDevTime","link":"BeamParameters.html#anchor41","text":"Beams:maxDevTime The collision time is restricted to be in the range Beams:maxDevTime |t| < sigma_t * maxDevTime."},{"name":"Beams:maxDevVertex","link":"BeamParameters.html#anchor39","text":"Beams:maxDevVertex The triply Gaussian distribution of interaction vertex position Beams:maxDevVertex (x, y, z) is restricted to a maximal total deviation from the origin, like Beams:maxDevVertex x^2/sigma_x^2 + y^2/sigma_y^2 + z^2/sigma_z^2 < maxDevVertex^2 (Note the absence of a factor 2 in the denominator, unlike the Gaussians used to pick Beams:maxDevVertex (x, y, z) .)"},{"name":"Beams:newLHEFsameInit","link":"BeamParameters.html#anchor15","text":"Beams:newLHEFsameInit Allow to begin reading events from a new LHEF or or a new Beams:newLHEFsameInit LHAup instance without a completely new initialization. Only useful when Beams:newLHEFsameInit Beams:frameType = 4 or 5."},{"name":"Beams:nSkipLHEFatInit","link":"BeamParameters.html#anchor17","text":"Beams:nSkipLHEFatInit Skip the first Beams:nSkipLHEFatInit nSkip events of the input stream (cf. the Beams:nSkipLHEFatInit LHAup::skipEvent(nSkip) method). Only used when Beams:nSkipLHEFatInit Beams:frameType = 4 or 5."},{"name":"Beams:offsetTime","link":"BeamParameters.html#anchor45","text":"Beams:offsetTime The time Beams:offsetTime t of the interaction vertex is centered at this value."},{"name":"Beams:offsetVertexX","link":"BeamParameters.html#anchor42","text":"Beams:offsetVertexX The Beams:offsetVertexX x location of the interaction vertex is centered at this value."},{"name":"Beams:offsetVertexY","link":"BeamParameters.html#anchor43","text":"Beams:offsetVertexY The Beams:offsetVertexY y location of the interaction vertex is centered at this value."},{"name":"Beams:offsetVertexZ","link":"BeamParameters.html#anchor44","text":"Beams:offsetVertexZ The Beams:offsetVertexZ z location of the interaction vertex is centered at this value."},{"name":"Beams:pxA","link":"BeamParameters.html#anchor7","text":"Beams:pxA The Beams:pxA p_x component of the first incoming particle, to be set if Beams:pxA Beams:frameType = 3."},{"name":"Beams:pxB","link":"BeamParameters.html#anchor10","text":"Beams:pxB The Beams:pxB p_x component of the second incoming particle, to be set if Beams:pxB Beams:frameType = 3."},{"name":"Beams:pyA","link":"BeamParameters.html#anchor8","text":"Beams:pyA The Beams:pyA p_y component of the first incoming particle, to be set if Beams:pyA Beams:frameType = 3."},{"name":"Beams:pyB","link":"BeamParameters.html#anchor11","text":"Beams:pyB The Beams:pyB p_y component of the second incoming particle, to be set if Beams:pyB Beams:frameType = 3."},{"name":"Beams:pzA","link":"BeamParameters.html#anchor9","text":"Beams:pzA The Beams:pzA p_z component of the first incoming particle, to be set if Beams:pzA Beams:frameType = 3."},{"name":"Beams:pzB","link":"BeamParameters.html#anchor12","text":"Beams:pzB The Beams:pzB p_z component of the second incoming particle, to be set if Beams:pzB Beams:frameType = 3."},{"name":"Beams:readLHEFheaders","link":"BeamParameters.html#anchor16","text":"Beams:readLHEFheaders Read in LHEF header blocks and store them in the Beams:readLHEFheaders Info class. See also Beams:readLHEFheaders LHAupLHEF for more information."},{"name":"Beams:setProductionScalesFromLHEF","link":"BeamParameters.html#anchor19","text":"Beams:setProductionScalesFromLHEF If enabled, production scales for all particles in an input Les Houches event will be set by using auxiliary information provided in the input event. Depending on which LHEF version is used, different information will be read. For LHEF 1.0, scale information can be transferred by including a line starting with the hashtag (#) character at the end of the event. The hashtag should be followed by the sequential scale values of the particles with status 1. For LHEF 3.0, the standardised Beams:setProductionScalesFromLHEF <scales> tag is used instead. In this case, please ensure that production scale of the final state particle with position Beams:setProductionScalesFromLHEF i in the input event will be transferred as the value of a scales tag attribute which contains Beams:setProductionScalesFromLHEF i at the end of the attribute name, separated from the rest of the name by an underscore (_). An example Beams:setProductionScalesFromLHEF <scales> tag would be Beams:setProductionScalesFromLHEF <scales muf='100' pt_start_3='100' pt_start_4='50'> </scales>. This could be used to set the production scales of particles three and four to 100 GeV and 50 GeV, respectively, provided that these particles have status 1."},{"name":"Beams:sigmaPxA","link":"BeamParameters.html#anchor27","text":"Beams:sigmaPxA The width of a Gaussian distribution of the Beams:sigmaPxA p_x spread of the first incoming particle."},{"name":"Beams:sigmaPxB","link":"BeamParameters.html#anchor31","text":"Beams:sigmaPxB The width of a Gaussian distribution of the Beams:sigmaPxB p_x spread of the second incoming particle."},{"name":"Beams:sigmaPyA","link":"BeamParameters.html#anchor28","text":"Beams:sigmaPyA The width of a Gaussian distribution of the Beams:sigmaPyA p_y spread of the first incoming particle."},{"name":"Beams:sigmaPyB","link":"BeamParameters.html#anchor32","text":"Beams:sigmaPyB The width of a Gaussian distribution of the Beams:sigmaPyB p_y spread of the second incoming particle."},{"name":"Beams:sigmaPzA","link":"BeamParameters.html#anchor29","text":"Beams:sigmaPzA The width of a Gaussian distribution of the Beams:sigmaPzA p_z spread of the first incoming particle."},{"name":"Beams:sigmaPzB","link":"BeamParameters.html#anchor33","text":"Beams:sigmaPzB The width of a Gaussian distribution of the Beams:sigmaPzB p_z spread of the second incoming particle."},{"name":"Beams:sigmaTime","link":"BeamParameters.html#anchor40","text":"Beams:sigmaTime The width of a Gaussian distribution of the collision time (in units of mm/c). Note that, if the above space parametrization is viewed as the effect of two incoming beams along the Beams:sigmaTime +-z axis, with each beam having a Gaussian spread, then the spread of the time would also become a Gaussian with the same width as the Beams:sigmaTime z one (times the velocity of the beams, which we expect is close to unity). For flexibility we have not enforced any such relation, however."},{"name":"Beams:sigmaVertexX","link":"BeamParameters.html#anchor36","text":"Beams:sigmaVertexX The width of a Gaussian distribution of the Beams:sigmaVertexX x location of the interaction vertex."},{"name":"Beams:sigmaVertexY","link":"BeamParameters.html#anchor37","text":"Beams:sigmaVertexY The width of a Gaussian distribution of the Beams:sigmaVertexY y location of the interaction vertex."},{"name":"Beams:sigmaVertexZ","link":"BeamParameters.html#anchor38","text":"Beams:sigmaVertexZ The width of a Gaussian distribution of the Beams:sigmaVertexZ z location of the interaction vertex."},{"name":"Beams:strictLHEFscale","link":"BeamParameters.html#anchor18","text":"Beams:strictLHEFscale Always use the Beams:strictLHEFscale SCALUP value read from LHEF as production scale for particles, also including particles coming from resonance decays. By default, the production scale of resonance decay products (W-, Z-, H-bosons, top quarks) will be set to Beams:strictLHEFscale M/2 , where Beams:strictLHEFscale M is the mass of the resonance."},{"name":"BoseEinstein:Eta","link":"BoseEinsteinEffects.html#anchor3","text":"BoseEinstein:Eta Include effects or not for identical BoseEinstein:Eta eta and BoseEinstein:Eta eta'."},{"name":"BoseEinstein:Kaon","link":"BoseEinsteinEffects.html#anchor2","text":"BoseEinstein:Kaon Include effects or not for identical BoseEinstein:Kaon K^+ , BoseEinstein:Kaon K^- , BoseEinstein:Kaon K_S^0 and BoseEinstein:Kaon K_L^0."},{"name":"BoseEinstein:lambda","link":"BoseEinsteinEffects.html#anchor4","text":"BoseEinstein:lambda The strength parameter for Bose-Einstein effects. On physical grounds it should not be above unity, but imperfections in the formalism used may require that nevertheless."},{"name":"BoseEinstein:Pion","link":"BoseEinsteinEffects.html#anchor1","text":"BoseEinstein:Pion Include effects or not for identical BoseEinstein:Pion pi^+ , BoseEinstein:Pion pi^- and BoseEinstein:Pion pi^0."},{"name":"BoseEinstein:QRef","link":"BoseEinsteinEffects.html#anchor5","text":"BoseEinstein:QRef The size parameter of the region in BoseEinstein:QRef Q space over which Bose-Einstein effects are significant.  Can be thought of as the inverse of an effective distance in normal space, BoseEinstein:QRef R = hbar / QRef , with BoseEinstein:QRef R as used in the above equation. That is, BoseEinstein:QRef f_2(Q) = (1 + lambda * exp(-(Q/QRef)^2)) * (...)."},{"name":"BoseEinstein:widthSep","link":"BoseEinsteinEffects.html#anchor6","text":"BoseEinstein:widthSep Particle species with a width above this value (in GeV) are assumed to be so short-lived that they decay before Bose-Einstein effects are considered, while otherwise they do not. In the former case the decay products thus can obtain shifted momenta, in the latter not. The default has been picked such that both BoseEinstein:widthSep rho and BoseEinstein:widthSep K^* decay products would be modified."},{"name":"Bottomonium:all","link":"OniaProcesses.html#anchor8","text":"Bottomonium:all Common switch for the group of bottomonium production, e.g. Bottomonium:all Upsilon and Bottomonium:all chi_b."},{"name":"Bottomonium:gg2bbbar(3DJ)[3DJ(1)]g","link":"OniaProcesses.html#anchor75","text":"Bottomonium:gg2bbbar(3DJ)[3DJ(1)]g Colour-singlet production of Bottomonium:gg2bbbar(3DJ)[3DJ(1)]g 3PJ bottomonium states via Bottomonium:gg2bbbar(3DJ)[3DJ(1)]g g g &rarr; bbbar[3DJ(1)] g. Code 517."},{"name":"Bottomonium:gg2bbbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor76","text":"Bottomonium:gg2bbbar(3DJ)[3PJ(8)]g Colour-octet production of Bottomonium:gg2bbbar(3DJ)[3PJ(8)]g 3DJ bottomonium states via Bottomonium:gg2bbbar(3DJ)[3PJ(8)]g g g &rarr; bbbar[3PJ(8)] g. Code 518."},{"name":"Bottomonium:gg2bbbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor66","text":"Bottomonium:gg2bbbar(3PJ)[3PJ(1)]g Colour-singlet production of Bottomonium:gg2bbbar(3PJ)[3PJ(1)]g 3PJ bottomonium states via Bottomonium:gg2bbbar(3PJ)[3PJ(1)]g g g &rarr; bbbar[3PJ(1)] g. Code 511."},{"name":"Bottomonium:gg2bbbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor69","text":"Bottomonium:gg2bbbar(3PJ)[3S1(8)]g Colour-octet production of Bottomonium:gg2bbbar(3PJ)[3S1(8)]g 3PJ bottomonium states via Bottomonium:gg2bbbar(3PJ)[3S1(8)]g g g &rarr; bbbar[3S1(8)] g. Code 514."},{"name":"Bottomonium:gg2bbbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor57","text":"Bottomonium:gg2bbbar(3S1)[1S0(8)]g Colour-octet production of Bottomonium:gg2bbbar(3S1)[1S0(8)]g 3S1 bottomonium states via Bottomonium:gg2bbbar(3S1)[1S0(8)]g g g &rarr; bbbar[1S0(8)] g. Code 505."},{"name":"Bottomonium:gg2bbbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor60","text":"Bottomonium:gg2bbbar(3S1)[3PJ(8)]g Colour-octet production of Bottomonium:gg2bbbar(3S1)[3PJ(8)]g 3S1 bottomonium states via Bottomonium:gg2bbbar(3S1)[3PJ(8)]g g g &rarr; bbbar[3PJ(8)] g. Code 508."},{"name":"Bottomonium:gg2bbbar(3S1)[3S1(1)]g","link":"OniaProcesses.html#anchor52","text":"Bottomonium:gg2bbbar(3S1)[3S1(1)]g Colour-singlet production of Bottomonium:gg2bbbar(3S1)[3S1(1)]g 3S1 bottomonium states via Bottomonium:gg2bbbar(3S1)[3S1(1)]g g g &rarr; bbbar[3S1(1)] g. Code 501."},{"name":"Bottomonium:gg2bbbar(3S1)[3S1(1)]gm","link":"OniaProcesses.html#anchor53","text":"Bottomonium:gg2bbbar(3S1)[3S1(1)]gm Colour-singlet production of Bottomonium:gg2bbbar(3S1)[3S1(1)]gm 3S1 bottomonium states via Bottomonium:gg2bbbar(3S1)[3S1(1)]gm g g &rarr; ccbar[3S1(1)] g with a hard Bottomonium:gg2bbbar(3S1)[3S1(1)]gm gamma. Code 551."},{"name":"Bottomonium:gg2bbbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor54","text":"Bottomonium:gg2bbbar(3S1)[3S1(8)]g Colour-octet production of Bottomonium:gg2bbbar(3S1)[3S1(8)]g 3S1 bottomonium states via Bottomonium:gg2bbbar(3S1)[3S1(8)]g g g &rarr; bbbar[3S1(8)] g. Code 502."},{"name":"Bottomonium:gg2doublebbbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor83","text":"Bottomonium:gg2doublebbbar(3S1)[3S1(1)] Colour-singlet production of Bottomonium:gg2doublebbbar(3S1)[3S1(1)] 3S1 bottomonium state pairs via Bottomonium:gg2doublebbbar(3S1)[3S1(1)] g g &rarr; bbbar[3S1(1)] bbbar[3S1(1)]. Code 521."},{"name":"Bottomonium:O(3DJ)[3D1(1)]","link":"OniaProcesses.html#anchor73","text":"Bottomonium:O(3DJ)[3D1(1)] The color-singlet long-distance matrix elements Bottomonium:O(3DJ)[3D1(1)] <O[3D1(1)]> for the Bottomonium:O(3DJ)[3D1(1)] 3PJ bottomonium states. For a Bottomonium:O(3DJ)[3D1(1)] 3DJ bottomonium state where Bottomonium:O(3DJ)[3D1(1)] J is not Bottomonium:O(3DJ)[3D1(1)] 1 the long distance matrix element Bottomonium:O(3DJ)[3D1(1)] <O[3DJ(1)]> is calculated by Bottomonium:O(3DJ)[3D1(1)] (2J+1)<O[3D1(1)]/3> using leading order spin symmetry relations."},{"name":"Bottomonium:O(3DJ)[3P0(8)]","link":"OniaProcesses.html#anchor74","text":"Bottomonium:O(3DJ)[3P0(8)] The colour-octet long-distance matrix elements Bottomonium:O(3DJ)[3P0(8)] <O[3P0(8)]>/m_Q^2 for the 3DJ bottomonium states. The remaining Bottomonium:O(3DJ)[3P0(8)] <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Bottomonium:O(3PJ)[3P0(1)]","link":"OniaProcesses.html#anchor64","text":"Bottomonium:O(3PJ)[3P0(1)] The color-singlet long-distance matrix elements Bottomonium:O(3PJ)[3P0(1)] <O[3P0(1)]>/m_Q^2 for the Bottomonium:O(3PJ)[3P0(1)] 3PJ bottomonium states. The remaining Bottomonium:O(3PJ)[3P0(1)] <O[3PJ(1)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Bottomonium:O(3PJ)[3S1(8)]","link":"OniaProcesses.html#anchor65","text":"Bottomonium:O(3PJ)[3S1(8)] The color-singlet long-distance matrix elements Bottomonium:O(3PJ)[3S1(8)] <O[3S1(8)]> for the Bottomonium:O(3PJ)[3S1(8)] 3PJ bottomonium states."},{"name":"Bottomonium:O(3S1)[1S0(8)]","link":"OniaProcesses.html#anchor50","text":"Bottomonium:O(3S1)[1S0(8)] The colour-octet long-distance matrix elements Bottomonium:O(3S1)[1S0(8)] <O[1S0(8)]> for the Bottomonium:O(3S1)[1S0(8)] 3S1 bottomonium states."},{"name":"Bottomonium:O(3S1)[3P0(8)]","link":"OniaProcesses.html#anchor51","text":"Bottomonium:O(3S1)[3P0(8)] The colour-octet long-distance matrix elements Bottomonium:O(3S1)[3P0(8)] <O[3P0(8)]>/m_Q^2 for the Bottomonium:O(3S1)[3P0(8)] 3S1 bottomonium states. The remaining Bottomonium:O(3S1)[3P0(8)] <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Bottomonium:O(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor48","text":"Bottomonium:O(3S1)[3S1(1)] The colour-singlet long-distance matrix elements Bottomonium:O(3S1)[3S1(1)] <O[3S1(1)]> for the Bottomonium:O(3S1)[3S1(1)] 3S1 bottomonium states."},{"name":"Bottomonium:O(3S1)[3S1(1)]1","link":"OniaProcesses.html#anchor81","text":"Bottomonium:O(3S1)[3S1(1)]1 The color-singlet long-distance matrix elements Bottomonium:O(3S1)[3S1(1)]1 <O[3S1(1)]> for the first Bottomonium:O(3S1)[3S1(1)]1 3S1 bottomonium states."},{"name":"Bottomonium:O(3S1)[3S1(1)]2","link":"OniaProcesses.html#anchor82","text":"Bottomonium:O(3S1)[3S1(1)]2 The color-singlet long-distance matrix elements Bottomonium:O(3S1)[3S1(1)]2 <O[3S1(1)]> for the second Bottomonium:O(3S1)[3S1(1)]2 3S1 bottomonium states."},{"name":"Bottomonium:O(3S1)[3S1(8)]","link":"OniaProcesses.html#anchor49","text":"Bottomonium:O(3S1)[3S1(8)] The colour-octet long-distance matrix elements Bottomonium:O(3S1)[3S1(8)] <O[3S1(8)]> for the Bottomonium:O(3S1)[3S1(8)] 3S1 bottomonium states."},{"name":"Bottomonium:qg2bbbar(3DJ)[3PJ(8)]q","link":"OniaProcesses.html#anchor77","text":"Bottomonium:qg2bbbar(3DJ)[3PJ(8)]q Colour-octet production of Bottomonium:qg2bbbar(3DJ)[3PJ(8)]q 3DJ bottomonium states via Bottomonium:qg2bbbar(3DJ)[3PJ(8)]q q g &rarr; bbbar[3PJ(8)] q. Code 519."},{"name":"Bottomonium:qg2bbbar(3PJ)[3PJ(1)]q","link":"OniaProcesses.html#anchor67","text":"Bottomonium:qg2bbbar(3PJ)[3PJ(1)]q Colour-singlet production of Bottomonium:qg2bbbar(3PJ)[3PJ(1)]q 3PJ bottomonium states via Bottomonium:qg2bbbar(3PJ)[3PJ(1)]q q g &rarr; bbbar[3PJ(1)] q. Code 512."},{"name":"Bottomonium:qg2bbbar(3PJ)[3S1(8)]q","link":"OniaProcesses.html#anchor70","text":"Bottomonium:qg2bbbar(3PJ)[3S1(8)]q Colour-octet production of Bottomonium:qg2bbbar(3PJ)[3S1(8)]q 3PJ bottomonium states via Bottomonium:qg2bbbar(3PJ)[3S1(8)]q q g &rarr; bbbar[3S1(8)] q. Code 515."},{"name":"Bottomonium:qg2bbbar(3S1)[1S0(8)]q","link":"OniaProcesses.html#anchor58","text":"Bottomonium:qg2bbbar(3S1)[1S0(8)]q Colour-octet production of Bottomonium:qg2bbbar(3S1)[1S0(8)]q 3S1 bottomonium states via Bottomonium:qg2bbbar(3S1)[1S0(8)]q q g &rarr; bbbar[1S0(8)] q. Code 506."},{"name":"Bottomonium:qg2bbbar(3S1)[3PJ(8)]q","link":"OniaProcesses.html#anchor61","text":"Bottomonium:qg2bbbar(3S1)[3PJ(8)]q Colour-octet production of Bottomonium:qg2bbbar(3S1)[3PJ(8)]q 3S1 bottomonium states via Bottomonium:qg2bbbar(3S1)[3PJ(8)]q q g &rarr; bbbar[3PJ(8)] q. Code 509."},{"name":"Bottomonium:qg2bbbar(3S1)[3S1(8)]q","link":"OniaProcesses.html#anchor55","text":"Bottomonium:qg2bbbar(3S1)[3S1(8)]q Colour-octet production of Bottomonium:qg2bbbar(3S1)[3S1(8)]q 3S1 bottomonium states via Bottomonium:qg2bbbar(3S1)[3S1(8)]q q g &rarr; bbbar[3S1(8)] q. Code 503."},{"name":"Bottomonium:qqbar2bbbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor78","text":"Bottomonium:qqbar2bbbar(3DJ)[3PJ(8)]g Colour-octet production of Bottomonium:qqbar2bbbar(3DJ)[3PJ(8)]g 3DJ bottomonium states via Bottomonium:qqbar2bbbar(3DJ)[3PJ(8)]g q qbar &rarr; bbbar[3PJ(8)] g. Code 520."},{"name":"Bottomonium:qqbar2bbbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor68","text":"Bottomonium:qqbar2bbbar(3PJ)[3PJ(1)]g Colour-singlet production of Bottomonium:qqbar2bbbar(3PJ)[3PJ(1)]g 3PJ bottomonium states via Bottomonium:qqbar2bbbar(3PJ)[3PJ(1)]g q qbar &rarr; bbbar[3PJ(1)] g. Code 513."},{"name":"Bottomonium:qqbar2bbbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor71","text":"Bottomonium:qqbar2bbbar(3PJ)[3S1(8)]g Colour-octet production of Bottomonium:qqbar2bbbar(3PJ)[3S1(8)]g 3PJ bottomonium states via Bottomonium:qqbar2bbbar(3PJ)[3S1(8)]g q qbar &rarr; bbbar[3S1(8)] g. Code 516."},{"name":"Bottomonium:qqbar2bbbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor59","text":"Bottomonium:qqbar2bbbar(3S1)[1S0(8)]g Colour-octet production of Bottomonium:qqbar2bbbar(3S1)[1S0(8)]g 3S1 bottomonium states via Bottomonium:qqbar2bbbar(3S1)[1S0(8)]g q qbar &rarr; bbbar[1S0(8)] g. Code 507."},{"name":"Bottomonium:qqbar2bbbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor62","text":"Bottomonium:qqbar2bbbar(3S1)[3PJ(8)]g Colour-octet production of Bottomonium:qqbar2bbbar(3S1)[3PJ(8)]g 3S1 bottomonium states via Bottomonium:qqbar2bbbar(3S1)[3PJ(8)]g q qbar &rarr; bbbar[3SJ(8)] g. Code 510."},{"name":"Bottomonium:qqbar2bbbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor56","text":"Bottomonium:qqbar2bbbar(3S1)[3S1(8)]g Colour-octet production of Bottomonium:qqbar2bbbar(3S1)[3S1(8)]g 3S1 bottomonium states via Bottomonium:qqbar2bbbar(3S1)[3S1(8)]g q qbar &rarr; bbbar[3S1(8)] g. Code 504."},{"name":"Bottomonium:qqbar2doublebbbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor84","text":"Bottomonium:qqbar2doublebbbar(3S1)[3S1(1)] Colour-singlet production of Bottomonium:qqbar2doublebbbar(3S1)[3S1(1)] 3S1 bottomonium state pairs via Bottomonium:qqbar2doublebbbar(3S1)[3S1(1)] q qbar &rarr; bbbar[3S1(1)] bbbar[3S1(1)]. Code 522."},{"name":"Bottomonium:states(3DJ)","link":"OniaProcesses.html#anchor72","text":"Bottomonium:states(3DJ) The Bottomonium:states(3DJ) 3DJ bottomonium states that can be produced from the following processes. Currently, no Bottomonium:states(3DJ) 3DJ states are included in the default Bottomonium:states(3DJ) ParticleData and so none are included here. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Bottomonium:states(3PJ)","link":"OniaProcesses.html#anchor63","text":"Bottomonium:states(3PJ) The Bottomonium:states(3PJ) 3PJ bottomonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Bottomonium:states(3S1)","link":"OniaProcesses.html#anchor47","text":"Bottomonium:states(3S1) The Bottomonium:states(3S1) 3S1 bottomonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Bottomonium:states(3S1)1","link":"OniaProcesses.html#anchor79","text":"Bottomonium:states(3S1)1 The first Bottomonium:states(3S1)1 3S1 bottomonium states of the bottomonium pairs that can be produced from the following processes. Note that all vectors within this section, either of modes, flags, or parameters, must be the same length as this vector."},{"name":"Bottomonium:states(3S1)2","link":"OniaProcesses.html#anchor80","text":"Bottomonium:states(3S1)2 The second Bottomonium:states(3S1)2 3S1 bottomonium states of the bottomonium pairs that can be produced from the following processes."},{"name":"Charmonium:all","link":"OniaProcesses.html#anchor7","text":"Charmonium:all Common switch for the group of charmonium production, e.g. Charmonium:all J/psi and Charmonium:all chi_c."},{"name":"Charmonium:gg2ccbar(3DJ)[3DJ(1)]g","link":"OniaProcesses.html#anchor37","text":"Charmonium:gg2ccbar(3DJ)[3DJ(1)]g Colour-singlet production of Charmonium:gg2ccbar(3DJ)[3DJ(1)]g 3PJ charmonium states via Charmonium:gg2ccbar(3DJ)[3DJ(1)]g g g &rarr; ccbar[3DJ(1)] g. Code 417."},{"name":"Charmonium:gg2ccbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor38","text":"Charmonium:gg2ccbar(3DJ)[3PJ(8)]g Colour-octet production of Charmonium:gg2ccbar(3DJ)[3PJ(8)]g 3DJ charmonium states via Charmonium:gg2ccbar(3DJ)[3PJ(8)]g g g &rarr; ccbar[3PJ(8)] g. Code 418."},{"name":"Charmonium:gg2ccbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor28","text":"Charmonium:gg2ccbar(3PJ)[3PJ(1)]g Colour-singlet production of Charmonium:gg2ccbar(3PJ)[3PJ(1)]g 3PJ charmonium states via Charmonium:gg2ccbar(3PJ)[3PJ(1)]g g g &rarr; ccbar[3PJ(1)] g. Code 411."},{"name":"Charmonium:gg2ccbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor31","text":"Charmonium:gg2ccbar(3PJ)[3S1(8)]g Colour-octet production of Charmonium:gg2ccbar(3PJ)[3S1(8)]g 3PJ charmonium states via Charmonium:gg2ccbar(3PJ)[3S1(8)]g g g &rarr; ccbar[3S1(8)] g. Code 414."},{"name":"Charmonium:gg2ccbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor19","text":"Charmonium:gg2ccbar(3S1)[1S0(8)]g Colour-octet production of Charmonium:gg2ccbar(3S1)[1S0(8)]g 3S1 charmonium states via Charmonium:gg2ccbar(3S1)[1S0(8)]g g g &rarr; ccbar[1S0(8)] g. Code 405."},{"name":"Charmonium:gg2ccbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor22","text":"Charmonium:gg2ccbar(3S1)[3PJ(8)]g Colour-octet production of Charmonium:gg2ccbar(3S1)[3PJ(8)]g 3S1 charmonium states via Charmonium:gg2ccbar(3S1)[3PJ(8)]g g g &rarr; ccbar[3PJ(8)] g. Code 408."},{"name":"Charmonium:gg2ccbar(3S1)[3S1(1)]g","link":"OniaProcesses.html#anchor14","text":"Charmonium:gg2ccbar(3S1)[3S1(1)]g Colour-singlet production of Charmonium:gg2ccbar(3S1)[3S1(1)]g 3S1 charmonium states via Charmonium:gg2ccbar(3S1)[3S1(1)]g g g &rarr; ccbar[3S1(1)] g. Code 401."},{"name":"Charmonium:gg2ccbar(3S1)[3S1(1)]gm","link":"OniaProcesses.html#anchor15","text":"Charmonium:gg2ccbar(3S1)[3S1(1)]gm Colour-singlet production of Charmonium:gg2ccbar(3S1)[3S1(1)]gm 3S1 charmonium states via Charmonium:gg2ccbar(3S1)[3S1(1)]gm g g &rarr; ccbar[3S1(1)] g with a hard Charmonium:gg2ccbar(3S1)[3S1(1)]gm gamma. Code 441."},{"name":"Charmonium:gg2ccbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor16","text":"Charmonium:gg2ccbar(3S1)[3S1(8)]g Colour-octet production of Charmonium:gg2ccbar(3S1)[3S1(8)]g 3S1 charmonium states via Charmonium:gg2ccbar(3S1)[3S1(8)]g g g &rarr; ccbar[3S1(8)] g. Code 402."},{"name":"Charmonium:gg2doubleccbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor45","text":"Charmonium:gg2doubleccbar(3S1)[3S1(1)] Colour-singlet production of Charmonium:gg2doubleccbar(3S1)[3S1(1)] 3S1 charmonium state pairs via Charmonium:gg2doubleccbar(3S1)[3S1(1)] g g &rarr; ccbar[3S1(1)] ccbar[3S1(1)]. Code 421."},{"name":"Charmonium:O(3DJ)[3D1(1)]","link":"OniaProcesses.html#anchor35","text":"Charmonium:O(3DJ)[3D1(1)] The color-singlet long-distance matrix elements Charmonium:O(3DJ)[3D1(1)] <O[3D1(1)]> for the Charmonium:O(3DJ)[3D1(1)] 3PJ charmonium states. For a Charmonium:O(3DJ)[3D1(1)] 3DJ charmonium state where Charmonium:O(3DJ)[3D1(1)] J is not Charmonium:O(3DJ)[3D1(1)] 1 the long distance matrix element Charmonium:O(3DJ)[3D1(1)] <O[3DJ(1)]> is calculated by Charmonium:O(3DJ)[3D1(1)] (2J+1)<O[3D1(1)]/3> using leading order spin symmetry relations."},{"name":"Charmonium:O(3DJ)[3P0(8)]","link":"OniaProcesses.html#anchor36","text":"Charmonium:O(3DJ)[3P0(8)] The colour-octet long-distance matrix elements Charmonium:O(3DJ)[3P0(8)] <O[3P0(8)]>/m_Q^2 for the 3DJ charmonium states. The remaining Charmonium:O(3DJ)[3P0(8)] <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Charmonium:O(3PJ)[3P0(1)]","link":"OniaProcesses.html#anchor26","text":"Charmonium:O(3PJ)[3P0(1)] The color-singlet long-distance matrix elements Charmonium:O(3PJ)[3P0(1)] <O[3P0(1)]>/m_Q^2 for the Charmonium:O(3PJ)[3P0(1)] 3PJ charmonium states. The remaining Charmonium:O(3PJ)[3P0(1)] <O[3PJ(1)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Charmonium:O(3PJ)[3S1(8)]","link":"OniaProcesses.html#anchor27","text":"Charmonium:O(3PJ)[3S1(8)] The color-singlet long-distance matrix elements Charmonium:O(3PJ)[3S1(8)] <O[3S1(8)]> for the Charmonium:O(3PJ)[3S1(8)] 3PJ charmonium states."},{"name":"Charmonium:O(3S1)[1S0(8)]","link":"OniaProcesses.html#anchor12","text":"Charmonium:O(3S1)[1S0(8)] The colour-octet long-distance matrix elements Charmonium:O(3S1)[1S0(8)] <O[1S0(8)]> for the Charmonium:O(3S1)[1S0(8)] 3S1 charmonium states."},{"name":"Charmonium:O(3S1)[3P0(8)]","link":"OniaProcesses.html#anchor13","text":"Charmonium:O(3S1)[3P0(8)] The colour-octet long-distance matrix elements Charmonium:O(3S1)[3P0(8)] <O[3P0(8)]>/m_Q^2 for the Charmonium:O(3S1)[3P0(8)] 3S1 charmonium states. The remaining Charmonium:O(3S1)[3P0(8)] <O[3PJ(8)]>/m_Q^2 are calculated from these long-distance matrix elements."},{"name":"Charmonium:O(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor10","text":"Charmonium:O(3S1)[3S1(1)] The colour-singlet long-distance matrix elements Charmonium:O(3S1)[3S1(1)] <O[3S1(1)]> for the Charmonium:O(3S1)[3S1(1)] 3S1 charmonium states."},{"name":"Charmonium:O(3S1)[3S1(1)]1","link":"OniaProcesses.html#anchor43","text":"Charmonium:O(3S1)[3S1(1)]1 The color-singlet long-distance matrix elements Charmonium:O(3S1)[3S1(1)]1 <O[3S1(1)]> for the first Charmonium:O(3S1)[3S1(1)]1 3S1 charmonium states."},{"name":"Charmonium:O(3S1)[3S1(1)]2","link":"OniaProcesses.html#anchor44","text":"Charmonium:O(3S1)[3S1(1)]2 The color-singlet long-distance matrix elements Charmonium:O(3S1)[3S1(1)]2 <O[3S1(1)]> for the second Charmonium:O(3S1)[3S1(1)]2 3S1 charmonium states."},{"name":"Charmonium:O(3S1)[3S1(8)]","link":"OniaProcesses.html#anchor11","text":"Charmonium:O(3S1)[3S1(8)] The colour-octet long-distance matrix elements Charmonium:O(3S1)[3S1(8)] <O[3S1(8)]> for the Charmonium:O(3S1)[3S1(8)] 3S1 charmonium states."},{"name":"Charmonium:qg2ccbar(3DJ)[3PJ(8)]q","link":"OniaProcesses.html#anchor39","text":"Charmonium:qg2ccbar(3DJ)[3PJ(8)]q Colour-octet production of Charmonium:qg2ccbar(3DJ)[3PJ(8)]q 3DJ charmonium states via Charmonium:qg2ccbar(3DJ)[3PJ(8)]q q g &rarr; ccbar[3PJ(8)] q. Code 419."},{"name":"Charmonium:qg2ccbar(3PJ)[3PJ(1)]q","link":"OniaProcesses.html#anchor29","text":"Charmonium:qg2ccbar(3PJ)[3PJ(1)]q Colour-singlet production of Charmonium:qg2ccbar(3PJ)[3PJ(1)]q 3PJ charmonium states via Charmonium:qg2ccbar(3PJ)[3PJ(1)]q q g &rarr; ccbar[3PJ(1)] q. Code 412."},{"name":"Charmonium:qg2ccbar(3PJ)[3S1(8)]q","link":"OniaProcesses.html#anchor32","text":"Charmonium:qg2ccbar(3PJ)[3S1(8)]q Colour-octet production of Charmonium:qg2ccbar(3PJ)[3S1(8)]q 3PJ charmonium states via Charmonium:qg2ccbar(3PJ)[3S1(8)]q q g &rarr; ccbar[3S1(8)] q. Code 415."},{"name":"Charmonium:qg2ccbar(3S1)[1S0(8)]q","link":"OniaProcesses.html#anchor20","text":"Charmonium:qg2ccbar(3S1)[1S0(8)]q Colour-octet production of Charmonium:qg2ccbar(3S1)[1S0(8)]q 3S1 charmonium states via Charmonium:qg2ccbar(3S1)[1S0(8)]q q g &rarr; ccbar[1S0(8)] q. Code 406."},{"name":"Charmonium:qg2ccbar(3S1)[3PJ(8)]q","link":"OniaProcesses.html#anchor23","text":"Charmonium:qg2ccbar(3S1)[3PJ(8)]q Colour-octet production of Charmonium:qg2ccbar(3S1)[3PJ(8)]q 3S1 charmonium states via Charmonium:qg2ccbar(3S1)[3PJ(8)]q q g &rarr; ccbar[3PJ(8)] q. Code 409."},{"name":"Charmonium:qg2ccbar(3S1)[3S1(8)]q","link":"OniaProcesses.html#anchor17","text":"Charmonium:qg2ccbar(3S1)[3S1(8)]q Colour-octet production of Charmonium:qg2ccbar(3S1)[3S1(8)]q 3S1 charmonium states via Charmonium:qg2ccbar(3S1)[3S1(8)]q q g &rarr; ccbar[3S1(8)] q. Code 403."},{"name":"Charmonium:qqbar2ccbar(3DJ)[3PJ(8)]g","link":"OniaProcesses.html#anchor40","text":"Charmonium:qqbar2ccbar(3DJ)[3PJ(8)]g Colour-octet production of Charmonium:qqbar2ccbar(3DJ)[3PJ(8)]g 3DJ charmonium states via Charmonium:qqbar2ccbar(3DJ)[3PJ(8)]g q qbar &rarr; ccbar[3PJ(8)] g. Code 420."},{"name":"Charmonium:qqbar2ccbar(3PJ)[3PJ(1)]g","link":"OniaProcesses.html#anchor30","text":"Charmonium:qqbar2ccbar(3PJ)[3PJ(1)]g Colour-singlet production of Charmonium:qqbar2ccbar(3PJ)[3PJ(1)]g 3PJ charmonium states via Charmonium:qqbar2ccbar(3PJ)[3PJ(1)]g q qbar &rarr; ccbar[3PJ(1)] g. Code 413."},{"name":"Charmonium:qqbar2ccbar(3PJ)[3S1(8)]g","link":"OniaProcesses.html#anchor33","text":"Charmonium:qqbar2ccbar(3PJ)[3S1(8)]g Colour-octet production of Charmonium:qqbar2ccbar(3PJ)[3S1(8)]g 3PJ charmonium states via Charmonium:qqbar2ccbar(3PJ)[3S1(8)]g q qbar &rarr; ccbar[3S1(8)] g. Code 416."},{"name":"Charmonium:qqbar2ccbar(3S1)[1S0(8)]g","link":"OniaProcesses.html#anchor21","text":"Charmonium:qqbar2ccbar(3S1)[1S0(8)]g Colour-octet production of Charmonium:qqbar2ccbar(3S1)[1S0(8)]g 3S1 charmonium states via Charmonium:qqbar2ccbar(3S1)[1S0(8)]g q qbar &rarr; ccbar[1S0(8)] g. Code 407."},{"name":"Charmonium:qqbar2ccbar(3S1)[3PJ(8)]g","link":"OniaProcesses.html#anchor24","text":"Charmonium:qqbar2ccbar(3S1)[3PJ(8)]g Colour-octet production of Charmonium:qqbar2ccbar(3S1)[3PJ(8)]g 3S1 charmonium states via Charmonium:qqbar2ccbar(3S1)[3PJ(8)]g q qbar &rarr; ccbar[3SJ(8)] g. Code 410."},{"name":"Charmonium:qqbar2ccbar(3S1)[3S1(8)]g","link":"OniaProcesses.html#anchor18","text":"Charmonium:qqbar2ccbar(3S1)[3S1(8)]g Colour-octet production of Charmonium:qqbar2ccbar(3S1)[3S1(8)]g 3S1 charmonium states via Charmonium:qqbar2ccbar(3S1)[3S1(8)]g q qbar &rarr; ccbar[3S1(8)] g. Code 404."},{"name":"Charmonium:qqbar2doubleccbar(3S1)[3S1(1)]","link":"OniaProcesses.html#anchor46","text":"Charmonium:qqbar2doubleccbar(3S1)[3S1(1)] Colour-singlet production of Charmonium:qqbar2doubleccbar(3S1)[3S1(1)] 3S1 charmonium state pairs via Charmonium:qqbar2doubleccbar(3S1)[3S1(1)] q qbar &rarr; ccbar[3S1(1)] ccbar[3S1(1)]. Code 422."},{"name":"Charmonium:states(3DJ)","link":"OniaProcesses.html#anchor34","text":"Charmonium:states(3DJ) The Charmonium:states(3DJ) 3DJ charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Charmonium:states(3PJ)","link":"OniaProcesses.html#anchor25","text":"Charmonium:states(3PJ) The Charmonium:states(3PJ) 3PJ charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Charmonium:states(3S1)","link":"OniaProcesses.html#anchor9","text":"Charmonium:states(3S1) The Charmonium:states(3S1) 3S1 charmonium states that can be produced from the following processes. Note that all vectors within this section, either of flags or parameters, must be the same length as this vector."},{"name":"Charmonium:states(3S1)1","link":"OniaProcesses.html#anchor41","text":"Charmonium:states(3S1)1 The first Charmonium:states(3S1)1 3S1 charmonium states of the charmonium pairs that can be produced from the following processes. Note that all vectors within this section, either of modes, flags, or parameters, must be the same length as this vector."},{"name":"Charmonium:states(3S1)2","link":"OniaProcesses.html#anchor42","text":"Charmonium:states(3S1)2 The second Charmonium:states(3S1)2 3S1 charmonium states of the charmonium pairs that can be produced from the following processes."},{"name":"Check:abortIfVeto","link":"ErrorChecks.html#anchor1","text":"Check:abortIfVeto There are a few ways in which an event can be vetoed, the most common being a Check:abortIfVeto User Hooks test. Normally this will simply mean that the next parton-level configuration is selected inside the Check:abortIfVeto Pythia::next() routine, without any need for a user intervention. With this option switched on, however, Check:abortIfVeto Pythia::next() will return Check:abortIfVeto false. It is then up to the user to decide what to do next."},{"name":"Check:beams","link":"ErrorChecks.html#anchor6","text":"Check:beams Check that Pythia supports the beam setup, i.e. if the beams are the allowed combinations described in Check:beams Beam Parameters. If turned off, all checks of allowed beam combinations will be skipped, as can e.g. be useful to allow processing of Les Houches event files with exotic beam structure."},{"name":"Check:epTolErr","link":"ErrorChecks.html#anchor8","text":"Check:epTolErr Maximum allowed summed deviation of Check:epTolErr E , Check:epTolErr p_x , Check:epTolErr p_y and Check:epTolErr p_z between the incoming beams and the final state, as a fraction of the initial energy, above which the event is counted as aborted. (Unfortunately roundoff errors do not scale linearly with the energy, and also have a very long tail. So while most events at lower energies may be correct to better than 1e-10, at LHC it does not have to signal any fundamental bug if also the default tolerance above is violated occasionally.)"},{"name":"Check:epTolWarn","link":"ErrorChecks.html#anchor9","text":"Check:epTolWarn A check on the same summed deviation as above, but counted as a warning rather than an error, and not leading to the event being classified as aborted."},{"name":"Check:event","link":"ErrorChecks.html#anchor4","text":"Check:event When an event has been successfully generated, check that the final event record in Check:event event does not contain any unphysical particles, or nonconserved charge or energy-momentum. If this check fails, then Check:event pythia.next() obtains the value Check:event false , i.e. the event is counted as aborted."},{"name":"Check:history","link":"ErrorChecks.html#anchor5","text":"Check:history When Check:history Check:event = on and the event is checked as above, further checks are made that all mother and daughter pointers are consistently set. Specifically that all daughters in the Check:history daughterlist (or Check:history motherList ) have the particle in their respective Check:history motherList (or Check:history daughterlist ). This operation takes a bit more time than the other error tests (of the order of 10% of what it takes to generate the event in the first place), and so could be switched off to save time."},{"name":"Check:levelParticleData","link":"ErrorChecks.html#anchor3","text":"Check:levelParticleData The level of verbosity and checks of particle data, if switched on. Check:levelParticleData minimal amount of checks, e.g. that no channels open. Check:levelParticleData further warning if individual channels closed, except for resonances. Check:levelParticleData also print branching-ratio-averaged threshold mass except for resonances. Check:levelParticleData as 1, but include resonances in detailed checks. Check:levelParticleData as 2, but include resonances in detailed checks."},{"name":"Check:mTolErr","link":"ErrorChecks.html#anchor10","text":"Check:mTolErr For each particle the maximum allowed deviation between the mass calculated from energy-momentum and the bookkept mass, as a fraction of the energy. This energy is taken to be at least 1 GeV, in order to avoid harmless problems at very low energies (gluons mainly)."},{"name":"Check:mTolWarn","link":"ErrorChecks.html#anchor11","text":"Check:mTolWarn A check on the deviation as above, but counted as a warning rather than an error."},{"name":"Check:nErrList","link":"ErrorChecks.html#anchor7","text":"Check:nErrList The number of erroneous events, in the above check, for which event listing and other detailed information will be printed. After that, only the normal error messages will be issued. Error counters are always updated, and accumulated numbers can be shown with Check:nErrList pythia.stat() at the end of the run."},{"name":"Check:particleData","link":"ErrorChecks.html#anchor2","text":"Check:particleData Check the particle data tables for potential problems during initialization. This includes inconsistent use of charge in particle names, inconsistent setup of mass, mass range, width and lifetime, sum of branching ratios not unity (allowed but discouraged) or charge not conserved in a decay channel. Warnings should be viewed as reasons to check further, but need not indicate a true problem, and also not all problems may be caught. The Check:particleData pythia.particleData.checkTable(level) method, used for these checks, may also be called directly."},{"name":"ColourReconnection:allowDoubleJunRem","link":"ColourReconnection.html#anchor12","text":"ColourReconnection:allowDoubleJunRem This parameter tells whether or not to allow a directly connected junction-antijunction pair to split into two strings. The lambda measure of the junction system is compared to that of the two possible string configurations. If the chosen configuration is the junction system, a q-qbar system is inserted between the junctions by removing some energy/momentum from the other legs."},{"name":"ColourReconnection:allowJunctions","link":"ColourReconnection.html#anchor10","text":"ColourReconnection:allowJunctions This switch disables the formation of junctions in the colour reconnection."},{"name":"ColourReconnection:blowR","link":"ColourReconnection.html#anchor24","text":"ColourReconnection:blowR Technical parameter used in the Monte Carlo sampling of the spatial phase space volume in SK I. There is no real reason to change this number."},{"name":"ColourReconnection:blowT","link":"ColourReconnection.html#anchor25","text":"ColourReconnection:blowT Technical parameter used in the Monte Carlo sampling of the temporal phase space volume in SK I. There is no real reason to change this number."},{"name":"ColourReconnection:dLambdaCut","link":"ColourReconnection.html#anchor17","text":"ColourReconnection:dLambdaCut Restrict gluon moves and colour flips to those that reduce ColourReconnection:dLambdaCut lambda by more than this amount. The larger this number, the fewer moves and flips will be performed, but those that remain are the ones most likely to produce large effects."},{"name":"ColourReconnection:flipMode","link":"ColourReconnection.html#anchor18","text":"ColourReconnection:flipMode Performing the flip step or not. Also possibility to omit the move step. ColourReconnection:flipMode No flip handling. ColourReconnection:flipMode Allow flips, but not for strings in junction topologies. ColourReconnection:flipMode Allow flips, including for strings in junction topologies. ColourReconnection:flipMode No move handling. Allow flips, but not for strings in junction topologies. ColourReconnection:flipMode No move handling. Allow flips, including for strings in junction topologies."},{"name":"ColourReconnection:forceHadronLevelCR","link":"ColourReconnection.html#anchor3","text":"ColourReconnection:forceHadronLevelCR This flag switches on colour reconnection in the ColourReconnection:forceHadronLevelCR forceHadronLevel function. The function is called when only the hadron level of PYTHIA is used (see ColourReconnection:forceHadronLevelCR Hadron-level Standalone ). The MPI-based model is not available for this setup and any resonance decays not already decayed are not included in the CR."},{"name":"ColourReconnection:forceResonance","link":"ColourReconnection.html#anchor4","text":"ColourReconnection:forceResonance This parameter allows an additional CR after late resonance decays. All the particles from all resonance decays are allowed to reconnect with each other. It is mainly intended for ColourReconnection:forceResonance H -> WW -> qqqq , where the Higgs decay ensures a separation between the W bosons and the MPI systems. Reconnections between the decay products from the two ColourReconnection:forceResonance W bosons is still a possibility, however. This option is not available for colored resonances, and not for the MPI-based model."},{"name":"ColourReconnection:fracGluon","link":"ColourReconnection.html#anchor16","text":"ColourReconnection:fracGluon The probability that a given gluon will be considered for being moved. It thus gives the average fraction of gluons being considered."},{"name":"ColourReconnection:fragmentationTime","link":"ColourReconnection.html#anchor22","text":"ColourReconnection:fragmentationTime This parameter specifies the average fragmentation time of the string, in fm. This is used as an upper limit on the invariant time where strings still exist and thus can collide. The expected fragmentation time is related to the ColourReconnection:fragmentationTime a and ColourReconnection:fragmentationTime b parameters of the Lund string fragmentation function as well as to the string tension. It is therefore not a quite free parameter."},{"name":"ColourReconnection:junctionCorrection","link":"ColourReconnection.html#anchor7","text":"ColourReconnection:junctionCorrection This variable allows to use a different m0 for junction strings in the lambda measure. It is multiplicative correction to the m0 chosen above."},{"name":"ColourReconnection:kI","link":"ColourReconnection.html#anchor21","text":"ColourReconnection:kI kI is the main free parameter in the reconnection probability for SK I. This probability is given by kI times the space-time overlap volume, up to saturation effects."},{"name":"ColourReconnection:lambdaForm","link":"ColourReconnection.html#anchor11","text":"ColourReconnection:lambdaForm This allows to switch between different options for what ColourReconnection:lambdaForm lambda -measure to use. The formula shown are how much each end of a dipole or junction contribute to the total ColourReconnection:lambdaForm lambda -measure. The energies are defined in respectively the dipole or junction rest frame. ColourReconnection:lambdaForm ColourReconnection:lambdaForm lambda = ln (1 + sqrt(2) E/m0) ColourReconnection:lambdaForm ColourReconnection:lambdaForm lambda = ln (1 + 2 E/m0) ColourReconnection:lambdaForm ColourReconnection:lambdaForm lambda = ln (2 E/m0)"},{"name":"ColourReconnection:lowerLambdaOnly","link":"ColourReconnection.html#anchor19","text":"ColourReconnection:lowerLambdaOnly Only allow overlaps that lowers the total string length."},{"name":"ColourReconnection:m0","link":"ColourReconnection.html#anchor6","text":"ColourReconnection:m0 This is the variable used in the lambda measure for the string length. See the different choices of lambda measure for exact formulas. This variable is in the new model also used as a cut for forming pseudo particles that are not colour reconnected."},{"name":"ColourReconnection:m2Lambda","link":"ColourReconnection.html#anchor15","text":"ColourReconnection:m2Lambda The ColourReconnection:m2Lambda m2Lambda parameter used in the definition of the approximate ColourReconnection:m2Lambda lambda measure above. It represents an approximate hadronic mass-square scale, cf. ColourReconnection:m2Lambda m0 in the previous model. Its value is uncertain up to factors of 2, but the ColourReconnection:m2Lambda lambda change induced by a potential move or flip is rather insensitive to the precise value, owing to large cancellations."},{"name":"ColourReconnection:mode","link":"ColourReconnection.html#anchor2","text":"ColourReconnection:mode Determine which model is used for colour reconnection. Beware that some settings may need to be changed to match the model selected. ColourReconnection:mode The MPI-based original Pythia 8 scheme. ColourReconnection:mode The new more QCD based scheme. Should be combined ewith ColourReconnection:mode BeamRemnants:remnantMode = 1. ColourReconnection:mode The new gluon-move model. ColourReconnection:mode The SK I ColourReconnection:mode e^+ e^- CR model. Requires ColourReconnection:mode ColourReconnection:forceResonance = on (and default ColourReconnection:mode PartonLevel:earlyResDec = off ) to give any CR. ColourReconnection:mode The SK II ColourReconnection:mode e^+ e^- CR model. Requires ColourReconnection:mode ColourReconnection:forceResonance = on (and default ColourReconnection:mode PartonLevel:earlyResDec = off ) to give any CR."},{"name":"ColourReconnection:nColours","link":"ColourReconnection.html#anchor8","text":"ColourReconnection:nColours The number of reconnection colours, this should not be confused with the standard number of QCD colours. Each string is given an integer number between 0 and ColourReconnection:nColours nColours - 1. Only strings with the same number are allowed to do a normal string reconnection. The default value provides the standard QCD probability that a triplet and an anti-triplet is in a singlet state. The probability for two strings to form a junction structure is in QCD given by the product of two triplets, which gives a probability of 1/3. Therefore the number of reconnection colours for junction formation is ColourReconnection:nColours iColours % 3 , where iColours refer to the integer of the string. The behaviour of junction formation therefore only changes slightly with this variable."},{"name":"ColourReconnection:range","link":"ColourReconnection.html#anchor5","text":"ColourReconnection:range The ColourReconnection:range range parameter defined above. The higher this number is the more reconnections can occur. For values above unity the reconnection rate tends to saturate, since then most systems are already connected with each other. This is why 10 is set as an effective upper limit, beyond which it is not meaningful to let the parameter go."},{"name":"ColourReconnection:reconnect","link":"ColourReconnection.html#anchor1","text":"ColourReconnection:reconnect Allow or not a system to be merged with another one."},{"name":"ColourReconnection:rHadron","link":"ColourReconnection.html#anchor23","text":"ColourReconnection:rHadron Width of the type I string in reconnection calculations, in fm, giving the radius of the Gaussian distribution in ColourReconnection:rHadron x and ColourReconnection:rHadron y separately."},{"name":"ColourReconnection:sameNeighbourColours","link":"ColourReconnection.html#anchor9","text":"ColourReconnection:sameNeighbourColours In the normal colour reconnection two neighbouring strings are not allowed to have the same colour. Similar two strings originating from a gluon split is not allowed to reconnect. The physics motivation for this is that it would require colour singlet gluons, and therefore for ordinary physics studies this should be turned off. But for testing of extreme scenarios (i.e. 1 colour), this variable needs to be turned on, since it is not possible to have different neighbouring colours."},{"name":"ColourReconnection:singleReconnection","link":"ColourReconnection.html#anchor20","text":"ColourReconnection:singleReconnection Limit the number of reconnections to a single reconnection."},{"name":"ColourReconnection:timeDilationMode","link":"ColourReconnection.html#anchor13","text":"ColourReconnection:timeDilationMode Disallow colour reconnection between strings that are not in causal contact; if either string has already decayed before the other string forms, there is no space-time region in which the reconnection could physically occur. The exact defintion of causal contact is not known, hence several possible defintions are included. They all include the boost factor, ColourReconnection:timeDilationMode gamma , and the majority also rely on the typical hadronization scale, ColourReconnection:timeDilationMode r , which is kept fixed at 1 fm. A tuneable dimensionless parameter is included, which can be used to control the overall amount of colour reconnection. ColourReconnection:timeDilationMode All strings are allowed to reconnect. ColourReconnection:timeDilationMode Strings are allowed to reconnect if ColourReconnection:timeDilationMode gamma < timeDilationPar and all strings should be causally connected to allow a reconnection. ColourReconnection:timeDilationMode Strings are allowed to reconnect if ColourReconnection:timeDilationMode gamma < timeDilationPar * mDip * r and all strings should be in causal contact to allow a reconnection. ColourReconnection:timeDilationMode Strings are allowed to reconnect if ColourReconnection:timeDilationMode gamma < timeDilationPar * mDip * r and if a single pair of dipoles are in causal contact the reconnection is allowed. ColourReconnection:timeDilationMode Strings are allowed to reconnect if ColourReconnection:timeDilationMode gamma < timeDilationPar * mDip' * r and all strings should be in causal contact to allow a reconnection. mDip' is the invariant mass at the formation of the dipole (ie. the first time the colour tag appear in the perturbative expansion). ColourReconnection:timeDilationMode Strings are allowed to reconnect if ColourReconnection:timeDilationMode gamma < timeDilationPar * mDip' * r and if a single pair of dipoles are in causal contact the reconnection is allowed. mDip' is the invariant mass at the formation of the dipole (ie. the first time the colour tag appear in the perturbative expansion)."},{"name":"ColourReconnection:timeDilationPar","link":"ColourReconnection.html#anchor14","text":"ColourReconnection:timeDilationPar This is a tuneable parameter for the time dilation. The definition can be seen above under ColourReconnection:timeDilationPar timeDilationMode."},{"name":"ContactInteractions:etaLL","link":"CompositenessProcesses.html#anchor39","text":"ContactInteractions:etaLL Helicity parameter. ContactInteractions:etaLL ContactInteractions:etaLL ContactInteractions:etaLL"},{"name":"ContactInteractions:etaLR","link":"CompositenessProcesses.html#anchor41","text":"ContactInteractions:etaLR Helicity parameter. ContactInteractions:etaLR ContactInteractions:etaLR ContactInteractions:etaLR"},{"name":"ContactInteractions:etaRL","link":"CompositenessProcesses.html#anchor42","text":"ContactInteractions:etaRL Helicity parameter.  Implemented only for the ContactInteractions:etaRL q qbar &rarr; l- l+ process. ContactInteractions:etaRL ContactInteractions:etaRL ContactInteractions:etaRL"},{"name":"ContactInteractions:etaRR","link":"CompositenessProcesses.html#anchor40","text":"ContactInteractions:etaRR Helicity parameter. ContactInteractions:etaRR ContactInteractions:etaRR ContactInteractions:etaRR"},{"name":"ContactInteractions:Lambda","link":"CompositenessProcesses.html#anchor38","text":"ContactInteractions:Lambda Compositeness scale ContactInteractions:Lambda Lambda in GeV. Its overall normalization is largely a matter of convention. The choice made here for the ContactInteractions:Lambda q qbar &rarr; l- l+ processes is such that the pure contact interaction part of the left-left interactions (i.e. disregarding ContactInteractions:Lambda gamma^* , ContactInteractions:Lambda Z^0 and interference terms) has the form ContactInteractions:Lambda d(sigmaHat)/d(tHat) = pi * uHat^2 / (3 * sHat^2 * Lambda^4). The corresponding part of the ContactInteractions:Lambda q qbar &rarr; q' qbar' cross section is a factor 3 larger from colour."},{"name":"ContactInteractions:nQuarkNew","link":"CompositenessProcesses.html#anchor37","text":"ContactInteractions:nQuarkNew Number of allowed outgoing new quark flavours in the above ContactInteractions:nQuarkNew q qbar &rarr; q' qbar' process. Similar to ContactInteractions:nQuarkNew HardQCD:nQuarkNew for the QCD processes."},{"name":"ContactInteractions:QCffbar2eebar","link":"CompositenessProcesses.html#anchor34","text":"ContactInteractions:QCffbar2eebar Scatterings ContactInteractions:QCffbar2eebar f fbar &rarr; e- e+ including contact interactions. Code 4203."},{"name":"ContactInteractions:QCffbar2mumubar","link":"CompositenessProcesses.html#anchor35","text":"ContactInteractions:QCffbar2mumubar Scatterings ContactInteractions:QCffbar2mumubar f fbar &rarr; mu- mu+ including contact interactions. Code 4204."},{"name":"ContactInteractions:QCffbar2tautaubar","link":"CompositenessProcesses.html#anchor36","text":"ContactInteractions:QCffbar2tautaubar Scatterings ContactInteractions:QCffbar2tautaubar f fbar &rarr; tau- tau+ including contact interactions. Code 4205."},{"name":"ContactInteractions:QCqq2qq","link":"CompositenessProcesses.html#anchor32","text":"ContactInteractions:QCqq2qq Scatterings ContactInteractions:QCqq2qq q q &rarr; q q including contact interactions. Code 4201."},{"name":"ContactInteractions:QCqqbar2qqbar","link":"CompositenessProcesses.html#anchor33","text":"ContactInteractions:QCqqbar2qqbar Scatterings ContactInteractions:QCqqbar2qqbar q qbar &rarr; q' qbar' including contact interactions. Code 4202."},{"name":"decays","link":"SUSYProcesses.html#anchor24","text":"decays"},{"name":"DeuteronProduction:channels","link":"DeuteronProduction.html#anchor2","text":"DeuteronProduction:channels List of the deuteron production channels to include of the form DeuteronProduction:channels initial states > final states where DeuteronProduction:channels initial states are the PDG particle IDs of the initial state particles to combine (there must be two), and DeuteronProduction:channels final states are the PIDs of the final state particles, excluding the deuteron. There must be one or more final state particles in addition to the deuteron. The products of each channel are space separated, while the channels are comma separated."},{"name":"DeuteronProduction:kMax","link":"DeuteronProduction.html#anchor6","text":"DeuteronProduction:kMax The maximum bracketing value of DeuteronProduction:kMax k (in DeuteronProduction:kMax GeV ) when maximum finding."},{"name":"DeuteronProduction:kMin","link":"DeuteronProduction.html#anchor5","text":"DeuteronProduction:kMin The minimum bracketing value of DeuteronProduction:kMin k (in DeuteronProduction:kMin GeV ) when maximum finding. For the default DeuteronProduction:kMin p n &rarr; gamma 2H production model the cross-section diverges at low DeuteronProduction:kMin k , but the probability of producing two nucleons with low DeuteronProduction:kMin k suppresses this divergence."},{"name":"DeuteronProduction:kSteps","link":"DeuteronProduction.html#anchor8","text":"DeuteronProduction:kSteps The number of steps to sample in DeuteronProduction:kSteps k when calculating the initial grid for maximum finding."},{"name":"DeuteronProduction:kTol","link":"DeuteronProduction.html#anchor7","text":"DeuteronProduction:kTol The minimum relative tolerance in DeuteronProduction:kTol k required when maximum finding."},{"name":"DeuteronProduction:models","link":"DeuteronProduction.html#anchor3","text":"DeuteronProduction:models List of the parameterization mode for each deuteron production channel specified by DeuteronProduction:models DeuteronProduction:channels. The parameters for each of the channels is specified with DeuteronProduction:models DeuteronProduction:parms. The length of this vector must be the same as DeuteronProduction:models DeuteronProduction:channels. DeuteronProduction:models the coalescence model, DeuteronProduction:models p DeuteronProduction:models 1 &theta;(p DeuteronProduction:models 0 - k) , a step function with two parameters: DeuteronProduction:models p DeuteronProduction:models 0 the cut-off of the step function and DeuteronProduction:models p DeuteronProduction:models 1 the normalization of the step function. DeuteronProduction:models the differential cross-section model in DeuteronProduction:models &kappa; is given by the piece-wise function DeuteronProduction:models &sum; DeuteronProduction:models i=1 DeuteronProduction:models 12 p DeuteronProduction:models i &kappa; DeuteronProduction:models i-2 for DeuteronProduction:models &kappa; < p DeuteronProduction:models 0 , otherwise DeuteronProduction:models exp(-p DeuteronProduction:models 13 &kappa; - p DeuteronProduction:models 14 &kappa; DeuteronProduction:models 2 ). A total of 15 parameters are required: the function split followed by 12 polynomial coefficients for the first function, and 2 polynomial coefficients for the second exponential function. The function is fixed below DeuteronProduction:models 0.1 GeV to its value at this DeuteronProduction:models &kappa; where DeuteronProduction:models &kappa; is defined as DeuteronProduction:models k/GeV. DeuteronProduction:models the differential cross-section model in DeuteronProduction:models &eta; is given by DeuteronProduction:models p DeuteronProduction:models 0 &eta; DeuteronProduction:models p DeuteronProduction:models 1 /((p DeuteronProduction:models 2 - exp(p DeuteronProduction:models 3 &eta;)) DeuteronProduction:models 2 + p DeuteronProduction:models 4 ). A total of 5 parameters is required. Here, DeuteronProduction:models &eta; is the momentum of the non-deuteron final state divided by its mass in the COM. This model is intended for two-body final states containing a deuteron and a pion. DeuteronProduction:models the differential cross-section model in DeuteronProduction:models &kappa; is given by DeuteronProduction:models &sum; DeuteronProduction:models i=0 p DeuteronProduction:models 5*i+0 &kappa; DeuteronProduction:models p DeuteronProduction:models 5*i+1 /((p DeuteronProduction:models 5*i+2 - exp(p DeuteronProduction:models 5*i+3 &kappa;)) DeuteronProduction:models 2 + p DeuteronProduction:models 5*i+4 ) where the number of parameters can be any multiple of 5 and DeuteronProduction:models &kappa; is defined as DeuteronProduction:models k/GeV."},{"name":"DeuteronProduction:norm","link":"DeuteronProduction.html#anchor1","text":"DeuteronProduction:norm An overall unitless multiplicative normalization scale to increase the maximum used when sampling the differential cross-sections. Increasing this scale decreases the cross-section for deuteron production. Using the default model, the maximum differential cross-section is DeuteronProduction:norm 3.2 mb with the DeuteronProduction:norm n0 n0 &rarr; pi- 2H and DeuteronProduction:norm p+ p+ &rarr; pi+ 2H channels. To convert the fit values from table VIII of DeuteronProduction:norm Dal15 into this multiplicative normalization factor, take DeuteronProduction:norm 1/(value from table * maximum cross-section). For example, the ALICE 7 TeV deuteron fit with a DeuteronProduction:norm 1/&sigma; DeuteronProduction:norm 0 of 2.63 inverse barn, the multiplicative normalization is 119.6."},{"name":"DeuteronProduction:parms","link":"DeuteronProduction.html#anchor4","text":"DeuteronProduction:parms The parameters needed for the model of each channel. The parameters for each channel are space separated, while the channels are separated by commas. The length of this vector must be the same as DeuteronProduction:parms DeuteronProduction:channels. Note, to match the parameters of DeuteronProduction:parms Dal15 these parameters give differential cross-sections in DeuteronProduction:parms &mu;b not DeuteronProduction:parms mb."},{"name":"Diffraction:bProfile","link":"Diffraction.html#anchor11","text":"Diffraction:bProfile Choice of impact parameter profile for the incoming hadron beams. Diffraction:bProfile no impact parameter dependence at all. Diffraction:bProfile a simple Gaussian matter distribution; no free parameters. Diffraction:bProfile a double Gaussian matter distribution, with the two free parameters Diffraction:bProfile coreRadius and Diffraction:bProfile coreFraction. Diffraction:bProfile an overlap function, i.e. the convolution of the matter distributions of the two incoming hadrons, of the form Diffraction:bProfile exp(- b^expPow) , where Diffraction:bProfile expPow is a free parameter."},{"name":"Diffraction:bSelHard","link":"Diffraction.html#anchor20","text":"Diffraction:bSelHard Selection of impact parameter Diffraction:bSelHard b and the related enhancement factor for the Pomeron-proton subsystem when the MPI check is carried out. This affects the underlying-event activity in hard diffractive events. Diffraction:bSelHard Use the same Diffraction:bSelHard b as already assigned for the proton-proton collision. This implicitly assumes that a Pomeron is as big as a proton and centered in the same place. Since small Diffraction:bSelHard b values already have been suppressed, few events should have high enhancement factors. Diffraction:bSelHard Use the square root of the Diffraction:bSelHard b as already assigned for the proton-proton collision, thereby making the enhancement factor fluctuate less between events. If the Pomeron is very tiny then what matters is where it strikes the other proton, not the details of its shape. Thus the variation with Diffraction:bSelHard b is of one proton, not two, and so the square root of the normal variation, loosely speaking. Tecnhically this is difficult to implement, but the current simple recipe provides the main effect of reducing the variation, bringing all Diffraction:bSelHard b values closer to the average. Diffraction:bSelHard Pick a completely new Diffraction:bSelHard b. This allows a broad spread from central to peripheral values, and thereby also a more varying MPI activity inside the diffractive system than the other two options. This offers an extreme picture, even if not the most likely one."},{"name":"Diffraction:coreFraction","link":"Diffraction.html#anchor13","text":"Diffraction:coreFraction When assuming a double Gaussian matter profile, Diffraction:coreFraction bProfile = 2 , the inner core is assumed to have a fraction Diffraction:coreFraction coreFraction of the matter content of the hadron."},{"name":"Diffraction:coreRadius","link":"Diffraction.html#anchor12","text":"Diffraction:coreRadius When assuming a double Gaussian matter profile, Diffraction:coreRadius bProfile = 2 , the inner core is assumed to have a radius that is a factor Diffraction:coreRadius coreRadius smaller than the rest."},{"name":"Diffraction:doHard","link":"Diffraction.html#anchor15","text":"Diffraction:doHard Allows for the possibility to include hard diffraction tests in a run."},{"name":"Diffraction:expPow","link":"Diffraction.html#anchor14","text":"Diffraction:expPow When Diffraction:expPow bProfile = 3 it gives the power of the assumed overlap shape Diffraction:expPow exp(- b^expPow). Default corresponds to a simple exponential drop, which is not too dissimilar from the overlap obtained with the standard double Gaussian parameters. For Diffraction:expPow expPow = 2 we reduce to the simple Gaussian, Diffraction:expPow bProfile = 1 , and for Diffraction:expPow expPow &rarr; infinity to no impact parameter dependence at all, Diffraction:expPow bProfile = 0. For small Diffraction:expPow expPow the program becomes slow and unstable, so the min limit must be respected."},{"name":"Diffraction:hardDiffSide","link":"Diffraction.html#anchor16","text":"Diffraction:hardDiffSide Side which diffraction is evaluated for. Especially useful for diffraction in ep, where experiments only look for gaps on the proton side. Diffraction:hardDiffSide Check for diffraction on boths sides A and B. Diffraction:hardDiffSide Check for diffraction on side A only. Diffraction:hardDiffSide Check for diffraction on side B only."},{"name":"Diffraction:largeMassSuppress","link":"Diffraction.html#anchor7","text":"Diffraction:largeMassSuppress The choice of longitudinal and transverse structure of a diffractive beam remnant for a kicked-out gluon implies a remnant mass Diffraction:largeMassSuppress m_rem distribution (i.e. quark plus diquark invariant mass for a baryon beam) that knows no bounds. A suppression like Diffraction:largeMassSuppress (1 - m_rem^2 / m_diff^2)^p is therefore introduced, where Diffraction:largeMassSuppress p is the Diffraction:largeMassSuppress diffLargeMassSuppress parameter."},{"name":"Diffraction:mMinPert","link":"Diffraction.html#anchor1","text":"Diffraction:mMinPert The abovementioned threshold mass Diffraction:mMinPert m_min for phasing in a perturbative treatment. If you put this parameter to be bigger than the CM energy then there will be no perturbative description at all, but only the older low- Diffraction:mMinPert pt description."},{"name":"Diffraction:mPowPomP","link":"Diffraction.html#anchor10","text":"Diffraction:mPowPomP The Diffraction:mPowPomP p mass rescaling pace introduced above."},{"name":"Diffraction:mRefPomP","link":"Diffraction.html#anchor9","text":"Diffraction:mRefPomP The Diffraction:mRefPomP mRef reference mass scale introduced above."},{"name":"Diffraction:mWidthPert","link":"Diffraction.html#anchor2","text":"Diffraction:mWidthPert The abovementioned threshold width Diffraction:mWidthPert m_width."},{"name":"Diffraction:pickQuarkNorm","link":"Diffraction.html#anchor4","text":"Diffraction:pickQuarkNorm The abovementioned normalization Diffraction:pickQuarkNorm N for the relative quark rate in diffractive systems."},{"name":"Diffraction:pickQuarkPower","link":"Diffraction.html#anchor5","text":"Diffraction:pickQuarkPower The abovementioned mass-dependence power Diffraction:pickQuarkPower p for the relative quark rate in diffractive systems."},{"name":"Diffraction:PomFluxRescale","link":"Diffraction.html#anchor18","text":"Diffraction:PomFluxRescale Rescale the Pomeron flux by this uniform factor. It should be Diffraction:PomFluxRescale 1 / PDF:PomRescale to preserve the convolution of Pomeron flux and PDFs, but for greater flxibility the two can be set separately."},{"name":"Diffraction:primKTwidth","link":"Diffraction.html#anchor6","text":"Diffraction:primKTwidth The width of Gaussian distributions in Diffraction:primKTwidth p_x and Diffraction:primKTwidth p_y separately that is assigned as a primordial Diffraction:primKTwidth kT to the two beam remnants when a gluon is kicked out of a diffractive system."},{"name":"Diffraction:probMaxPert","link":"Diffraction.html#anchor3","text":"Diffraction:probMaxPert The abovementioned maximum probability Diffraction:probMaxPert P_max.. Would normally be assumed to be unity, but a somewhat lower value could be used to represent a small nonperturbative component also at high diffractive masses."},{"name":"Diffraction:sampleType","link":"Diffraction.html#anchor17","text":"Diffraction:sampleType Type of process the user wants to generate. Depends strongly on how an event is classified as diffractive. Diffraction:sampleType Generate an inclusive sample of both diffractive and nondiffractive hard processes, MPI-unchecked. Diffraction:sampleType Generate an inclusive sample of both diffractive and nondiffractive hard processes, MPI-checked. Diffraction:sampleType Generate an exclusive diffractive sample, MPI-unchecked. Diffraction:sampleType Generate an exclusive diffractive sample, MPI-checked."},{"name":"Diffraction:sigmaRefPomP","link":"Diffraction.html#anchor8","text":"Diffraction:sigmaRefPomP The assumed Pomeron-proton effective cross section, as used for multiparton interactions in diffractive systems. If this cross section is made to depend on the mass of the diffractive system then the above value refers to the cross section at the reference scale, and Diffraction:sigmaRefPomP sigma_PomP(m) = sigma_PomP(m_ref) * (m / m_ref)^p where Diffraction:sigmaRefPomP m is the mass of the diffractive system, Diffraction:sigmaRefPomP m_ref is the reference mass scale Diffraction:sigmaRefPomP Diffraction:mRefPomP below and Diffraction:sigmaRefPomP p is the mass-dependence power Diffraction:sigmaRefPomP Diffraction:mPowPomP. Note that a larger cross section value gives less MPI activity per event. There is no point in making the cross section too big, however, since then Diffraction:sigmaRefPomP pT0 will be adjusted downwards to ensure that the integrated perturbative cross section stays above this assumed total cross section. (The requirement of at least one perturbative interaction per event.)"},{"name":"Diffraction:useMBRrenormalization","link":"Diffraction.html#anchor19","text":"Diffraction:useMBRrenormalization Use the renormalized MBR flux."},{"name":"DM:DYtype","link":"DarkMatterProcesses.html#anchor27","text":"DM:DYtype Select the co-annihilation partner to produce via Drell-Yan production. DM:DYtype Scalar lepton production.  Coupling to electrons, muons and taus can be fixed by DM:DYtype DM:yuk1 , DM:DYtype DM:yuk2 , and DM:DYtype DM:yuk3 respectively. DM:DYtype Production of charged partners (i.e. 'charginos'). DM:DYtype Production of doubly charged partners. DM:DYtype Production of neutral and singly-charged partners."},{"name":"DM:ffbar2Zp2XX","link":"DarkMatterProcesses.html#anchor8","text":"DM:ffbar2Zp2XX Scattering DM:ffbar2Zp2XX f fbar &rarr;Z'^0 &rarr; X Xbar. Code 6001. DM:ffbar2Zp2XX Z' is assumed to be on-shell."},{"name":"DM:ffbar2Zp2XXj","link":"DarkMatterProcesses.html#anchor10","text":"DM:ffbar2Zp2XXj Scattering DM:ffbar2Zp2XXj f fbar &rarr;Z'^0 j &rarr; X Xbar j. Code 6002. DM:ffbar2Zp2XXj Z' is assumed to be on-shell. (Not yet available.)"},{"name":"DM:ffbar2ZpH","link":"DarkMatterProcesses.html#anchor9","text":"DM:ffbar2ZpH Scattering DM:ffbar2ZpH f fbar &rarr;Z'^0 H. Code 6004. DM:ffbar2ZpH Z' is assumed to be on-shell. The coupling of the DM:ffbar2ZpH Z' to the SM Higgs is given by the parameter DM:ffbar2ZpH Zp:coupH. Interference with gamma/Z currently not implemented therefore this is only suitable when DM:ffbar2ZpH Z' &rarr; X Xbar.  This can be ensured using DM:ffbar2ZpH DM:ffbar2ZpH 55:onMode = off DM:ffbar2ZpH DM:ffbar2ZpH 55:onIfAny = 52"},{"name":"DM:gg2S2XX","link":"DarkMatterProcesses.html#anchor1","text":"DM:gg2S2XX Scattering DM:gg2S2XX g g &rarr; S &rarr; X Xbar. Code 6011. S is assumed to be on-shell."},{"name":"DM:gg2S2XXj","link":"DarkMatterProcesses.html#anchor2","text":"DM:gg2S2XXj Scattering DM:gg2S2XXj g g &rarr;S &rarr; X Xbar j. Code 6012. S is assumed to be on-shell. (Not yet available.)"},{"name":"DM:Lambda","link":"DarkMatterProcesses.html#anchor34","text":"DM:Lambda The suppression scale of the mixing. The Wilson co-efficient is absorbed into the suppression scale as there is no independent measurement to disentangle it from the scale."},{"name":"DM:M1","link":"DarkMatterProcesses.html#anchor32","text":"DM:M1 Mass of the DM singlet state."},{"name":"DM:M2","link":"DarkMatterProcesses.html#anchor33","text":"DM:M2 Mass of the DM N-plet state."},{"name":"DM:Nplet","link":"DarkMatterProcesses.html#anchor31","text":"DM:Nplet DM:Nplet Doublet DM:Nplet Triplet DM:Nplet Quintuplet"},{"name":"DM:qg2Zp2XXj","link":"DarkMatterProcesses.html#anchor11","text":"DM:qg2Zp2XXj Scattering DM:qg2Zp2XXj q g &rarr;Z'^0 j &rarr; X Xbar j. Code 6003. DM:qg2Zp2XXj Z' is assumed to be on-shell. (Not yet available.)"},{"name":"DM:qqbar2DY","link":"DarkMatterProcesses.html#anchor26","text":"DM:qqbar2DY Scattering DM:qqbar2DY q qbar &rarr; X_i Xbar_i. Code 6020."},{"name":"DM:yuk1","link":"DarkMatterProcesses.html#anchor28","text":"DM:yuk1 Electron-DM Yukawa."},{"name":"DM:yuk2","link":"DarkMatterProcesses.html#anchor29","text":"DM:yuk2 Muon-DM Yukawa."},{"name":"DM:yuk3","link":"DarkMatterProcesses.html#anchor30","text":"DM:yuk3 Tau-DM Yukawa."},{"name":"Event:startColTag","link":"EventRecord.html#anchor12","text":"Event:startColTag This sets the initial colour tag value used, so that the first one assigned is Event:startColTag startColTag + 1 , etc. The Les Houches accord Event:startColTag Boo01 suggests this number to be 500, but 100 works equally well."},{"name":"ExcitedFermion:all","link":"CompositenessProcesses.html#anchor1","text":"ExcitedFermion:all Common switch for the group of implemented processes that produce an excited fermion."},{"name":"ExcitedFermion:bg2bStar","link":"CompositenessProcesses.html#anchor6","text":"ExcitedFermion:bg2bStar Scatterings ExcitedFermion:bg2bStar b g &rarr; b^*. Code 4005."},{"name":"ExcitedFermion:cg2cStar","link":"CompositenessProcesses.html#anchor5","text":"ExcitedFermion:cg2cStar Scatterings ExcitedFermion:cg2cStar c g &rarr; c^*. Code 4004."},{"name":"ExcitedFermion:contactDec","link":"CompositenessProcesses.html#anchor31","text":"ExcitedFermion:contactDec Strength of contact-interaction decay channels, implemented as three-body decays ExcitedFermion:contactDec l^* &rarr; l f fbar for excited leptons and neutrinos, where unity corresponds to the same normalization as for the production channels."},{"name":"ExcitedFermion:coupF","link":"CompositenessProcesses.html#anchor28","text":"ExcitedFermion:coupF Strength ExcitedFermion:coupF f of the ExcitedFermion:coupF SU(2) coupling."},{"name":"ExcitedFermion:coupFcol","link":"CompositenessProcesses.html#anchor30","text":"ExcitedFermion:coupFcol Strength ExcitedFermion:coupFcol f_c of the ExcitedFermion:coupFcol SU(3) coupling."},{"name":"ExcitedFermion:coupFprime","link":"CompositenessProcesses.html#anchor29","text":"ExcitedFermion:coupFprime Strength ExcitedFermion:coupFprime f' of the ExcitedFermion:coupFprime U(1) coupling."},{"name":"ExcitedFermion:dg2dStar","link":"CompositenessProcesses.html#anchor2","text":"ExcitedFermion:dg2dStar Scatterings ExcitedFermion:dg2dStar d g &rarr; d^*. Code 4001."},{"name":"ExcitedFermion:egm2eStar","link":"CompositenessProcesses.html#anchor7","text":"ExcitedFermion:egm2eStar Scatterings ExcitedFermion:egm2eStar e gamma &rarr; e^*. Code 4011."},{"name":"ExcitedFermion:Lambda","link":"CompositenessProcesses.html#anchor27","text":"ExcitedFermion:Lambda Compositeness scale ExcitedFermion:Lambda Lambda in GeV."},{"name":"ExcitedFermion:mugm2muStar","link":"CompositenessProcesses.html#anchor8","text":"ExcitedFermion:mugm2muStar Scatterings ExcitedFermion:mugm2muStar mu gamma &rarr; mu^*. Code 4013."},{"name":"ExcitedFermion:qq2bStarq","link":"CompositenessProcesses.html#anchor14","text":"ExcitedFermion:qq2bStarq Scatterings ExcitedFermion:qq2bStarq q q(bar) &rarr; b^* q(bar). Code 4025."},{"name":"ExcitedFermion:qq2cStarq","link":"CompositenessProcesses.html#anchor13","text":"ExcitedFermion:qq2cStarq Scatterings ExcitedFermion:qq2cStarq q q(bar) &rarr; c^* q(bar). Code 4024."},{"name":"ExcitedFermion:qq2dStarq","link":"CompositenessProcesses.html#anchor10","text":"ExcitedFermion:qq2dStarq Scatterings ExcitedFermion:qq2dStarq q q(bar) &rarr; d^* q(bar). Code 4021."},{"name":"ExcitedFermion:qq2sStarq","link":"CompositenessProcesses.html#anchor12","text":"ExcitedFermion:qq2sStarq Scatterings ExcitedFermion:qq2sStarq q q(bar) &rarr; s^* q(bar). Code 4023."},{"name":"ExcitedFermion:qq2uStarq","link":"CompositenessProcesses.html#anchor11","text":"ExcitedFermion:qq2uStarq Scatterings ExcitedFermion:qq2uStarq q q(bar) &rarr; u^* q(bar). Code 4022."},{"name":"ExcitedFermion:qqbar2eStare","link":"CompositenessProcesses.html#anchor15","text":"ExcitedFermion:qqbar2eStare Scatterings ExcitedFermion:qqbar2eStare q qbar &rarr; e^*+- e^-+. Code 4031."},{"name":"ExcitedFermion:qqbar2eStareStar","link":"CompositenessProcesses.html#anchor21","text":"ExcitedFermion:qqbar2eStareStar Scatterings ExcitedFermion:qqbar2eStareStar q qbar &rarr; e^*+- e^*-+. Code 4051."},{"name":"ExcitedFermion:qqbar2muStarmu","link":"CompositenessProcesses.html#anchor17","text":"ExcitedFermion:qqbar2muStarmu Scatterings ExcitedFermion:qqbar2muStarmu q qbar &rarr; mu^*+- mu^-+. Code 4033."},{"name":"ExcitedFermion:qqbar2muStarmuStar","link":"CompositenessProcesses.html#anchor23","text":"ExcitedFermion:qqbar2muStarmuStar Scatterings ExcitedFermion:qqbar2muStarmuStar q qbar &rarr; mu^*+- mu^*-+. Code 4053."},{"name":"ExcitedFermion:qqbar2nueStarnue","link":"CompositenessProcesses.html#anchor16","text":"ExcitedFermion:qqbar2nueStarnue Scatterings ExcitedFermion:qqbar2nueStarnue q qbar &rarr; nu_e^* nu_ebar. Code 4032."},{"name":"ExcitedFermion:qqbar2nueStarnueStar","link":"CompositenessProcesses.html#anchor22","text":"ExcitedFermion:qqbar2nueStarnueStar Scatterings ExcitedFermion:qqbar2nueStarnueStar q qbar &rarr; nu_e^* nu_e^*bar. Code 4052."},{"name":"ExcitedFermion:qqbar2numuStarnumu","link":"CompositenessProcesses.html#anchor18","text":"ExcitedFermion:qqbar2numuStarnumu Scatterings ExcitedFermion:qqbar2numuStarnumu q qbar &rarr; nu_mu^* nu_mubar. Code 4034."},{"name":"ExcitedFermion:qqbar2numuStarnumuStar","link":"CompositenessProcesses.html#anchor24","text":"ExcitedFermion:qqbar2numuStarnumuStar Scatterings ExcitedFermion:qqbar2numuStarnumuStar q qbar &rarr; nu_mu^* nu_mu^*bar. Code 4054."},{"name":"ExcitedFermion:qqbar2nutauStarnutau","link":"CompositenessProcesses.html#anchor20","text":"ExcitedFermion:qqbar2nutauStarnutau Scatterings ExcitedFermion:qqbar2nutauStarnutau q qbar &rarr; nu_tau^* nu_taubar. Code 4036."},{"name":"ExcitedFermion:qqbar2nutauStarnutauStar","link":"CompositenessProcesses.html#anchor26","text":"ExcitedFermion:qqbar2nutauStarnutauStar Scatterings ExcitedFermion:qqbar2nutauStarnutauStar q qbar &rarr; nu_tau^* nu_tau^*bar. Code 4056."},{"name":"ExcitedFermion:qqbar2tauStartau","link":"CompositenessProcesses.html#anchor19","text":"ExcitedFermion:qqbar2tauStartau Scatterings ExcitedFermion:qqbar2tauStartau q qbar &rarr; tau^*+- tau^-+. Code 4035."},{"name":"ExcitedFermion:qqbar2tauStartauStar","link":"CompositenessProcesses.html#anchor25","text":"ExcitedFermion:qqbar2tauStartauStar Scatterings ExcitedFermion:qqbar2tauStartauStar q qbar &rarr; tau^*+- tau^*-+. Code 4055."},{"name":"ExcitedFermion:sg2sStar","link":"CompositenessProcesses.html#anchor4","text":"ExcitedFermion:sg2sStar Scatterings ExcitedFermion:sg2sStar s g &rarr; s^*. Code 4003."},{"name":"ExcitedFermion:taugm2tauStar","link":"CompositenessProcesses.html#anchor9","text":"ExcitedFermion:taugm2tauStar Scatterings ExcitedFermion:taugm2tauStar tau gamma &rarr; tau^*. Code 4015."},{"name":"ExcitedFermion:ug2uStar","link":"CompositenessProcesses.html#anchor3","text":"ExcitedFermion:ug2uStar Scatterings ExcitedFermion:ug2uStar u g &rarr; u^*. Code 4002."},{"name":"ExtraDimensionsG*:all","link":"ExtraDimensionalProcesses.html#anchor1","text":"ExtraDimensionsG*:all Common switch for the group of lowest-order ExtraDimensionsG*:all G^* production processes, i.e. the two ones below."},{"name":"ExtraDimensionsG*:ffbar2G*","link":"ExtraDimensionalProcesses.html#anchor3","text":"ExtraDimensionsG*:ffbar2G* Scatterings ExtraDimensionsG*:ffbar2G* f fbar &rarr; G^*. Code 5002."},{"name":"ExtraDimensionsG*:Gbb","link":"ExtraDimensionalProcesses.html#anchor13","text":"ExtraDimensionsG*:Gbb Coupling between graviton and bottom quark."},{"name":"ExtraDimensionsG*:gg2G*","link":"ExtraDimensionalProcesses.html#anchor2","text":"ExtraDimensionsG*:gg2G* Scatterings ExtraDimensionsG*:gg2G* g g &rarr; G^*. Code 5001."},{"name":"ExtraDimensionsG*:gg2G*g","link":"ExtraDimensionalProcesses.html#anchor4","text":"ExtraDimensionsG*:gg2G*g Scatterings ExtraDimensionsG*:gg2G*g g g &rarr; G^* g. Code 5003."},{"name":"ExtraDimensionsG*:Ggg","link":"ExtraDimensionalProcesses.html#anchor15","text":"ExtraDimensionsG*:Ggg Coupling between graviton and gluon."},{"name":"ExtraDimensionsG*:Ggmgm","link":"ExtraDimensionalProcesses.html#anchor16","text":"ExtraDimensionsG*:Ggmgm Coupling between graviton and gamma."},{"name":"ExtraDimensionsG*:Ghh","link":"ExtraDimensionalProcesses.html#anchor19","text":"ExtraDimensionsG*:Ghh Coupling between graviton and Higgs bosons."},{"name":"ExtraDimensionsG*:Gll","link":"ExtraDimensionalProcesses.html#anchor11","text":"ExtraDimensionsG*:Gll Coupling between graviton and leptons."},{"name":"ExtraDimensionsG*:Gqq","link":"ExtraDimensionalProcesses.html#anchor12","text":"ExtraDimensionsG*:Gqq Coupling between graviton and light quarks."},{"name":"ExtraDimensionsG*:Gtt","link":"ExtraDimensionalProcesses.html#anchor14","text":"ExtraDimensionsG*:Gtt Coupling between graviton and top quark."},{"name":"ExtraDimensionsG*:GWW","link":"ExtraDimensionalProcesses.html#anchor18","text":"ExtraDimensionsG*:GWW Coupling between graviton and W boson."},{"name":"ExtraDimensionsG*:GZZ","link":"ExtraDimensionalProcesses.html#anchor17","text":"ExtraDimensionsG*:GZZ Coupling between graviton and Z boson."},{"name":"ExtraDimensionsG*:kappaMG","link":"ExtraDimensionalProcesses.html#anchor10","text":"ExtraDimensionsG*:kappaMG dimensionless coupling, which enters quadratically in all on-shell partial widths of the ExtraDimensionsG*:kappaMG G^*. Is ExtraDimensionsG*:kappaMG kappa m_G* = sqrt(2) x_1 k / Mbar_Pl , where ExtraDimensionsG*:kappaMG x_1 = 3.83 is the first zero of the ExtraDimensionsG*:kappaMG J_1 Bessel function and ExtraDimensionsG*:kappaMG Mbar_Pl is the modified Planck mass. In width and cross section calculations, ExtraDimensionsG*:kappaMG kappa is fixed by the on-shell ExtraDimensionsG*:kappaMG G^* mass and ExtraDimensionsG*:kappaMG kappaMG , i.e. ExtraDimensionsG*:kappaMG kappaMG scales with the off-shell ExtraDimensionsG*:kappaMG G^* mass."},{"name":"ExtraDimensionsG*:KKgbL","link":"ExtraDimensionalProcesses.html#anchor23","text":"ExtraDimensionsG*:KKgbL Coupling between KK-gluon and a left-handed bottom quark."},{"name":"ExtraDimensionsG*:KKgbR","link":"ExtraDimensionalProcesses.html#anchor22","text":"ExtraDimensionsG*:KKgbR Coupling between KK-gluon and a right-handed bottom quark."},{"name":"ExtraDimensionsG*:KKgqL","link":"ExtraDimensionalProcesses.html#anchor21","text":"ExtraDimensionsG*:KKgqL Coupling between KK-gluon and a left-handed light quark."},{"name":"ExtraDimensionsG*:KKgqR","link":"ExtraDimensionalProcesses.html#anchor20","text":"ExtraDimensionsG*:KKgqR Coupling between KK-gluon and a right-handed light quark."},{"name":"ExtraDimensionsG*:KKgtL","link":"ExtraDimensionalProcesses.html#anchor25","text":"ExtraDimensionsG*:KKgtL Coupling between KK-gluon and a left-handed top quark."},{"name":"ExtraDimensionsG*:KKgtR","link":"ExtraDimensionalProcesses.html#anchor24","text":"ExtraDimensionsG*:KKgtR Coupling between KK-gluon and a right-handed top quark."},{"name":"ExtraDimensionsG*:KKintMode","link":"ExtraDimensionalProcesses.html#anchor26","text":"ExtraDimensionsG*:KKintMode Choice of full ExtraDimensionsG*:KKintMode g^*/KK-gluon^* structure or not in relevant processes. ExtraDimensionsG*:KKintMode full ExtraDimensionsG*:KKintMode g^*/KK-gluon^* structure, with interference included. ExtraDimensionsG*:KKintMode only pure ExtraDimensionsG*:KKintMode gluon_{SM} contribution. ExtraDimensionsG*:KKintMode only pure ExtraDimensionsG*:KKintMode gluon_{KK} contribution."},{"name":"ExtraDimensionsG*:qg2G*q","link":"ExtraDimensionalProcesses.html#anchor5","text":"ExtraDimensionsG*:qg2G*q Scatterings ExtraDimensionsG*:qg2G*q q g &rarr; G^* q. Code 5004."},{"name":"ExtraDimensionsG*:qqbar2G*g","link":"ExtraDimensionalProcesses.html#anchor6","text":"ExtraDimensionsG*:qqbar2G*g Scatterings ExtraDimensionsG*:qqbar2G*g q qbar &rarr; G^* g. Code 5005."},{"name":"ExtraDimensionsG*:qqbar2KKgluon*","link":"ExtraDimensionalProcesses.html#anchor7","text":"ExtraDimensionsG*:qqbar2KKgluon* Scatterings ExtraDimensionsG*:qqbar2KKgluon* q qbar &rarr; g^*/KKgluon^*. Code 5006."},{"name":"ExtraDimensionsG*:SMinBulk","link":"ExtraDimensionalProcesses.html#anchor8","text":"ExtraDimensionsG*:SMinBulk Parameter to choose between the two scenarios: ExtraDimensionsG*:SMinBulk off , SM on the TeV brane (common ExtraDimensionsG*:SMinBulk kappaMG coupling); ExtraDimensionsG*:SMinBulk on , SM in the ED bulk (flavour dependent couplings). This parameter is only relevant for the lowest-order graviton ( ExtraDimensionsG*:SMinBulk G* ) processes, where as the first-order processes corresponds to the ExtraDimensionsG*:SMinBulk off scenario."},{"name":"ExtraDimensionsG*:VLVL","link":"ExtraDimensionalProcesses.html#anchor9","text":"ExtraDimensionsG*:VLVL Parameter to specify Z/W coupling scenario: ExtraDimensionsG*:VLVL off , usual Z/W boson couplings; ExtraDimensionsG*:VLVL on , coupling only to longitudinal Z/W bosons. In both cases the ExtraDimensionsG*:VLVL GZZ and ExtraDimensionsG*:VLVL GWW values are used and this parameter is only relevant when ExtraDimensionsG*:VLVL SMinBulk = on. The formulas for longitudinal bosons should be appropriate up to ExtraDimensionsG*:VLVL O(m_V/E_V) corrections."},{"name":"ExtraDimensionsLED:c","link":"ExtraDimensionalProcesses.html#anchor67","text":"ExtraDimensionsLED:c Coupling related to scalar graviton emission."},{"name":"ExtraDimensionsLED:CutOffMode","link":"ExtraDimensionalProcesses.html#anchor64","text":"ExtraDimensionsLED:CutOffMode Options for when the hard scale of the process (e.g. ExtraDimensionsLED:CutOffMode sHat ) approaches or exceed the scale of validity of the low energy effective theory (e.g. ExtraDimensionsLED:CutOffMode M_D ). ExtraDimensionsLED:CutOffMode Note: Option 1 only concerns the graviton emission processes and the form factor is currently not available for the scalar graviton processes. ExtraDimensionsLED:CutOffMode Do nothing, i.e. all values of ExtraDimensionsLED:CutOffMode sHat contribute. ExtraDimensionsLED:CutOffMode Truncate contributing ExtraDimensionsLED:CutOffMode sHat region ( ExtraDimensionsLED:CutOffMode Ask09 ). ExtraDimensionsLED:CutOffMode Form factor, using ExtraDimensionsLED:CutOffMode mu = renormScale2. ExtraDimensionsLED:CutOffMode Form factor, using ExtraDimensionsLED:CutOffMode mu = E_jet."},{"name":"ExtraDimensionsLED:dijets","link":"ExtraDimensionalProcesses.html#anchor52","text":"ExtraDimensionsLED:dijets Common switch for the group of lowest-order ExtraDimensionsLED:dijets jet jet production processes with graviton exchange, i.e. the six ones below."},{"name":"ExtraDimensionsLED:ffbar2gammagamma","link":"ExtraDimensionalProcesses.html#anchor48","text":"ExtraDimensionsLED:ffbar2gammagamma Scatterings ExtraDimensionsLED:ffbar2gammagamma f fbar &rarr; (LED G*) &rarr; gamma gamma. If the graviton contribution is zero, the results corresponds to the SM contribution, i.e. equivalent to ExtraDimensionsLED:ffbar2gammagamma PromptPhoton:ffbar2gammagamma. Code 5026."},{"name":"ExtraDimensionsLED:ffbar2Ggamma","link":"ExtraDimensionalProcesses.html#anchor47","text":"ExtraDimensionsLED:ffbar2Ggamma Scatterings ExtraDimensionsLED:ffbar2Ggamma f fbar &rarr; G gamma. This process corresponds to the photon limit of the ExtraDimensionsLED:ffbar2Ggamma G Z process, as described in ExtraDimensionsLED:ffbar2Ggamma Ask09. Code 5025."},{"name":"ExtraDimensionsLED:ffbar2GZ","link":"ExtraDimensionalProcesses.html#anchor46","text":"ExtraDimensionsLED:ffbar2GZ Scatterings ExtraDimensionsLED:ffbar2GZ f fbar &rarr; G Z. Code 5024."},{"name":"ExtraDimensionsLED:ffbar2llbar","link":"ExtraDimensionalProcesses.html#anchor50","text":"ExtraDimensionsLED:ffbar2llbar Scatterings ExtraDimensionsLED:ffbar2llbar f fbar &rarr; (LED G*) &rarr; l l , where ExtraDimensionsLED:ffbar2llbar l is a charged lepton. If the graviton contribution is zero, the results corresponds to the SM contribution, i.e. similar to ExtraDimensionsLED:ffbar2llbar WeakSingleBoson:ffbar2gmZ. Does not include t-channel amplitude relevant for e^+e^- to e^+e^- and no K-factor is used. Code 5028."},{"name":"ExtraDimensionsLED:g","link":"ExtraDimensionalProcesses.html#anchor66","text":"ExtraDimensionsLED:g Coupling related to scalar graviton emission."},{"name":"ExtraDimensionsLED:gg2DJgg","link":"ExtraDimensionalProcesses.html#anchor53","text":"ExtraDimensionsLED:gg2DJgg Scatterings ExtraDimensionsLED:gg2DJgg g g &rarr; (LED G*) &rarr; g g. Code 5030."},{"name":"ExtraDimensionsLED:gg2DJqqbar","link":"ExtraDimensionalProcesses.html#anchor54","text":"ExtraDimensionsLED:gg2DJqqbar Scatterings ExtraDimensionsLED:gg2DJqqbar g g &rarr; (LED G*) &rarr; q qbar. Number of outgoing flavours specified by ExtraDimensionsLED:gg2DJqqbar nQuarkNew parameter below. Code 5031."},{"name":"ExtraDimensionsLED:gg2gammagamma","link":"ExtraDimensionalProcesses.html#anchor49","text":"ExtraDimensionsLED:gg2gammagamma Scatterings ExtraDimensionsLED:gg2gammagamma g g &rarr; (LED G*) &rarr; gamma gamma. Code 5027."},{"name":"ExtraDimensionsLED:gg2Gg","link":"ExtraDimensionalProcesses.html#anchor43","text":"ExtraDimensionsLED:gg2Gg Scatterings ExtraDimensionsLED:gg2Gg g g &rarr; G g. Code 5021."},{"name":"ExtraDimensionsLED:gg2llbar","link":"ExtraDimensionalProcesses.html#anchor51","text":"ExtraDimensionsLED:gg2llbar Scatterings ExtraDimensionsLED:gg2llbar g g &rarr; (LED G*) &rarr; l l. Code 5029."},{"name":"ExtraDimensionsLED:GravScalar","link":"ExtraDimensionalProcesses.html#anchor59","text":"ExtraDimensionsLED:GravScalar Allow the monojet processes to produce scalar graviton emission instead of the default tensor one. The scalar option is according to the processes described in ExtraDimensionsLED:GravScalar Azu05 and includes two coupling constants below."},{"name":"ExtraDimensionsLED:LambdaT","link":"ExtraDimensionalProcesses.html#anchor62","text":"ExtraDimensionsLED:LambdaT Ultraviolet cutoff parameter for the virtual graviton exchange processes."},{"name":"ExtraDimensionsLED:MD","link":"ExtraDimensionalProcesses.html#anchor61","text":"ExtraDimensionsLED:MD Fundamental scale of gravity in ExtraDimensionsLED:MD D = 4 + n dimensions."},{"name":"ExtraDimensionsLED:monojet","link":"ExtraDimensionalProcesses.html#anchor42","text":"ExtraDimensionsLED:monojet Common switch for the group of lowest-order ExtraDimensionsLED:monojet G jet emission processes, i.e. the three ones below."},{"name":"ExtraDimensionsLED:n","link":"ExtraDimensionalProcesses.html#anchor60","text":"ExtraDimensionsLED:n Number of extra dimensions."},{"name":"ExtraDimensionsLED:NegInt","link":"ExtraDimensionalProcesses.html#anchor63","text":"ExtraDimensionsLED:NegInt Allows to change sign of the interference terms in the graviton exchange processes, common in connection to using the ExtraDimensionsLED:NegInt Hewett convention ExtraDimensionsLED:NegInt Hew99. ExtraDimensionsLED:NegInt 1 ExtraDimensionsLED:NegInt -1"},{"name":"ExtraDimensionsLED:nQuarkNew","link":"ExtraDimensionalProcesses.html#anchor68","text":"ExtraDimensionsLED:nQuarkNew Number of allowed outgoing new quark flavours in the above ExtraDimensionsLED:nQuarkNew q qbar &rarr; (LED G*) &rarr; q' qbar' and ExtraDimensionsLED:nQuarkNew g g &rarr; (LED G*) &rarr; q' qbar' processes. Similar to ExtraDimensionsLED:nQuarkNew HardQCD:nQuarkNew for the QCD processes."},{"name":"ExtraDimensionsLED:opMode","link":"ExtraDimensionalProcesses.html#anchor69","text":"ExtraDimensionsLED:opMode Options to specify ExtraDimensionsLED:opMode S function for LED dijet amplitudes. ExtraDimensionsLED:opMode Use detailed amplitude, as described in ExtraDimensionsLED:opMode Fra11. ExtraDimensionsLED:opMode Use conventional ExtraDimensionsLED:opMode LambdaT parametrization, like the other LED processes."},{"name":"ExtraDimensionsLED:qg2DJqg","link":"ExtraDimensionalProcesses.html#anchor55","text":"ExtraDimensionsLED:qg2DJqg Scatterings ExtraDimensionsLED:qg2DJqg q g &rarr; (LED G*) &rarr; q g and ExtraDimensionsLED:qg2DJqg qbar g &rarr; (LED G*) &rarr; qbar g. Code 5032."},{"name":"ExtraDimensionsLED:qg2Gq","link":"ExtraDimensionalProcesses.html#anchor44","text":"ExtraDimensionsLED:qg2Gq Scatterings ExtraDimensionsLED:qg2Gq q g &rarr; G q. Code 5022."},{"name":"ExtraDimensionsLED:qq2DJqq","link":"ExtraDimensionalProcesses.html#anchor56","text":"ExtraDimensionsLED:qq2DJqq Scatterings ExtraDimensionsLED:qq2DJqq q q(bar)' &rarr; (LED G*) &rarr; q q(bar)'. Including ExtraDimensionsLED:qq2DJqq q and ExtraDimensionsLED:qq2DJqq qbar of same or different flavours, but the outgoing flavours equals the incoming ones. Code 5033."},{"name":"ExtraDimensionsLED:qqbar2DJgg","link":"ExtraDimensionalProcesses.html#anchor57","text":"ExtraDimensionsLED:qqbar2DJgg Scatterings ExtraDimensionsLED:qqbar2DJgg q qbar &rarr; (LED G*) &rarr; g g. Code 5034."},{"name":"ExtraDimensionsLED:qqbar2DJqqbarNew","link":"ExtraDimensionalProcesses.html#anchor58","text":"ExtraDimensionsLED:qqbar2DJqqbarNew Scatterings ExtraDimensionsLED:qqbar2DJqqbarNew q qbar &rarr; (LED G*) &rarr; q' qbar'. Number of outgoing flavours specified by ExtraDimensionsLED:qqbar2DJqqbarNew nQuarkNew parameter below. Code 5035."},{"name":"ExtraDimensionsLED:qqbar2Gg","link":"ExtraDimensionalProcesses.html#anchor45","text":"ExtraDimensionsLED:qqbar2Gg Scatterings ExtraDimensionsLED:qqbar2Gg q qbar &rarr; G g. Code 5023."},{"name":"ExtraDimensionsLED:t","link":"ExtraDimensionalProcesses.html#anchor65","text":"ExtraDimensionsLED:t Form factor parameter."},{"name":"ExtraDimensionsTEV:ffbar2bbbar","link":"ExtraDimensionalProcesses.html#anchor31","text":"ExtraDimensionsTEV:ffbar2bbbar Scatterings ExtraDimensionsTEV:ffbar2bbbar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; b bbar , Code 5065."},{"name":"ExtraDimensionsTEV:ffbar2ccbar","link":"ExtraDimensionalProcesses.html#anchor30","text":"ExtraDimensionsTEV:ffbar2ccbar Scatterings ExtraDimensionsTEV:ffbar2ccbar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; c cbar , Code 5064."},{"name":"ExtraDimensionsTEV:ffbar2ddbar","link":"ExtraDimensionalProcesses.html#anchor27","text":"ExtraDimensionsTEV:ffbar2ddbar Scatterings ExtraDimensionsTEV:ffbar2ddbar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; d dbar , Code 5061."},{"name":"ExtraDimensionsTEV:ffbar2e+e-","link":"ExtraDimensionalProcesses.html#anchor33","text":"ExtraDimensionsTEV:ffbar2e+e- Scatterings ExtraDimensionsTEV:ffbar2e+e- f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; e+ e- , Code 5071."},{"name":"ExtraDimensionsTEV:ffbar2mu+mu-","link":"ExtraDimensionalProcesses.html#anchor35","text":"ExtraDimensionsTEV:ffbar2mu+mu- Scatterings ExtraDimensionsTEV:ffbar2mu+mu- f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; mu+ mu- , Code 5073."},{"name":"ExtraDimensionsTEV:ffbar2nuenuebar","link":"ExtraDimensionalProcesses.html#anchor34","text":"ExtraDimensionsTEV:ffbar2nuenuebar Scatterings ExtraDimensionsTEV:ffbar2nuenuebar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; nue nuebar , Code 5072."},{"name":"ExtraDimensionsTEV:ffbar2numunumubar","link":"ExtraDimensionalProcesses.html#anchor36","text":"ExtraDimensionsTEV:ffbar2numunumubar Scatterings ExtraDimensionsTEV:ffbar2numunumubar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; numu numubar , Code 5074."},{"name":"ExtraDimensionsTEV:ffbar2nutaunutaubar","link":"ExtraDimensionalProcesses.html#anchor38","text":"ExtraDimensionsTEV:ffbar2nutaunutaubar Scatterings ExtraDimensionsTEV:ffbar2nutaunutaubar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; nutau nutaubar , Code 5076."},{"name":"ExtraDimensionsTEV:ffbar2ssbar","link":"ExtraDimensionalProcesses.html#anchor29","text":"ExtraDimensionsTEV:ffbar2ssbar Scatterings ExtraDimensionsTEV:ffbar2ssbar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; s sbar , Code 5063."},{"name":"ExtraDimensionsTEV:ffbar2tau+tau-","link":"ExtraDimensionalProcesses.html#anchor37","text":"ExtraDimensionsTEV:ffbar2tau+tau- Scatterings ExtraDimensionsTEV:ffbar2tau+tau- f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; tau+ tau- , Code 5075."},{"name":"ExtraDimensionsTEV:ffbar2ttbar","link":"ExtraDimensionalProcesses.html#anchor32","text":"ExtraDimensionsTEV:ffbar2ttbar Scatterings ExtraDimensionsTEV:ffbar2ttbar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; t tbar , Code 5066."},{"name":"ExtraDimensionsTEV:ffbar2uubar","link":"ExtraDimensionalProcesses.html#anchor28","text":"ExtraDimensionsTEV:ffbar2uubar Scatterings ExtraDimensionsTEV:ffbar2uubar f fbar &rarr; (gamma_{KK}/Z_{KK}) &rarr; u ubar , Code 5062."},{"name":"ExtraDimensionsTEV:gmZmode","link":"ExtraDimensionalProcesses.html#anchor39","text":"ExtraDimensionsTEV:gmZmode Choice of full ExtraDimensionsTEV:gmZmode gamma_{KK}/Z_{KK} structure or not in relevant processes. ExtraDimensionsTEV:gmZmode full ExtraDimensionsTEV:gmZmode gamma_{SM}/Z_{SM} structure, with interference included. ExtraDimensionsTEV:gmZmode only pure ExtraDimensionsTEV:gmZmode gamma_{SM} contribution. ExtraDimensionsTEV:gmZmode only pure ExtraDimensionsTEV:gmZmode Z_{SM} contribution. ExtraDimensionsTEV:gmZmode full ExtraDimensionsTEV:gmZmode gamma_{KK}/Z_{KK} structure, with interference included. ExtraDimensionsTEV:gmZmode only pure ExtraDimensionsTEV:gmZmode gamma_{KK} contribution, with SM interference included. ExtraDimensionsTEV:gmZmode only pure ExtraDimensionsTEV:gmZmode Z_{KK} contribution, with SM interference included."},{"name":"ExtraDimensionsTEV:mStar","link":"ExtraDimensionalProcesses.html#anchor41","text":"ExtraDimensionsTEV:mStar The KK mass ExtraDimensionsTEV:mStar m^* , given by the inverse of the single extra dimension radius."},{"name":"ExtraDimensionsTEV:nMax","link":"ExtraDimensionalProcesses.html#anchor40","text":"ExtraDimensionsTEV:nMax The number of included KK excitations."},{"name":"ExtraDimensionsUnpart:CutOffMode","link":"ExtraDimensionalProcesses.html#anchor85","text":"ExtraDimensionsUnpart:CutOffMode Options for when the hard scale of the process (e.g. ExtraDimensionsUnpart:CutOffMode sHat ) approaches or exceed the scale of validity of the low energy effective theory ( ExtraDimensionsUnpart:CutOffMode Lambda_U ). This mode only concerns the unparticle emission processes. ExtraDimensionsUnpart:CutOffMode Do nothing, i.e. all values of ExtraDimensionsUnpart:CutOffMode sHat contribute. ExtraDimensionsUnpart:CutOffMode Truncate contributing ExtraDimensionsUnpart:CutOffMode sHat region ( ExtraDimensionsUnpart:CutOffMode Ask09 )."},{"name":"ExtraDimensionsUnpart:dU","link":"ExtraDimensionalProcesses.html#anchor81","text":"ExtraDimensionsUnpart:dU Scale dimension parameter."},{"name":"ExtraDimensionsUnpart:ffbar2gammagamma","link":"ExtraDimensionalProcesses.html#anchor76","text":"ExtraDimensionsUnpart:ffbar2gammagamma Scatterings ExtraDimensionsUnpart:ffbar2gammagamma f fbar &rarr; (U*) &rarr; gamma gamma. If the unparticle contribution is zero in the spin-2 case, the results corresponds to the SM contribution, i.e. equivalent to ExtraDimensionsUnpart:ffbar2gammagamma PromptPhoton:ffbar2gammagamma. Code 5043."},{"name":"ExtraDimensionsUnpart:ffbar2llbar","link":"ExtraDimensionalProcesses.html#anchor78","text":"ExtraDimensionsUnpart:ffbar2llbar Scatterings ExtraDimensionsUnpart:ffbar2llbar f fbar &rarr; (U*) &rarr; l lbar , where ExtraDimensionsUnpart:ffbar2llbar l is a charged lepton. If the unparticle contribution is zero, the results corresponds to the SM contribution, i.e. similar to ExtraDimensionsUnpart:ffbar2llbar WeakSingleBoson:ffbar2gmZ. Does not include t-channel amplitude relevant for e^+e^- to e^+e^- and no K-factor is used. Code 5048."},{"name":"ExtraDimensionsUnpart:ffbar2Ugamma","link":"ExtraDimensionalProcesses.html#anchor75","text":"ExtraDimensionsUnpart:ffbar2Ugamma Scatterings ExtraDimensionsUnpart:ffbar2Ugamma f fbar &rarr; U gamma. This process corresponds to the photon limit of the ExtraDimensionsUnpart:ffbar2Ugamma U Z process, as described in ExtraDimensionsUnpart:ffbar2Ugamma Ask09. Code 5042."},{"name":"ExtraDimensionsUnpart:ffbar2UZ","link":"ExtraDimensionalProcesses.html#anchor74","text":"ExtraDimensionsUnpart:ffbar2UZ Scatterings ExtraDimensionsUnpart:ffbar2UZ f fbar &rarr; U Z. Code 5041."},{"name":"ExtraDimensionsUnpart:gg2gammagamma","link":"ExtraDimensionalProcesses.html#anchor77","text":"ExtraDimensionsUnpart:gg2gammagamma Scatterings ExtraDimensionsUnpart:gg2gammagamma g g &rarr; (U*) &rarr; gamma gamma. Code 5044."},{"name":"ExtraDimensionsUnpart:gg2llbar","link":"ExtraDimensionalProcesses.html#anchor79","text":"ExtraDimensionsUnpart:gg2llbar Scatterings ExtraDimensionsUnpart:gg2llbar g g &rarr; (U*) &rarr; l lbar. Code 5049."},{"name":"ExtraDimensionsUnpart:gg2Ug","link":"ExtraDimensionalProcesses.html#anchor71","text":"ExtraDimensionsUnpart:gg2Ug Scatterings ExtraDimensionsUnpart:gg2Ug g g &rarr; U g. Code 5045."},{"name":"ExtraDimensionsUnpart:gXX","link":"ExtraDimensionalProcesses.html#anchor86","text":"ExtraDimensionsUnpart:gXX Chiral unparticle couplings, ExtraDimensionsUnpart:gXX gXX = gLL = gRR. Only relevant for lepton production from spin-1 unparticle exchange. ExtraDimensionsUnpart:gXX 1 ExtraDimensionsUnpart:gXX -1 ExtraDimensionsUnpart:gXX 0"},{"name":"ExtraDimensionsUnpart:gXY","link":"ExtraDimensionalProcesses.html#anchor87","text":"ExtraDimensionsUnpart:gXY Chiral unparticle couplings, ExtraDimensionsUnpart:gXY gXY = gLR = gRL. Only relevant for lepton production from spin-1 unparticle exchange. ExtraDimensionsUnpart:gXY 1 ExtraDimensionsUnpart:gXY -1 ExtraDimensionsUnpart:gXY 0"},{"name":"ExtraDimensionsUnpart:lambda","link":"ExtraDimensionalProcesses.html#anchor83","text":"ExtraDimensionsUnpart:lambda Unparticle coupling to the SM fields."},{"name":"ExtraDimensionsUnpart:LambdaU","link":"ExtraDimensionalProcesses.html#anchor82","text":"ExtraDimensionsUnpart:LambdaU Unparticle renormalization scale."},{"name":"ExtraDimensionsUnpart:monojet","link":"ExtraDimensionalProcesses.html#anchor70","text":"ExtraDimensionsUnpart:monojet Common switch for the group of lowest-order ExtraDimensionsUnpart:monojet U jet emission processes, i.e. the three ones below."},{"name":"ExtraDimensionsUnpart:qg2Uq","link":"ExtraDimensionalProcesses.html#anchor72","text":"ExtraDimensionsUnpart:qg2Uq Scatterings ExtraDimensionsUnpart:qg2Uq q g &rarr; U q. Code 5046."},{"name":"ExtraDimensionsUnpart:qqbar2Ug","link":"ExtraDimensionalProcesses.html#anchor73","text":"ExtraDimensionsUnpart:qqbar2Ug Scatterings ExtraDimensionsUnpart:qqbar2Ug q qbar &rarr; U g. Code 5047."},{"name":"ExtraDimensionsUnpart:ratio","link":"ExtraDimensionalProcesses.html#anchor84","text":"ExtraDimensionsUnpart:ratio Ratio, ExtraDimensionsUnpart:ratio lambda'/lambda , between the two possible coupling constants of the spin-2 ME. ExtraDimensionsUnpart:ratio Warning: A ExtraDimensionsUnpart:ratio ratio value different from one give rise to an IR divergence which makes the event generation very slow, so this values is fixed to ExtraDimensionsUnpart:ratio ratio = 1 for the moment."},{"name":"ExtraDimensionsUnpart:spinU","link":"ExtraDimensionalProcesses.html#anchor80","text":"ExtraDimensionsUnpart:spinU Unparticle spin."},{"name":"FourthBottom:all","link":"FourthGenerationProcesses.html#anchor1","text":"FourthBottom:all Common switch for the group of FourthBottom:all b' production. Also includes the process FourthBottom:all f fbar' &rarr; t' b'bar in section 3 below."},{"name":"FourthBottom:ffbar2bPrimebPrimebar(s:gmZ)","link":"FourthGenerationProcesses.html#anchor5","text":"FourthBottom:ffbar2bPrimebPrimebar(s:gmZ) Scatterings FourthBottom:ffbar2bPrimebPrimebar(s:gmZ) f fbar &rarr; b' b'bar by FourthBottom:ffbar2bPrimebPrimebar(s:gmZ) s -channel exchange of a FourthBottom:ffbar2bPrimebPrimebar(s:gmZ) gamma^*/Z^0 boson. Code 804."},{"name":"FourthBottom:ffbar2bPrimeqbar(s:W)","link":"FourthGenerationProcesses.html#anchor6","text":"FourthBottom:ffbar2bPrimeqbar(s:W) Scatterings FourthBottom:ffbar2bPrimeqbar(s:W) f fbar' &rarr; b' qbar'' by FourthBottom:ffbar2bPrimeqbar(s:W) s -channel exchange of a FourthBottom:ffbar2bPrimeqbar(s:W) W^+- boson. Here FourthBottom:ffbar2bPrimeqbar(s:W) q'' is either FourthBottom:ffbar2bPrimeqbar(s:W) u or FourthBottom:ffbar2bPrimeqbar(s:W) c. Code 805."},{"name":"FourthBottom:ffbar2bPrimetbar(s:W)","link":"FourthGenerationProcesses.html#anchor7","text":"FourthBottom:ffbar2bPrimetbar(s:W) Scatterings FourthBottom:ffbar2bPrimetbar(s:W) f fbar' &rarr; b' tbar by FourthBottom:ffbar2bPrimetbar(s:W) s -channel exchange of a FourthBottom:ffbar2bPrimetbar(s:W) W^+- boson. Code 806."},{"name":"FourthBottom:gg2bPrimebPrimebar","link":"FourthGenerationProcesses.html#anchor2","text":"FourthBottom:gg2bPrimebPrimebar Scatterings FourthBottom:gg2bPrimebPrimebar g g &rarr; b' b'bar. Code 801."},{"name":"FourthBottom:qq2bPrimeq(t:W)","link":"FourthGenerationProcesses.html#anchor4","text":"FourthBottom:qq2bPrimeq(t:W) Scatterings FourthBottom:qq2bPrimeq(t:W) q q' &rarr; b' q'' by FourthBottom:qq2bPrimeq(t:W) t -channel exchange of a FourthBottom:qq2bPrimeq(t:W) W^+- boson. Code 803."},{"name":"FourthBottom:qqbar2bPrimebPrimebar","link":"FourthGenerationProcesses.html#anchor3","text":"FourthBottom:qqbar2bPrimebPrimebar Scatterings FourthBottom:qqbar2bPrimebPrimebar q qbar &rarr; b' b'bar by gluon exchange. Code 802."},{"name":"FourthGeneration:VcbPrime","link":"FourthGenerationProcesses.html#anchor17","text":"FourthGeneration:VcbPrime The FourthGeneration:VcbPrime V_cb' matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VtbPrime","link":"FourthGenerationProcesses.html#anchor18","text":"FourthGeneration:VtbPrime The FourthGeneration:VtbPrime V_tb' matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VtPrimeb","link":"FourthGenerationProcesses.html#anchor21","text":"FourthGeneration:VtPrimeb The FourthGeneration:VtPrimeb V_t'b matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VtPrimebPrime","link":"FourthGenerationProcesses.html#anchor22","text":"FourthGeneration:VtPrimebPrime The FourthGeneration:VtPrimebPrime V_t'b' matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VtPrimed","link":"FourthGenerationProcesses.html#anchor19","text":"FourthGeneration:VtPrimed The FourthGeneration:VtPrimed V_t'd matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VtPrimes","link":"FourthGenerationProcesses.html#anchor20","text":"FourthGeneration:VtPrimes The FourthGeneration:VtPrimes V_t's matrix element in the 4 * 4 CKM matrix."},{"name":"FourthGeneration:VubPrime","link":"FourthGenerationProcesses.html#anchor16","text":"FourthGeneration:VubPrime The FourthGeneration:VubPrime V_ub' matrix element in the 4 * 4 CKM matrix."},{"name":"FourthPair:ffbar2tauPrimenuPrimebar(s:W)","link":"FourthGenerationProcesses.html#anchor15","text":"FourthPair:ffbar2tauPrimenuPrimebar(s:W) Scatterings FourthPair:ffbar2tauPrimenuPrimebar(s:W) f fbar' &rarr; tau' nu'_taubar by FourthPair:ffbar2tauPrimenuPrimebar(s:W) s -channel exchange of a FourthPair:ffbar2tauPrimenuPrimebar(s:W) W^+- boson. Code 842."},{"name":"FourthPair:ffbar2tPrimebPrimebar(s:W)","link":"FourthGenerationProcesses.html#anchor14","text":"FourthPair:ffbar2tPrimebPrimebar(s:W) Scatterings FourthPair:ffbar2tPrimebPrimebar(s:W) f fbar' &rarr; t' b'bar by FourthPair:ffbar2tPrimebPrimebar(s:W) s -channel exchange of a FourthPair:ffbar2tPrimebPrimebar(s:W) W^+- boson. Code 841."},{"name":"FourthTop:all","link":"FourthGenerationProcesses.html#anchor8","text":"FourthTop:all Common switch for the group of FourthTop:all t' production. Also includes the process FourthTop:all f fbar' &rarr; t' b'bar in section 3 below."},{"name":"FourthTop:ffbar2tPrimeqbar(s:W)","link":"FourthGenerationProcesses.html#anchor13","text":"FourthTop:ffbar2tPrimeqbar(s:W) Scatterings FourthTop:ffbar2tPrimeqbar(s:W) f fbar' &rarr; t' qbar'' by FourthTop:ffbar2tPrimeqbar(s:W) s -channel exchange of a FourthTop:ffbar2tPrimeqbar(s:W) W^+- boson. Code 825."},{"name":"FourthTop:ffbar2tPrimetPrimebar(s:gmZ)","link":"FourthGenerationProcesses.html#anchor12","text":"FourthTop:ffbar2tPrimetPrimebar(s:gmZ) Scatterings FourthTop:ffbar2tPrimetPrimebar(s:gmZ) f fbar &rarr; t' t'bar by FourthTop:ffbar2tPrimetPrimebar(s:gmZ) s -channel exchange of a FourthTop:ffbar2tPrimetPrimebar(s:gmZ) gamma^*/Z^0 boson. Code 824."},{"name":"FourthTop:gg2tPrimetPrimebar","link":"FourthGenerationProcesses.html#anchor9","text":"FourthTop:gg2tPrimetPrimebar Scatterings FourthTop:gg2tPrimetPrimebar g g &rarr; t' t'bar. Code 821."},{"name":"FourthTop:qq2tPrimeq(t:W)","link":"FourthGenerationProcesses.html#anchor11","text":"FourthTop:qq2tPrimeq(t:W) Scatterings FourthTop:qq2tPrimeq(t:W) q q' &rarr; t' q'' by FourthTop:qq2tPrimeq(t:W) t -channel exchange of a FourthTop:qq2tPrimeq(t:W) W^+- boson. Code 823."},{"name":"FourthTop:qqbar2tPrimetPrimebar","link":"FourthGenerationProcesses.html#anchor10","text":"FourthTop:qqbar2tPrimetPrimebar Scatterings FourthTop:qqbar2tPrimetPrimebar q qbar &rarr; t' t'bar by gluon exchange. Code 822."},{"name":"Fragmentation:setVertices","link":"HadronScattering.html#anchor27","text":"Fragmentation:setVertices Normally primary hadron production vertices are not set, but if on they are. In the latter case the further switches and parameters below provide more detailed choices."},{"name":"FragmentationSystems:mJoin","link":"Fragmentation.html#anchor42","text":"FragmentationSystems:mJoin When two colour-connected partons are very nearby, with at least one being a gluon, they can be joined into one, to avoid technical problems of very small string regions. The requirement for joining is that the invariant mass of the pair is below FragmentationSystems:mJoin mJoin , where a gluon only counts with half its momentum, i.e. with its contribution to the string region under consideration. (Note that, for technical reasons, the 0.2 GeV lower limit is de facto hardcoded.)"},{"name":"FragmentationSystems:mJoinJunction","link":"Fragmentation.html#anchor43","text":"FragmentationSystems:mJoinJunction When the invariant mass of two of the quarks in a three-quark junction string system becomes too small, the system is simplified to a quark-diquark simple string. The requirement for this simplification is that the diquark mass, minus the two quark masses, falls below FragmentationSystems:mJoinJunction mJoinJunction. Gluons on the string between the junction and the respective quark, if any, are counted as part of the quark four-momentum. Those on the two combined legs are clustered with the diquark when it is formed."},{"name":"generic","link":"SUSYLesHouchesAccord.html#anchor10","text":"generic"},{"name":"HadronLevel:all","link":"MasterSwitches.html#anchor11","text":"HadronLevel:all If off then stop the generation after the hard process and parton-level activity has been generated, but before the hadron-level steps."},{"name":"HadronLevel:BoseEinstein","link":"MasterSwitches.html#anchor15","text":"HadronLevel:BoseEinstein Master switch for the simulation of Bose-Einstein effects; on/off = true/false. Further options are found HadronLevel:BoseEinstein here."},{"name":"HadronLevel:Decay","link":"MasterSwitches.html#anchor14","text":"HadronLevel:Decay Master switch for decays; on/off = true/false. Further options are found HadronLevel:Decay here."},{"name":"HadronLevel:DeuteronProduction","link":"MasterSwitches.html#anchor16","text":"HadronLevel:DeuteronProduction Master switch for the production of deuterons and anti-deuterons in an event; on/off = true/false. Further options are found HadronLevel:DeuteronProduction here."},{"name":"HadronLevel:Hadronize","link":"MasterSwitches.html#anchor12","text":"HadronLevel:Hadronize Master switch for hadronization; on/off = true/false. Further options are found HadronLevel:Hadronize here."},{"name":"HadronLevel:HadronScatter","link":"MasterSwitches.html#anchor13","text":"HadronLevel:HadronScatter Master switch for hadron rescattering, following the hadronization; on/off = true/false. Further options are found HadronLevel:HadronScatter here."},{"name":"HadronLevel:mStringMin","link":"Fragmentation.html#anchor41","text":"HadronLevel:mStringMin Decides whether a partonic system should be considered as a normal string or a ministring, the latter only producing one or two primary hadrons. The system mass should be above HadronLevel:mStringMin mStringMin plus the sum of quark/diquark constituent masses for a normal string description, else the ministring scenario is used."},{"name":"HadronScatter:afterDecay","link":"HadronScattering.html#anchor16","text":"HadronScatter:afterDecay Perform hadron scattering before or after first round of decays, involving very short-lived particles like the HadronScatter:afterDecay rho. The default is to perform scattering directly after the string fragmentation, before any decays."},{"name":"HadronScatter:allowDecayProd","link":"HadronScattering.html#anchor17","text":"HadronScatter:allowDecayProd Allow two hadrons with same parent hadron to scatter."},{"name":"HadronScatter:hadronSelect","link":"HadronScattering.html#anchor19","text":"HadronScatter:hadronSelect Probability that a hadron is soft enough to scatter. (A high- HadronScatter:hadronSelect pT hadron presumably being part of a jet, and thus produced away from the high-particle-density region at small transverse dimensions.) HadronScatter:hadronSelect HadronScatter:hadronSelect P = N exp(-pT^2 / 2 / sigma^2) /  ( (1 - k) exp(-pT^2 / 2 / sigma^2) + k pT0^p / (pT0^2 + pT^2)^(p/2), with HadronScatter:hadronSelect sigma = 2 StringPT:sigma and HadronScatter:hadronSelect pT0 the same as that used in HadronScatter:hadronSelect MultipartonInteractions."},{"name":"HadronScatter:j","link":"HadronScattering.html#anchor24","text":"HadronScatter:j HadronScatter:j j parameter as above."},{"name":"HadronScatter:k","link":"HadronScattering.html#anchor21","text":"HadronScatter:k HadronScatter:k k parameter as above."},{"name":"HadronScatter:maxProbDS","link":"HadronScattering.html#anchor10","text":"HadronScatter:maxProbDS The maximum probability HadronScatter:maxProbDS P HadronScatter:maxProbDS max HadronScatter:maxProbDS DS for the  scattering of two hadrons that are not part of the same string."},{"name":"HadronScatter:maxProbSS","link":"HadronScattering.html#anchor14","text":"HadronScatter:maxProbSS The maximum probability HadronScatter:maxProbSS P HadronScatter:maxProbSS max HadronScatter:maxProbSS SS for the  scattering of two hadrons within the same string. (Relative to that for  different strings, i.e. for the total probability the baseline HadronScatter:maxProbSS maxProbDS factor also enters.)"},{"name":"HadronScatter:minProbSS","link":"HadronScattering.html#anchor13","text":"HadronScatter:minProbSS The minimum probability HadronScatter:minProbSS P HadronScatter:minProbSS min HadronScatter:minProbSS SS for the  scattering of two hadrons within the same string. (Relative to that for  different strings, i.e. for the total probability the baseline HadronScatter:minProbSS maxProbDS factor also enters.)"},{"name":"HadronScatter:mode","link":"HadronScattering.html#anchor1","text":"HadronScatter:mode The first two options are variations of the same model, whereas option 2 respresents a different model. HadronScatter:mode The new model, based on separation in rapidity as described in HadronScatter:mode Fis16. Further options are found HadronScatter:mode here. HadronScatter:mode The new model, based on separation in rapidity and azimuthal angle as described in HadronScatter:mode Fis16. Further options are found HadronScatter:mode here. HadronScatter:mode The old model. Further options are found HadronScatter:mode here. HadronScatter:mode Warning: Option 2 is still at an experimental level, and should not be used unless you know what you are doing."},{"name":"HadronScatter:N","link":"HadronScattering.html#anchor20","text":"HadronScatter:N HadronScatter:N N parameter as above."},{"name":"HadronScatter:neighbourFar","link":"HadronScattering.html#anchor12","text":"HadronScatter:neighbourFar If scattering of hadrons within the same string is allowed this  parameter gives the neighbour starting from which the maximum  probability HadronScatter:neighbourFar maxProbSS is applied."},{"name":"HadronScatter:neighbourNear","link":"HadronScattering.html#anchor11","text":"HadronScatter:neighbourNear If scattering of hadrons within the same string is allowed this  parameter gives the closest neighbour that is allowed. The value 1  corresponds to the direct neighbour. The probability associated  with this potential scattering partner is HadronScatter:neighbourNear minProbSS."},{"name":"HadronScatter:p","link":"HadronScattering.html#anchor22","text":"HadronScatter:p HadronScatter:p p parameter as above."},{"name":"HadronScatter:pMax","link":"HadronScattering.html#anchor3","text":"HadronScatter:pMax"},{"name":"HadronScatter:rMax","link":"HadronScattering.html#anchor25","text":"HadronScatter:rMax HadronScatter:rMax rMax parameter as above."},{"name":"HadronScatter:Rmax","link":"HadronScattering.html#anchor6","text":"HadronScatter:Rmax"},{"name":"HadronScatter:scatterMultipleTimes","link":"HadronScattering.html#anchor9","text":"HadronScatter:scatterMultipleTimes If switched off, each hadron is only allowed to scatter at most once.  By the way that possible scattering pairs are considered in order of  increasing rapidity separation, this introduces a bias towards pairs  with small HadronScatter:scatterMultipleTimes y separation."},{"name":"HadronScatter:scatterProb","link":"HadronScattering.html#anchor23","text":"HadronScatter:scatterProb Probability for a pair of hadrons to scatter. HadronScatter:scatterProb All hadrons scatter with probability HadronScatter:scatterProb j max(0, 1 - dR^2 / rMax^2). Angular distribution is picked flat in HadronScatter:scatterProb cos(theta). HadronScatter:scatterProb As option 0, above, but only HadronScatter:scatterProb pi-pi , HadronScatter:scatterProb pi-K and HadronScatter:scatterProb pi-p scatterings are considered. HadronScatter:scatterProb Only HadronScatter:scatterProb pi-pi , HadronScatter:scatterProb pi-K and HadronScatter:scatterProb pi-p scatterings are considered, with probability given by HadronScatter:scatterProb (1 - exp(-j sigEl)) max(0, 1 - dR^2 / rMax^2). The elastic cross sections and angular distributions are taken from the partial-wave distributions."},{"name":"HadronScatter:scatterRepeat","link":"HadronScattering.html#anchor18","text":"HadronScatter:scatterRepeat Allow hadrons which have already scattered to scatter again. Even if switched on, the same pair can not scatter off each other twice."},{"name":"HadronScatter:scatterSameString","link":"HadronScattering.html#anchor8","text":"HadronScatter:scatterSameString If switched on, strings within the same string are allowed to  scatter off each other. Otherwise only hadron pairs that are  not produced on the same string are taken into account."},{"name":"HadronScatter:tile","link":"HadronScattering.html#anchor26","text":"HadronScatter:tile Use tiling in HadronScatter:tile (eta, phi) to reduce number of pairwise tests."},{"name":"HadronScatter:yDiffMax","link":"HadronScattering.html#anchor4","text":"HadronScatter:yDiffMax"},{"name":"HadronVertex:constantTau","link":"HadronScattering.html#anchor32","text":"HadronVertex:constantTau The transverse smearing might change either the time coordinate or the invariant time of the breakup points with respect to the origin. Normally, the HadronVertex:constantTau tau is kept constant and the time coordinate is recalculated to compensate the effect of the smearing. If off, the time coordinate is kept constant and the invariant time is modified by the smearing."},{"name":"HadronVertex:intermediateTau0","link":"HadronScattering.html#anchor34","text":"HadronVertex:intermediateTau0 Average lifetime HadronVertex:intermediateTau0 c * tau_0 , expressed in mm, assigned to particle species which are unstable, but have neither been assigned a nonvanishing lifetime nor a non-negligible (above HadronVertex:intermediateTau0 NARROWMASS ) width. For such cases an intermediate scale is chosen, such that the decays happen well separated from the primary vertex, and yet not as far away as to give rise to an experimentally discernible secondary vertex. The default HadronVertex:intermediateTau0 10^-9 mm = 1000 fm meets this requirement, and is additionally a reasonable value for the particles that mainly decay electromagnetically. The value is also used for a few rare particles that probably have a non-negligible width, but are so poorly known that no width is listed in the Review of Particle Physics."},{"name":"HadronVertex:kappa","link":"HadronScattering.html#anchor29","text":"HadronVertex:kappa The string tension HadronVertex:kappa kappa in units of GeV/fm, i.e. how much energy is stored in a string per unit length."},{"name":"HadronVertex:mode","link":"HadronScattering.html#anchor28","text":"HadronVertex:mode The definition of hadron production points is not unique, and here three alternatives are considered: one early, one late and one in the middle. Further expressions below are written for a hadron HadronVertex:mode i produced between two string vertices HadronVertex:mode i and HadronVertex:mode i+1. HadronVertex:mode A hadron production point is defined as the middle point between the two breakup vertices, HadronVertex:mode v HadronVertex:mode h HadronVertex:mode i = (v HadronVertex:mode i + v HadronVertex:mode i+1 )/2. HadronVertex:mode An 'early' hadron production, counted backwards to the point where a fictitious string oscillation could have begun that would have reached the two string breakup vertices above. Given the hadronic four-momentum HadronVertex:mode p HadronVertex:mode h and the string tension HadronVertex:mode kappa , this vertex would be HadronVertex:mode v HadronVertex:mode h HadronVertex:mode i = (v HadronVertex:mode i + v HadronVertex:mode i+1 )/2 - p HadronVertex:mode h HadronVertex:mode i / (2 kappa). With this prescription is is possible to obtain a negative squared proper time, since the HadronVertex:mode p HadronVertex:mode h contains a transverse-momentum smearing that does not quite match up with longitudinal-momentum string picture. In such cases the negative term is scaled down to give a vanishing proper time. HadronVertex:mode A 'late' hadron production, defined as the point where the two partons that form the hadron cross for the first time. The hadron momentum contribution then shifts sign relative to the previous option, HadronVertex:mode v HadronVertex:mode h HadronVertex:mode i = (v HadronVertex:mode i + v HadronVertex:mode i+1 )/2 + p HadronVertex:mode h HadronVertex:mode i / (2 kappa) , and there is no problem with negative squared proper times."},{"name":"HadronVertex:rapidDecays","link":"HadronScattering.html#anchor33","text":"HadronVertex:rapidDecays The decay products of particles with short lifetimes, such as rho, should be displaced from the production point of the mother particle. When on, the corresponding displacement is included in the space--time location of the daughter production points. More specifically, the width stored for these particles are inverted to give the respective lifetimes. (Even more specifically, the width must be above HadronVertex:rapidDecays NARROWMASS = HadronVertex:rapidDecays 10^-6 GeV .) Particles that by default already have a nonvanishing lifetime (in the database or set by the user) are always given a displaced vertex based on that value, so for them this flag makes no difference. See below for unstable particles that have neither a know width nor a known lifetime."},{"name":"HadronVertex:smearOn","link":"HadronScattering.html#anchor30","text":"HadronVertex:smearOn When on, the space--time location of breakp points is smear in transverse space accordingly to the value of xySmear given."},{"name":"HadronVertex:xySmear","link":"HadronScattering.html#anchor31","text":"HadronVertex:xySmear Transverse smearing of the hadron production vertices in units of fm. This is initially assigned as a Gaussian smearing of the string breakup vertices in the plane perpendicular to the string direction. The HadronVertex:xySmear xySmear parameter is picked such that a breakup vertex should have a smearing HadronVertex:xySmear <x^2 + y^2> = xySmear^2 for a simple string along the HadronVertex:xySmear z direction. The default value has been picked roughly like HadronVertex:xySmear sqrt(2/3) of the proton radius, to represent two out of three spatial directions. For a hadron this is then averaged, as described above in HadronVertex:xySmear v HadronVertex:xySmear h HadronVertex:xySmear i = (v HadronVertex:xySmear i + v HadronVertex:xySmear i+1 )/2 and its variants, giving a width reduction of 1/sqrt(2)."},{"name":"HadScatNew1","link":"HadronScattering.html#anchor2","text":"HadScatNew1"},{"name":"HadScatNew2","link":"HadronScattering.html#anchor5","text":"HadScatNew2"},{"name":"HadScatNewCom","link":"HadronScattering.html#anchor7","text":"HadScatNewCom"},{"name":"HadScatOld","link":"HadronScattering.html#anchor15","text":"HadScatOld"},{"name":"HardQCD:3parton","link":"QCDProcesses.html#anchor22","text":"HardQCD:3parton Common switch for the group of all hard QCD processes with three partons in the final state, as listed separately in the following."},{"name":"HardQCD:all","link":"QCDProcesses.html#anchor8","text":"HardQCD:all Common switch for the group of all hard QCD processes, as listed separately in the following."},{"name":"HardQCD:gg2bbbar","link":"QCDProcesses.html#anchor19","text":"HardQCD:gg2bbbar Scatterings HardQCD:gg2bbbar g g &rarr; b bbar. Code 123."},{"name":"HardQCD:gg2ccbar","link":"QCDProcesses.html#anchor16","text":"HardQCD:gg2ccbar Scatterings HardQCD:gg2ccbar g g &rarr; c cbar. Code 121."},{"name":"HardQCD:gg2gg","link":"QCDProcesses.html#anchor9","text":"HardQCD:gg2gg Scatterings HardQCD:gg2gg g g &rarr; g g. Code 111."},{"name":"HardQCD:gg2ggg","link":"QCDProcesses.html#anchor23","text":"HardQCD:gg2ggg Scatterings HardQCD:gg2ggg g g &rarr; g g g. Code 131."},{"name":"HardQCD:gg2qqbar","link":"QCDProcesses.html#anchor10","text":"HardQCD:gg2qqbar Scatterings HardQCD:gg2qqbar g g &rarr; q qbar , where HardQCD:gg2qqbar q by default is a light quark ( HardQCD:gg2qqbar u, d, s ) (see below). Code 112."},{"name":"HardQCD:gg2qqbarg","link":"QCDProcesses.html#anchor30","text":"HardQCD:gg2qqbarg Scatterings HardQCD:gg2qqbarg g g &rarr; q qbar g , where HardQCD:gg2qqbarg q by default is a light quark ( HardQCD:gg2qqbarg u, d, s ) (see HardQCD:gg2qqbarg HardQCD:nQuarkNew above). Code 138."},{"name":"HardQCD:hardbbbar","link":"QCDProcesses.html#anchor21","text":"HardQCD:hardbbbar Sum of the previous two event types. Codes 123 and 124."},{"name":"HardQCD:hardccbar","link":"QCDProcesses.html#anchor18","text":"HardQCD:hardccbar Sum of the previous two event types. Codes 121 and 122."},{"name":"HardQCD:nQuarkNew","link":"QCDProcesses.html#anchor15","text":"HardQCD:nQuarkNew Number of allowed outgoing new quark flavours in the above HardQCD:nQuarkNew g g &rarr; q qbar and HardQCD:nQuarkNew q qbar &rarr; q' qbar' processes, where quarks are treated as massless in the matrix-element expressions (but correctly in the phase space). It is thus assumed that HardQCD:nQuarkNew c cbar and HardQCD:nQuarkNew b bbar are added separately with masses taken into account, using the processes below. A change to 4 would also include HardQCD:nQuarkNew c cbar in the massless approximation, etc. In order to avoid double-counting the processes below should then not be used simultaneously."},{"name":"HardQCD:qg2qg","link":"QCDProcesses.html#anchor11","text":"HardQCD:qg2qg Scatterings HardQCD:qg2qg q g &rarr; q g and HardQCD:qg2qg qbar g &rarr; qbar g. Code 113."},{"name":"HardQCD:qg2qgg","link":"QCDProcesses.html#anchor25","text":"HardQCD:qg2qgg Scatterings HardQCD:qg2qgg q g &rarr; q g g and HardQCD:qg2qgg qbar g &rarr; qbar g g. Code 133."},{"name":"HardQCD:qg2qqqbarDiff","link":"QCDProcesses.html#anchor31","text":"HardQCD:qg2qqqbarDiff Scatterings HardQCD:qg2qqqbarDiff q g &rarr; q q' qbar' and HardQCD:qg2qqqbarDiff qbar g &rarr; qbar qbar' q' , where HardQCD:qg2qqqbarDiff q' by default is a light quark ( HardQCD:qg2qqqbarDiff u, d, s ) (see HardQCD:qg2qqqbarDiff HardQCD:nQuarkNew above). Code 139."},{"name":"HardQCD:qg2qqqbarSame","link":"QCDProcesses.html#anchor32","text":"HardQCD:qg2qqqbarSame Scatterings HardQCD:qg2qqqbarSame q g &rarr; q q qbar and HardQCD:qg2qqqbarSame qbar g &rarr; qbar qbar q. Code 140."},{"name":"HardQCD:qq2qq","link":"QCDProcesses.html#anchor12","text":"HardQCD:qq2qq Scatterings HardQCD:qq2qq q q' &rarr; q q' , HardQCD:qq2qq q qbar' &rarr; q qbar' , HardQCD:qq2qq qbar qbar' &rarr; qbar qbar' , where HardQCD:qq2qq q' and HardQCD:qq2qq q may agree, but the outgoing flavours equals the incoming ones Code 114."},{"name":"HardQCD:qq2qqgDiff","link":"QCDProcesses.html#anchor26","text":"HardQCD:qq2qqgDiff Scatterings HardQCD:qq2qqgDiff q q' &rarr; q q' g , HardQCD:qq2qqgDiff q qbar' &rarr; q qbar' g , and HardQCD:qq2qqgDiff qbar qbar' &rarr; qbar qbar' g. Code 134."},{"name":"HardQCD:qq2qqgSame","link":"QCDProcesses.html#anchor27","text":"HardQCD:qq2qqgSame Scatterings HardQCD:qq2qqgSame q q &rarr; q q g and HardQCD:qq2qqgSame qbar qbar &rarr; qbar qbar g ( HardQCD:qq2qqgSame q qbar &rarr; q qbar g scatterings are considered separately below, see HardQCD:qq2qqgSame HardQCD:qqbar2qqbargSame ). Code 135."},{"name":"HardQCD:qqbar2bbbar","link":"QCDProcesses.html#anchor20","text":"HardQCD:qqbar2bbbar Scatterings HardQCD:qqbar2bbbar q qbar &rarr; b bbar. Code 124."},{"name":"HardQCD:qqbar2ccbar","link":"QCDProcesses.html#anchor17","text":"HardQCD:qqbar2ccbar Scatterings HardQCD:qqbar2ccbar q qbar &rarr; c cbar. Code 122."},{"name":"HardQCD:qqbar2gg","link":"QCDProcesses.html#anchor13","text":"HardQCD:qqbar2gg Scatterings HardQCD:qqbar2gg q qbar &rarr; g g. Code 115."},{"name":"HardQCD:qqbar2ggg","link":"QCDProcesses.html#anchor24","text":"HardQCD:qqbar2ggg Scatterings HardQCD:qqbar2ggg q qbar &rarr; g g g. Code 132."},{"name":"HardQCD:qqbar2qqbargDiff","link":"QCDProcesses.html#anchor28","text":"HardQCD:qqbar2qqbargDiff Scatterings HardQCD:qqbar2qqbargDiff q qbar &rarr; q' qbar' g , where HardQCD:qqbar2qqbargDiff q' by default is a light quark ( HardQCD:qqbar2qqbargDiff u, d, s ) (see HardQCD:qqbar2qqbargDiff HardQCD:nQuarkNew above). Code 136."},{"name":"HardQCD:qqbar2qqbargSame","link":"QCDProcesses.html#anchor29","text":"HardQCD:qqbar2qqbargSame Scatterings HardQCD:qqbar2qqbargSame q qbar &rarr; q qbar g. Code 137."},{"name":"HardQCD:qqbar2qqbarNew","link":"QCDProcesses.html#anchor14","text":"HardQCD:qqbar2qqbarNew Scatterings HardQCD:qqbar2qqbarNew q qbar &rarr; q' qbar' , where HardQCD:qqbar2qqbarNew q' by default is a light quark ( HardQCD:qqbar2qqbarNew u, d, s ) (see below). Code 116."},{"name":"HeavyIon:bWidth","link":"HeavyIons.html#anchor8","text":"HeavyIon:bWidth The width in fermi of the distribution by which the impact parameter  is sampled. If zero, a suitable width must be guessed by the HeavyIon:bWidth ImpactParamerGenerator itself."},{"name":"HeavyIon:gaussHardCore","link":"HeavyIons.html#anchor5","text":"HeavyIon:gaussHardCore Option to use a Gaussian profile of the hard core instead of a sharp  cut-off, inspired by HeavyIon:gaussHardCore Bay95."},{"name":"HeavyIon:mode","link":"HeavyIons.html#anchor1","text":"HeavyIon:mode This is the master switch for heavy ions, and determines the mode of operation of the HeavyIon model. HeavyIon:mode The heavy ion machinery will be used in case of ion beams. HeavyIon:mode Even collisions without ions are treated using the heavy ion machinery. (Typically only used for debugging purposes.)"},{"name":"HeavyIon:showInit","link":"HeavyIons.html#anchor2","text":"HeavyIon:showInit Output detailed initialization information from the heavy ion model. Typically there will be several HeavyIon:showInit Pythia object initialised in a heavy ion run, this flag can be used to reduce the amount of output. If off, only the output from initialisation of the primary HeavyIon:showInit Pythia object will be shown"},{"name":"HeavyIon:SigFitDefPar","link":"HeavyIons.html#anchor10","text":"HeavyIon:SigFitDefPar These are the default values of the parameters of the HeavyIon:SigFitDefPar SubCollisionModel in Angantyr. They will be used as starting point when fitting to the inclusive nucleon cross sections."},{"name":"HeavyIon:SigFitErr","link":"HeavyIons.html#anchor11","text":"HeavyIon:SigFitErr The relative error assumed in the calculation of goodness of fit corresponding to the different cross sections fitted to. The cross sections are obtained from the HeavyIon:SigFitErr HeavyIon:SigFitErr SigmaTotal and are given as (in order) total, non-diffractive, double diffractive, wounded target, wounded projectile, central diffractive, and elastic cross sections, and in addition the elastic slope parameter. A relative error of zero for one of these cross sections means the corresponding cross section not be used in the fit."},{"name":"HeavyIon:SigFitFuzz","link":"HeavyIons.html#anchor15","text":"HeavyIon:SigFitFuzz A parameter determining the probability that an individual parameter setting will evolves further away from the best parameter set in each generation."},{"name":"HeavyIon:SigFitNGen","link":"HeavyIons.html#anchor14","text":"HeavyIon:SigFitNGen The number of generation used in the genetic algorithm. If set to zero, no fitting will be performed and the values in HeavyIon:SigFitNGen HeavyIon:SigFitDefPar will be used."},{"name":"HeavyIon:SigFitNInt","link":"HeavyIons.html#anchor12","text":"HeavyIon:SigFitNInt The number of integration points used for each parameter setting to calculate the cross sections."},{"name":"HeavyIon:SigFitNPop","link":"HeavyIons.html#anchor13","text":"HeavyIon:SigFitNPop The number individuals (parameter settings) in a population in each  generation."},{"name":"HeavyIon:SigFitPrint","link":"HeavyIons.html#anchor16","text":"HeavyIon:SigFitPrint Controls the output from the fitting procedure. If on, extensive information about the fitting will be printed."},{"name":"HeavyIon:WSa","link":"HeavyIons.html#anchor7","text":"HeavyIon:WSa The HeavyIon:WSa skin width of a nucleus in units of fermi in the default Woods-Saxon model for nucleon distributions.  If zero, the size is given by the numbers in HeavyIon:WSa Ryb14 , based on the number of nucleons in the nuclus and whether a hard core is used or not."},{"name":"HeavyIon:WSHardCore","link":"HeavyIons.html#anchor3","text":"HeavyIon:WSHardCore In the default Woods-Saxon model for nucleon distributions, assume  that there is a minimum distance between nucleons defined by a hard  core radius in HeavyIon:WSHardCore HeavyIon:WSRh."},{"name":"HeavyIon:WSR","link":"HeavyIons.html#anchor6","text":"HeavyIon:WSR The radius of a nucleon in units of fermi in the default Woods-Saxon model for nucleon distributions. If zero, the size is given by the formulae HeavyIon:WSR Ryb14 , based on the number of nucleons in the nuclei and whether a hard core is used or not."},{"name":"HeavyIon:WSRh","link":"HeavyIons.html#anchor4","text":"HeavyIon:WSRh The hard core radius in units of fermi, defining the minimum  distance between nucleons in a nucleus in the default Woods-Saxon  model for nucleon distributions."},{"name":"HiddenValley:all","link":"HiddenValleyProcesses.html#anchor7","text":"HiddenValley:all Common switch for the group of all hard Hidden Valley processes, as listed separately in the following."},{"name":"HiddenValley:alphaFSR","link":"HiddenValleyProcesses.html#anchor35","text":"HiddenValley:alphaFSR fixed alpha scale of HiddenValley:alphaFSR gv/gammav emission; corresponds to HiddenValley:alphaFSR alpha_strong of QCD or HiddenValley:alphaFSR alpha_em of QED. For shower branchings such as HiddenValley:alphaFSR Dv &rarr; Dv + gv the coupling is multiplied by HiddenValley:alphaFSR C_F = (N^2 - 1) / (2 * N) for an HiddenValley:alphaFSR SU(N) group and for HiddenValley:alphaFSR gv &rarr; gv + gv by HiddenValley:alphaFSR N."},{"name":"HiddenValley:alphaOrder","link":"HiddenValleyProcesses.html#anchor34","text":"HiddenValley:alphaOrder Order at which HiddenValley:alphaOrder alpha_HV runs, HiddenValley:alphaOrder zeroth order, i.e. HiddenValley:alphaOrder alpha_HV is kept fixed at the value HiddenValley:alphaOrder alphaFSR. HiddenValley:alphaOrder first order, with the beta function based on HiddenValley:alphaOrder Ngauge and HiddenValley:alphaOrder Nflav."},{"name":"HiddenValley:aLund","link":"HiddenValleyProcesses.html#anchor41","text":"HiddenValley:aLund The HiddenValley:aLund a parameter of the Lund symmetric fragmentation function. See the normal HiddenValley:aLund fragmentation function description for the shape of this function."},{"name":"HiddenValley:bmqv2","link":"HiddenValleyProcesses.html#anchor42","text":"HiddenValley:bmqv2 The HiddenValley:bmqv2 b parameter of the Lund symmetric fragmentation function, multiplied by the square of the HiddenValley:bmqv2 qv mass. This scaling ensures that the fragmentation function keeps the same shape when the HiddenValley:bmqv2 qv mass is changed (neglecting transverse momenta)."},{"name":"HiddenValley:doKinMix","link":"HiddenValleyProcesses.html#anchor5","text":"HiddenValley:doKinMix allow kinematic mixing or not."},{"name":"HiddenValley:ffbar2BvBvbar","link":"HiddenValleyProcesses.html#anchor24","text":"HiddenValley:ffbar2BvBvbar Pair production HiddenValley:ffbar2BvBvbar f fbar &rarr; Bv Bvbar via intermediate HiddenValley:ffbar2BvBvbar gamma*/Z^*. Code 4925."},{"name":"HiddenValley:ffbar2CvCvbar","link":"HiddenValleyProcesses.html#anchor23","text":"HiddenValley:ffbar2CvCvbar Pair production HiddenValley:ffbar2CvCvbar f fbar &rarr; Cv Cvbar via intermediate HiddenValley:ffbar2CvCvbar gamma*/Z^*. Code 4924."},{"name":"HiddenValley:ffbar2DvDvbar","link":"HiddenValleyProcesses.html#anchor20","text":"HiddenValley:ffbar2DvDvbar Pair production HiddenValley:ffbar2DvDvbar f fbar &rarr; Dv Dvbar via intermediate HiddenValley:ffbar2DvDvbar gamma*/Z^*. Code 4921."},{"name":"HiddenValley:ffbar2EvEvbar","link":"HiddenValleyProcesses.html#anchor26","text":"HiddenValley:ffbar2EvEvbar Pair production HiddenValley:ffbar2EvEvbar f fbar &rarr; Ev Evbar via intermediate HiddenValley:ffbar2EvEvbar gamma*/Z^*. Code 4931."},{"name":"HiddenValley:ffbar2MUvMUvbar","link":"HiddenValleyProcesses.html#anchor28","text":"HiddenValley:ffbar2MUvMUvbar Pair production HiddenValley:ffbar2MUvMUvbar f fbar &rarr; MUv MUvbar via intermediate HiddenValley:ffbar2MUvMUvbar gamma*/Z^*. Code 4933."},{"name":"HiddenValley:ffbar2nuEvnuEvbar","link":"HiddenValleyProcesses.html#anchor27","text":"HiddenValley:ffbar2nuEvnuEvbar Pair production HiddenValley:ffbar2nuEvnuEvbar f fbar &rarr; nuEv nuEvbar via intermediate HiddenValley:ffbar2nuEvnuEvbar gamma*/Z^*. Code 4932."},{"name":"HiddenValley:ffbar2nuMUvnuMUvbar","link":"HiddenValleyProcesses.html#anchor29","text":"HiddenValley:ffbar2nuMUvnuMUvbar Pair production HiddenValley:ffbar2nuMUvnuMUvbar f fbar &rarr; nuMUv nuMUvbar via intermediate HiddenValley:ffbar2nuMUvnuMUvbar gamma*/Z^*. Code 4934."},{"name":"HiddenValley:ffbar2nuTAUvnuTAUvbar","link":"HiddenValleyProcesses.html#anchor31","text":"HiddenValley:ffbar2nuTAUvnuTAUvbar Pair production HiddenValley:ffbar2nuTAUvnuTAUvbar f fbar &rarr; nuTAUv nuTAUvbar via intermediate HiddenValley:ffbar2nuTAUvnuTAUvbar gamma*/Z^*. Code 4936."},{"name":"HiddenValley:ffbar2SvSvbar","link":"HiddenValleyProcesses.html#anchor22","text":"HiddenValley:ffbar2SvSvbar Pair production HiddenValley:ffbar2SvSvbar f fbar &rarr; Sv Svbar via intermediate HiddenValley:ffbar2SvSvbar gamma*/Z^*. Code 4923."},{"name":"HiddenValley:ffbar2TAUvTAUvbar","link":"HiddenValleyProcesses.html#anchor30","text":"HiddenValley:ffbar2TAUvTAUvbar Pair production HiddenValley:ffbar2TAUvTAUvbar f fbar &rarr; TAUv TAUvbar via intermediate HiddenValley:ffbar2TAUvTAUvbar gamma*/Z^*. Code 4935."},{"name":"HiddenValley:ffbar2TvTvbar","link":"HiddenValleyProcesses.html#anchor25","text":"HiddenValley:ffbar2TvTvbar Pair production HiddenValley:ffbar2TvTvbar f fbar &rarr; Tv Tvbar via intermediate HiddenValley:ffbar2TvTvbar gamma*/Z^*. Code 4926."},{"name":"HiddenValley:ffbar2UvUvbar","link":"HiddenValleyProcesses.html#anchor21","text":"HiddenValley:ffbar2UvUvbar Pair production HiddenValley:ffbar2UvUvbar f fbar &rarr; Uv Uvbar via intermediate HiddenValley:ffbar2UvUvbar gamma*/Z^*. Code 4922."},{"name":"HiddenValley:ffbar2Zv","link":"HiddenValleyProcesses.html#anchor32","text":"HiddenValley:ffbar2Zv Production HiddenValley:ffbar2Zv f fbar &rarr; Zv where HiddenValley:ffbar2Zv Zv is a generic resonance that couples both SM fermion pairs and a HiddenValley:ffbar2Zv qv qvbar pair. Not part of the framework of the above processes, but as an alternative. Code 4941."},{"name":"HiddenValley:fragment","link":"HiddenValleyProcesses.html#anchor38","text":"HiddenValley:fragment switch on string fragmentation of the HV partonic system. Only relevant for HiddenValley:fragment SU(N) scenarios."},{"name":"HiddenValley:FSR","link":"HiddenValleyProcesses.html#anchor33","text":"HiddenValley:FSR switch on final-state shower of HiddenValley:FSR gv or HiddenValley:FSR gammav in a HV production process."},{"name":"HiddenValley:gg2BvBvbar","link":"HiddenValleyProcesses.html#anchor12","text":"HiddenValley:gg2BvBvbar Pair production HiddenValley:gg2BvBvbar g g &rarr; Bv Bvbar. Code 4905."},{"name":"HiddenValley:gg2CvCvbar","link":"HiddenValleyProcesses.html#anchor11","text":"HiddenValley:gg2CvCvbar Pair production HiddenValley:gg2CvCvbar g g &rarr; Cv Cvbar. Code 4904."},{"name":"HiddenValley:gg2DvDvbar","link":"HiddenValleyProcesses.html#anchor8","text":"HiddenValley:gg2DvDvbar Pair production HiddenValley:gg2DvDvbar g g &rarr; Dv Dvbar. Code 4901."},{"name":"HiddenValley:gg2SvSvbar","link":"HiddenValleyProcesses.html#anchor10","text":"HiddenValley:gg2SvSvbar Pair production HiddenValley:gg2SvSvbar g g &rarr; Sv Svbar. Code 4903."},{"name":"HiddenValley:gg2TvTvbar","link":"HiddenValleyProcesses.html#anchor13","text":"HiddenValley:gg2TvTvbar Pair production HiddenValley:gg2TvTvbar g g &rarr; Tv Tvbar. Code 4906."},{"name":"HiddenValley:gg2UvUvbar","link":"HiddenValleyProcesses.html#anchor9","text":"HiddenValley:gg2UvUvbar Pair production HiddenValley:gg2UvUvbar g g &rarr; Uv Uvbar. Code 4902."},{"name":"HiddenValley:kappa","link":"HiddenValleyProcesses.html#anchor4","text":"HiddenValley:kappa If the HiddenValley:kappa Fv have spin 1 then their production cross section depends on the presence of anomalous magnetic dipole moment, i.e. of a HiddenValley:kappa kappa different from unity. For other spins this parameter is not used."},{"name":"HiddenValley:kinMix","link":"HiddenValleyProcesses.html#anchor6","text":"HiddenValley:kinMix strength of kinetic mixing."},{"name":"HiddenValley:Lambda","link":"HiddenValleyProcesses.html#anchor36","text":"HiddenValley:Lambda the parameter used for the case of a running (first order) HiddenValley:Lambda alpha_HV."},{"name":"HiddenValley:nFlav","link":"HiddenValleyProcesses.html#anchor39","text":"HiddenValley:nFlav number of different flavours assumed to exist in the hadronization description, leading to approximately HiddenValley:nFlav 1/n_Flav of the produced HV-mesons being flavour-diagonal and capable to decay back to Standard Model particles."},{"name":"HiddenValley:Ngauge","link":"HiddenValleyProcesses.html#anchor1","text":"HiddenValley:Ngauge is HiddenValley:Ngauge U(1) for HiddenValley:Ngauge Ngauge = 1 , is HiddenValley:Ngauge SU(N) if HiddenValley:Ngauge Ngauge > 1. Note that pair production cross sections contains a factor of HiddenValley:Ngauge Ngauge for new particles in the fundamental representation of this group."},{"name":"HiddenValley:probVector","link":"HiddenValleyProcesses.html#anchor40","text":"HiddenValley:probVector fraction of HV-mesons that are assigned spin 1 (vector), with the remainder spin 0 (pseudoscalar). Assuming the HiddenValley:probVector qv have spin HiddenValley:probVector 1/2 and the mass splitting is small, spin counting predicts that HiddenValley:probVector 3/4 of the mesons should have spin 1."},{"name":"HiddenValley:pTminFSR","link":"HiddenValleyProcesses.html#anchor37","text":"HiddenValley:pTminFSR lowest allowed HiddenValley:pTminFSR pT of emission. Should be greater than or equal to 1.1 times HiddenValley:pTminFSR Lambda , or it will be reset automatically."},{"name":"HiddenValley:qqbar2BvBvbar","link":"HiddenValleyProcesses.html#anchor18","text":"HiddenValley:qqbar2BvBvbar Pair production HiddenValley:qqbar2BvBvbar q qbar &rarr; Bv Bvbar via intermediate gluon. Code 4915."},{"name":"HiddenValley:qqbar2CvCvbar","link":"HiddenValleyProcesses.html#anchor17","text":"HiddenValley:qqbar2CvCvbar Pair production HiddenValley:qqbar2CvCvbar q qbar &rarr; Cv Cvbar via intermediate gluon. Code 4914."},{"name":"HiddenValley:qqbar2DvDvbar","link":"HiddenValleyProcesses.html#anchor14","text":"HiddenValley:qqbar2DvDvbar Pair production HiddenValley:qqbar2DvDvbar q qbar &rarr; Dv Dvbar via intermediate gluon. Code 4911."},{"name":"HiddenValley:qqbar2SvSvbar","link":"HiddenValleyProcesses.html#anchor16","text":"HiddenValley:qqbar2SvSvbar Pair production HiddenValley:qqbar2SvSvbar q qbar &rarr; Sv Svbar via intermediate gluon. Code 4913."},{"name":"HiddenValley:qqbar2TvTvbar","link":"HiddenValleyProcesses.html#anchor19","text":"HiddenValley:qqbar2TvTvbar Pair production HiddenValley:qqbar2TvTvbar q qbar &rarr; Tv Tvbar via intermediate gluon. Code 4916."},{"name":"HiddenValley:qqbar2UvUvbar","link":"HiddenValleyProcesses.html#anchor15","text":"HiddenValley:qqbar2UvUvbar Pair production HiddenValley:qqbar2UvUvbar q qbar &rarr; Uv Uvbar via intermediate gluon. Code 4912."},{"name":"HiddenValley:rFactqv","link":"HiddenValleyProcesses.html#anchor43","text":"HiddenValley:rFactqv HiddenValley:rFactqv r_qv , i.e. the Bowler correction factor to the Lund symmetric fragmentation function, which could be made weaker or stronger than its natural value."},{"name":"HiddenValley:sigmamqv","link":"HiddenValleyProcesses.html#anchor44","text":"HiddenValley:sigmamqv the width HiddenValley:sigmamqv sigma of transverse momenta in the HV fragmentation process, normalized to the HiddenValley:sigmamqv qv mass. This ensures that HiddenValley:sigmamqv sigma scales proportionately to HiddenValley:sigmamqv m_qv. See the normal HiddenValley:sigmamqv fragmentation HiddenValley:sigmamqv pT description for conventions for factors of 2."},{"name":"HiddenValley:spinFv","link":"HiddenValleyProcesses.html#anchor2","text":"HiddenValley:spinFv The spin of the HV partners of the SM fermions, e.g. HiddenValley:spinFv Dv , HiddenValley:spinFv Uv , HiddenValley:spinFv Ev and HiddenValley:spinFv nuEv. HiddenValley:spinFv spin 0. HiddenValley:spinFv spin 1/2. HiddenValley:spinFv spin 1."},{"name":"HiddenValley:spinqv","link":"HiddenValleyProcesses.html#anchor3","text":"HiddenValley:spinqv The spin of HiddenValley:spinqv qv when the HiddenValley:spinqv Fv (the HV partners of the SM fermions) have spin 1/2. (While, if they have spin 0 or 1, the HiddenValley:spinqv qv spin is fixed at 1/2.) HiddenValley:spinqv spin 0. HiddenValley:spinqv spin 1."},{"name":"Higgs:clipWings","link":"HiggsProcesses.html#anchor3","text":"Higgs:clipWings The Breit-Wigner shape of a Higgs is nontrivial, owing to the rapid width variation with the mass of a Higgs. This implies that a Higgs of low nominal mass may still acquire a non-negligible high-end tail. The validity of the calculation may be questioned in these wings. With this option on, the Higgs:clipWings Higgs:wingsFac value is used to cut away the wings. Higgs:clipWings Warning: with this option on, the allowed mass range is shrunk, but never widened. This can lead to inconsistencies if a run consists of several subruns with different Higgs masses. The Higgs:clipWings id:mMin and Higgs:clipWings id:mMax values should therefore be reset (e.g. to the defaults 50. and 0.) when Higgs:clipWings id:m0 is changed."},{"name":"Higgs:cubicWidth","link":"HiggsProcesses.html#anchor1","text":"Higgs:cubicWidth The partial width of a Higgs particle to a pair of gauge bosons, Higgs:cubicWidth W^+ W^- or Higgs:cubicWidth Z^0 Z^0 , depends cubically on the Higgs mass. When selecting the Higgs according to a Breit-Wigner, so that the actual mass Higgs:cubicWidth mHat does not agree with the nominal Higgs:cubicWidth m_Higgs one, an ambiguity arises which of the two to use Higgs:cubicWidth Sey95. The default is to use a linear dependence on Higgs:cubicWidth mHat , i.e. a width proportional to Higgs:cubicWidth m_Higgs^2 * mHat , while Higgs:cubicWidth on gives a Higgs:cubicWidth mHat^3 dependence. This does not affect the widths to fermions, which only depend linearly on Higgs:cubicWidth mHat. This flag is used both for SM and BSM Higgs bosons."},{"name":"Higgs:runningLoopMass","link":"HiggsProcesses.html#anchor2","text":"Higgs:runningLoopMass The partial width of a Higgs particle to a pair of gluons or photons, or a Higgs:runningLoopMass gamma Z^0 pair, proceeds in part through quark loops, mainly Higgs:runningLoopMass b and Higgs:runningLoopMass t. There is some ambiguity what kind of masses to use. Default is running MSbar ones, but alternatively fixed pole masses are allowed (as was standard in PYTHIA 6), which typically gives a noticeably higher cross section for these channels. (For a decay to a pair of fermions, such as top, the running mass is used for couplings and the fixed one for phase space.)"},{"name":"Higgs:useBSM","link":"HiggsProcesses.html#anchor22","text":"Higgs:useBSM Master switch to initialize and use the two-Higgs-doublet states. If off, only the above SM Higgs processes can be used, with couplings as predicted in the SM. If on, only the below BSM Higgs processes can be used, with couplings that can be set freely, also found further down on this page."},{"name":"Higgs:wingsFac","link":"HiggsProcesses.html#anchor4","text":"Higgs:wingsFac With Higgs:wingsFac Higgs:clipWings on, all Higgs masses which deviate from the nominal one by more than Higgs:wingsFac Higgs:wingsFac times the nominal width are forbidden. This is achieved by setting the Higgs:wingsFac mMin and Higgs:wingsFac mMax values of the Higgs states at initialization. These changes never  allow a wider range than already set by the user, alternatively by the current default values, see warning above."},{"name":"HiggsA3:coup2d","link":"HiggsProcesses.html#anchor98","text":"HiggsA3:coup2d The HiggsA3:coup2d A^0(H_3^0) coupling to down-type quarks."},{"name":"HiggsA3:coup2H1H1","link":"HiggsProcesses.html#anchor105","text":"HiggsA3:coup2H1H1 The HiggsA3:coup2H1H1 A^0(H_3^0) coupling to a HiggsA3:coup2H1H1 h^0(H_1^0) pair. Vanishes in the MSSM."},{"name":"HiggsA3:coup2H1Z","link":"HiggsProcesses.html#anchor101","text":"HiggsA3:coup2H1Z The HiggsA3:coup2H1Z A^0(H_3^0) coupling to a HiggsA3:coup2H1Z h^0(H_1^0) Z^0 pair. Is HiggsA3:coup2H1Z cos(beta - alpha) in the MSSM."},{"name":"HiggsA3:coup2H2Z","link":"HiggsProcesses.html#anchor102","text":"HiggsA3:coup2H2Z The HiggsA3:coup2H2Z A^0(H_3^0) coupling to a HiggsA3:coup2H2Z H^0(H_2^0) Z^0 pair. Is HiggsA3:coup2H2Z sin(beta - alpha) in the MSSM."},{"name":"HiggsA3:coup2Hchg","link":"HiggsProcesses.html#anchor106","text":"HiggsA3:coup2Hchg The HiggsA3:coup2Hchg A^0(H_3^0) coupling to HiggsA3:coup2Hchg H^+-. Vanishes in the MSSM."},{"name":"HiggsA3:coup2HchgW","link":"HiggsProcesses.html#anchor107","text":"HiggsA3:coup2HchgW The HiggsA3:coup2HchgW A^0(H_3^0) coupling to a HiggsA3:coup2HchgW H^+- W-+ pair. Is 1 in the MSSM."},{"name":"HiggsA3:coup2l","link":"HiggsProcesses.html#anchor100","text":"HiggsA3:coup2l The HiggsA3:coup2l A^0(H_3^0) coupling to (charged) leptons."},{"name":"HiggsA3:coup2u","link":"HiggsProcesses.html#anchor99","text":"HiggsA3:coup2u The HiggsA3:coup2u A^0(H_3^0) coupling to up-type quarks."},{"name":"HiggsA3:coup2W","link":"HiggsProcesses.html#anchor104","text":"HiggsA3:coup2W The HiggsA3:coup2W A^0(H_3^0) coupling to HiggsA3:coup2W W^+-. Vanishes in the MSSM."},{"name":"HiggsA3:coup2Z","link":"HiggsProcesses.html#anchor103","text":"HiggsA3:coup2Z The HiggsA3:coup2Z A^0(H_3^0) coupling to HiggsA3:coup2Z Z^0. Vanishes in the MSSM."},{"name":"HiggsA3:etaParity","link":"HiggsProcesses.html#anchor118","text":"HiggsA3:etaParity The HiggsA3:etaParity eta value of CP-violation in the HiggsA3:etaParity HiggsA3:parity = 3 option."},{"name":"HiggsA3:parity","link":"HiggsProcesses.html#anchor117","text":"HiggsA3:parity possibility to modify angular decay correlations in the decay of a HiggsA3:parity A^0(H_3) decay HiggsA3:parity Z^0 Z^0 or HiggsA3:parity W^+ W^- to four fermions, or HiggsA3:parity tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. HiggsA3:parity isotropic decays. HiggsA3:parity assuming the HiggsA3:parity A^0(H_3) is a pure scalar (CP-even). HiggsA3:parity assuming the HiggsA3:parity A^0(H_3) is a pure pseudoscalar (CP-odd), as in the MSSM. HiggsA3:parity assuming the HiggsA3:parity A^0(H_3) is a mixture of the two, including the CP-violating interference term. The parameter HiggsA3:parity eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to HiggsA3:parity eta and the CP-odd one to HiggsA3:parity eta^2. Intended for decays into HiggsA3:parity W^+ W^- or HiggsA3:parity Z^0 Z^0. HiggsA3:parity same as HiggsA3:parity 3 but now HiggsA3:parity phi , see below, sets the CP-mixing angle. The CP-even term is proportional to HiggsA3:parity sin^2(phi) , the interference to HiggsA3:parity sin(phi)cos(phi) , and the CP-odd term to HiggsA3:parity cos^2(phi). Consequently HiggsA3:parity phi=0 is pure CP-odd and HiggsA3:parity phi=pi/2 is pure CP-even. Intended for decays of HiggsA3:parity A -> f fbar , notably for HiggsA3:parity tau lepton polarization, whereas HiggsA3:parity W^+ W^- and HiggsA3:parity Z^0 Z^0 decays are isotropic."},{"name":"HiggsA3:phiParity","link":"HiggsProcesses.html#anchor119","text":"HiggsA3:phiParity The HiggsA3:phiParity phi value of CP-mixing in the HiggsA3:phiParity HiggsA3:parity = 4 option."},{"name":"HiggsBSM:all","link":"HiggsProcesses.html#anchor23","text":"HiggsBSM:all Common switch for the group of Higgs production beyond the Standard Model, as listed below."},{"name":"HiggsBSM:allA3","link":"HiggsProcesses.html#anchor44","text":"HiggsBSM:allA3 Common switch for the group of HiggsBSM:allA3 A^0(H_3^0) production processes."},{"name":"HiggsBSM:allH+-","link":"HiggsProcesses.html#anchor54","text":"HiggsBSM:allH+- Common switch for the group of HiggsBSM:allH+- H^+- production processes."},{"name":"HiggsBSM:allH1","link":"HiggsProcesses.html#anchor24","text":"HiggsBSM:allH1 Common switch for the group of HiggsBSM:allH1 h^0(H_1^0) production processes."},{"name":"HiggsBSM:allH2","link":"HiggsProcesses.html#anchor34","text":"HiggsBSM:allH2 Common switch for the group of HiggsBSM:allH2 H^0(H_2^0) production processes."},{"name":"HiggsBSM:allHpair","link":"HiggsProcesses.html#anchor57","text":"HiggsBSM:allHpair Common switch for the group of Higgs pair-production processes."},{"name":"HiggsBSM:bg2H+-t","link":"HiggsProcesses.html#anchor56","text":"HiggsBSM:bg2H+-t Scattering HiggsBSM:bg2H+-t b g &rarr; H^+ tbar. At hadron colliders this is the dominant process for single-charged-Higgs production. Code 1062."},{"name":"HiggsBSM:ff2A3ff(t:WW)","link":"HiggsProcesses.html#anchor51","text":"HiggsBSM:ff2A3ff(t:WW) Scattering HiggsBSM:ff2A3ff(t:WW) f_1 f_2 &rarr; A^0(A_3^0) f_3 f_4 via HiggsBSM:ff2A3ff(t:WW) W^+ W^- fusion. Code 1047."},{"name":"HiggsBSM:ff2A3ff(t:ZZ)","link":"HiggsProcesses.html#anchor50","text":"HiggsBSM:ff2A3ff(t:ZZ) Scattering HiggsBSM:ff2A3ff(t:ZZ) f f' &rarr; A^0(A_3^0) f f' via HiggsBSM:ff2A3ff(t:ZZ) Z^0 Z^0 fusion. Code 1046."},{"name":"HiggsBSM:ff2H1ff(t:WW)","link":"HiggsProcesses.html#anchor31","text":"HiggsBSM:ff2H1ff(t:WW) Scattering HiggsBSM:ff2H1ff(t:WW) f_1 f_2 &rarr; h^0(H_1^0) f_3 f_4 via HiggsBSM:ff2H1ff(t:WW) W^+ W^- fusion. Code 1007."},{"name":"HiggsBSM:ff2H1ff(t:ZZ)","link":"HiggsProcesses.html#anchor30","text":"HiggsBSM:ff2H1ff(t:ZZ) Scattering HiggsBSM:ff2H1ff(t:ZZ) f f' &rarr; h^0(H_1^0) f f' via HiggsBSM:ff2H1ff(t:ZZ) Z^0 Z^0 fusion. Code 1006."},{"name":"HiggsBSM:ff2H2ff(t:WW)","link":"HiggsProcesses.html#anchor41","text":"HiggsBSM:ff2H2ff(t:WW) Scattering HiggsBSM:ff2H2ff(t:WW) f_1 f_2 &rarr; H^0(H_2^0) f_3 f_4 via HiggsBSM:ff2H2ff(t:WW) W^+ W^- fusion. Code 1027."},{"name":"HiggsBSM:ff2H2ff(t:ZZ)","link":"HiggsProcesses.html#anchor40","text":"HiggsBSM:ff2H2ff(t:ZZ) Scattering HiggsBSM:ff2H2ff(t:ZZ) f f' &rarr; H^0(H_2^0) f f' via HiggsBSM:ff2H2ff(t:ZZ) Z^0 Z^0 fusion. Code 1026."},{"name":"HiggsBSM:ffbar2A3","link":"HiggsProcesses.html#anchor45","text":"HiggsBSM:ffbar2A3 Scattering HiggsBSM:ffbar2A3 f fbar &rarr; A^0(H_3^0) , where HiggsBSM:ffbar2A3 f sums over available flavours except top. Code 1041."},{"name":"HiggsBSM:ffbar2A3H1","link":"HiggsProcesses.html#anchor58","text":"HiggsBSM:ffbar2A3H1 Scattering HiggsBSM:ffbar2A3H1 f fbar &rarr; A^0(H_3) h^0(H_1). Code 1081."},{"name":"HiggsBSM:ffbar2A3H2","link":"HiggsProcesses.html#anchor59","text":"HiggsBSM:ffbar2A3H2 Scattering HiggsBSM:ffbar2A3H2 f fbar &rarr; A^0(H_3) H^0(H_2). Code 1082."},{"name":"HiggsBSM:ffbar2A3W","link":"HiggsProcesses.html#anchor49","text":"HiggsBSM:ffbar2A3W Scattering HiggsBSM:ffbar2A3W f fbar &rarr; A^0(A_3^0) W^+- via HiggsBSM:ffbar2A3W s -channel HiggsBSM:ffbar2A3W W^+- exchange. Code 1045."},{"name":"HiggsBSM:ffbar2A3Z","link":"HiggsProcesses.html#anchor48","text":"HiggsBSM:ffbar2A3Z Scattering HiggsBSM:ffbar2A3Z f fbar &rarr; A^0(A_3^0) Z^0 via HiggsBSM:ffbar2A3Z s -channel HiggsBSM:ffbar2A3Z Z^0 exchange. Code 1044."},{"name":"HiggsBSM:ffbar2H+-","link":"HiggsProcesses.html#anchor55","text":"HiggsBSM:ffbar2H+- Scattering HiggsBSM:ffbar2H+- f fbar' &rarr; H^+- , where HiggsBSM:ffbar2H+- f, fbar' sums over available incoming flavours. Since couplings are assumed generation-diagonal, in practice this means HiggsBSM:ffbar2H+- c sbar &rarr; H^+ and HiggsBSM:ffbar2H+- s cbar &rarr; H^-. Code 1061."},{"name":"HiggsBSM:ffbar2H+-H1","link":"HiggsProcesses.html#anchor60","text":"HiggsBSM:ffbar2H+-H1 Scattering HiggsBSM:ffbar2H+-H1 f fbar &rarr; H^+- h^0(H_1). Code 1083."},{"name":"HiggsBSM:ffbar2H+-H2","link":"HiggsProcesses.html#anchor61","text":"HiggsBSM:ffbar2H+-H2 Scattering HiggsBSM:ffbar2H+-H2 f fbar &rarr; H^+- H^0(H_2). Code 1084."},{"name":"HiggsBSM:ffbar2H+H-","link":"HiggsProcesses.html#anchor62","text":"HiggsBSM:ffbar2H+H- Scattering HiggsBSM:ffbar2H+H- f fbar &rarr; H+ H-. Code 1085."},{"name":"HiggsBSM:ffbar2H1","link":"HiggsProcesses.html#anchor25","text":"HiggsBSM:ffbar2H1 Scattering HiggsBSM:ffbar2H1 f fbar &rarr; h^0(H_1^0) , where HiggsBSM:ffbar2H1 f sums over available flavours except top. Code 1001."},{"name":"HiggsBSM:ffbar2H1W","link":"HiggsProcesses.html#anchor29","text":"HiggsBSM:ffbar2H1W Scattering HiggsBSM:ffbar2H1W f fbar &rarr; h^0(H_1^0) W^+- via HiggsBSM:ffbar2H1W s -channel HiggsBSM:ffbar2H1W W^+- exchange. Code 1005."},{"name":"HiggsBSM:ffbar2H1Z","link":"HiggsProcesses.html#anchor28","text":"HiggsBSM:ffbar2H1Z Scattering HiggsBSM:ffbar2H1Z f fbar &rarr; h^0(H_1^0) Z^0 via HiggsBSM:ffbar2H1Z s -channel HiggsBSM:ffbar2H1Z Z^0 exchange. Code 1004."},{"name":"HiggsBSM:ffbar2H2","link":"HiggsProcesses.html#anchor35","text":"HiggsBSM:ffbar2H2 Scattering HiggsBSM:ffbar2H2 f fbar &rarr; H^0(H_2^0) , where HiggsBSM:ffbar2H2 f sums over available flavours except top. Code 1021."},{"name":"HiggsBSM:ffbar2H2W","link":"HiggsProcesses.html#anchor39","text":"HiggsBSM:ffbar2H2W Scattering HiggsBSM:ffbar2H2W f fbar &rarr; H^0(H_2^0) W^+- via HiggsBSM:ffbar2H2W s -channel HiggsBSM:ffbar2H2W W^+- exchange. Code 1025."},{"name":"HiggsBSM:ffbar2H2Z","link":"HiggsProcesses.html#anchor38","text":"HiggsBSM:ffbar2H2Z Scattering HiggsBSM:ffbar2H2Z f fbar &rarr; H^0(H_2^0) Z^0 via HiggsBSM:ffbar2H2Z s -channel HiggsBSM:ffbar2H2Z Z^0 exchange. Code 1024."},{"name":"HiggsBSM:gg2A3","link":"HiggsProcesses.html#anchor46","text":"HiggsBSM:gg2A3 Scattering HiggsBSM:gg2A3 g g &rarr; A^0(A_3^0) via loop contributions primarily from top. Code 1042."},{"name":"HiggsBSM:gg2A3bbbar","link":"HiggsProcesses.html#anchor76","text":"HiggsBSM:gg2A3bbbar Scattering HiggsBSM:gg2A3bbbar g g &rarr; A^0 b bbar. This process is yet one order higher of the HiggsBSM:gg2A3bbbar b bbar &rarr; A^0 and HiggsBSM:gg2A3bbbar b g &rarr; A^0 b chain, where now two quarks should be required above some large HiggsBSM:gg2A3bbbar pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1052."},{"name":"HiggsBSM:gg2A3g(l:t)","link":"HiggsProcesses.html#anchor78","text":"HiggsBSM:gg2A3g(l:t) Scattering HiggsBSM:gg2A3g(l:t) g g &rarr; A^0 g via loop contributions primarily from top. Code 1054."},{"name":"HiggsBSM:gg2A3ttbar","link":"HiggsProcesses.html#anchor52","text":"HiggsBSM:gg2A3ttbar Scattering HiggsBSM:gg2A3ttbar g g &rarr; A^0(A_3^0) t tbar via HiggsBSM:gg2A3ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1048."},{"name":"HiggsBSM:gg2H1","link":"HiggsProcesses.html#anchor26","text":"HiggsBSM:gg2H1 Scattering HiggsBSM:gg2H1 g g &rarr; h^0(H_1^0) via loop contributions primarily from top. Code 1002."},{"name":"HiggsBSM:gg2H1bbbar","link":"HiggsProcesses.html#anchor64","text":"HiggsBSM:gg2H1bbbar Scattering HiggsBSM:gg2H1bbbar g g &rarr; h^0 b bbar. This process is yet one order higher of the HiggsBSM:gg2H1bbbar b bbar &rarr; h^0 and HiggsBSM:gg2H1bbbar b g &rarr; h^0 b chain, where now two quarks should be required above some large HiggsBSM:gg2H1bbbar pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1012."},{"name":"HiggsBSM:gg2H1g(l:t)","link":"HiggsProcesses.html#anchor66","text":"HiggsBSM:gg2H1g(l:t) Scattering HiggsBSM:gg2H1g(l:t) g g &rarr; h^0 g via loop contributions primarily from top. Code 1014."},{"name":"HiggsBSM:gg2H1ttbar","link":"HiggsProcesses.html#anchor32","text":"HiggsBSM:gg2H1ttbar Scattering HiggsBSM:gg2H1ttbar g g &rarr; h^0(H_1^0) t tbar via HiggsBSM:gg2H1ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1008."},{"name":"HiggsBSM:gg2H2","link":"HiggsProcesses.html#anchor36","text":"HiggsBSM:gg2H2 Scattering HiggsBSM:gg2H2 g g &rarr; H^0(H_2^0) via loop contributions primarily from top. Code 1022."},{"name":"HiggsBSM:gg2H2bbbar","link":"HiggsProcesses.html#anchor70","text":"HiggsBSM:gg2H2bbbar Scattering HiggsBSM:gg2H2bbbar g g &rarr; H^0 b bbar. This process is yet one order higher of the HiggsBSM:gg2H2bbbar b bbar &rarr; H^0 and HiggsBSM:gg2H2bbbar b g &rarr; H^0 b chain, where now two quarks should be required above some large HiggsBSM:gg2H2bbbar pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1032."},{"name":"HiggsBSM:gg2H2g(l:t)","link":"HiggsProcesses.html#anchor72","text":"HiggsBSM:gg2H2g(l:t) Scattering HiggsBSM:gg2H2g(l:t) g g &rarr; H^0 g via loop contributions primarily from top. Code 1034."},{"name":"HiggsBSM:gg2H2ttbar","link":"HiggsProcesses.html#anchor42","text":"HiggsBSM:gg2H2ttbar Scattering HiggsBSM:gg2H2ttbar g g &rarr; H^0(H_2^0) t tbar via HiggsBSM:gg2H2ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1028."},{"name":"HiggsBSM:gmgm2A3","link":"HiggsProcesses.html#anchor47","text":"HiggsBSM:gmgm2A3 Scattering HiggsBSM:gmgm2A3 gamma gamma &rarr; A^0(A_3^0) via loop contributions primarily from top and HiggsBSM:gmgm2A3 W. Code 1043."},{"name":"HiggsBSM:gmgm2H1","link":"HiggsProcesses.html#anchor27","text":"HiggsBSM:gmgm2H1 Scattering HiggsBSM:gmgm2H1 gamma gamma &rarr; h^0(H_1^0) via loop contributions primarily from top and HiggsBSM:gmgm2H1 W. Code 1003."},{"name":"HiggsBSM:gmgm2H2","link":"HiggsProcesses.html#anchor37","text":"HiggsBSM:gmgm2H2 Scattering HiggsBSM:gmgm2H2 gamma gamma &rarr; H^0(H_2^0) via loop contributions primarily from top and HiggsBSM:gmgm2H2 W. Code 1023."},{"name":"HiggsBSM:qg2A3q","link":"HiggsProcesses.html#anchor75","text":"HiggsBSM:qg2A3q Scattering HiggsBSM:qg2A3q q g &rarr; A^0 q. This process gives first-order corrections to the HiggsBSM:qg2A3q f fbar &rarr; A^0 one above, and should only be used to study  the high- HiggsBSM:qg2A3q pT tail, while HiggsBSM:qg2A3q f fbar &rarr; A^0 should be used for inclusive production. Only the dominant HiggsBSM:qg2A3q c and HiggsBSM:qg2A3q b contributions are included, and generated separately for technical reasons. Note that another first-order process would be HiggsBSM:qg2A3q q qbar &rarr; A^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any HiggsBSM:qg2A3q b at large HiggsBSM:qg2A3q pT , however, so is less interesting for many applications. Code 1051."},{"name":"HiggsBSM:qg2A3q(l:t)","link":"HiggsProcesses.html#anchor79","text":"HiggsBSM:qg2A3q(l:t) Scattering HiggsBSM:qg2A3q(l:t) q g &rarr; A^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2A3q(l:t) HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1055."},{"name":"HiggsBSM:qg2H1q","link":"HiggsProcesses.html#anchor63","text":"HiggsBSM:qg2H1q Scattering HiggsBSM:qg2H1q q g &rarr; h^0 q. This process gives first-order corrections to the HiggsBSM:qg2H1q f fbar &rarr; h^0 one above, and should only be used to study  the high- HiggsBSM:qg2H1q pT tail, while HiggsBSM:qg2H1q f fbar &rarr; h^0 should be used for inclusive production. Only the dominant HiggsBSM:qg2H1q c and HiggsBSM:qg2H1q b contributions are included, and generated separately for technical reasons. Note that another first-order process would be HiggsBSM:qg2H1q q qbar &rarr; h^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any HiggsBSM:qg2H1q b at large HiggsBSM:qg2H1q pT , however, so is less interesting for many applications. Code 1011."},{"name":"HiggsBSM:qg2H1q(l:t)","link":"HiggsProcesses.html#anchor67","text":"HiggsBSM:qg2H1q(l:t) Scattering HiggsBSM:qg2H1q(l:t) q g &rarr; h^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2H1q(l:t) HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1015."},{"name":"HiggsBSM:qg2H2q","link":"HiggsProcesses.html#anchor69","text":"HiggsBSM:qg2H2q Scattering HiggsBSM:qg2H2q q g &rarr; H^0 q. This process gives first-order corrections to the HiggsBSM:qg2H2q f fbar &rarr; H^0 one above, and should only be used to study  the high- HiggsBSM:qg2H2q pT tail, while HiggsBSM:qg2H2q f fbar &rarr; H^0 should be used for inclusive production. Only the dominant HiggsBSM:qg2H2q c and HiggsBSM:qg2H2q b contributions are included, and generated separately for technical reasons. Note that another first-order process would be HiggsBSM:qg2H2q q qbar &rarr; H^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any HiggsBSM:qg2H2q b at large HiggsBSM:qg2H2q pT , however, so is less interesting for many applications. Code 1031."},{"name":"HiggsBSM:qg2H2q(l:t)","link":"HiggsProcesses.html#anchor73","text":"HiggsBSM:qg2H2q(l:t) Scattering HiggsBSM:qg2H2q(l:t) q g &rarr; H^0 q via loop contributions primarily from top. Not to be confused with the HiggsBSM:qg2H2q(l:t) HiggsBSM:qg2H1q process above, with its direct fermion-to-Higgs coupling. Code 1035."},{"name":"HiggsBSM:qqbar2A3bbbar","link":"HiggsProcesses.html#anchor77","text":"HiggsBSM:qqbar2A3bbbar Scattering HiggsBSM:qqbar2A3bbbar q qbar &rarr; A^0 b bbar via an HiggsBSM:qqbar2A3bbbar s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1053."},{"name":"HiggsBSM:qqbar2A3g(l:t)","link":"HiggsProcesses.html#anchor80","text":"HiggsBSM:qqbar2A3g(l:t) Scattering HiggsBSM:qqbar2A3g(l:t) q qbar &rarr; A^0 g via an HiggsBSM:qqbar2A3g(l:t) s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from HiggsBSM:qqbar2A3g(l:t) g g &rarr; A^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1056."},{"name":"HiggsBSM:qqbar2A3ttbar","link":"HiggsProcesses.html#anchor53","text":"HiggsBSM:qqbar2A3ttbar Scattering HiggsBSM:qqbar2A3ttbar q qbar &rarr; A^0(A_3^0) t tbar via HiggsBSM:qqbar2A3ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1049."},{"name":"HiggsBSM:qqbar2H1bbbar","link":"HiggsProcesses.html#anchor65","text":"HiggsBSM:qqbar2H1bbbar Scattering HiggsBSM:qqbar2H1bbbar q qbar &rarr; h^0 b bbar via an HiggsBSM:qqbar2H1bbbar s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1013."},{"name":"HiggsBSM:qqbar2H1g(l:t)","link":"HiggsProcesses.html#anchor68","text":"HiggsBSM:qqbar2H1g(l:t) Scattering HiggsBSM:qqbar2H1g(l:t) q qbar &rarr; h^0 g via an HiggsBSM:qqbar2H1g(l:t) s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from HiggsBSM:qqbar2H1g(l:t) g g &rarr; h^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1016."},{"name":"HiggsBSM:qqbar2H1ttbar","link":"HiggsProcesses.html#anchor33","text":"HiggsBSM:qqbar2H1ttbar Scattering HiggsBSM:qqbar2H1ttbar q qbar &rarr; h^0(H_1^0) t tbar via HiggsBSM:qqbar2H1ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1009."},{"name":"HiggsBSM:qqbar2H2bbbar","link":"HiggsProcesses.html#anchor71","text":"HiggsBSM:qqbar2H2bbbar Scattering HiggsBSM:qqbar2H2bbbar q qbar &rarr; H^0 b bbar via an HiggsBSM:qqbar2H2bbbar s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1033."},{"name":"HiggsBSM:qqbar2H2g(l:t)","link":"HiggsProcesses.html#anchor74","text":"HiggsBSM:qqbar2H2g(l:t) Scattering HiggsBSM:qqbar2H2g(l:t) q qbar &rarr; H^0 g via an HiggsBSM:qqbar2H2g(l:t) s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from HiggsBSM:qqbar2H2g(l:t) g g &rarr; H^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 1036."},{"name":"HiggsBSM:qqbar2H2ttbar","link":"HiggsProcesses.html#anchor43","text":"HiggsBSM:qqbar2H2ttbar Scattering HiggsBSM:qqbar2H2ttbar q qbar &rarr; H^0(H_2^0) t tbar via HiggsBSM:qqbar2H2ttbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 1029."},{"name":"HiggsH1:coup2d","link":"HiggsProcesses.html#anchor81","text":"HiggsH1:coup2d The HiggsH1:coup2d h^0(H_1^0) coupling to down-type quarks."},{"name":"HiggsH1:coup2Hchg","link":"HiggsProcesses.html#anchor86","text":"HiggsH1:coup2Hchg The HiggsH1:coup2Hchg h^0(H_1^0) coupling to HiggsH1:coup2Hchg H^+- (in loops). Is HiggsH1:coup2Hchg sin(beta - alpha) + cos(2 beta) sin(beta + alpha) / (2 cos^2theta_W) in the MSSM."},{"name":"HiggsH1:coup2l","link":"HiggsProcesses.html#anchor83","text":"HiggsH1:coup2l The HiggsH1:coup2l h^0(H_1^0) coupling to (charged) leptons."},{"name":"HiggsH1:coup2u","link":"HiggsProcesses.html#anchor82","text":"HiggsH1:coup2u The HiggsH1:coup2u h^0(H_1^0) coupling to up-type quarks."},{"name":"HiggsH1:coup2W","link":"HiggsProcesses.html#anchor85","text":"HiggsH1:coup2W The HiggsH1:coup2W h^0(H_1^0) coupling to HiggsH1:coup2W W^+-."},{"name":"HiggsH1:coup2Z","link":"HiggsProcesses.html#anchor84","text":"HiggsH1:coup2Z The HiggsH1:coup2Z h^0(H_1^0) coupling to HiggsH1:coup2Z Z^0."},{"name":"HiggsH1:etaParity","link":"HiggsProcesses.html#anchor112","text":"HiggsH1:etaParity The HiggsH1:etaParity eta value of CP-violation in the HiggsH1:etaParity HiggsH1:parity = 3 option."},{"name":"HiggsH1:parity","link":"HiggsProcesses.html#anchor111","text":"HiggsH1:parity possibility to modify angular decay correlations in the decay of a HiggsH1:parity h^0(H_1) decay HiggsH1:parity Z^0 Z^0 or HiggsH1:parity W^+ W^- to four fermions, or HiggsH1:parity tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. HiggsH1:parity isotropic decays. HiggsH1:parity assuming the HiggsH1:parity h^0(H_1) is a pure scalar (CP-even), as in the MSSM. HiggsH1:parity assuming the HiggsH1:parity h^0(H_1) is a pure pseudoscalar (CP-odd). HiggsH1:parity assuming the HiggsH1:parity h^0(H_1) is a mixture of the two, including the CP-violating interference term. The parameter HiggsH1:parity eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to HiggsH1:parity eta and the CP-odd one to HiggsH1:parity eta^2. Intended for decays into HiggsH1:parity W^+ W^- or HiggsH1:parity Z^0 Z^0. HiggsH1:parity same as HiggsH1:parity 3 but now HiggsH1:parity phi , see below, sets the CP-mixing angle. The CP-even term is proportional to HiggsH1:parity sin^2(phi) , the interference to HiggsH1:parity sin(phi)cos(phi) , and the CP-odd term to HiggsH1:parity cos^2(phi). Consequently HiggsH1:parity phi=0 is pure CP-odd and HiggsH1:parity phi=pi/2 is pure CP-even. Intended for decays of HiggsH1:parity h -> f fbar , notably for HiggsH1:parity tau lepton polarization, whereas HiggsH1:parity W^+ W^- and HiggsH1:parity Z^0 Z^0 decays are isotropic."},{"name":"HiggsH1:phiParity","link":"HiggsProcesses.html#anchor113","text":"HiggsH1:phiParity The HiggsH1:phiParity phi value of CP-mixing in the HiggsH1:phiParity HiggsH1:parity = 4 option."},{"name":"HiggsH2:coup2A3A3","link":"HiggsProcesses.html#anchor94","text":"HiggsH2:coup2A3A3 The HiggsH2:coup2A3A3 H^0(H_2^0) coupling to an HiggsH2:coup2A3A3 A^0(H_3^0) pair. Is HiggsH2:coup2A3A3 cos(2 beta) cos(beta + alpha) in the MSSM."},{"name":"HiggsH2:coup2A3H1","link":"HiggsProcesses.html#anchor96","text":"HiggsH2:coup2A3H1 The HiggsH2:coup2A3H1 H^0(H_2^0) coupling to an HiggsH2:coup2A3H1 A^0(H_3^0) h^0(H_1^0) pair. Vanishes in the MSSM."},{"name":"HiggsH2:coup2d","link":"HiggsProcesses.html#anchor87","text":"HiggsH2:coup2d The HiggsH2:coup2d H^0(H_2^0) coupling to down-type quarks."},{"name":"HiggsH2:coup2H1H1","link":"HiggsProcesses.html#anchor93","text":"HiggsH2:coup2H1H1 The HiggsH2:coup2H1H1 H^0(H_2^0) coupling to a HiggsH2:coup2H1H1 h^0(H_1^0) pair. Is HiggsH2:coup2H1H1 cos(2 alpha) cos(beta + alpha) - 2 sin(2 alpha) sin(beta + alpha) in the MSSM."},{"name":"HiggsH2:coup2H1Z","link":"HiggsProcesses.html#anchor95","text":"HiggsH2:coup2H1Z The HiggsH2:coup2H1Z H^0(H_2^0) coupling to a HiggsH2:coup2H1Z h^0(H_1^0) Z^0 pair. Vanishes in the MSSM."},{"name":"HiggsH2:coup2Hchg","link":"HiggsProcesses.html#anchor92","text":"HiggsH2:coup2Hchg The HiggsH2:coup2Hchg H^0(H_2^0) coupling to HiggsH2:coup2Hchg H^+- (in loops). Is HiggsH2:coup2Hchg cos(beta - alpha) + cos(2 beta) cos(beta + alpha) / (2 cos^2theta_W) in the MSSM."},{"name":"HiggsH2:coup2HchgW","link":"HiggsProcesses.html#anchor97","text":"HiggsH2:coup2HchgW The HiggsH2:coup2HchgW H^0(H_2^0) coupling to a HiggsH2:coup2HchgW H^+- W-+ pair. Is HiggsH2:coup2HchgW sin(beta - alpha) in the MSSM."},{"name":"HiggsH2:coup2l","link":"HiggsProcesses.html#anchor89","text":"HiggsH2:coup2l The HiggsH2:coup2l H^0(H_2^0) coupling to (charged) leptons."},{"name":"HiggsH2:coup2u","link":"HiggsProcesses.html#anchor88","text":"HiggsH2:coup2u The HiggsH2:coup2u H^0(H_2^0) coupling to up-type quarks."},{"name":"HiggsH2:coup2W","link":"HiggsProcesses.html#anchor91","text":"HiggsH2:coup2W The HiggsH2:coup2W H^0(H_2^0) coupling to HiggsH2:coup2W W^+-."},{"name":"HiggsH2:coup2Z","link":"HiggsProcesses.html#anchor90","text":"HiggsH2:coup2Z The HiggsH2:coup2Z H^0(H_2^0) coupling to HiggsH2:coup2Z Z^0."},{"name":"HiggsH2:etaParity","link":"HiggsProcesses.html#anchor115","text":"HiggsH2:etaParity The HiggsH2:etaParity eta value of CP-violation in the HiggsH2:etaParity HiggsH2:parity = 3 option."},{"name":"HiggsH2:parity","link":"HiggsProcesses.html#anchor114","text":"HiggsH2:parity possibility to modify angular decay correlations in the decay of a HiggsH2:parity H^0(H_2) decay HiggsH2:parity Z^0 Z^0 or HiggsH2:parity W^+ W^- to four fermions, or HiggsH2:parity tau^+ tau^- to any final state. Currently it does not affect the partial width of the channels, which is only based on the above parameters. HiggsH2:parity isotropic decays. HiggsH2:parity assuming the HiggsH2:parity H^0(H_2) is a pure scalar (CP-even), as in the MSSM. HiggsH2:parity assuming the HiggsH2:parity H^0(H_2) is a pure pseudoscalar (CP-odd). HiggsH2:parity assuming the HiggsH2:parity H^0(H_2) is a mixture of the two, including the CP-violating interference term. The parameter HiggsH2:parity eta , see below, sets the strength of the CP-odd admixture, with the interference term being proportional to HiggsH2:parity eta and the CP-odd one to HiggsH2:parity eta^2. Intended or decays into HiggsH2:parity W^+ W^- or HiggsH2:parity Z^0 Z^0. HiggsH2:parity same as HiggsH2:parity 3 but now HiggsH2:parity phi , see below, sets the CP-mixing angle. The CP-even term is proportional to HiggsH2:parity sin^2(phi) , the interference to HiggsH2:parity sin(phi)cos(phi) , and the CP-odd term to HiggsH2:parity cos^2(phi). Consequently HiggsH2:parity phi=0 is pure CP-odd and HiggsH2:parity phi=pi/2 is pure CP-even. Intended for decays of HiggsH2:parity H -> f fbar , notably for HiggsH2:parity tau lepton polarization, whereas HiggsH2:parity W^+ W^- and HiggsH2:parity Z^0 Z^0 decays are isotropic."},{"name":"HiggsH2:phiParity","link":"HiggsProcesses.html#anchor116","text":"HiggsH2:phiParity The HiggsH2:phiParity phi value of CP-mixing in the HiggsH2:phiParity HiggsH2:parity = 4 option."},{"name":"HiggsHchg:coup2H1W","link":"HiggsProcesses.html#anchor109","text":"HiggsHchg:coup2H1W The HiggsHchg:coup2H1W H^+- coupling to a HiggsHchg:coup2H1W h^0(H_1^0) W^+- pair. Is HiggsHchg:coup2H1W cos(beta - alpha) in the MSSM."},{"name":"HiggsHchg:coup2H2W","link":"HiggsProcesses.html#anchor110","text":"HiggsHchg:coup2H2W The HiggsHchg:coup2H2W H^+- coupling to a HiggsHchg:coup2H2W H^0(H_2^0) W^+- pair. Is HiggsHchg:coup2H2W sin(beta - alpha) in the MSSM."},{"name":"HiggsHchg:tanBeta","link":"HiggsProcesses.html#anchor108","text":"HiggsHchg:tanBeta The HiggsHchg:tanBeta tan(beta) value, which leads to an enhancement of the HiggsHchg:tanBeta H^+- coupling to down-type fermions and suppression to up-type ones. The same angle also appears in many other places, but this particular parameter is only used for the charged-Higgs case."},{"name":"HiggsSM:all","link":"HiggsProcesses.html#anchor6","text":"HiggsSM:all Common switch for the group of Higgs production within the Standard Model."},{"name":"HiggsSM:ff2Hff(t:WW)","link":"HiggsProcesses.html#anchor13","text":"HiggsSM:ff2Hff(t:WW) Scattering HiggsSM:ff2Hff(t:WW) f_1 f_2 &rarr; H^0 f_3 f_4 via HiggsSM:ff2Hff(t:WW) W^+ W^- fusion. Code 907."},{"name":"HiggsSM:ff2Hff(t:ZZ)","link":"HiggsProcesses.html#anchor12","text":"HiggsSM:ff2Hff(t:ZZ) Scattering HiggsSM:ff2Hff(t:ZZ) f f' &rarr; H^0 f f' via HiggsSM:ff2Hff(t:ZZ) Z^0 Z^0 fusion. Code 906."},{"name":"HiggsSM:ffbar2H","link":"HiggsProcesses.html#anchor7","text":"HiggsSM:ffbar2H Scattering HiggsSM:ffbar2H f fbar &rarr; H^0 , where HiggsSM:ffbar2H f sums over available flavours except top. Related to the mass-dependent Higgs point coupling to fermions, so at hadron colliders the bottom contribution will dominate. Code 901."},{"name":"HiggsSM:ffbar2HW","link":"HiggsProcesses.html#anchor11","text":"HiggsSM:ffbar2HW Scattering HiggsSM:ffbar2HW f fbar &rarr; H^0 W^+- via HiggsSM:ffbar2HW s -channel HiggsSM:ffbar2HW W^+- exchange. Code 905."},{"name":"HiggsSM:ffbar2HZ","link":"HiggsProcesses.html#anchor10","text":"HiggsSM:ffbar2HZ Scattering HiggsSM:ffbar2HZ f fbar &rarr; H^0 Z^0 via HiggsSM:ffbar2HZ s -channel HiggsSM:ffbar2HZ Z^0 exchange. Code 904."},{"name":"HiggsSM:gg2H","link":"HiggsProcesses.html#anchor8","text":"HiggsSM:gg2H Scattering HiggsSM:gg2H g g &rarr; H^0 via loop contributions primarily from top. Code 902."},{"name":"HiggsSM:gg2Hbbbar","link":"HiggsProcesses.html#anchor17","text":"HiggsSM:gg2Hbbbar Scattering HiggsSM:gg2Hbbbar g g &rarr; H^0 b bbar. This process is yet one order higher of the HiggsSM:gg2Hbbbar b bbar &rarr; H^0 and HiggsSM:gg2Hbbbar b g &rarr; H^0 b chain, where now two quarks should be required above some large HiggsSM:gg2Hbbbar pT threshold. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 912."},{"name":"HiggsSM:gg2Hg(l:t)","link":"HiggsProcesses.html#anchor19","text":"HiggsSM:gg2Hg(l:t) Scattering HiggsSM:gg2Hg(l:t) g g &rarr; H^0 g via loop contributions primarily from top. Code 914."},{"name":"HiggsSM:gg2Httbar","link":"HiggsProcesses.html#anchor14","text":"HiggsSM:gg2Httbar Scattering HiggsSM:gg2Httbar g g &rarr; H^0 t tbar via HiggsSM:gg2Httbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 908."},{"name":"HiggsSM:gmgm2H","link":"HiggsProcesses.html#anchor9","text":"HiggsSM:gmgm2H Scattering HiggsSM:gmgm2H gamma gamma &rarr; H^0 via loop contributions primarily from top and HiggsSM:gmgm2H W. Code 903."},{"name":"HiggsSM:NLOWidths","link":"HiggsProcesses.html#anchor5","text":"HiggsSM:NLOWidths The partial width of the SM Higgs particle are multiplied by the respective factors needed to bring the LO widths encoded in PYTHIA to the NLO ones recommended by the LHCXSWG. The multiplicative factors have been derived for a 125 GeV Higgs, but should apply for a reasonable mass range around that value."},{"name":"HiggsSM:qg2Hq","link":"HiggsProcesses.html#anchor16","text":"HiggsSM:qg2Hq Scattering HiggsSM:qg2Hq q g &rarr; H^0 q. This process gives first-order corrections to the HiggsSM:qg2Hq f fbar &rarr; H^0 one above, and should only be used to study  the high- HiggsSM:qg2Hq pT tail, while HiggsSM:qg2Hq f fbar &rarr; H^0 should be used for inclusive production. Only the dominant HiggsSM:qg2Hq c and HiggsSM:qg2Hq b contributions are included, and generated separately for technical reasons. Note that another first-order process would be HiggsSM:qg2Hq q qbar &rarr; H^0 g , which is not explicitly implemented here, but is obtained from showering off the lowest-order process. It does not contain any HiggsSM:qg2Hq b at large HiggsSM:qg2Hq pT , however, so is less interesting for many applications. Code 911."},{"name":"HiggsSM:qg2Hq(l:t)","link":"HiggsProcesses.html#anchor20","text":"HiggsSM:qg2Hq(l:t) Scattering HiggsSM:qg2Hq(l:t) q g &rarr; H^0 q via loop contributions primarily from top. Not to be confused with the HiggsSM:qg2Hq(l:t) HiggsSM:qg2Hq process above, with its direct fermion-to-Higgs coupling. Code 915."},{"name":"HiggsSM:qqbar2Hbbbar","link":"HiggsProcesses.html#anchor18","text":"HiggsSM:qqbar2Hbbbar Scattering HiggsSM:qqbar2Hbbbar q qbar &rarr; H^0 b bbar via an HiggsSM:qqbar2Hbbbar s -channel gluon, so closely related to the previous one, but typically less important owing to the smaller rate of (anti)quarks relative to gluons. Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 913."},{"name":"HiggsSM:qqbar2Hg(l:t)","link":"HiggsProcesses.html#anchor21","text":"HiggsSM:qqbar2Hg(l:t) Scattering HiggsSM:qqbar2Hg(l:t) q qbar &rarr; H^0 g via an HiggsSM:qqbar2Hg(l:t) s -channel gluon and loop contributions primarily from top. Is strictly speaking a 'new' process, not directly derived from HiggsSM:qqbar2Hg(l:t) g g &rarr; H^0 , and could therefore be included in the standard mix without double-counting, but is numerically negligible. Code 916."},{"name":"HiggsSM:qqbar2Httbar","link":"HiggsProcesses.html#anchor15","text":"HiggsSM:qqbar2Httbar Scattering HiggsSM:qqbar2Httbar q qbar &rarr; H^0 t tbar via HiggsSM:qqbar2Httbar t tbar fusion (or, alternatively put, Higgs radiation off a top line). Warning: unfortunately this process is rather slow, owing to a lengthy cross-section expression and inefficient phase-space selection. Code 909."},{"name":"Init:showAllParticleData","link":"MainProgramSettings.html#anchor7","text":"Init:showAllParticleData Print a list of all particle and decay data. Warning: this will be a long list."},{"name":"Init:showAllSettings","link":"MainProgramSettings.html#anchor4","text":"Init:showAllSettings Print a list of all flag/mode/parameter/word settings. Warning: this will be a long list."},{"name":"Init:showChangedParticleData","link":"MainProgramSettings.html#anchor5","text":"Init:showChangedParticleData Print a list of particle and decay data for those particles that were changed (one way or another)."},{"name":"Init:showChangedResonanceData","link":"MainProgramSettings.html#anchor6","text":"Init:showChangedResonanceData In the previous listing also include the resonances that are initialized at the beginning of a run and thus get new particle data, even if these may well agree with the default ones. Warning: this will be a rather long list."},{"name":"Init:showChangedSettings","link":"MainProgramSettings.html#anchor3","text":"Init:showChangedSettings Print a list of the changed flag/mode/parameter/word settings."},{"name":"Init:showMultipartonInteractions","link":"MainProgramSettings.html#anchor2","text":"Init:showMultipartonInteractions Print initialization information for the multiparton interactions machinery."},{"name":"Init:showOneParticleData","link":"MainProgramSettings.html#anchor8","text":"Init:showOneParticleData Print particle and decay data for the particle with this particular identity code. Default means that no particle is printed."},{"name":"Init:showProcesses","link":"MainProgramSettings.html#anchor1","text":"Init:showProcesses Print a list of all processes that will be simulated, with their estimated cross section maxima, as used for the subsequent Monte Carlo selection. Also print corresponding Les Houches initialization data, where relevant."},{"name":"JetMatching:clFact","link":"JetMatching.html#anchor24","text":"JetMatching:clFact The JetMatching:clFact clFact parameter determines how jet-to parton matching is done. A match is defined as a squared cluster scale that equals: JetMatching:clFact JetMatching:clFact |clFact| * qCut for inclusive mode, JetMatching:clFact JetMatching:clFact |clFact| * max(qCut,min(p JetMatching:clFact T (parton))) for exclusive mode, JetMatching:clFact clFact &ge; 0, or JetMatching:clFact JetMatching:clFact |clFact| * min(k JetMatching:clFact T (parton)) for exclusive mode, JetMatching:clFact clFact < 0."},{"name":"JetMatching:coneMatchHeavy","link":"JetMatching.html#anchor20","text":"JetMatching:coneMatchHeavy The JetMatching:coneMatchHeavy coneMatchHeavy parameter used when JetMatching:coneMatchHeavy JetMatching:jetMatch = 1."},{"name":"JetMatching:coneMatchLight","link":"JetMatching.html#anchor18","text":"JetMatching:coneMatchLight The JetMatching:coneMatchLight coneMatchLight parameter used when JetMatching:coneMatchLight JetMatching:jetMatch = 1."},{"name":"JetMatching:coneRadius","link":"JetMatching.html#anchor11","text":"JetMatching:coneRadius For the JetMatching:coneRadius CellJet algorithm, this gives the size of the cone in JetMatching:coneRadius (eta, phi) space drawn around the geometric center of the jet. For the JetMatching:coneRadius SlowJet algorithm, this gives the JetMatching:coneRadius R parameter."},{"name":"JetMatching:coneRadiusHeavy","link":"JetMatching.html#anchor19","text":"JetMatching:coneRadiusHeavy The JetMatching:coneRadiusHeavy coneRadiusHeavy parameter used when JetMatching:coneRadiusHeavy JetMatching:jetMatch = 1. When assigned a negative value, the value of JetMatching:coneRadiusHeavy JetMatching:coneRadius is used."},{"name":"JetMatching:doFxFx","link":"JetMatching.html#anchor26","text":"JetMatching:doFxFx If turned on, then FxFx merging with aMC\@NLO inputs is performed. Note that this requires event samples that are specifically generated for this task."},{"name":"JetMatching:doShowerKt","link":"JetMatching.html#anchor21","text":"JetMatching:doShowerKt This switch changes the merging prescription to the shower-kT matching scheme outlined in JetMatching:doShowerKt Alw08. This scheme differs from 'classical' MLM jet matching with respect to when the matching veto is checked. The shower-kT scheme considers already immediately after the first shower emission if an event should be discarded. A detailed comparison of the 'classical' MLM prescription (e.g. Madgraph-style matching with JetMatching:doShowerKt JetMatching:doShowerKt = off ) and the shower-kT scheme are in preparation."},{"name":"JetMatching:doVeto","link":"JetMatching.html#anchor25","text":"JetMatching:doVeto If turned off, then no jet matching veto will be applied internally in Pythia. Instead, it is assumed that the (expert) user enforces all necessary vetoes externally by some other means. Do not change the default value unless you are an expert in MLM jet matching and want to use your own code to perform the necessary vetoes."},{"name":"JetMatching:etaJetMax","link":"JetMatching.html#anchor12","text":"JetMatching:etaJetMax For both jet algorithms, this defines the maximum pseudorapidity that the detector is assumed to cover. In this context, however, it is tied to the phase space region in which partons have been generated. For the Alpgen-style matching, particles within JetMatching:etaJetMax etaJetMax + coneRadius are passed to the jet algorithm, with only jets within JetMatching:etaJetMax etaJetMax retained in the merging. For the Madgraph-style matching, only particles within JetMatching:etaJetMax etaJetMax are used."},{"name":"JetMatching:eTjetMin","link":"JetMatching.html#anchor10","text":"JetMatching:eTjetMin For the JetMatching:eTjetMin CellJet algorithm, this gives the minimum transverse energy inside a cone for a jet to be accepted. For the JetMatching:eTjetMin SlowJet algorithm, this is instead the minimum transverse momentum required for a cluster to be accepted as a jet. For Madgraph-style matching, this parameter should match the JetMatching:eTjetMin qCut parameter described later."},{"name":"JetMatching:eTseed","link":"JetMatching.html#anchor8","text":"JetMatching:eTseed Specific to the JetMatching:eTseed CellJet algorithm, the minimum JetMatching:eTseed eT for a cell to be acceptable as the trial center of a jet."},{"name":"JetMatching:eTthreshold","link":"JetMatching.html#anchor9","text":"JetMatching:eTthreshold Specific to the JetMatching:eTthreshold CellJet algorithm, cells with JetMatching:eTthreshold eT < eTthreshold are completely neglected by the jet algorithm."},{"name":"JetMatching:exclusive","link":"JetMatching.html#anchor13","text":"JetMatching:exclusive Exclusive or inclusive merging. JetMatching:exclusive The merging is run in inclusive mode. All partons must match jets, but additional jets are allowed, provided they are not harder than the matched jets. JetMatching:exclusive The merging is run in exclusive mode.  All partons must match jets, and no additional jets are allowed. JetMatching:exclusive If JetMatching:exclusive nJet < nJetMax , then the merging is run in exclusive mode, otherwise it is run in inclusive mode. For Madgraph-style matching, this is checked on an event-by-event basis, which is useful when an LHEF contains a 'soup' of partonic multiplicities. If JetMatching:exclusive nJetMax < 0 or JetMatching:exclusive nJet < 0 , then the algorithm defaults to exclusive mode."},{"name":"JetMatching:jetAlgorithm","link":"JetMatching.html#anchor4","text":"JetMatching:jetAlgorithm The choice of jet algorithm to use when merging against hard partons. Currently, only JetMatching:jetAlgorithm SlowJet with the k JetMatching:jetAlgorithm T algorithm (and JetMatching:jetAlgorithm useStandardR = false ) is supported for Madgraph-style matching, while there is full freedom for the ALPGEN-style matching. JetMatching:jetAlgorithm The JetMatching:jetAlgorithm CellJet cone algorithm. JetMatching:jetAlgorithm The JetMatching:jetAlgorithm SlowJet clustering algorithm."},{"name":"JetMatching:jetAllow","link":"JetMatching.html#anchor16","text":"JetMatching:jetAllow Controls which particles are clustered by the jet algorithm. JetMatching:jetAllow This option explicitly disallows top quarks, leptons and photons. All other particle types are passed to the jet algorithm. JetMatching:jetAllow No extra particles are disallowed."},{"name":"JetMatching:jetMatch","link":"JetMatching.html#anchor17","text":"JetMatching:jetMatch Criteria for matching a clustered jet to a parton. JetMatching:jetMatch This option can be used with both the JetMatching:jetMatch CellJet and JetMatching:jetMatch SlowJet algorithms. The JetMatching:jetMatch delta R between each parton and jet is taken, and the minimal value compared against JetMatching:jetMatch coneMatchLight * coneRadius for light jets or JetMatching:jetMatch coneMatchHeavy * coneRadiusHeavy for heavy jets. Note that by default JetMatching:jetMatch coneRadiusHeavy = coneRadius , see below. If below this value, the parton and jet are considered to match. With JetMatching:jetMatch CellJet , the JetMatching:jetMatch delta R measure is in JetMatching:jetMatch (eta, phi) , while with JetMatching:jetMatch SlowJet it is in JetMatching:jetMatch (y, phi). JetMatching:jetMatch This option can only be used with the JetMatching:jetMatch SlowJet algorithm. The hard partons are inserted into the parton level event as 'ghost' particles, but at the correct JetMatching:jetMatch (y, phi) position. If this particle is then clustered into a jet, it is considered a match."},{"name":"JetMatching:merge","link":"JetMatching.html#anchor2","text":"JetMatching:merge Master switch to activate parton-jet matching. When off, all external events are accepted (unless they are rejected due to weighting or event processing problems)."},{"name":"JetMatching:nEta","link":"JetMatching.html#anchor6","text":"JetMatching:nEta Specific to the JetMatching:nEta CellJet algorithm, the number of bins in pseudorapidity."},{"name":"JetMatching:nJet","link":"JetMatching.html#anchor14","text":"JetMatching:nJet When JetMatching:nJet JetMatching:exclusive = 2 , JetMatching:nJet nJet indicates the minimum number of additional light jets in the incoming process. This value may be set automatically."},{"name":"JetMatching:nJetMax","link":"JetMatching.html#anchor15","text":"JetMatching:nJetMax When JetMatching:nJetMax JetMatching:exclusive = 2 , JetMatching:nJetMax nJetMax is used to indicate the maximum number of jets that will be matched."},{"name":"JetMatching:nPartonsNow","link":"JetMatching.html#anchor27","text":"JetMatching:nPartonsNow The number of partons in Born-like events for the current input LHEF. If the current sample e.g. contains JetMatching:nPartonsNow pp &rarr; e+e- + 2 partons Born-like configurations, and JetMatching:nPartonsNow pp &rarr; e+e- + 3 partons Real-emission-type events, then JetMatching:nPartonsNow JetMatching:nPartonsNow = 2 applies."},{"name":"JetMatching:nPhi","link":"JetMatching.html#anchor7","text":"JetMatching:nPhi Specific to the JetMatching:nPhi CellJet algorithm, the number of bins in phi."},{"name":"JetMatching:nQmatch","link":"JetMatching.html#anchor23","text":"JetMatching:nQmatch Controls the treatment of heavy quarks. JetMatching:nQmatch All quarks (except top) are treated as light quarks for matching. JetMatching:nQmatch Bottom quarks are treated separately.  Currently, they are unmatched."},{"name":"JetMatching:qCut","link":"JetMatching.html#anchor22","text":"JetMatching:qCut k JetMatching:qCut T scale for merging shower products into jets."},{"name":"JetMatching:qCutME","link":"JetMatching.html#anchor28","text":"JetMatching:qCutME The cut applied to regulate multi-jet matrix elements. Note that this cut can differ from the matching scale."},{"name":"JetMatching:scheme","link":"JetMatching.html#anchor3","text":"JetMatching:scheme The parton-jet MLM-style matching scheme. JetMatching:scheme The one inspired by the Madgraph matching code, here implemented in the JetMatching:scheme JetMatchingMadgraph class. JetMatching:scheme The one inspired by the ALPGEN matching code, here implemented in the JetMatching:scheme JetMatchingAlpgen class."},{"name":"JetMatching:setMad","link":"JetMatching.html#anchor1","text":"JetMatching:setMad When enabled, the merging parameters are set according to the values in the LHEF header. Specifically, the header must set the JetMatching:setMad ickkw , JetMatching:setMad xqcut , JetMatching:setMad maxjetflavor and JetMatching:setMad alpsfact values, and JetMatching:setMad ickkw must be nonzero. Note that these labels are Madgraph-specific. For other programs with LHEF output, or for Madgraph files lacking this information, these parameters should be set by the user (or one can rely on the default values). The following parameters (described below) must then be specified: JetMatching:setMad JetMatching:setMad JetMatching:setMad JetMatching:doMerge = ickkw , JetMatching:setMad JetMatching:setMad JetMatching:qCut = xqcut , JetMatching:setMad JetMatching:setMad JetMatching:nQmatch = maxjetflavor , JetMatching:setMad JetMatching:setMad JetMatching:clFact = alpsfact. With this flag on, the values from the LHEF for these parameters take precedence over other values."},{"name":"JetMatching:slowJetPower","link":"JetMatching.html#anchor5","text":"JetMatching:slowJetPower The power to use in the JetMatching:slowJetPower SlowJet algorithm. JetMatching:slowJetPower The anti-k JetMatching:slowJetPower T algorithm. JetMatching:slowJetPower The Cambridge/Aachen algorithm. JetMatching:slowJetPower The k JetMatching:slowJetPower T algorithm."},{"name":"keywords","link":"Variations.html#anchor13","text":"keywords"},{"name":"LeftRightSymmmetry:all","link":"LeftRightSymmetryProcesses.html#anchor1","text":"LeftRightSymmmetry:all Common switch for the group of implemented processes within a left-right-symmetric scenario."},{"name":"LeftRightSymmmetry:coupHee","link":"LeftRightSymmetryProcesses.html#anchor19","text":"LeftRightSymmmetry:coupHee Yukawa coupling for LeftRightSymmmetry:coupHee H^-- &rarr; e- e-."},{"name":"LeftRightSymmmetry:coupHmue","link":"LeftRightSymmetryProcesses.html#anchor20","text":"LeftRightSymmmetry:coupHmue Yukawa coupling for LeftRightSymmmetry:coupHmue H^-- &rarr; mu- e-."},{"name":"LeftRightSymmmetry:coupHmumu","link":"LeftRightSymmetryProcesses.html#anchor21","text":"LeftRightSymmmetry:coupHmumu Yukawa coupling for LeftRightSymmmetry:coupHmumu H^-- &rarr; mu- mu-."},{"name":"LeftRightSymmmetry:coupHtaue","link":"LeftRightSymmetryProcesses.html#anchor22","text":"LeftRightSymmmetry:coupHtaue Yukawa coupling for LeftRightSymmmetry:coupHtaue H^-- &rarr; tau- e-."},{"name":"LeftRightSymmmetry:coupHtaumu","link":"LeftRightSymmetryProcesses.html#anchor23","text":"LeftRightSymmmetry:coupHtaumu Yukawa coupling for LeftRightSymmmetry:coupHtaumu H^-- &rarr; tau- mu-."},{"name":"LeftRightSymmmetry:coupHtautau","link":"LeftRightSymmetryProcesses.html#anchor24","text":"LeftRightSymmmetry:coupHtautau Yukawa coupling for LeftRightSymmmetry:coupHtautau H^-- &rarr; tau- tau-."},{"name":"LeftRightSymmmetry:ff2HLff","link":"LeftRightSymmetryProcesses.html#anchor8","text":"LeftRightSymmmetry:ff2HLff Scatterings LeftRightSymmmetry:ff2HLff f_1 f_2 &rarr; H_L^-- f_3 f_4 via LeftRightSymmmetry:ff2HLff WW fusion. Code 3125."},{"name":"LeftRightSymmmetry:ff2HRff","link":"LeftRightSymmetryProcesses.html#anchor14","text":"LeftRightSymmmetry:ff2HRff Scatterings LeftRightSymmmetry:ff2HRff f_1 f_2 &rarr; H_R^-- f_3 f_4 via LeftRightSymmmetry:ff2HRff WW fusion. Code 3145."},{"name":"LeftRightSymmmetry:ffbar2HLHL","link":"LeftRightSymmetryProcesses.html#anchor9","text":"LeftRightSymmmetry:ffbar2HLHL Scatterings LeftRightSymmmetry:ffbar2HLHL f fbar &rarr;  H_L^++ H_L^--. Code 3126."},{"name":"LeftRightSymmmetry:ffbar2HRHR","link":"LeftRightSymmetryProcesses.html#anchor15","text":"LeftRightSymmmetry:ffbar2HRHR Scatterings LeftRightSymmmetry:ffbar2HRHR f fbar &rarr;  H_R^++ H_R^--. Code 3146."},{"name":"LeftRightSymmmetry:ffbar2WR","link":"LeftRightSymmetryProcesses.html#anchor3","text":"LeftRightSymmmetry:ffbar2WR Scatterings LeftRightSymmmetry:ffbar2WR f fbar' &rarr; W_R^+. Code 3102."},{"name":"LeftRightSymmmetry:ffbar2ZR","link":"LeftRightSymmetryProcesses.html#anchor2","text":"LeftRightSymmmetry:ffbar2ZR Scatterings LeftRightSymmmetry:ffbar2ZR f fbar &rarr; Z_R^0. Code 3101."},{"name":"LeftRightSymmmetry:gL","link":"LeftRightSymmetryProcesses.html#anchor16","text":"LeftRightSymmmetry:gL lefthanded coupling LeftRightSymmmetry:gL g_L = e / sin(theta)."},{"name":"LeftRightSymmmetry:gR","link":"LeftRightSymmetryProcesses.html#anchor17","text":"LeftRightSymmmetry:gR righthanded coupling LeftRightSymmmetry:gR g_R , assumed the same as LeftRightSymmmetry:gR g_L."},{"name":"LeftRightSymmmetry:lgm2HLe","link":"LeftRightSymmetryProcesses.html#anchor5","text":"LeftRightSymmmetry:lgm2HLe Scatterings LeftRightSymmmetry:lgm2HLe l_i gamma &rarr; H_L^-- e^+. Code 3122."},{"name":"LeftRightSymmmetry:lgm2HLmu","link":"LeftRightSymmetryProcesses.html#anchor6","text":"LeftRightSymmmetry:lgm2HLmu Scatterings LeftRightSymmmetry:lgm2HLmu l_i gamma &rarr; H_L^-- mu^+. Code 3123."},{"name":"LeftRightSymmmetry:lgm2HLtau","link":"LeftRightSymmetryProcesses.html#anchor7","text":"LeftRightSymmmetry:lgm2HLtau Scatterings LeftRightSymmmetry:lgm2HLtau l_i gamma &rarr; H_L^-- tau^+. Code 3124."},{"name":"LeftRightSymmmetry:lgm2HRe","link":"LeftRightSymmetryProcesses.html#anchor11","text":"LeftRightSymmmetry:lgm2HRe Scatterings LeftRightSymmmetry:lgm2HRe l_i gamma &rarr; H_R^-- e^+. Code 3142."},{"name":"LeftRightSymmmetry:lgm2HRmu","link":"LeftRightSymmetryProcesses.html#anchor12","text":"LeftRightSymmmetry:lgm2HRmu Scatterings LeftRightSymmmetry:lgm2HRmu l_i gamma &rarr; H_R^-- mu^+. Code 3143."},{"name":"LeftRightSymmmetry:lgm2HRtau","link":"LeftRightSymmetryProcesses.html#anchor13","text":"LeftRightSymmmetry:lgm2HRtau Scatterings LeftRightSymmmetry:lgm2HRtau l_i gamma &rarr; H_R^-- tau^+. Code 3144."},{"name":"LeftRightSymmmetry:ll2HL","link":"LeftRightSymmetryProcesses.html#anchor4","text":"LeftRightSymmmetry:ll2HL Scatterings LeftRightSymmmetry:ll2HL l_i l_j &rarr; H_L^--. Code 3121."},{"name":"LeftRightSymmmetry:ll2HR","link":"LeftRightSymmetryProcesses.html#anchor10","text":"LeftRightSymmmetry:ll2HR Scatterings LeftRightSymmmetry:ll2HR l_i l_j &rarr; H_R^--. Code 3141."},{"name":"LeftRightSymmmetry:vL","link":"LeftRightSymmetryProcesses.html#anchor18","text":"LeftRightSymmmetry:vL vacuum expectation value LeftRightSymmmetry:vL v_L (in GeV) for the left-triplet."},{"name":"LeptoQuark:all","link":"LeptoquarkProcesses.html#anchor1","text":"LeptoQuark:all Common switch for the group of lowest-order LeptoQuark:all LQ production processes, i.e. the four ones below."},{"name":"LeptoQuark:gg2LQLQbar","link":"LeptoquarkProcesses.html#anchor4","text":"LeptoQuark:gg2LQLQbar Scatterings LeptoQuark:gg2LQLQbar g g &rarr; LQ LQbar. Code 3203."},{"name":"LeptoQuark:kCoup","link":"LeptoquarkProcesses.html#anchor6","text":"LeptoQuark:kCoup multiplicative factor in the LeptoQuark:kCoup LQ &rarr; q l squared Yukawa coupling, and thereby in the LeptoQuark:kCoup LQ width and the LeptoQuark:kCoup q l &rarr; LQ and other cross sections. Specifically, LeptoQuark:kCoup lambda^2/(4 pi) = k alpha_em , i.e. it corresponds to the $k$ factor of LeptoQuark:kCoup Hew88."},{"name":"LeptoQuark:qg2LQl","link":"LeptoquarkProcesses.html#anchor3","text":"LeptoQuark:qg2LQl Scatterings LeptoQuark:qg2LQl q g &rarr; LQ l. Code 3202."},{"name":"LeptoQuark:ql2LQ","link":"LeptoquarkProcesses.html#anchor2","text":"LeptoQuark:ql2LQ Scatterings LeptoQuark:ql2LQ q l &rarr; LQ. Code 3201."},{"name":"LeptoQuark:qqbar2LQLQbar","link":"LeptoquarkProcesses.html#anchor5","text":"LeptoQuark:qqbar2LQLQbar Scatterings LeptoQuark:qqbar2LQLQbar q qbar &rarr; LQ LQbar. Code 3204."},{"name":"LesHouches:idRenameBeams","link":"LesHouchesAccord.html#anchor69","text":"LesHouches:idRenameBeams PYTHIA only implements a certain number of incoming beam particles. Specifically it needs to have PDFs for every composite particle to be used. Sometimes exotic beam particles are used, e.g. when a neutralino is supposed to be the Dark Matter particle and therefore neutralino pairs can collide and annihilate. Such a particle identity code, picked by this mode, is mapped onto an incoming tau neutrino beam (or antineutrino for the second beam), to bring it to a familiar situation. The trick cannot be used for composite particles, nor for a pair of different particles."},{"name":"LesHouches:matchInOut","link":"LesHouchesAccord.html#anchor74","text":"LesHouches:matchInOut The energies and longitudinal momenta of the two incoming partons are recalculated from the sum of the outgoing final (i.e. status 1) particles. The incoming partons are set massless. There are two main applications for this option. Firstly, if there is a mismatch in the Les Houches input itself, e.g. owing to limited precision in the stored momenta. Secondly, if a mismatch is induced by PYTHIA recalculations, notably when an outgoing lepton or quark is assigned a mass although assumed massless in the Les Houches input. LesHouches:matchInOut Warning: it is assumed that the incoming partons are along the LesHouches:matchInOut +-z axis; else the kinematics construction will fail."},{"name":"LesHouches:mRecalculate","link":"LesHouchesAccord.html#anchor73","text":"LesHouches:mRecalculate Does not have any effect by default, or more generally when it is negative. If it is positive then all particles with an input mass above this value will have the mass recalculated and reset from the four-momentum, LesHouches:mRecalculate m^2 = E^2 - p^2. This step is prompted by an unforeseen choice made in some programs (like CalcHEP) of storing the nominal mass of a particle species rather than the mass of the current member of that species, a choice that is likely to induce energy-momentum nonconservation when the event is further processed. Obviously such a recalculation is problematic numerically for light particles, so it should only be used for the programs and particles where it is needed. Thus the value ought to be at least 10 GeV, so that only massive particles like LesHouches:mRecalculate W^+- , LesHouches:mRecalculate Z^0 and LesHouches:mRecalculate t are affected. If a particle does not have its mass recalculated, currently instead the energy is recalculated from its three-momntum and mass. This is to avoid spurious mismatches from limited numerical precision in an LHEF."},{"name":"LesHouches:setLeptonMass","link":"LesHouchesAccord.html#anchor71","text":"LesHouches:setLeptonMass setting of mass for final-state charged leptons. The reason here is that some matrix-element generators assume leptons to be massless, so as to simplify calculations. This is particularly common for the LesHouches:setLeptonMass e and LesHouches:setLeptonMass mu leptons, but sometimes also the LesHouches:setLeptonMass tau lepton is afflicted. Incoming leptons are not affected by this procedure. LesHouches:setLeptonMass all lepton masses are taken from the Les Houches input. LesHouches:setLeptonMass if the input lepton mass deviates by more than 10% from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. This should catch weird masses, while allowing sensible variations. LesHouches:setLeptonMass each lepton mass is reset according to the PYTHIA value. LesHouches:setLeptonMass Warning: when the mass is changed, also energy and/or momentum need to be shifted. This cannot be done for the lepton in isolation, but should be made so as to preserve the energy and momentum of the event as a whole. An attempt is therefore made to find another final-state particle recoiler that can transfer the appropriate amount of energy and momentum. The recoiler may be unstable, and if so the transfer is inherited by its decay products. The choice is straightforward if only two final-state particles exist, or in a two-body decay of an intermediate resonance, else a matching (anti)neutrino or (anti)lepton is searched for. These rules catch most of the standard cases for lepton production, such as LesHouches:setLeptonMass gamma^*/Z^0/W^+- , but not necessarily all. Should they all fail the potential final-state recoiler with largest relative invariant mass is picked. In either case, if the transfer fails because the intended recoiler has too little energy to give up, then instead the energy is recalculated for the new mass without any transfer. The energy violation is partly compensated by changed energies for the incoming partons to the hard collision if LesHouches:setLeptonMass LesHouches:matchInOut = on , but not always perfectly. One possibility then is to change the LesHouches:setLeptonMass tolerance to such errors."},{"name":"LesHouches:setLifetime","link":"LesHouchesAccord.html#anchor70","text":"LesHouches:setLifetime handling of the decay time information stored in LesHouches:setLifetime VTIMUP when the Les Houches event record is stored into the PYTHIA LesHouches:setLifetime process one. The reason is that some matrix-element generators (like POWHEG) do not set decay times, so that it is up to PYTHIA to make that selection. This is particularly important for the LesHouches:setLifetime tau lepton. LesHouches:setLifetime all decay times are taken from the Les Houches input. LesHouches:setLifetime the decay time of LesHouches:setLifetime tau leptons is generated like for internal PYTHIA LesHouches:setLifetime tau s, whereas all other decay times are taken from the Les Houches input. LesHouches:setLifetime all decay times are generated by PYTHIA, thus completely disregarding the Les Houches values. This option could go wrong in BSM scenarios with long-lived particles, if PYTHIA has not been provided with the information to select those lifetimes correctly."},{"name":"LesHouches:setQuarkMass","link":"LesHouchesAccord.html#anchor72","text":"LesHouches:setQuarkMass setting of mass for final-state quarks. The reason here is that some matrix-element generators assume all quarks to be massless, except for the top, so as to simplify calculations. Especially for LesHouches:setQuarkMass c and LesHouches:setQuarkMass b quarks this is a poor approximation, although PYTHIA most of the time still manages to shower and hadronize even such events. The reason is the resilience of the string fragmentation model, where the excess gluons near (in colour and momentum) to a massless LesHouches:setQuarkMass b are 'eaten up' when string fragmentation needs to gather enough invariant mass to give to the LesHouches:setQuarkMass B hadron. Nevertheless it is an uncomfortable situation, to be avoided where possible. For LesHouches:setQuarkMass d , LesHouches:setQuarkMass u and LesHouches:setQuarkMass s quarks the issue is less critical. Incoming or intermediate quarks are not affected by this procedure. LesHouches:setQuarkMass all quark masses are taken from the Les Houches input. LesHouches:setQuarkMass if the input LesHouches:setQuarkMass c or LesHouches:setQuarkMass b mass is more than 50% away from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. LesHouches:setQuarkMass if the input mass, for all quarks except the top, is more than 50% away from the PYTHIA (data table) mass then its mass is reset according to the PYTHIA value. LesHouches:setQuarkMass Warning: when the mass is changed, also energy and/or momentum need to be shifted. This cannot be done for the quark in isolation, but should be made so as to preserve the energy and momentum of the event as a whole. An attempt is therefore made to find another final-state particle recoiler that can transfer the appropriate amount of energy and momentum. The recoiler may be unstable, and if so the transfer is inherited by its decay products. The choice is straightforward if only two final-state particles exist, or in a two-body decay of an intermediate resonance. If no recoiler is found this way a matching opposite-coloured parton is searched for. Should also this fail the potential final-state recoiler with largest relative invariant mass is picked. In either case, if the transfer fails because the intended recoiler has too little energy to give up, then instead the energy is recalculated for the new mass without any transfer. The energy violation is partly compensated by changed energies for the incoming partons to the hard collision if LesHouches:setQuarkMass LesHouches:matchInOut = true , but not always perfectly. One possibility then is to change the LesHouches:setQuarkMass tolerance to such errors."},{"name":"Main:LHEFskipInit","link":"MainProgramSettings.html#anchor26","text":"Main:LHEFskipInit If you read several Les Houches Event Files that you want to see considered as one single combined event sample you can set this flag Main:LHEFskipInit on after the first subrun to skip (most of) the (re-)initialization step."},{"name":"Main:numberOfAcceptedEvents","link":"MainProgramSettings.html#anchor23","text":"Main:numberOfAcceptedEvents The number of events to be accepted during generation. Any number smaller than one means that the setting will be ignored."},{"name":"Main:numberOfEvents","link":"MainProgramSettings.html#anchor20","text":"Main:numberOfEvents The number of events to be generated."},{"name":"Main:numberOfSelectedEvents","link":"MainProgramSettings.html#anchor22","text":"Main:numberOfSelectedEvents The number of events to be selected during generation. Any number smaller than one means that the setting will be ignored."},{"name":"Main:numberOfSubruns","link":"MainProgramSettings.html#anchor27","text":"Main:numberOfSubruns The number of subruns you intend to use in your current run. Unlike the two settings above, Main:numberOfSubruns Pythia itself will not interpret this number, but you could e.g. have a loop in your main program to loop over subruns from 0 through Main:numberOfSubruns numberOfSubruns - 1."},{"name":"Main:numberOfTriedEvents","link":"MainProgramSettings.html#anchor21","text":"Main:numberOfTriedEvents The number of events to be tried during generation. Any number smaller than one means that the setting will be ignored."},{"name":"Main:spareFlag1","link":"MainProgramSettings.html#anchor28","text":"Main:spareFlag1"},{"name":"Main:spareFlag2","link":"MainProgramSettings.html#anchor29","text":"Main:spareFlag2"},{"name":"Main:spareFlag3","link":"MainProgramSettings.html#anchor30","text":"Main:spareFlag3"},{"name":"Main:spareMode1","link":"MainProgramSettings.html#anchor31","text":"Main:spareMode1"},{"name":"Main:spareMode2","link":"MainProgramSettings.html#anchor32","text":"Main:spareMode2"},{"name":"Main:spareMode3","link":"MainProgramSettings.html#anchor33","text":"Main:spareMode3"},{"name":"Main:spareParm1","link":"MainProgramSettings.html#anchor34","text":"Main:spareParm1"},{"name":"Main:spareParm2","link":"MainProgramSettings.html#anchor35","text":"Main:spareParm2"},{"name":"Main:spareParm3","link":"MainProgramSettings.html#anchor36","text":"Main:spareParm3"},{"name":"Main:spareWord1","link":"MainProgramSettings.html#anchor37","text":"Main:spareWord1"},{"name":"Main:spareWord2","link":"MainProgramSettings.html#anchor38","text":"Main:spareWord2"},{"name":"Main:spareWord3","link":"MainProgramSettings.html#anchor39","text":"Main:spareWord3"},{"name":"Main:subrun","link":"MainProgramSettings.html#anchor25","text":"Main:subrun The number of the current subrun, a non-negative integer, put as first line in a section of lines to be read for this particular subrun."},{"name":"Main:timesAllowErrors","link":"MainProgramSettings.html#anchor24","text":"Main:timesAllowErrors Allow this many times that Main:timesAllowErrors pythia.next() returns false, i.e. that an event is flawed, before aborting the run."},{"name":"Merging:aCollFSR","link":"CKKWLMerging.html#anchor44","text":"Merging:aCollFSR Factor with which to multiply the scalar Merging:aCollFSR pT of a final state splitting, when choosing the history by the smallest sum of scalar Merging:aCollFSR pT. Default value taken from Herwig++ Merging:aCollFSR Tul09."},{"name":"Merging:aCollISR","link":"CKKWLMerging.html#anchor45","text":"Merging:aCollISR Factor with which to multiply the scalar Merging:aCollISR pT of an initial state splitting, when choosing the history by the smallest sum of scalar Merging:aCollISR pT. Default value taken from Herwig++ Merging:aCollISR Tul09."},{"name":"Merging:allowColourShuffling","link":"CKKWLMerging.html#anchor50","text":"Merging:allowColourShuffling If on, this will allow the algorithm to swap one colour index in the state, when trying to find all possible clusterings, if no clustering has been found, but more clusterings had been requested. In this way, some incomplete histories can be avoided. Generally, we advise the non-expert user to not touch this switch, because a slight change in the colour structure can change the radiation pattern. To however study the sensitivity of the predictions on these effects, allowing for colour reshuffling can be useful."},{"name":"Merging:allowIncompleteHistoriesInReal","link":"NLOMerging.html#anchor17","text":"Merging:allowIncompleteHistoriesInReal If switched on, this will allow to keep states with incomplete parton shower histories (i.e. states that cannot be projected onto an allowed underlying Born process) in the real contributions of an NLO input sample. By default, such configurations will instead be included through higher-multiplicity tree-level matrix elements. However, NLO input samples can contain a significant number of such configurations if Diagram Subtraction (DS) techniques had been applied. In order not to change the DS scheme, it is important not to remove incomplete histories from the real-emission contribution. Note that furthermore, if this switch turned on, you will have to ensure yourself that no double-counting between states with incomplete histories will occur between NLO samples and higher-multiplicity tree-level samples. This might for example entail using the Merging:allowIncompleteHistoriesInReal MergingHooks facilities, and the function Merging:allowIncompleteHistoriesInReal double MergingHooks::dampenIfFailCuts(const Event& event)' in particular."},{"name":"Merging:allowSQCDClustering","link":"CKKWLMerging.html#anchor54","text":"Merging:allowSQCDClustering Allow clustering of gluon emission off squarks."},{"name":"Merging:allowWeakClustering","link":"CKKWLMerging.html#anchor32","text":"Merging:allowWeakClustering Allow clustering of weak bosons, as necessary if a merging of matrix elements with QCD and weak showering is attempted. Currently, only emissions of W-bosons are accounted for. This switch should only be used if weak showering is turned on (see Merging:allowWeakClustering Timelike showers , Merging:allowWeakClustering Spacelike showers and Merging:allowWeakClustering Weak showers for details on weak showering)."},{"name":"Merging:applyVeto","link":"CKKWLMerging.html#anchor56","text":"Merging:applyVeto If off, no event veto based on the merging scale is applied in CKKW-L merging. This means that the user has to implement the veto by hand in the Pythia main program. It can be useful to postpone event vetoes for the purpose of merging scale variations."},{"name":"Merging:doCutBasedMerging","link":"CKKWLMerging.html#anchor10","text":"Merging:doCutBasedMerging This switch will use cuts on ( Merging:doCutBasedMerging pT Merging:doCutBasedMerging i ), Merging:doCutBasedMerging &Delta;R Merging:doCutBasedMerging ij and Merging:doCutBasedMerging Q Merging:doCutBasedMerging ij to define when parton shower emissions are allowed. Please note for this particular merging scale definition, only light jets ( Merging:doCutBasedMerging u,d,c,s,g ) are checked."},{"name":"Merging:doKTMerging","link":"CKKWLMerging.html#anchor1","text":"Merging:doKTMerging If the additional jets in the LHE files have been regulated by a Merging:doKTMerging kT cut, the user can supply the merging scale definition by setting this flag to on. Merging:doKTMerging kT here and below means cutting on Durham Merging:doKTMerging kT for Merging:doKTMerging e+e- collisions, and cutting on longitudinally invariant Merging:doKTMerging kT for hadronic  collisions. Please note that this particular merging scale definition will check Merging:doKTMerging kT between all pairs of Merging:doKTMerging u,d,c,s,b,g partons."},{"name":"Merging:doMerging","link":"CKKWLMerging.html#anchor8","text":"Merging:doMerging Finally, it is also possible to switch on the merging machinery without switching on specific merging procedure, by turning this setting on. This is not sufficient for the internal merging of PYTHIA itself, but convenient when using an external shower plugin."},{"name":"Merging:doMGMerging","link":"CKKWLMerging.html#anchor7","text":"Merging:doMGMerging Even easier, but highly non-general, is to perform the merging with MadGraph/MadEvent-produced LHE files, with a merging scale defined by a Merging:doMGMerging kT cut.  For this, set this switch to on. The merging scale value will be read from  the +1 jet LHE file by searching for the string Merging:doMGMerging ktdurham , and  extracting the value from Merging:doMGMerging value  = ktdurham. Also, the hard  process will be read from the +0 jet LHE file, from the line containing  the string Merging:doMGMerging \@1 (the tag specifying the first process in the  MadGraph process card). For this to work, PYTHIA should be initialised on LHE files called Merging:doMGMerging NameOfYourLesHouchesFile_0.lhe (+0 jet sample) and Merging:doMGMerging NameOfYourLesHouchesFile_1.lhe (+1 jet sample) and the same naming convention for LHE files with two or more additional jets. Since for this option, the merging scale value is read from the LHEF, no merging scale value needs to be supplied by setting Merging:doMGMerging Merging:TMS.  Also, the hard process is read from LHEF, the input Merging:doMGMerging Merging::Process does not have to be defined. However, the maximal number of merged jets still has to be supplied by setting Merging:doMGMerging Merging:nJetMax."},{"name":"Merging:doNL3Loop","link":"NLOMerging.html#anchor10","text":"Merging:doNL3Loop This switch will allow the processing of POWHEG NLO events in the NL Merging:doNL3Loop 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Loop Merging:doNL3Tree and the switch Merging:doNL3Loop Merging:doNL3Subt have to be turned off. As for the estimation of cross sections, it is Merging:doNL3Loop mandatory to set the correct value of Merging:doNL3Loop Merging:nRequested."},{"name":"Merging:doNL3Subt","link":"NLOMerging.html#anchor11","text":"Merging:doNL3Subt This switch will allow the processing of tree-level events, to produce explicit phase space subtractions in the NL Merging:doNL3Subt 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Subt Merging:doNL3Tree and the switch Merging:doNL3Subt Merging:doNL3Loop have to be turned off. As for the estimation of cross sections, it is Merging:doNL3Subt mandatory to set the correct value of Merging:doNL3Subt Merging:nRequested. Furthermore, it is necessary to set the value of Merging:doNL3Subt Merging:nRecluster to one."},{"name":"Merging:doNL3Tree","link":"NLOMerging.html#anchor9","text":"Merging:doNL3Tree This switch will allow the generation of the weight that should be applied to tree-level events in the NL Merging:doNL3Tree 3 merging scheme. Please note that, in order for this to work smoothly, the switch Merging:doNL3Tree Merging:doNL3Loop and the switch Merging:doNL3Tree Merging:doNL3Subt have to be turned off. As for the estimation of cross sections, it is Merging:doNL3Tree mandatory to set the correct value of Merging:doNL3Tree Merging:nRequested."},{"name":"Merging:doPTLundMerging","link":"CKKWLMerging.html#anchor9","text":"Merging:doPTLundMerging The merging scale is then defined by finding the minimal Pythia evolution Merging:doPTLundMerging pT between sets of radiator, emitted and recoiler partons. For this particular merging scale definition, Merging:doPTLundMerging u,d,c,s,b,g are considered partons. The Pythia evolution Merging:doPTLundMerging pT of a single three-parton set is defined by Merging:doPTLundMerging Merging:doPTLundMerging pT Merging:doPTLundMerging evol = z Merging:doPTLundMerging ijk (1-z Merging:doPTLundMerging ijk )   Q Merging:doPTLundMerging ij Merging:doPTLundMerging 2 for FSR, where Merging:doPTLundMerging i is the radiating   parton, Merging:doPTLundMerging j is the emitted parton and Merging:doPTLundMerging k is the recoiler,   and Merging:doPTLundMerging Q Merging:doPTLundMerging ij Merging:doPTLundMerging 2 =     (p Merging:doPTLundMerging i + p Merging:doPTLundMerging j ) Merging:doPTLundMerging 2 , and Merging:doPTLundMerging z Merging:doPTLundMerging ijk =     x Merging:doPTLundMerging i,jk / (x Merging:doPTLundMerging i,jk + x Merging:doPTLundMerging j,ik ) with Merging:doPTLundMerging x Merging:doPTLundMerging i,jk =     2 p Merging:doPTLundMerging i (p Merging:doPTLundMerging i + p Merging:doPTLundMerging j + p Merging:doPTLundMerging k )      / (p Merging:doPTLundMerging i + p Merging:doPTLundMerging j + p Merging:doPTLundMerging k ) Merging:doPTLundMerging 2 Merging:doPTLundMerging Merging:doPTLundMerging pT Merging:doPTLundMerging evol = (1-z Merging:doPTLundMerging ijk )   Q Merging:doPTLundMerging ij Merging:doPTLundMerging 2 for ISR, where Merging:doPTLundMerging i is the radiating   parton, Merging:doPTLundMerging j is the emitted parton and Merging:doPTLundMerging k is the second   initial state parton, and Merging:doPTLundMerging Q Merging:doPTLundMerging ij Merging:doPTLundMerging 2 =    -(p Merging:doPTLundMerging i - p Merging:doPTLundMerging j ) Merging:doPTLundMerging 2 , and Merging:doPTLundMerging z Merging:doPTLundMerging ijk =    (p Merging:doPTLundMerging i - p Merging:doPTLundMerging j + p Merging:doPTLundMerging k ) Merging:doPTLundMerging 2 / (p Merging:doPTLundMerging i + p Merging:doPTLundMerging k ) Merging:doPTLundMerging 2. Merging:doPTLundMerging When using this option, the merging scale is defined by the minimum Merging:doPTLundMerging pT Merging:doPTLundMerging evol for all combinations of three partons in the event, irrespective of flavour or colour-connections. The merging scale value will be read from the Merging:doPTLundMerging Merging:TMS parameter, so that this needs to be set just as in the case of the Merging:doPTLundMerging kT -merging prescription. Of course you will also need to set Merging:doPTLundMerging Merging:Process and the maximal number of additional matrix element jets Merging:doPTLundMerging Merging:nJetMax."},{"name":"Merging:doUMEPSSubt","link":"UMEPSMerging.html#anchor2","text":"Merging:doUMEPSSubt Reweight events according to the UMEPS prescription of reweighted, integrated configurations. Please note that, in order for this to work smoothly, the switch Merging:doUMEPSSubt Merging:doUMEPSTree has to be turned off."},{"name":"Merging:doUMEPSTree","link":"UMEPSMerging.html#anchor1","text":"Merging:doUMEPSTree Reweight events according to the UMEPS prescription for tree-level configurations."},{"name":"Merging:doUNLOPSLoop","link":"NLOMerging.html#anchor13","text":"Merging:doUNLOPSLoop This switch will allow the processing of POWHEG NLO events in the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSLoop Merging:doUNLOPSTree , Merging:doUNLOPSLoop Merging:doUNLOPSSubt and Merging:doUNLOPSLoop Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is Merging:doUNLOPSLoop mandatory to set the correct value of Merging:doUNLOPSLoop Merging:nRequested."},{"name":"Merging:doUNLOPSSubt","link":"NLOMerging.html#anchor14","text":"Merging:doUNLOPSSubt This switch will allow the processing of tree-level events, to produce UMEPS subtraction terms for the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSSubt Merging:doUNLOPSTree , Merging:doUNLOPSSubt Merging:doUNLOPSLoop and Merging:doUNLOPSSubt Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is Merging:doUNLOPSSubt mandatory to set the correct value of Merging:doUNLOPSSubt Merging:nRequested. Furthermore, it is necessary to set the value of Merging:doUNLOPSSubt Merging:nRecluster to one."},{"name":"Merging:doUNLOPSSubtNLO","link":"NLOMerging.html#anchor15","text":"Merging:doUNLOPSSubtNLO This switch will allow the processing of POWHEG NLO events, to produce NLO subtraction terms for the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSSubtNLO Merging:doUNLOPSTree , Merging:doUNLOPSSubtNLO Merging:doUNLOPSLoop and Merging:doUNLOPSSubtNLO Merging:doUNLOPSSubt have to be turned off. As for the estimation of cross sections, it is Merging:doUNLOPSSubtNLO mandatory to set the correct value of Merging:doUNLOPSSubtNLO Merging:nRequested. Furthermore, it is necessary to set the value of Merging:doUNLOPSSubtNLO Merging:nRecluster to one."},{"name":"Merging:doUNLOPSTilde","link":"NLOMerging.html#anchor16","text":"Merging:doUNLOPSTilde This flag allows the UNLOPS machinery to produce the event weights if exclusive NLO input is used for the merging. This flag should be set to 'on' directly after the cross section estimates have been produced."},{"name":"Merging:doUNLOPSTree","link":"NLOMerging.html#anchor12","text":"Merging:doUNLOPSTree This switch will allow the generation of the weight that should be applied to tree-level events in the UNLOPS merging scheme. Please note that, in order for this to work smoothly, the switches Merging:doUNLOPSTree Merging:doUNLOPSLoop , Merging:doUNLOPSTree Merging:doUNLOPSSubt and Merging:doUNLOPSTree Merging:doUNLOPSSubtNLO have to be turned off. As for the estimation of cross sections, it is Merging:doUNLOPSTree mandatory to set the correct value of Merging:doUNLOPSTree Merging:nRequested."},{"name":"Merging:doUserMerging","link":"CKKWLMerging.html#anchor15","text":"Merging:doUserMerging General user defined merging on/off."},{"name":"Merging:doXSectionEstimate","link":"CKKWLMerging.html#anchor30","text":"Merging:doXSectionEstimate If on, estimate cross section after merging scale cut. This switch has to be used in conjunction with a merging scale definition (e.g. Merging:doXSectionEstimate Merging:doPTLundMerging = on ). Then, this merging scale definition will be used as a cut on the input events. After the requested number of Monte Carlo events, the cross section after the cut can be extracted by inferring the Merging:doXSectionEstimate Info::sigmaGen() method, and the number of accepted events by using Merging:doXSectionEstimate Info::nAccepted()"},{"name":"Merging:Dparameter","link":"CKKWLMerging.html#anchor3","text":"Merging:Dparameter The value of the Merging:Dparameter D parameter needed in the definition of longitudinally invariant Merging:Dparameter kT separation."},{"name":"Merging:dRijMS","link":"CKKWLMerging.html#anchor13","text":"Merging:dRijMS The value of the minimal Merging:dRijMS &Delta;R Merging:dRijMS ij separation between pairs of final state partons used in the matrix element generation, where Merging:dRijMS &Delta;R Merging:dRijMS ij Merging:dRijMS 2 = (&Delta;y Merging:dRijMS ij ) Merging:dRijMS 2 + (&Delta;&phi; Merging:dRijMS ij ) Merging:dRijMS 2."},{"name":"Merging:enforceCutOnLHE","link":"CKKWLMerging.html#anchor14","text":"Merging:enforceCutOnLHE This will check if the events read from LHE file are in the matrix element region as defined by the merging scale definition and value(s). If on, LHE input outside the matrix element region will be rejected. If off, every event is assumed to pass the merging scale cut."},{"name":"Merging:enforceStrongOrdering","link":"CKKWLMerging.html#anchor35","text":"Merging:enforceStrongOrdering If on, preferably pick parton shower histories of the matrix element which  have strongly ordered consecutive splittings, i.e. paths in which consecutive reclustered evolution scales are separated by a user-defined factor."},{"name":"Merging:fsrInRecNorm","link":"CKKWLMerging.html#anchor43","text":"Merging:fsrInRecNorm Normalisation factor with which to multiply splitting probability for final state splittings with an initial state recoiler."},{"name":"Merging:includeMassive","link":"CKKWLMerging.html#anchor34","text":"Merging:includeMassive If on, use the correct massive evolution variable and massive splitting kernels in the reconstruction and picking of parton shower histories of the matrix  element. If off, reconstruct evolution scales, kinematics and splitting kernels  as if all partons were massless."},{"name":"Merging:includeRedundant","link":"CKKWLMerging.html#anchor41","text":"Merging:includeRedundant If on, then also include PDF ratios and Merging:includeRedundant &alpha; Merging:includeRedundant s factors in the  splitting probabilities used for picking a parton shower history of the matrix  element, when picking histories by the full shower splitting probability. As argued in Merging:includeRedundant Lon11 , this should not be done since a reweighting with PDF ratios and Merging:includeRedundant &alpha; Merging:includeRedundant s factors will be performed. However, it can give useful insight in how sensitive the results  are to the prescription on how to choose PS histories."},{"name":"Merging:includeWeightInXsection","link":"CKKWLMerging.html#anchor57","text":"Merging:includeWeightInXsection If on, then the reweighting of events in the CKKW-L scheme is included in the event weight Merging:includeWeightInXsection Info::weight() , the merging weight Merging:includeWeightInXsection Info:mergingWeight() is unity, and the cross section printed by Merging:includeWeightInXsection Info::sigmaGen() includes the effect of CKKW-L merging."},{"name":"Merging:incompleteScalePrescrip","link":"CKKWLMerging.html#anchor49","text":"Merging:incompleteScalePrescrip When no complete parton shower history (i.e. starting from a Merging:incompleteScalePrescrip 2 &rarr; 2 process)  for a matrix element with additional jets can be found, such a configuration is said to have an incomplete history. Since in incomplete histories, not all  shower starting scales are determined by clusterings, a prescription for setting the starting scale of trial showers in incomplete histories is needed. Three options are provided. Merging:incompleteScalePrescrip Use factorisation scale as shower starting scale for  incomplete histories. Merging:incompleteScalePrescrip Use Merging:incompleteScalePrescrip sHat as shower starting scale for incomplete histories. Merging:incompleteScalePrescrip Use Merging:incompleteScalePrescrip s as shower starting scale for incomplete histories."},{"name":"Merging:kFactor0j","link":"NLOMerging.html#anchor6","text":"Merging:kFactor0j The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of zero-jet tree-level events."},{"name":"Merging:kFactor1j","link":"NLOMerging.html#anchor7","text":"Merging:kFactor1j The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of one-jet tree-level events."},{"name":"Merging:kFactor2j","link":"NLOMerging.html#anchor8","text":"Merging:kFactor2j The k-Factor used to rescale the tree-level (i.e. CKKW-L or UMEPS) part of two-jet tree-level events."},{"name":"Merging:ktType","link":"CKKWLMerging.html#anchor2","text":"Merging:ktType Precise functional definition of longitudinally invariant Merging:ktType kT. For e+e- collisions, Merging:ktType Durham kT is always defined by the square root of Merging:ktType min{ 2*min[ E Merging:ktType i Merging:ktType 2 , E Merging:ktType j Merging:ktType 2 ] * [ 1 - cos&theta; Merging:ktType ij ] } , so that this switch will have no effect. Merging:ktType Longitudinally invariant Merging:ktType kT is defined by the  square root of the minimum of minimal jet kinematic Merging:ktType pT ( Merging:ktType p Merging:ktType Tkin,min Merging:ktType 2 = min{ p Merging:ktType T,i Merging:ktType 2 } ) and Merging:ktType p Merging:ktType Tlon,min Merging:ktType 2 = min{ min[ p Merging:ktType T,i Merging:ktType 2 , p Merging:ktType T,j Merging:ktType 2 ] *  [ (&Delta;y Merging:ktType ij ) Merging:ktType 2 + (&Delta;&phi; Merging:ktType ij ) Merging:ktType 2 ] / D Merging:ktType 2 } , i.e. Merging:ktType kT = min{ &radic;p Merging:ktType Tkin,min Merging:ktType 2 ,  &radic;p Merging:ktType Tlon,min Merging:ktType 2 } for hadronic collisions. Note that the true rapidity of partons is used. Merging:ktType Longitudinally invariant Merging:ktType kT is defined by the  square root of the minimum of minimal jet kinematic Merging:ktType pT ( Merging:ktType p Merging:ktType Tkin,min Merging:ktType 2 = min{ p Merging:ktType T,i Merging:ktType 2 } ) and Merging:ktType p Merging:ktType Tlon,min Merging:ktType 2 = min{ min[ p Merging:ktType T,i Merging:ktType 2 , p Merging:ktType T,j Merging:ktType 2 ] * [ (&Delta;&eta; Merging:ktType ij ) Merging:ktType 2 + (&Delta;&phi; Merging:ktType ij ) Merging:ktType 2 ] / D Merging:ktType 2 } , i.e. Merging:ktType kT = min{ &radic;p Merging:ktType Tkin,min Merging:ktType 2 ,  &radic;p Merging:ktType Tlon,min Merging:ktType 2 } for hadronic collisions. Note that the pseudorapidity of partons is used. Merging:ktType Longitudinally invariant Merging:ktType kT is defined by the  square root of the minimum of minimal jet kinematic Merging:ktType pT ( Merging:ktType p Merging:ktType Tkin,min Merging:ktType 2 = min{ p Merging:ktType T,i Merging:ktType 2 } ) and Merging:ktType p Merging:ktType Tlon,min Merging:ktType 2 = min{ min[ p Merging:ktType T,i Merging:ktType 2 , p Merging:ktType T,j Merging:ktType 2 ] * [ cosh(&Delta;&eta; Merging:ktType ij ) - cos(&Delta;&phi; Merging:ktType ij ) ] / D Merging:ktType 2 } ,  i.e. Merging:ktType kT = min{ &radic;p Merging:ktType Tkin,min Merging:ktType 2 , &radic;p Merging:ktType Tlon,min Merging:ktType 2 } for hadronic collisions."},{"name":"Merging:mayRemoveDecayProducts","link":"CKKWLMerging.html#anchor53","text":"Merging:mayRemoveDecayProducts Remove products of resonances in the hard process, in case Pythia generates decay products before merging. This makes merging possible even for an indeterminate final state, if Pythia itself has produced the decay products. The merging methods will instead be invoked on the 'non-decayed' event, thus removing the limitation to only one decay channel when performing the merging. This switch is necessary e.g. for slepton pair production in association with additional QCD jets, if the input LHE file contains the resonant sleptons, and Pythia decides on a decay according to the branching fractions read from SLHA input."},{"name":"Merging:muFac","link":"NLOMerging.html#anchor2","text":"Merging:muFac The fixed factorisation scale used in the hard process cross section, as needed to generate the leading-order weight, in case the factorisation scale cannot be inferred from Les Houches event input. (This is the case for files that have been generated with the POWHEG-BOX program, since this program prints the transverse momentum scale of the real emission into the LH events.). If the value is not set, the Merging:muFac SCALUP variable of the current LH event will be used instead. If wimpy showers (see Merging:muFac Timelike Showers and Merging:muFac Spacelike Showers ) are used together with multi-jet merging, then this scale further sets the parton shower starting scale ( Merging:muFac &mu; Merging:muFac Q ) for the core hard process."},{"name":"Merging:muFacInME","link":"NLOMerging.html#anchor4","text":"Merging:muFacInME The fixed factorisation scale used in the matrix element calculation. This information is needed if factorisation scale variations in NLO merged results are attempted. Depending on the matrix element generator, it might not be possible to infer the factorisation scale from Les Houches event input, and thus, setting an explicit value is required. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the Merging:muFacInME SCALUP variable of the current LH event will be used instead."},{"name":"Merging:muRen","link":"NLOMerging.html#anchor3","text":"Merging:muRen The fixed renormalisation scale used in the hard process cross section, as needed to generate the leading-order weight, in case the renormalisation scale cannot be inferred from Les Houches event input. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the Merging:muRen SCALUP variable of the current LH event will be used instead."},{"name":"Merging:muRenInME","link":"NLOMerging.html#anchor5","text":"Merging:muRenInME The fixed renormalisation scale used in the matrix element calculation. This information is needed if renormalisation scale variations in NLO merged results are attempted, for the same reason as factorisation scales might be required. (As mentioned above, this is the case for files generated with the POWHEG-BOX program.) If the value is not set, the Merging:muRenInME SCALUP variable of the current LH event will be used instead."},{"name":"Merging:nJetMax","link":"CKKWLMerging.html#anchor4","text":"Merging:nJetMax Maximal number of additional jets in the matrix element. Note that the EW-improved 'merging of mergings' strategy presented in Merging:nJetMax Chr15a requires a different meaning of 'additional', as explained in the 'Electroweak Merging' section below."},{"name":"Merging:nJetMaxNLO","link":"NLOMerging.html#anchor1","text":"Merging:nJetMaxNLO The maximal number of additional jets for which NLO event samples are supplied by the user."},{"name":"Merging:nJetMinWinnerTakesAll","link":"CKKWLMerging.html#anchor58","text":"Merging:nJetMinWinnerTakesAll Minimal number of additional jets in the matrix element that will be handled by winner-takes-all cluctering. The default, negative value means that no clusterings will be handled by winner-takes-all, and instead all histories are constructed."},{"name":"Merging:nonJoinedNorm","link":"CKKWLMerging.html#anchor42","text":"Merging:nonJoinedNorm Normalisation factor with which to multiply splitting probability for splittings without joined evolution equation."},{"name":"Merging:nQuarksMerge","link":"CKKWLMerging.html#anchor33","text":"Merging:nQuarksMerge This switch controls which quarks flavours (labelled by PDG id's) are considered additional partons. If e.g. set to 4, then u-, d-, c- and s-quarks will be merged, while b-quarks will not be considered in the merging (corresponding to a 4-flavour merging scheme). We advise caution when changing this number. In particular, please ensure that the allowed flavour for additional partons in the input LHE file does not exceed this value, since unnecessary double-counting might occur otherwise."},{"name":"Merging:nRecluster","link":"UMEPSMerging.html#anchor3","text":"Merging:nRecluster Number of hard partons to integrate out in the UMEPS procedure."},{"name":"Merging:nRequested","link":"CKKWLMerging.html#anchor31","text":"Merging:nRequested Exact number of additional jets requested for a particular LHE file. If a file should for example only contain Merging:nRequested W Merging:nRequested + g g events, this switch should be set to '2' for this LHE file. For NLO merging schemes (see Merging:nRequested NLO Merging ), this number has to be set."},{"name":"Merging:orderInRapidity","link":"CKKWLMerging.html#anchor37","text":"Merging:orderInRapidity If on, preferably pick parton shower histories of the matrix element with  consecutive splittings ordered in rapidity and Merging:orderInRapidity pT."},{"name":"Merging:pickByFullP","link":"CKKWLMerging.html#anchor38","text":"Merging:pickByFullP If on, pick parton shower histories of the matrix element by the full shower  splitting kernels, including potential ME corrections and Jacobians from joined evolution measures."},{"name":"Merging:pickByPoPT2","link":"CKKWLMerging.html#anchor39","text":"Merging:pickByPoPT2 If on, pick parton shower histories of the matrix element by the shower  splitting kernels divided by the evolution Merging:pickByPoPT2 pT."},{"name":"Merging:pickBySumPT","link":"CKKWLMerging.html#anchor40","text":"Merging:pickBySumPT If on, exclusively pick parton shower histories of the matrix element for which have the smallest sum of scalar evolution Merging:pickBySumPT pT for consecutive splittings has been calculated."},{"name":"Merging:Process","link":"CKKWLMerging.html#anchor6","text":"Merging:Process The string specifying the hard core process, in MG4/ME notation."},{"name":"Merging:pTiMS","link":"CKKWLMerging.html#anchor12","text":"Merging:pTiMS The value of the minimal transverse momentum cut Merging:pTiMS pT Merging:pTiMS i on final state partons, as used in the matrix element generation."},{"name":"Merging:QijMS","link":"CKKWLMerging.html#anchor11","text":"Merging:QijMS The value of the invariant mass cut Merging:QijMS Q Merging:QijMS ij of pairs of final state partons used in the matrix element generation."},{"name":"Merging:scaleSeparationFactor","link":"CKKWLMerging.html#anchor36","text":"Merging:scaleSeparationFactor The factor by which scales should differ to be classified as strongly ordered."},{"name":"Merging:TMS","link":"CKKWLMerging.html#anchor5","text":"Merging:TMS The value of the merging scale. The name is inspired by the scale in evolution equations, which is often called 't', and the suffix 'MS' stands for merging  scale.  In the particular case of Merging:TMS kT -merging, this would be the value of the Merging:TMS kT -cut  in GeV. For any merging scale definition, this input is considered the actual value of the merging scale."},{"name":"Merging:unlopsTMSdefinition","link":"NLOMerging.html#anchor18","text":"Merging:unlopsTMSdefinition The definition of the merging scale for UNLOPS merging. Any value larger or equal to zero means a user-defined merging scale function (to be defined by supplying a Merging:unlopsTMSdefinition MergingHooks class) is used for UNLOPS."},{"name":"Merging:unorderedASscalePrescrip","link":"CKKWLMerging.html#anchor47","text":"Merging:unorderedASscalePrescrip Prescription which scale to use to evaluate Merging:unorderedASscalePrescrip &alpha; Merging:unorderedASscalePrescrip s weight for  splittings in a sequence of splittings which are not ordered in evolution Merging:unorderedASscalePrescrip pT. Merging:unorderedASscalePrescrip Use the combined splitting scale as argument in Merging:unorderedASscalePrescrip &alpha; Merging:unorderedASscalePrescrip s , for both splittings. Merging:unorderedASscalePrescrip Use the true reconstructed scale  as as argument in Merging:unorderedASscalePrescrip &alpha; Merging:unorderedASscalePrescrip s , for each splitting separately."},{"name":"Merging:unorderedPDFscalePrescrip","link":"CKKWLMerging.html#anchor48","text":"Merging:unorderedPDFscalePrescrip Prescription which scale to use to evaluate ratios of parton distributions for splittings in a sequence of splittings which are not ordered in evolution Merging:unorderedPDFscalePrescrip pT. Merging:unorderedPDFscalePrescrip Use the combined splitting scale as argument in PDF ratios, for both splittings. Merging:unorderedPDFscalePrescrip Use the true reconstructed scale as argument in PDF ratios, for each splitting separately."},{"name":"Merging:unorderedScalePrescrip","link":"CKKWLMerging.html#anchor46","text":"Merging:unorderedScalePrescrip When the parton shower history of the matrix element contains a sequence of splittings which are not ordered in evolution Merging:unorderedScalePrescrip pT (called an unordered history), this sequence is interpreted as a combined emission. Then, a decision on which starting scale for trial emissions off reconstructed states in this sequence of unordered splittings has to be made. Two options are available: Merging:unorderedScalePrescrip Use larger of the two reconstructed (unordered) scales as  starting scale. Merging:unorderedScalePrescrip Use smaller of the two reconstructed (unordered) scales as  starting scale."},{"name":"Merging:usePythiaQFacHard","link":"CKKWLMerging.html#anchor52","text":"Merging:usePythiaQFacHard If on, this will allow the algorithm to use a dynamical factorisation scale to evaluate parton distributions associated with the hadronic cross section of the core hard process in dijet and prompt photon events. In the calculation of PDF ratios as part of the CKKW-L weight of an event, parton distributions that should be evaluated at the scale of the core 2 - >2 process will be evaluated using the dynamical factorisation scale Pythia would attribute to this process. This means that the hard process factorisation scale is set to the smaller of the squared transverse masses of the two outgoing particles."},{"name":"Merging:usePythiaQRenHard","link":"CKKWLMerging.html#anchor51","text":"Merging:usePythiaQRenHard If on, this will allow the algorithm to use a dynamical renormalisation scale to evaluate the strong couplings of the core hard process in dijet and prompt photon events. This means that the value of Merging:usePythiaQRenHard &alpha; Merging:usePythiaQRenHard s used as coupling of the hard process in the matrix element generation will be replaced with a running coupling evaluated at the geometric mean of the squared transverse masses of the two outgoing particles, as is the default prescription in Pythia."},{"name":"Merging:useShowerPlugin","link":"CKKWLMerging.html#anchor55","text":"Merging:useShowerPlugin Use the splitting probabilities, evolution variables and phase space mappings of an external shower plugin. This will become possible as soon as new showers containing the necessary ingredients are available in Pythia."},{"name":"MiniStringFragmentation:nTry","link":"Fragmentation.html#anchor44","text":"MiniStringFragmentation:nTry Whenever the machinery is called, first this many attempts are made to pick two hadrons that the system fragments to. If the hadrons are too massive the attempt will fail, but a new subsequent try could involve other flavour and hadrons and thus still succeed. After MiniStringFragmentation:nTry nTry attempts, instead an attempt is made to produce a single hadron from the system. Should also this fail, some further attempts at obtaining two hadrons will be made before eventually giving up."},{"name":"MultipartonInteractions:a1","link":"MultipartonInteractions.html#anchor17","text":"MultipartonInteractions:a1 When MultipartonInteractions:a1 bProfile = 4 , this gives the MultipartonInteractions:a1 a1 constant in the Gaussian width. When MultipartonInteractions:a1 a1 = 0. , this reduces back to the single Gaussian case."},{"name":"MultipartonInteractions:allowDoubleRescatter","link":"MultipartonInteractions.html#anchor20","text":"MultipartonInteractions:allowDoubleRescatter Switch to allow rescattering of partons, where both incoming partons have already rescattered; on/off = true/false. Is only used if MultipartonInteractions:allowDoubleRescatter MultipartonInteractions:allowRescatter is switched on. MultipartonInteractions:allowDoubleRescatter MultipartonInteractions:allowDoubleRescatter Warning: currently there is no complete implementation that combines it with shower evolution, so you must use MultipartonInteractions:allowDoubleRescatter PartonLevel:ISR = off and MultipartonInteractions:allowDoubleRescatter PartonLevel:FSR = off. If not, a warning will be issued and double rescattering will not be simulated. The rate also comes out to be much lower than for single rescattering, so to first approximation it can be neglected."},{"name":"MultipartonInteractions:allowRescatter","link":"MultipartonInteractions.html#anchor19","text":"MultipartonInteractions:allowRescatter Switch to allow rescattering of partons; on/off = true/false. MultipartonInteractions:allowRescatter MultipartonInteractions:allowRescatter Note: the rescattering framework has not yet been implemented for the MultipartonInteractions:allowRescatter MultipartonInteractions:bProfile = 4 option, and can therefore not be switched on in that case. MultipartonInteractions:allowRescatter Warning: use with caution since machinery is still not so well tested."},{"name":"MultipartonInteractions:alphaEMorder","link":"MultipartonInteractions.html#anchor4","text":"MultipartonInteractions:alphaEMorder The running of MultipartonInteractions:alphaEMorder alpha_em used in hard processes. MultipartonInteractions:alphaEMorder first-order running, constrained to agree with MultipartonInteractions:alphaEMorder StandardModel:alphaEMmZ at the MultipartonInteractions:alphaEMorder Z^0 mass. MultipartonInteractions:alphaEMorder zeroth order, i.e. MultipartonInteractions:alphaEMorder alpha_em is kept fixed at its value at vanishing momentum transfer. MultipartonInteractions:alphaEMorder zeroth order, i.e. MultipartonInteractions:alphaEMorder alpha_em is kept fixed, but at MultipartonInteractions:alphaEMorder StandardModel:alphaEMmZ , i.e. its value at the MultipartonInteractions:alphaEMorder Z^0 mass."},{"name":"MultipartonInteractions:alphaSorder","link":"MultipartonInteractions.html#anchor3","text":"MultipartonInteractions:alphaSorder The order at which MultipartonInteractions:alphaSorder alpha_strong runs at scales away from MultipartonInteractions:alphaSorder m_Z. MultipartonInteractions:alphaSorder zeroth order, i.e. MultipartonInteractions:alphaSorder alpha_strong is kept fixed. MultipartonInteractions:alphaSorder first order, which is the normal value. MultipartonInteractions:alphaSorder second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"MultipartonInteractions:alphaSvalue","link":"MultipartonInteractions.html#anchor2","text":"MultipartonInteractions:alphaSvalue The value of MultipartonInteractions:alphaSvalue alpha_strong at MultipartonInteractions:alphaSvalue m_Z. Default value is picked equal to the one used in CTEQ 5L."},{"name":"MultipartonInteractions:bProfile","link":"MultipartonInteractions.html#anchor13","text":"MultipartonInteractions:bProfile Choice of impact parameter profile for the incoming hadron beams. MultipartonInteractions:bProfile no impact parameter dependence at all. MultipartonInteractions:bProfile a simple Gaussian matter distribution; no free parameters. MultipartonInteractions:bProfile a double Gaussian matter distribution, with the two free parameters MultipartonInteractions:bProfile coreRadius and MultipartonInteractions:bProfile coreFraction. MultipartonInteractions:bProfile an overlap function (i.e. the convolution of the matter distributions of the two incoming hadrons) of the form MultipartonInteractions:bProfile exp(- b^expPow) , where MultipartonInteractions:bProfile expPow is a free parameter. MultipartonInteractions:bProfile a Gaussian matter distribution with a width that varies according to the selected MultipartonInteractions:bProfile x value of an interaction, MultipartonInteractions:bProfile 1. + a1 log (1 / x) , where MultipartonInteractions:bProfile a1 is a free parameter. Note that once MultipartonInteractions:bProfile b has been selected for the hard process, it remains fixed for the remainder of the evolution. Also note that the machinery for MultipartonInteractions:bProfile a second hard process is not adapted to calculate the impact-parameter enhancement factor for this option."},{"name":"MultipartonInteractions:bSelScale","link":"MultipartonInteractions.html#anchor18","text":"MultipartonInteractions:bSelScale The selection of impact parameter is related to the scale of the hard process: the harder this scale is, the more central the collision. In practice this centrality saturates quickly, however, and beyond a scale of roughly 20 GeV very little changes. (The relevant quantity is that the QCD jet cross section above the scale should be a tiny fraction of the total cross section.) In MultipartonInteractions:bSelScale 2 &rarr; 1 and MultipartonInteractions:bSelScale 2 &rarr; 2 processes traditional scale choices work fine, but ambiguities arise for higher multiplicities, in particular when the scale is used for matching between the multiparton matrix elements and parton showers. Then the event scale may be chosen as that of a very low- MultipartonInteractions:bSelScale pT parton, i.e. suggesting a peripheral collision, while the much harder other partons instead would favour a central collision. Therefore the default here is to override whatever scale value have been read in from an LHEF, say. Notice that the scale used here is decoupled from the maximum scale for MPIs ( MultipartonInteractions:bSelScale MultipartonInteractions:pTmaxMatch ). MultipartonInteractions:bSelScale Use the mass for a MultipartonInteractions:bSelScale 2 &rarr; 1 process. For MultipartonInteractions:bSelScale 2 &rarr; n, n > 1 processes order the particles in falling MultipartonInteractions:bSelScale mmT = m + mT and then let the scale be MultipartonInteractions:bSelScale (mmT_1 + mmT_2)/2 + mmT_3/3 + mmT_4/4 + ... + mmT_n/n. This is constructed always to be above MultipartonInteractions:bSelScale m1 , and to assign decreasing importance to softer particles that are less likely to be associated with the hard process. MultipartonInteractions:bSelScale Use the MultipartonInteractions:bSelScale scale parameter of the event. MultipartonInteractions:bSelScale use the same scale as chosen by the rules for MultipartonInteractions:bSelScale MultipartonInteractions:pTmaxMatch."},{"name":"MultipartonInteractions:coreFraction","link":"MultipartonInteractions.html#anchor15","text":"MultipartonInteractions:coreFraction When assuming a double Gaussian matter profile, MultipartonInteractions:coreFraction bProfile = 2 , the inner core is assumed to have a fraction MultipartonInteractions:coreFraction coreFraction of the matter content of the hadron."},{"name":"MultipartonInteractions:coreRadius","link":"MultipartonInteractions.html#anchor14","text":"MultipartonInteractions:coreRadius When assuming a double Gaussian matter profile, MultipartonInteractions:coreRadius bProfile = 2 , the inner core is assumed to have a radius that is a factor MultipartonInteractions:coreRadius coreRadius smaller than the rest."},{"name":"MultipartonInteractions:deltaYRescatter","link":"MultipartonInteractions.html#anchor23","text":"MultipartonInteractions:deltaYRescatter used for some of the MultipartonInteractions:deltaYRescatter MultipartonInteractions:rescatterMode options above, as the width of the rapidity transition region, where the probability rises from zero to unity that a scattered parton is considered as a potential rescatterer."},{"name":"MultipartonInteractions:ecmPow","link":"MultipartonInteractions.html#anchor10","text":"MultipartonInteractions:ecmPow The MultipartonInteractions:ecmPow ecmPow energy rescaling pace introduced above."},{"name":"MultipartonInteractions:ecmRef","link":"MultipartonInteractions.html#anchor9","text":"MultipartonInteractions:ecmRef The MultipartonInteractions:ecmRef ecmRef reference energy scale introduced above."},{"name":"MultipartonInteractions:enhanceScreening","link":"MultipartonInteractions.html#anchor12","text":"MultipartonInteractions:enhanceScreening Choice to activate the above screening scenario, i.e. an increasing effective MultipartonInteractions:enhanceScreening pT0 for consecutive interactions. MultipartonInteractions:enhanceScreening No activity-dependent screening, i.e. MultipartonInteractions:enhanceScreening pT0 is fixed. MultipartonInteractions:enhanceScreening The MultipartonInteractions:enhanceScreening pT0 scale is increased as a function of the number of MPI's, as explained above. ISR is not affected, but note that, if MultipartonInteractions:enhanceScreening SpaceShower:samePTasMPI is on, then MultipartonInteractions:enhanceScreening MultipartonInteractions:pT0Ref is used also for ISR, which may or may not be desirable. MultipartonInteractions:enhanceScreening Both MPI and ISR influence and are influenced by the screening. That is, the dampening is reduced based on the total number of MPI and ISR steps considered so far, including the current one. This dampening is implemented both for MPI and for ISR emissions, for the latter provided that MultipartonInteractions:enhanceScreening SpaceShower:samePTasMPI is on (default)."},{"name":"MultipartonInteractions:expPow","link":"MultipartonInteractions.html#anchor16","text":"MultipartonInteractions:expPow When MultipartonInteractions:expPow bProfile = 3 it gives the power of the assumed overlap shape MultipartonInteractions:expPow exp(- b^expPow). Since the convolution of two Gaussians is another Gaussian, the overlap shape obtained for MultipartonInteractions:expPow expPow = 2 is the same as that obtained for a Gaussian matter distribution, MultipartonInteractions:expPow bProfile = 1. The limit MultipartonInteractions:expPow expPow &rarr; infinity corresponds to no impact parameter dependence at all, MultipartonInteractions:expPow bProfile = 0. The overlap shape that would be obtained for an exponential matter distribution cannot be represented exactly on this form, but a similar variance (for fixed normalisation and average MultipartonInteractions:expPow b ) is obtained for MultipartonInteractions:expPow expPow = 1.4. The double Gaussian matter profiles that are obtained for MultipartonInteractions:expPow bProfile = 2 generally correspond to the range between MultipartonInteractions:expPow expPow = 1 and MultipartonInteractions:expPow expPow = 2 , with the former representing scenarios with pronounced 'hot spots' and consequently very significant fluctuations (high variance). Note that for small MultipartonInteractions:expPow expPow the program becomes slow and unstable, so the min limit must be respected."},{"name":"MultipartonInteractions:Kfactor","link":"MultipartonInteractions.html#anchor5","text":"MultipartonInteractions:Kfactor Multiply all cross sections by this fix factor."},{"name":"MultipartonInteractions:nQuarkIn","link":"MultipartonInteractions.html#anchor24","text":"MultipartonInteractions:nQuarkIn Number of allowed incoming quark flavours in the beams; a change to 4 would thus exclude MultipartonInteractions:nQuarkIn b and MultipartonInteractions:nQuarkIn bbar as incoming partons, etc."},{"name":"MultipartonInteractions:nSample","link":"MultipartonInteractions.html#anchor25","text":"MultipartonInteractions:nSample The allowed MultipartonInteractions:nSample pT range is split (unevenly) into 100 bins, and in each of these the interaction cross section is evaluated in MultipartonInteractions:nSample nSample random phase space points. The full integral is used at initialization, and the differential one during the run as a 'Sudakov form factor' for the choice of the hardest interaction. A larger number implies increased accuracy of the calculations."},{"name":"MultipartonInteractions:processLevel","link":"MultipartonInteractions.html#anchor6","text":"MultipartonInteractions:processLevel Set of processes included in the machinery. MultipartonInteractions:processLevel only the simplest MultipartonInteractions:processLevel 2 &rarr; 2 QCD processes between quarks and gluons, giving no new flavours, i.e. dominated by MultipartonInteractions:processLevel t -channel gluon exchange. MultipartonInteractions:processLevel also MultipartonInteractions:processLevel 2 &rarr; 2 QCD processes giving new flavours (including charm and bottom), i.e. proceeding through MultipartonInteractions:processLevel s -channel gluon exchange. MultipartonInteractions:processLevel also MultipartonInteractions:processLevel 2 &rarr; 2 processes involving one or two photons in the final state, MultipartonInteractions:processLevel s -channel MultipartonInteractions:processLevel gamma boson exchange and MultipartonInteractions:processLevel t -channel MultipartonInteractions:processLevel gamma/Z^0/W^+- boson exchange. MultipartonInteractions:processLevel also charmonium and bottomonium production, via colour singlet and colour octet channels."},{"name":"MultipartonInteractions:pT0parametrization","link":"MultipartonInteractions.html#anchor7","text":"MultipartonInteractions:pT0parametrization Choice of MultipartonInteractions:pT0parametrization pT0 parametrization. MultipartonInteractions:pT0parametrization Power law dependence on MultipartonInteractions:pT0parametrization ecmNow : MultipartonInteractions:pT0parametrization MultipartonInteractions:pT0parametrization pT0 = pT0(ecmNow) = pT0Ref * (ecmNow / ecmRef)^ecmPow MultipartonInteractions:pT0parametrization Logarithmic dependence on MultipartonInteractions:pT0parametrization ecmNow : MultipartonInteractions:pT0parametrization pT0 = pT0(ecmNow) = pT0Ref + ecmPow * log (ecmNow / ecmRef) where MultipartonInteractions:pT0parametrization pT0Ref , MultipartonInteractions:pT0parametrization ecmRef and MultipartonInteractions:pT0parametrization ecmPow are the three parameters below. In case of photon-photon collisions the corresponding parameters are set in MultipartonInteractions:pT0parametrization Photoproduction."},{"name":"MultipartonInteractions:pT0Ref","link":"MultipartonInteractions.html#anchor8","text":"MultipartonInteractions:pT0Ref The MultipartonInteractions:pT0Ref pT0Ref scale in the above formula. MultipartonInteractions:pT0Ref Note: MultipartonInteractions:pT0Ref pT0Ref is one of the key parameters in a complete PYTHIA tune. Its value is intimately tied to a number of other choices, such as that of colour flow description, so unfortunately it is difficult to give an independent meaning to MultipartonInteractions:pT0Ref pT0Ref."},{"name":"MultipartonInteractions:pTmaxMatch","link":"MultipartonInteractions.html#anchor1","text":"MultipartonInteractions:pTmaxMatch Way in which the maximum scale for multiparton interactions is set to match the scale of the hard process itself. MultipartonInteractions:pTmaxMatch MultipartonInteractions:pTmaxMatch (i) if the final state of the hard process (not counting subsequent resonance decays) contains only quarks ( MultipartonInteractions:pTmaxMatch u, d, s, c, b ), gluons and photons then MultipartonInteractions:pTmaxMatch pT_max is chosen to be the factorization scale for internal processes and the MultipartonInteractions:pTmaxMatch scale value for Les Houches input; MultipartonInteractions:pTmaxMatch (ii) if not, interactions are allowed to go all the way up to the kinematical limit. The reasoning is that the former kind of processes are generated by the multiparton-interactions machinery and so would double-count hard processes if allowed to overlap the same MultipartonInteractions:pTmaxMatch pT range, while no such danger exists in the latter case. MultipartonInteractions:pTmaxMatch always use the factorization scale for an internal process and the MultipartonInteractions:pTmaxMatch scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some interactions that ought to have been simulated. MultipartonInteractions:pTmaxMatch always allow multiparton interactions up to the kinematical limit. This will simulate all possible event topologies, but may lead to double-counting. MultipartonInteractions:pTmaxMatch as option 0, but for case (i) the MultipartonInteractions:pTmaxMatch pT_max is chosen to be half the summed MultipartonInteractions:pTmaxMatch pT of the final-state particles. This may be more relevant than option 0 for multiparton final states, where the factorization scale could be associated with the lowest MultipartonInteractions:pTmaxMatch pT of any parton, as appropriate for parton showers, but not for MPI. The scale for no doublecounting and no gaps should rather be associated with the 'core' MultipartonInteractions:pTmaxMatch 2 &rarr; 2 hard process, which here is approximated by MultipartonInteractions:pTmaxMatch sum pT / 2. MultipartonInteractions:pTmaxMatch Note: If a 'second hard' process is present, the two are analyzed separately for the default 0 option, and for 3. It is enough that one of them only consists of quarks, gluons and photons to restrict the MultipartonInteractions:pTmaxMatch pT range. The maximum for MPI is then set by the hard interaction with lowest scale."},{"name":"MultipartonInteractions:pTmin","link":"MultipartonInteractions.html#anchor11","text":"MultipartonInteractions:pTmin Lower cutoff in MultipartonInteractions:pTmin pT , below which no further interactions are allowed. Normally MultipartonInteractions:pTmin pT0 above would be used to provide the main regularization of the cross section for MultipartonInteractions:pTmin pT &rarr; 0 , in which case MultipartonInteractions:pTmin pTmin is used  mainly for technical reasons. It is possible, however, to set MultipartonInteractions:pTmin pT0Ref = 0 and use MultipartonInteractions:pTmin pTmin to provide a step-function regularization, or to combine them in intermediate approaches. Currently MultipartonInteractions:pTmin pTmin is taken to be energy-independent."},{"name":"MultipartonInteractions:rescatterMode","link":"MultipartonInteractions.html#anchor21","text":"MultipartonInteractions:rescatterMode Selection of which partons rescatter against unscattered partons from the incoming beams A and B, based on their rapidity value MultipartonInteractions:rescatterMode y in the collision rest frame. Here MultipartonInteractions:rescatterMode ySep is shorthand for MultipartonInteractions:rescatterMode MultipartonInteractions:ySepRescatter and MultipartonInteractions:rescatterMode deltaY for MultipartonInteractions:rescatterMode MultipartonInteractions:deltaYRescatter , defined below. The description is symmetric between the two beams, so only one case is described below. MultipartonInteractions:rescatterMode only scattered partons with MultipartonInteractions:rescatterMode y > 0 can collide with unscattered partons from beam B. MultipartonInteractions:rescatterMode only scattered partons with MultipartonInteractions:rescatterMode y > ySep can collide with unscattered partons from beam B. MultipartonInteractions:rescatterMode the probability for a scattered parton to be considered as a potential rescatterer against unscattered partons in beam B increases linearly from zero at MultipartonInteractions:rescatterMode y = ySep - deltaY to unity at MultipartonInteractions:rescatterMode y = ySep + deltaY. MultipartonInteractions:rescatterMode the probability for a scattered parton to be considered as a potential rescatterer against unscattered partons in beam B increases with MultipartonInteractions:rescatterMode y according to MultipartonInteractions:rescatterMode (1/2) * (1 + tanh( (y - ySep) / deltaY)). MultipartonInteractions:rescatterMode all partons are potential rescatterers against both beams."},{"name":"MultipartonInteractions:ySepRescatter","link":"MultipartonInteractions.html#anchor22","text":"MultipartonInteractions:ySepRescatter used for some of the MultipartonInteractions:ySepRescatter MultipartonInteractions:rescatterMode options above, as the rapidity for which a scattered parton has a 50% probability to be considered as a potential rescatterer. A MultipartonInteractions:ySepRescatter ySep > 0 generally implies that some central partons cannot rescatter at all, while a MultipartonInteractions:ySepRescatter ySep < 0 instead allows central partons to scatter against either beam."},{"name":"NewGaugeBoson:ffbar2gmZZprime","link":"NewGaugeBosonProcesses.html#anchor1","text":"NewGaugeBoson:ffbar2gmZZprime Scattering NewGaugeBoson:ffbar2gmZZprime f fbar &rarr;Z'^0. Code 3001."},{"name":"NewGaugeBoson:ffbar2R0","link":"NewGaugeBosonProcesses.html#anchor46","text":"NewGaugeBoson:ffbar2R0 Scattering NewGaugeBoson:ffbar2R0 f_1 fbar_2 &rarr; R^0 &rarr; f_3 fbar_4 , where NewGaugeBoson:ffbar2R0 f_1 and NewGaugeBoson:ffbar2R0 fbar_2 are separated by NewGaugeBoson:ffbar2R0 +- one generation and similarly for NewGaugeBoson:ffbar2R0 f_3 and NewGaugeBoson:ffbar2R0 fbar_4. Thus possible final states are e.g. NewGaugeBoson:ffbar2R0 d sbar , NewGaugeBoson:ffbar2R0 u cbar NewGaugeBoson:ffbar2R0 s bbar , NewGaugeBoson:ffbar2R0 c tbar , NewGaugeBoson:ffbar2R0 e- mu+ and NewGaugeBoson:ffbar2R0 mu- tau+. Code 3041."},{"name":"NewGaugeBoson:ffbar2Wprime","link":"NewGaugeBosonProcesses.html#anchor39","text":"NewGaugeBoson:ffbar2Wprime Scattering NewGaugeBoson:ffbar2Wprime f fbar' &rarr; W'^+-. Code 3021."},{"name":"Next:numberCount","link":"MainProgramSettings.html#anchor9","text":"Next:numberCount Print a line telling how many events have been generated so far, once every Next:numberCount numberCount events. If set zero then no lines are ever printed. Next:numberCount In Next:numberCount include/Pythia8Plugins/ProgressLog.h an alternative method is implemented that intermittently prints out run progress information, reports on CPU usage and estimates when the run will end. It is used in the Next:numberCount main111.cc example."},{"name":"Next:numberShowEvent","link":"MainProgramSettings.html#anchor13","text":"Next:numberShowEvent The number of events to list the Next:numberShowEvent event record for, where relevant."},{"name":"Next:numberShowInfo","link":"MainProgramSettings.html#anchor11","text":"Next:numberShowInfo The number of events to list the Next:numberShowInfo Info information for, where relevant."},{"name":"Next:numberShowLHA","link":"MainProgramSettings.html#anchor10","text":"Next:numberShowLHA The number of events to list the Les Houches input information for, where relevant."},{"name":"Next:numberShowProcess","link":"MainProgramSettings.html#anchor12","text":"Next:numberShowProcess The number of events to list the Next:numberShowProcess process record for, where relevant."},{"name":"Next:showMothersAndDaughters","link":"MainProgramSettings.html#anchor15","text":"Next:showMothersAndDaughters In addition to the normal information in the listing of the Next:showMothersAndDaughters process and Next:showMothersAndDaughters event records, further lines list all the mothers and daughters of each particle."},{"name":"Next:showScaleAndVertex","link":"MainProgramSettings.html#anchor14","text":"Next:showScaleAndVertex In addition to the normal information in the listing of the Next:showScaleAndVertex process and Next:showScaleAndVertex event records, a second line per particle provides information on the production scale, particle polarization and production vertex."},{"name":"Onia:all","link":"OniaProcesses.html#anchor3","text":"Onia:all Common switch for the group of onia production."},{"name":"Onia:all(3DJ)","link":"OniaProcesses.html#anchor6","text":"Onia:all(3DJ) Common switch for the group of Onia:all(3DJ) 3DJ onia production, e.g. Onia:all(3DJ) psi(3770)."},{"name":"Onia:all(3PJ)","link":"OniaProcesses.html#anchor5","text":"Onia:all(3PJ) Common switch for the group of Onia:all(3PJ) 3PJ onia production, e.g. Onia:all(3PJ) chi_c and Onia:all(3PJ) chi_b."},{"name":"Onia:all(3S1)","link":"OniaProcesses.html#anchor4","text":"Onia:all(3S1) Common switch for the group of Onia:all(3S1) 3S1 onia production, e.g. Onia:all(3S1) J/psi and Onia:all(3S1) Upsilon."},{"name":"Onia:forceMassSplit","link":"OniaProcesses.html#anchor1","text":"Onia:forceMassSplit Force the mass splitting between the colour-singlet states and their corresponding colour-octet state to be Onia:forceMassSplit Onia:massSplit."},{"name":"Onia:massSplit","link":"OniaProcesses.html#anchor2","text":"Onia:massSplit Mass splitting in GeV between the physical colour-singlet states and their corresponding colour-octet state."},{"name":"ParticleData:alphaSvalueMRun","link":"ParticleData.html#anchor9","text":"ParticleData:alphaSvalueMRun the ParticleData:alphaSvalueMRun alpha_s(M_Z) value used to define the rate at which MSbar masses run."},{"name":"ParticleData:maxEnhanceBW","link":"ParticleData.html#anchor2","text":"ParticleData:maxEnhanceBW The modifications in options 2 and 4 above enhance the large-mass tail of the Breit-Wigner distributions (the mass spectrum develops a ParticleData:maxEnhanceBW dm/m divergence). However, we expect form factors to dampen this tail at masses some distance above the nominal one, so cut off the rise by requiring the actual Breit-Wigner weight not to be more than a factor ParticleData:maxEnhanceBW maxEnhanceBW above the one obtained with options 1 or 3, respectively. This also opens up for a simpler technical handling of mass selection in options 2 and 4, by using standard hit-and-miss Monte Carlo."},{"name":"ParticleData:mbRun","link":"ParticleData.html#anchor7","text":"ParticleData:mbRun the b quark MSbar mass at the mass scale itself."},{"name":"ParticleData:mcRun","link":"ParticleData.html#anchor6","text":"ParticleData:mcRun the c quark MSbar mass at the mass scale itself."},{"name":"ParticleData:mdRun","link":"ParticleData.html#anchor3","text":"ParticleData:mdRun the d quark MSbar mass at 2 GeV scale."},{"name":"ParticleData:modeBreitWigner","link":"ParticleData.html#anchor1","text":"ParticleData:modeBreitWigner Selection of particle masses when the ParticleData:modeBreitWigner mSel(id) is called to provide a new mass: ParticleData:modeBreitWigner mass is fixed at the nominal ParticleData:modeBreitWigner m_0 value. ParticleData:modeBreitWigner particles registered as having a mass width are given a mass in the range ParticleData:modeBreitWigner m_min < m < m_max , according to a truncated nonrelativistic Breit-Wigner, i.e. linear in ParticleData:modeBreitWigner m. ParticleData:modeBreitWigner as above, except that the width is made mass-dependent: ParticleData:modeBreitWigner Gamma = Gamma_0 * sqrt( (m^2 - m_thr^2) / (m_0^2 - m_thr^2) ) where ParticleData:modeBreitWigner m is the current mass, ParticleData:modeBreitWigner m_0 the nominal one and ParticleData:modeBreitWigner m_thr is the mass threshold, given by the sum of the nominal masses of the decay products. In order to decouple production and decay the threshold is defined as the branching-ratio-weighted average over all allowed decay channels. ParticleData:modeBreitWigner particles registered as having a mass width are given a mass in the range ParticleData:modeBreitWigner m_min < m < m_max , according to a truncated relativistic Breit-Wigner, i.e. quadratic in ParticleData:modeBreitWigner m. ParticleData:modeBreitWigner as 3, but the width is modified as for 2, and the current mass is used for its phase-space prefactor, i.e. ParticleData:modeBreitWigner m_0 Gamma_0 &rarr; m Gamma(m). ParticleData:modeBreitWigner Note: this mode only applies to normal hadronic resonances like the ParticleData:modeBreitWigner rho. The more massive states of the ParticleData:modeBreitWigner isResonance() type, like ParticleData:modeBreitWigner Z^0 or top, are considered separately."},{"name":"ParticleData:msRun","link":"ParticleData.html#anchor5","text":"ParticleData:msRun the s quark MSbar mass at 2 GeV scale."},{"name":"ParticleData:mtRun","link":"ParticleData.html#anchor8","text":"ParticleData:mtRun the t quark MSbar mass at the mass scale itself."},{"name":"ParticleData:muRun","link":"ParticleData.html#anchor4","text":"ParticleData:muRun the u quark MSbar mass at 2 GeV scale."},{"name":"ParticleDecays:allowPhotonRadiation","link":"ParticleDecays.html#anchor17","text":"ParticleDecays:allowPhotonRadiation Allow or not photon radiations in decays to a lepton pair, see above. ParticleDecays:allowPhotonRadiation Note: The current default is to have radiation switched off, in order to avoid double-counting of emissions if you link to an external QED-radiation program, as is the norm in many collaborations."},{"name":"ParticleDecays:colRearrange","link":"ParticleDecays.html#anchor24","text":"ParticleDecays:colRearrange When a decay is given as a list of four partons to be turned into hadrons (primarily for modes 41 - 80)  it is assumed that they are listed in pairs, as a first and a second colour singlet, which could give rise to separate sets of hadrons. Here ParticleDecays:colRearrange colRearrange is the probability that this original assignment is not respected, and default corresponds to no memory of this original colour topology."},{"name":"ParticleDecays:FSRinDecays","link":"ParticleDecays.html#anchor25","text":"ParticleDecays:FSRinDecays When a particle decays to ParticleDecays:FSRinDecays q qbar , ParticleDecays:FSRinDecays g g , ParticleDecays:FSRinDecays g g g or ParticleDecays:FSRinDecays gamma g g , with ParticleDecays:FSRinDecays meMode > 90 , allow or not a shower to develop from it, before the partonic system is hadronized. (The typical example is ParticleDecays:FSRinDecays Upsilon decay.) In addition, some variables defined for string fragmentation and for flavour production are used also here."},{"name":"ParticleDecays:limitCylinder","link":"ParticleDecays.html#anchor7","text":"ParticleDecays:limitCylinder When on, only particles with a decay within a volume limited by ParticleDecays:limitCylinder rho = sqrt(x^2 + y^2) < xyMax and ParticleDecays:limitCylinder |z| < zMax are decayed. There is assumed to be no magnetic field or other detector effects."},{"name":"ParticleDecays:limitRadius","link":"ParticleDecays.html#anchor5","text":"ParticleDecays:limitRadius When on, only particles with a decay within a radius ParticleDecays:limitRadius r < rMax are decayed. There is assumed to be no magnetic field or other detector effects."},{"name":"ParticleDecays:limitTau","link":"ParticleDecays.html#anchor3","text":"ParticleDecays:limitTau When on, only particles with ParticleDecays:limitTau tau < tauMax are decayed."},{"name":"ParticleDecays:limitTau0","link":"ParticleDecays.html#anchor1","text":"ParticleDecays:limitTau0 When on, only particles with ParticleDecays:limitTau0 tau0 < tau0Max are decayed."},{"name":"ParticleDecays:mixB","link":"ParticleDecays.html#anchor10","text":"ParticleDecays:mixB Allow or not ParticleDecays:mixB B^0 - B^0bar and ParticleDecays:mixB B_s^0 - B_s^0bar mixing."},{"name":"ParticleDecays:mSafety","link":"ParticleDecays.html#anchor18","text":"ParticleDecays:mSafety Minimum mass difference required between the decaying mother mass and the sum of the daughter masses, kept as a safety margin to avoid numerical problems in the decay generation."},{"name":"ParticleDecays:multGoffset","link":"ParticleDecays.html#anchor23","text":"ParticleDecays:multGoffset The above ParticleDecays:multGoffset multGoffset parameter."},{"name":"ParticleDecays:multIncrease","link":"ParticleDecays.html#anchor20","text":"ParticleDecays:multIncrease The above ParticleDecays:multIncrease multIncrease parameter, except for ParticleDecays:multIncrease meMode = 23."},{"name":"ParticleDecays:multIncreaseWeak","link":"ParticleDecays.html#anchor21","text":"ParticleDecays:multIncreaseWeak The above ParticleDecays:multIncreaseWeak multIncrease parameter, specifically for ParticleDecays:multIncreaseWeak meMode = 23. Here the weak decay implies that only the virtual W mass should contribute to the production of new particles, rather than the full meson mass."},{"name":"ParticleDecays:multRefMass","link":"ParticleDecays.html#anchor22","text":"ParticleDecays:multRefMass The above ParticleDecays:multRefMass multRefMass parameter."},{"name":"ParticleDecays:rMax","link":"ParticleDecays.html#anchor6","text":"ParticleDecays:rMax The above ParticleDecays:rMax rMax , expressed in mm."},{"name":"ParticleDecays:sigmaSoft","link":"ParticleDecays.html#anchor19","text":"ParticleDecays:sigmaSoft In semileptonic decays to more than one hadron, such as ParticleDecays:sigmaSoft B &rarr; nu l D pi , decay products after the first three are dampened in momentum by an explicit weight factor ParticleDecays:sigmaSoft exp(-p^2/sigmaSoft^2) , where ParticleDecays:sigmaSoft p is the three-momentum in the rest frame of the decaying particle. This takes into account that such further particles come from the fragmentation of the spectator parton and thus should be soft."},{"name":"ParticleDecays:tau0Max","link":"ParticleDecays.html#anchor2","text":"ParticleDecays:tau0Max The above ParticleDecays:tau0Max tau0Max , expressed in mm/c."},{"name":"ParticleDecays:tauMax","link":"ParticleDecays.html#anchor4","text":"ParticleDecays:tauMax The above ParticleDecays:tauMax tauMax , expressed in mm/c. ParticleDecays:tauMax In order for this and the subsequent tests to work, a ParticleDecays:tauMax tau is selected and stored for each particle, whether in the end it decays or not. (If each test would use a different temporary ParticleDecays:tauMax tau it would lead to inconsistencies.)"},{"name":"ParticleDecays:xBdMix","link":"ParticleDecays.html#anchor11","text":"ParticleDecays:xBdMix The mixing parameter ParticleDecays:xBdMix x_d = Delta(m_B^0)/Gamma_B^0 in the ParticleDecays:xBdMix B^0 - B^0bar system. (Default from RPP2006.)"},{"name":"ParticleDecays:xBsMix","link":"ParticleDecays.html#anchor12","text":"ParticleDecays:xBsMix The mixing parameter ParticleDecays:xBsMix x_s = Delta(m_B_s^0)/Gamma_B_s^0 in the ParticleDecays:xBsMix B_s^0 - B_s^0bar system. (Delta-m from CDF hep-ex-0609040, Gamma from RPP2006.)"},{"name":"ParticleDecays:xyMax","link":"ParticleDecays.html#anchor8","text":"ParticleDecays:xyMax The above ParticleDecays:xyMax xyMax , expressed in mm."},{"name":"ParticleDecays:zMax","link":"ParticleDecays.html#anchor9","text":"ParticleDecays:zMax The above ParticleDecays:zMax zMax , expressed in mm."},{"name":"PartonLevel:all","link":"MasterSwitches.html#anchor3","text":"PartonLevel:all If off then stop the generation after the hard process has been generated, but before the parton-level and hadron-level steps. The PartonLevel:all process record is filled, but the PartonLevel:all event one is then not."},{"name":"PartonLevel:earlyResDec","link":"MasterSwitches.html#anchor9","text":"PartonLevel:earlyResDec If on then do resonance decays early, before beam handling including colour reconnection. If off then decays are done afterwards, and so are unaffected by colour reconnection. The early-decay option is still primitive, for some first studies. Eventually the choice should be made individually for each resonance based on lifetime (and the environment)."},{"name":"PartonLevel:FSR","link":"MasterSwitches.html#anchor6","text":"PartonLevel:FSR Master switch for final-state radiation; on/off = true/false. Further options are found PartonLevel:FSR here. If you leave this switch on, the following two switches allow more detailed control to switch off only parts of the showers."},{"name":"PartonLevel:FSRinProcess","link":"MasterSwitches.html#anchor7","text":"PartonLevel:FSRinProcess Switch for final-state radiation in association with the hard process itself; on/off = true/false. In addition PartonLevel:FSRinProcess PartonLevel:FSR must be on for these emissions to occur."},{"name":"PartonLevel:FSRinResonances","link":"MasterSwitches.html#anchor8","text":"PartonLevel:FSRinResonances Master switch for final-state radiation in any resonance decays subsequent to the hard process itself; on/off = true/false. In addition PartonLevel:FSRinResonances PartonLevel:FSR must be on for these emissions to occur."},{"name":"PartonLevel:ISR","link":"MasterSwitches.html#anchor5","text":"PartonLevel:ISR Master switch for initial-state radiation; on/off = true/false. Further options are found PartonLevel:ISR here."},{"name":"PartonLevel:MPI","link":"MasterSwitches.html#anchor4","text":"PartonLevel:MPI Master switch for multiparton interactions; on/off = true/false. Further options are found PartonLevel:MPI here."},{"name":"PartonLevel:Remnants","link":"MasterSwitches.html#anchor10","text":"PartonLevel:Remnants Master switch for addition of beam remnants; on/off = true/false. Only intended for very special applications, and cannot be used to generate complete events. Specifically, unlike the other switches above, the program will complain and possibly crash unlike you also set PartonLevel:Remnants HadronLevel:all = off and PartonLevel:Remnants Check:event = off."},{"name":"PartonVertex:EmissionWidth","link":"VertexInformation.html#anchor4","text":"PartonVertex:EmissionWidth Vertices of ISR+FSR partons are smeared relative to their mother by a Gaussian distribution with a width of PartonVertex:EmissionWidth EmissionWidth / PartonVertex:EmissionWidth pT , where PartonVertex:EmissionWidth pT is the transverse momentum of the emission (in GeV). This parameter thus determined the overall strength of the transverse space smearing."},{"name":"PartonVertex:modeVertex","link":"VertexInformation.html#anchor2","text":"PartonVertex:modeVertex Choice between alternative procedures to select vertex. PartonVertex:modeVertex Proton profile is a uniform black disc. PartonVertex:modeVertex Proton profile is a two-dimensional Gaussian."},{"name":"PartonVertex:ProtonRadius","link":"VertexInformation.html#anchor3","text":"PartonVertex:ProtonRadius The proton radius and shape depends on collision energy. At LHC collision energies, say 14 TeV, the profile corresponds roughly to a Gaussian with a with of around 0.7 fm, according to the DIPSY model PartonVertex:ProtonRadius Fle11."},{"name":"PartonVertex:pTmin","link":"VertexInformation.html#anchor5","text":"PartonVertex:pTmin The parton transverse smearing is assumed proportional to PartonVertex:pTmin 1 / pT , but PartonVertex:pTmin pT is limited to be above this parameter so as to avoid unreasonable values."},{"name":"PartonVertex:setVertex","link":"VertexInformation.html#anchor1","text":"PartonVertex:setVertex Master switch to allow the setting of partonic vertices."},{"name":"PDF:extrapolate","link":"PDFSelection.html#anchor1","text":"PDF:extrapolate Allow PDF sets to be extrapolated to small PDF:extrapolate x values, instead of being frozen at PDF:extrapolate x_min. This is a global flag that affects all PDF sets used, whenever extrapolation has been implemented. Among internal PDFs, all Pomeron sets are affected by this flag, as are the CTEQ6/CT09 proton ones, the NNPDF 3.1 ones and others accessed by the PDF:extrapolate LHAGrid1 approach. For the rest some by default extrapolate to small PDF:extrapolate x (GRV 94 L, MRST/MSTW) while others are frozen at the border (CTEQ 5 L, NNPDF 2.3). When in doubt, check whether and how the behaviour depends on the choice made for your region of interest. When LHAPDF (5 or 6) is used, the extrapolation switch is set according to the choice here, and the behaviour is according to the rules of the respective program. PDF:extrapolate To put the issue in context, parton densities have a guaranteed range of validity in PDF:extrapolate x and PDF:extrapolate Q^2 , and what should be done beyond that range usually is not explained by the authors of PDF sets. Nevertheless these boundaries very often are exceeded, e.g. minimum-bias studies at LHC may sample PDF:extrapolate x values down to PDF:extrapolate 10^-8 , while many PDF sets stop already at PDF:extrapolate 10^-5. The default behaviour is then that the PDF's are frozen at the boundary, i.e. PDF:extrapolate xf(x,Q^2) is fixed at its value at PDF:extrapolate x_min for all values PDF:extrapolate x < x_min , and so on. This is a conservative approach. Alternatively, if you switch on extrapolation, then parametrizations will be extended beyond the boundaries, by some prescription. In some cases this will provide a more realistic answer, in others complete rubbish. Another problem is that some of the PDF-set codes will write a warning message anytime the limits are exceeded, thus swamping your output file. Therefore you should study a set seriously before you run it with this switch on. PDF:extrapolate Warning: It has been found out that the LHAPDF program by default uses a damping of PDFs at low PDF:extrapolate Q scales, below PDF:extrapolate Q_min , based on an anomalous dimension ansatz. This overlaps with the damping imposed in the MPI framework by the PDF:extrapolate p_T0 parameter, and to have both would probably imply doublecounting of effects. Therefore, as of version 8.227, PDFs are frozen below PDF:extrapolate Q_min. This change affects the LHAPDF 5 interface. The native LHAPDF 6 interface already contained this restriction, as does the PDFs that come with PYTHIA. Also limits at PDF:extrapolate Q_max and PDF:extrapolate x_max are checked and PDFs frozen outside them, so the extrapolate option now is strictly a choice of low- PDF:extrapolate x behaviour."},{"name":"PDF:gammaFluxApprox2bMin","link":"PDFSelection.html#anchor30","text":"PDF:gammaFluxApprox2bMin Minimal allowed impact parameter for which the flux is considered. Units in PDF:gammaFluxApprox2bMin fm. Should match the flux provided by user."},{"name":"PDF:gammaFluxApprox2mBeam","link":"PDFSelection.html#anchor31","text":"PDF:gammaFluxApprox2mBeam Per-nucleon mass used for the overestimate. Units in PDF:gammaFluxApprox2mBeam GeV and should again match to the user-provided flux."},{"name":"PDF:gammaFluxApprox2xCut","link":"PDFSelection.html#anchor33","text":"PDF:gammaFluxApprox2xCut Value that defines at which PDF:gammaFluxApprox2xCut x_gamma different approximations are used. As above, vary with caution."},{"name":"PDF:gammaFluxApprox2xPow","link":"PDFSelection.html#anchor32","text":"PDF:gammaFluxApprox2xPow Value of the exponent of the power law. The default value should work well for the foreseen cases, so vary with caution."},{"name":"PDF:GammaHardSet","link":"PDFSelection.html#anchor25","text":"PDF:GammaHardSet Parton densities to be used by the beams of the hard process. For photons the other options are the ones provided by LHAPDF5. If this option is set to PDF:GammaHardSet void then the same PDF set as PDF:GammaHardSet PDF:GammaSet is used."},{"name":"PDF:GammaSet","link":"PDFSelection.html#anchor24","text":"PDF:GammaSet Parton densities that can be used for resolved photon beams. PDF:GammaSet CJKL, based on PDF:GammaSet Cor03 but the rescaling for heavy quarks due to kinematic constraints in DIS is undone to obtain correct behaviour for photon-photon/hadron collisions."},{"name":"PDF:lepton","link":"PDFSelection.html#anchor26","text":"PDF:lepton Use parton densities for lepton beams or not. If off the colliding leptons carry the full beam energy, if on part of the energy is radiated away by initial-state photons. In the latter case the initial-state showers will generate the angles and energies of the set of photons that go with the collision. In addition one collinear photon per beam carries any leftover amount of energy not described by shower emissions. If the initial-state showers are switched off these collinear photons will carry the full radiated energy."},{"name":"PDF:lepton2gamma","link":"PDFSelection.html#anchor27","text":"PDF:lepton2gamma Gives photon beams from leptons. Both, unresolved (direct) and resolved contributions are included, see PDF:lepton2gamma Photoproduction for details. Can be used only with charged leptons. The applied photon PDF set is selected with the PDF:lepton2gamma PDF:GammaSet and PDF:lepton2gamma PDF:GammaHardSet options above. Events with two unresolved photon initiators can be generated also with the PDF:lepton2gamma PDF:lepton = on but then additional phase-space cuts (e.g. cut on the invariant mass of the photon-photon pair) are not applied."},{"name":"PDF:lepton2gammaApprox","link":"PDFSelection.html#anchor29","text":"PDF:lepton2gammaApprox Controls which type of overestimate is used for photon flux sampling. PDF:lepton2gammaApprox Estimate optimized for photons from leptons. Works reasonable well also for photoproduction in p+p. PDF:lepton2gammaApprox Estimate optimized for ultraperipheral heavy-ion collisions as presented in PDF:lepton2gammaApprox main70.cc. Here the estimate is divided into two regions, a power-law in PDF:lepton2gammaApprox x_gamma below PDF:lepton2gammaApprox x_cut and an exponential fall-off above, see the related parameters below. Default values are optimized for p+Pb collisions where Pb-nucleus provide the photons but they should work reasonably well also for other similar configurations. PDF:lepton2gammaApprox Note: Parameters do not affect the flux itself, only the sampling efficiency."},{"name":"PDF:lepton2gammaSet","link":"PDFSelection.html#anchor28","text":"PDF:lepton2gammaSet The type of photon flux. PDF:lepton2gammaSet Convolute the photon flux from EPA with the selected photon PDF set. Convolution integral is performed 'on the fly', meaning that the actual integral is not computed but the PDF:lepton2gammaSet x_gamma is sampled event-by-event. Since the final PDF value depends on the sampled value for PDF:lepton2gammaSet x_gamma the phase-space sampling is set up using an overestimate for the PDFs. This makes the process selection somewhat less efficient compared to the case where the PDFs are fixed (e.g. for protons). PDF:lepton2gammaSet Uses an approximation of the photon flux to sample processes and corrects this later with an externally provided flux. For leptons a bit less efficient than option 1 but allows straightforward implementation of photon fluxes from different particles. To use this option user has to provide the external photon flux using method PDF:lepton2gammaSet Pythia::setPhotonFluxPtr(PDF*, PDF*) as demostrated in the sample program PDF:lepton2gammaSet main70.cc."},{"name":"PDF:nPDFBeamA","link":"PDFSelection.html#anchor11","text":"PDF:nPDFBeamA The PDG code for nuclear beam A, provides the number of protons and neutrons. Default code for Pb."},{"name":"PDF:nPDFBeamB","link":"PDFSelection.html#anchor12","text":"PDF:nPDFBeamB The PDG code for nucleus B."},{"name":"PDF:nPDFSetA","link":"PDFSelection.html#anchor9","text":"PDF:nPDFSetA The nuclear modication to be used for beam A if enabled with the switch above. PDF:nPDFSetA Only Isospin effect. PDF:nPDFSetA EPS09, LO PDF:nPDFSetA Esk09. PDF:nPDFSetA EPS09, NLO PDF:nPDFSetA Esk09. The grid files can be found from PDF:nPDFSetA here and are to be stored in the same folder as other PDF grid files (usually share/Pythia8/xmldoc/). PDF:nPDFSetA EPPS16, NLO PDF:nPDFSetA Esk16. The grid files can be found from PDF:nPDFSetA here."},{"name":"PDF:nPDFSetB","link":"PDFSelection.html#anchor10","text":"PDF:nPDFSetB The nuclear modication to be used for beam B. Same options as above. PDF:nPDFSetB Only Isospin effect. PDF:nPDFSetB EPS09, LO. PDF:nPDFSetB EPS09, NLO. PDF:nPDFSetB EPPS16, NLO."},{"name":"PDF:pHardSet","link":"PDFSelection.html#anchor5","text":"PDF:pHardSet Parton densities to be used by the proton beams of the hard process, with the same options available as for PDF:pHardSet PDF:pSet. If this option is set to PDF:pHardSet void then the same PDF set as PDF:pHardSet PDF:pSet is used."},{"name":"PDF:pHardSetB","link":"PDFSelection.html#anchor6","text":"PDF:pHardSetB Parton densities to be used by PDF:pHardSetB proton beam B of the hard process, with the same options available as for PDF:pHardSetB PDF:pSet. If this option is set to PDF:pHardSetB void then the same PDF set as PDF:pHardSetB PDF:pHardSet is used."},{"name":"PDF:piSet","link":"PDFSelection.html#anchor13","text":"PDF:piSet Parton densities that can be used for pion beams, currently with only one internal choice. PDF:piSet GRV 92 L. PDF:piSet Use an external LHAPDF set where PDF:piSet set is the name of the set to use and PDF:piSet member is the member of the set to use. The value for PDF:piSet set can either be a relative path to the LHAPDF path, or an absolute path. The value for PDF:piSet member must be an integer. PDF:piSet Same as for PDF:piSet LHAPDF5:set/member but now the LHAPDF6 library is used instead. PDF:piSet Use the internal implementation of interpolation in PDF:piSet .dat files in the default 'lhagrid1' LHAPDF6 format, cf. the corresponding proton option."},{"name":"PDF:piSetB","link":"PDFSelection.html#anchor14","text":"PDF:piSetB Parton density for PDF:piSetB pion beam B. If this option is set to PDF:piSetB void then the same PDF set as PDF:piSetB PDF:piSet is used."},{"name":"PDF:PomGluonA","link":"PDFSelection.html#anchor16","text":"PDF:PomGluonA the parameter PDF:PomGluonA a in the ansatz PDF:PomGluonA xg(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"PDF:PomGluonB","link":"PDFSelection.html#anchor17","text":"PDF:PomGluonB the parameter PDF:PomGluonB b in the ansatz PDF:PomGluonB xg(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"PDF:PomHixSupp","link":"PDFSelection.html#anchor23","text":"PDF:PomHixSupp the power in the suppression of the high-x PDF for option 11 above."},{"name":"PDF:PomQuarkA","link":"PDFSelection.html#anchor18","text":"PDF:PomQuarkA the parameter PDF:PomQuarkA a in the ansatz PDF:PomQuarkA xq(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"PDF:PomQuarkB","link":"PDFSelection.html#anchor19","text":"PDF:PomQuarkB the parameter PDF:PomQuarkB b in the ansatz PDF:PomQuarkB xq(x) = N_ab x^a (1 - x)^b for option 1 above."},{"name":"PDF:PomQuarkFrac","link":"PDFSelection.html#anchor20","text":"PDF:PomQuarkFrac the fraction of the Pomeron momentum carried by quarks for option 1 above, with the rest carried by gluons."},{"name":"PDF:PomRescale","link":"PDFSelection.html#anchor22","text":"PDF:PomRescale Rescale several of the fits above by this uniform factor, e.g. to bring up their momentum sum to around unity. By default many of the sets have a momentum sum of order 0.5, suggesting that a factor around 2.0 should be used. You can use PDF:PomRescale examples/main51.cc to get a more precise value. Note that also other parameters in the PDF:PomRescale diffraction framework may need to be retuned when this parameter is changed. Specifically PDF:PomRescale Diffraction:PomFluxRescale should be set to the inverse of PDF:PomRescale PDF:PomRescale to preserve the cross section for hard diffractive processes."},{"name":"PDF:PomSet","link":"PDFSelection.html#anchor15","text":"PDF:PomSet Parton densities that can be used for Pomeron beams. PDF:PomSet PDF:PomSet Q^2 -independent parametrizations PDF:PomSet xf(x) = N_ab x^a (1 - x)^b , where PDF:PomSet N_ab ensures unit momentum sum. The PDF:PomSet a and PDF:PomSet b parameters can be set separately for the gluon and the quark distributions. The momentum fraction of gluons and quarks can be freely mixed, and production of PDF:PomSet s quarks can be suppressed relative to that of PDF:PomSet d and PDF:PomSet u ones, with antiquarks as likely as quarks. See further below how to set the six parameters of this approach. PDF:PomSet PDF:PomSet pi0 distributions, as specified in the section above. PDF:PomSet the H1 2006 Fit A NLO PDF:PomSet Q^2 -dependent parametrization, based on a tune to their data PDF:PomSet H1P06 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the H1 2006 Fit B NLO PDF:PomSet Q^2 -dependent parametrization, based on a tune to their data PDF:PomSet H1P06 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the H1 2007 Jets NLO PDF:PomSet Q^2 -dependent parametrization, based on a tune to their data PDF:PomSet H1P07 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the H1 2006 Fit B LO PDF:PomSet Q^2 -dependent parametrization, based on a tune to their data PDF:PomSet H1P06 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the ACTW B NLO PDF:PomSet Q^2 -dependent parametrization with PDF:PomSet epsilon=0.14 , based on a tune to H1 and ZEUS data PDF:PomSet Alv99 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the ACTW D NLO PDF:PomSet Q^2 -dependent parametrization with PDF:PomSet epsilon=0.14 , based on a tune to H1 and ZEUS data PDF:PomSet Alv99 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the ACTW SG NLO PDF:PomSet Q^2 -dependent parametrization with PDF:PomSet epsilon=0.14 , based on a tune to H1 and ZEUS data PDF:PomSet Alv99 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet the ACTW D NLO PDF:PomSet Q^2 -dependent parametrization with PDF:PomSet epsilon=0.19 , based on a tune to H1 and ZEUS data PDF:PomSet Alv99 , rescaled by the factor PDF:PomSet PomRescale below. PDF:PomSet a rescaling of the proton PDF, PDF:PomSet xf^pom(x)=xf^p(x x_pom) , used in the PDF:PomSet Angantyr model for Heavy Ion collisions. For high PDF:PomSet x there is an additional suppression by PDF:PomSet (1-x)^p , where the power is given by PDF:PomSet PDF:PomHixSupp below. PDF:PomSet The GKG18-DPDF LO Fit A central member PDF:PomSet Q^2 -dependent parametrization based on a tune to H1 and ZEUS data PDF:PomSet Goh18. PDF:PomSet The GKG18-DPDF LO Fit B central member PDF:PomSet Q^2 -dependent parametrization based on a tune to H1 and ZEUS data PDF:PomSet Goh18. PDF:PomSet The GKG18-DPDF NLO Fit A central member PDF:PomSet Q^2 -dependent parametrization based on a tune to H1 and ZEUS data PDF:PomSet Goh18. PDF:PomSet The GKG18-DPDF NLO Fit B central member PDF:PomSet Q^2 -dependent parametrization based on a tune to H1 and ZEUS data PDF:PomSet Goh18. PDF:PomSet Use an external LHAPDF5 set, cf. the corresponding proton option. PDF:PomSet Use an external LHAPDF6 set, cf. the corresponding proton option. PDF:PomSet Use the internal implementation for a LHAPDF6 set, cf. the corresponding proton option."},{"name":"PDF:PomStrangeSupp","link":"PDFSelection.html#anchor21","text":"PDF:PomStrangeSupp the suppression of the PDF:PomStrangeSupp s quark density relative to that of the PDF:PomStrangeSupp d and PDF:PomStrangeSupp u ones for option 1 above."},{"name":"PDF:pSet","link":"PDFSelection.html#anchor2","text":"PDF:pSet Parton densities to be used for proton beams (and, by implication, antiproton ones). Note that the choice of a string input (rather than e.g. an integer) allows to pick either an internal, LHAPDF5 or LHAPDF6 set in one single setting, by some behind-the-scenes machinations. PDF:pSet GRV 94L, LO PDF:pSet alpha_s(M_Z) = 0.128 (this set is out of date, but retained for historical comparisons). PDF:pSet CTEQ 5L, LO PDF:pSet alpha_s(M_Z) = 0.127 (this set is also out of date, but not badly so, and many tunes are based on it). PDF:pSet MRST LO* (2007), NLO PDF:pSet alpha_s(M_Z) = 0.12032. PDF:pSet MRST LO** (2008), NLO PDF:pSet alpha_s(M_Z) = 0.11517. PDF:pSet MSTW 2008 LO (central member), LO PDF:pSet alpha_s(M_Z) = 0.13939. PDF:pSet MSTW 2008 NLO (central member), NLO PDF:pSet alpha_s(M_Z) = 0.12018 (NLO, see Warning 3 above). PDF:pSet CTEQ6L, NLO PDF:pSet alpha_s(M_Z) = 0.1180. PDF:pSet CTEQ6L1, LO PDF:pSet alpha_s(M_Z) = 0.1298. PDF:pSet CTEQ66.00 (NLO, central member), NLO PDF:pSet alpha_s(M_Z) = 0.1180 (NLO, see Warning 3 above). PDF:pSet CT09MC1, LO PDF:pSet alpha_s(M_Z) = 0.1300. PDF:pSet CT09MC2, NLO PDF:pSet alpha_s(M_Z) = 0.1180. PDF:pSet CT09MCS, NLO PDF:pSet alpha_s(M_Z) = 0.1180. PDF:pSet NNPDF2.3 QCD+QED LO PDF:pSet alpha_s(M_Z) = 0.130. PDF:pSet NNPDF2.3 QCD+QED LO PDF:pSet alpha_s(M_Z) = 0.119. PDF:pSet NNPDF2.3 QCD+QED NLO PDF:pSet alpha_s(M_Z) = 0.119. PDF:pSet NNPDF2.3 QCD+QED NNLO PDF:pSet alpha_s(M_Z) = 0.119. PDF:pSet Warning : the following four NNPDF 3.1 sets are quite different from the NNPDF 2.3 ones, and cannot be used interchangeably, but need retuning of the MPI framework. Some also do not contain QED evolution. PDF:pSet NNPDF3.1 QCD LO PDF:pSet alpha_s(M_Z) = 0.130. PDF:pSet NNPDF3.1 QCD LO PDF:pSet alpha_s(M_Z) = 0.118. PDF:pSet NNPDF3.1 QCD+LUXQED NLO PDF:pSet alpha_s(M_Z) = 0.118. PDF:pSet NNPDF3.1 QCD+LUXQED NNLO PDF:pSet alpha_s(M_Z) = 0.118. PDF:pSet NNPDF3.1sx+LHCb NLO+NLLx LUXQED PDF:pSet alpha_s(M_Z) = 0.118 PDF:pSet Ber18. While at NLO, the additional small- PDF:pSet x resummation, anchored by LHC-b data, offers a more reasonable small- PDF:pSet x behaviour than most NLO PDFs, as required for the successful usage e.g. with traditional 'improved LL' parton showers. The photon part is unchanged from the earlier NNPDF 3.1 QED analysis PDF:pSet Ber17. PDF:pSet Warning : in version 8.235 the 21 identifier was used to denote and earlier attempt to obtain a more reasonable small- PDF:pSet x behaviour. This PDF set is superseded by the new 21 and 22 sets, and has been removed, as was forewarned. PDF:pSet NNPDF3.1sx+LHCb NNLO+NLLx LUXQED PDF:pSet alpha_s(M_Z) = 0.118. Comments as for 21, but this set is at NNLO rather than NLO. PDF:pSet Use an external LHAPDF set where PDF:pSet set is the name of the set to use and PDF:pSet member is the member of the set to use. The value for PDF:pSet set is the name of the PDF set to use while the value for PDF:pSet member must be an integer and is the member of the set to use. If member is not supplied, then PDF:pSet 0 is assumed. PDF:pSet Same as for PDF:pSet LHAPDF5:set/member but now the LHAPDF6 library is used instead. PDF:pSet Use the internal implementation of interpolation in PDF:pSet .dat files in the default 'lhagrid1' LHAPDF6 format. This is a simplified implementation, with cubic interpolation in PDF:pSet ln(x) and in PDF:pSet ln(Q2). If there are several PDF:pSet Q^2 subgrids they have to have the same PDF:pSet x grid. (Linear interpolation in PDF:pSet ln(Q2) is used, should a subgrid contain fewer than four PDF:pSet Q2 values.) Other restrictions may also apply, so use with caution. If the PDF:pSet filename begins with a / it is supposed to contain the absolute path to the file, and if not the file is supposed to be located in the standard PDF:pSet share/Pythia8/xmldoc directory. Note that, unlike LHAPDF, there is no explicit hierarchy of a set containing separate members; each PDF:pSet .dat file can be used without any reference to the set it is a member of. PDF:pSet Warning 1: the PDF:pSet alpha_s(M_Z) values and the order of the running in the description above is purely informative, and does not affect any other parts of the program. Instead you have the freedom to set PDF:pSet alpha_s(M_Z) value and running separately for PDF:pSet hard processes (including resonance decays), PDF:pSet multiparton interactions , PDF:pSet initial-state radiation , and PDF:pSet final-state radiation. PDF:pSet Warning 2: in order for PDF:pSet LHAPDF PDF sets to work you must have compiled the appropriate LHAPDF plugins for PYTHIA and have set the PDF:pSet LHAPATH environment variable (or PDF:pSet LHAPDF_DATA_PATH ) to provide the data-files directory of your local LHAPDF installation. See the README file in the PDF:pSet examples directory for further instructions. PDF:pSet Warning 3: it is technically possible to simultaneously use PDF:pSet LHAPDF5 and PDF:pSet LHAPDF6 PDF sets at the same time for the two beams, but such a configuration is not officially supported and strongly discouraged."},{"name":"PDF:pSetB","link":"PDFSelection.html#anchor3","text":"PDF:pSetB Parton densities to be used by PDF:pSetB proton beam B , with the same options available as for PDF:pSetB PDF:pSet. If this option is set to PDF:pSetB void then the same PDF set as PDF:pSetB PDF:pSet is used."},{"name":"PDF:useHard","link":"PDFSelection.html#anchor4","text":"PDF:useHard If on then select a separate PDF set for the hard process, using the variables below. If off then use the same PDF set for everything, as already chosen above."},{"name":"PDF:useHardNPDFA","link":"PDFSelection.html#anchor7","text":"PDF:useHardNPDFA If on, the hard processes are generated with nuclear modifications for beam A."},{"name":"PDF:useHardNPDFB","link":"PDFSelection.html#anchor8","text":"PDF:useHardNPDFB If on, the hard processes are generated with nuclear modifications for beam B."},{"name":"PDFinProcess:nQuarkIn","link":"PDFSelection.html#anchor34","text":"PDFinProcess:nQuarkIn Number of allowed incoming quark flavours in the beams; a change to 4 would thus exclude PDFinProcess:nQuarkIn b and PDFinProcess:nQuarkIn bbar as incoming partons, etc."},{"name":"PhaseSpace:bias2Selection","link":"PhaseSpaceCuts.html#anchor23","text":"PhaseSpace:bias2Selection Possibility to switch on a biased phase space sampling, with compensatingly weighted events, for PhaseSpace:bias2Selection 2 &rarr; 2 processes. Can only be used under the specific conditions explained in the paragraph above; under other conditions the initialization will abort."},{"name":"PhaseSpace:bias2SelectionPow","link":"PhaseSpaceCuts.html#anchor24","text":"PhaseSpace:bias2SelectionPow If the above flag is on, then a PhaseSpace:bias2SelectionPow 2 &rarr; 2 process at a scale PhaseSpace:bias2SelectionPow pTHat will be oversampled in phase space by an amount PhaseSpace:bias2SelectionPow (pTHat/pTRef)^pow , where you set the power PhaseSpace:bias2SelectionPow pow here. Events are assigned a compensating PhaseSpace:bias2SelectionPow weight the inverse of this, i.e. PhaseSpace:bias2SelectionPow Info::weight() will return PhaseSpace:bias2SelectionPow (pTRef/pTHat)^pow. This weight should then be used in the histogramming of event properties. The final overall normalization also involves the PhaseSpace:bias2SelectionPow Info::weightSum() value."},{"name":"PhaseSpace:bias2SelectionRef","link":"PhaseSpaceCuts.html#anchor25","text":"PhaseSpace:bias2SelectionRef The reference scale PhaseSpace:bias2SelectionRef pTRef introduced above, such that events with this PhaseSpace:bias2SelectionRef pTHat obtain unit weight in the reweighting procedure. The value of this parameter has no impact on the final result of the reweighting procedure, but is only there for convenience, i.e. to give 'reasonably-sized' weights."},{"name":"PhaseSpace:increaseMaximum","link":"PhaseSpaceCuts.html#anchor22","text":"PhaseSpace:increaseMaximum Strategy for handling cases where a larger cross section is obtained during the event generation than was assumed at initialization, i.e. when a violation occurs. PhaseSpace:increaseMaximum PhaseSpace:increaseMaximum off: each event comes with a weight, which normally is unity (as a consequence of the acceptance/rejection step), and is found in PhaseSpace:increaseMaximum PhaseSpace:increaseMaximum Info::weight(). For events which exceed the maximum instead the true-to-simple ratio is stored as event weight, which then is above unity. If the user so wishes this weight can then be carried along when event properties are histogrammed. Since normally such violations should be rare and not too much above unity one could expect most users to ignore such issues be default. Should maximum violations turn out to be frequent (visible in the PhaseSpace:increaseMaximum PhaseSpace:increaseMaximum Pythia::stat() output) the option exists to use the information. PhaseSpace:increaseMaximum PhaseSpace:increaseMaximum on: the maximum is increased whenever it is exceeded. Thus events generated after this point will be 'correctly' distributed, while ones generated previously obviously then have had too high a relative weight. If violations occur early on and/or are small this strategy should do a good job of correcting to the desired phase-space distribution. This strategy may be more convenient for the normal user, who would not wish to worry about event weights. It does have the disadvantage that the raised maximum introduces an extra amount of 'history memory' to the generation sequence, so that it becomes less easy to save-and-restore the PhaseSpace:increaseMaximum random-number state for debugging purposes."},{"name":"PhaseSpace:mHatMax","link":"PhaseSpaceCuts.html#anchor2","text":"PhaseSpace:mHatMax The maximum invariant mass. A value below PhaseSpace:mHatMax mHatMin means there is no upper limit."},{"name":"PhaseSpace:mHatMaxSecond","link":"PhaseSpaceCuts.html#anchor17","text":"PhaseSpace:mHatMaxSecond The maximum invariant mass for a second interaction, if separate. A value below PhaseSpace:mHatMaxSecond mHatMin means there is no upper limit."},{"name":"PhaseSpace:mHatMin","link":"PhaseSpaceCuts.html#anchor1","text":"PhaseSpace:mHatMin The minimum invariant mass."},{"name":"PhaseSpace:mHatMinSecond","link":"PhaseSpaceCuts.html#anchor16","text":"PhaseSpace:mHatMinSecond The minimum invariant mass for a second interaction, if separate."},{"name":"PhaseSpace:minWidthBreitWigners","link":"PhaseSpaceCuts.html#anchor7","text":"PhaseSpace:minWidthBreitWigners The minimum width a resonance must have for the mass to be dynamically selected according to a Breit-Wigner shape, within the limits set below. The Breit-Wigner shape is deformed by the variation of the cross section across the peak. Only applies when PhaseSpace:minWidthBreitWigners useBreitWigners is on; else the nominal mass value is always used."},{"name":"PhaseSpace:minWidthNarrowBW","link":"PhaseSpaceCuts.html#anchor8","text":"PhaseSpace:minWidthNarrowBW A particle that is not wide enough to qualify for the dynamical mass generation above can still qualify for a simplified treatment if it has a width above this value. Then the mass is selected according to a simple symmetric Breit-Wigner that will not be (significantly) distorted by the cross section variation. Only applies when PhaseSpace:minWidthNarrowBW useBreitWigners is on; else the nominal mass value is always used. Note that this parameter is also used for mass selection in the MPI machinery."},{"name":"PhaseSpace:pTHat3Max","link":"PhaseSpaceCuts.html#anchor11","text":"PhaseSpace:pTHat3Max The maximum invariant PhaseSpace:pTHat3Max pT of the highest- PhaseSpace:pTHat3Max pT parton in QCD PhaseSpace:pTHat3Max 2 &rarr; 3 processes A value below PhaseSpace:pTHat3Max pTHat3Min means there is no upper limit."},{"name":"PhaseSpace:pTHat3Min","link":"PhaseSpaceCuts.html#anchor10","text":"PhaseSpace:pTHat3Min The minimum invariant PhaseSpace:pTHat3Min pT of the highest- PhaseSpace:pTHat3Min pT parton in QCD PhaseSpace:pTHat3Min 2 &rarr; 3 processes."},{"name":"PhaseSpace:pTHat5Max","link":"PhaseSpaceCuts.html#anchor13","text":"PhaseSpace:pTHat5Max The maximum invariant PhaseSpace:pTHat5Max pT of the lowest- PhaseSpace:pTHat5Max pT parton in QCD PhaseSpace:pTHat5Max 2 &rarr; 3 processes A value below PhaseSpace:pTHat5Max pTHat5Min means there is no upper limit."},{"name":"PhaseSpace:pTHat5Min","link":"PhaseSpaceCuts.html#anchor12","text":"PhaseSpace:pTHat5Min The minimum invariant PhaseSpace:pTHat5Min pT of the lowest- PhaseSpace:pTHat5Min pT parton in QCD PhaseSpace:pTHat5Min 2 &rarr; 3 processes."},{"name":"PhaseSpace:pTHatMax","link":"PhaseSpaceCuts.html#anchor4","text":"PhaseSpace:pTHatMax The maximum invariant PhaseSpace:pTHatMax pT. A value below PhaseSpace:pTHatMax pTHatMin means there is no upper limit."},{"name":"PhaseSpace:pTHatMaxSecond","link":"PhaseSpaceCuts.html#anchor19","text":"PhaseSpace:pTHatMaxSecond The maximum invariant PhaseSpace:pTHatMaxSecond pT for a second interaction, if separate. A value below PhaseSpace:pTHatMaxSecond pTHatMin means there is no upper limit."},{"name":"PhaseSpace:pTHatMin","link":"PhaseSpaceCuts.html#anchor3","text":"PhaseSpace:pTHatMin The minimum invariant PhaseSpace:pTHatMin pT."},{"name":"PhaseSpace:pTHatMinDiverge","link":"PhaseSpaceCuts.html#anchor5","text":"PhaseSpace:pTHatMinDiverge Extra PhaseSpace:pTHatMinDiverge pT cut to avoid the divergences of some processes in the limit PhaseSpace:pTHatMinDiverge pT &rarr; 0. Specifically, if either or both produced particles have a mass below PhaseSpace:pTHatMinDiverge pTHatMinDiverge then PhaseSpace:pTHatMinDiverge pT is limited from below by the larger of PhaseSpace:pTHatMinDiverge pTHatMin and PhaseSpace:pTHatMinDiverge pTHatMinDiverge."},{"name":"PhaseSpace:pTHatMinSecond","link":"PhaseSpaceCuts.html#anchor18","text":"PhaseSpace:pTHatMinSecond The minimum invariant PhaseSpace:pTHatMinSecond pT for a second interaction, if separate."},{"name":"PhaseSpace:Q2Min","link":"PhaseSpaceCuts.html#anchor9","text":"PhaseSpace:Q2Min The minimum value for the DIS variable PhaseSpace:Q2Min Q^2 = - tHat. Can only meaningfully be used for scattering processes between two non-identical particles, i.e. where PhaseSpace:Q2Min tHat and PhaseSpace:Q2Min uHat are experimentally distinguishable. No cut will be applied for PhaseSpace:Q2Min Q2Min < pTHatMinDiverge^2."},{"name":"PhaseSpace:RsepMin","link":"PhaseSpaceCuts.html#anchor14","text":"PhaseSpace:RsepMin The minimum separation PhaseSpace:RsepMin R in PhaseSpace:RsepMin (eta, phi) space between any two outgoing partons in QCD PhaseSpace:RsepMin 2 &rarr; 3 processes."},{"name":"PhaseSpace:sameForSecond","link":"PhaseSpaceCuts.html#anchor15","text":"PhaseSpace:sameForSecond By default use the same cuts for a second hard process as for the first. If PhaseSpace:sameForSecond off then instead use the mass and PhaseSpace:sameForSecond pT cuts below, where relevant. (The other cuts above still remain the same.)"},{"name":"PhaseSpace:showSearch","link":"PhaseSpaceCuts.html#anchor20","text":"PhaseSpace:showSearch Possibility to print information on the search for phase-space coefficients that (in a multichannel approach) provides an analytical upper envelope of the differential cross section, and the corresponding upper estimate of the cross section. Of interest for crosschecks by expert users only."},{"name":"PhaseSpace:showViolation","link":"PhaseSpaceCuts.html#anchor21","text":"PhaseSpace:showViolation Possibility to print information whenever the assumed maximum differential cross section of a process is violated, i.e. when the initial maximization procedure did not find the true maximum. Also, should negative cross sections occur, print whenever a more negative value is encountered."},{"name":"PhaseSpace:useBreitWigners","link":"PhaseSpaceCuts.html#anchor6","text":"PhaseSpace:useBreitWigners Allows masses to be selected according to Breit-Wigner shapes in PhaseSpace:useBreitWigners 2 &rarr; 2 processes, whenever particles have been declared with a nonvanishing width above the threshold below. In those cases also the limits below will be used for the mass selection. For PhaseSpace:useBreitWigners 2 &rarr; 1 processes the Breit-Wigner shape is part of the cross section itself, and therefore always included."},{"name":"Photon:ProcessType","link":"Photoproduction.html#anchor1","text":"Photon:ProcessType Sets desired contribution for interactions with one or two photons. Photon:ProcessType Mix of relevant contributions below. Photon:ProcessType Resolved-Resolved: Both colliding photons are resolved and the partonic content is given by the PDFs. Hard processes and non-diffractive events can be generated. Photon:ProcessType Resolved-Direct: Photon A is resolved and photon B unresolved, i.e. act as an initiator for the hard process. Hard processes with a parton and a photon in the initial state can be generated. In case of photon-hadron collision this provides the direct contribution when hadron is beam A and photon beam B. Photon:ProcessType Direct-Resolved: As above but now photon A is unresolved and photon B resolved. Direct contribution of photon-hadron when photon beam A. Photon:ProcessType Direct-Direct: Both photons are unresolved. Hard processes with two photon initiators can be generated."},{"name":"Photon:Q2max","link":"Photoproduction.html#anchor8","text":"Photon:Q2max Upper limit for (quasi-)real photon virtuality in Photon:Q2max GeV^2. Too low value might cause problems, e.g. if the lower Photon:Q2max Q^2 limit derived from kinematics becomes larger than upper limit."},{"name":"Photon:sampleQ2","link":"Photoproduction.html#anchor13","text":"Photon:sampleQ2 Determines whether the sampling for the photon virtuality is done. This can be used only with Photon:sampleQ2 PDF:lepton2gammaSet = 2 option where Photon:sampleQ2 Q^2 -integrated photon is provided by the user with Photon:sampleQ2 Pythia::setPhotonFluxPtr(PDF*, PDF*) method. In this case the virtuality and the transverse momentum of the photon (and recoiling particle) is set to zero which strictly speaking is kinematically not possible. The error here is, however, very small for the cases where the virtualities are negligible (e.g. photons from heavy ions)."},{"name":"Photon:showUnres","link":"Photoproduction.html#anchor2","text":"Photon:showUnres Show the evolution steps of the beam photon in the event record, if on."},{"name":"Photon:thetaAMax","link":"Photoproduction.html#anchor11","text":"Photon:thetaAMax Upper limit for scattering angle of lepton A in Photon:thetaAMax rad. A negative value means that no cut is applied. Since Photon:thetaAMax k_T depends on virtuality of the emitted photon, the Photon:thetaAMax Photon:Q2max cut is usually more restrictive unless a very small angle is used. This cut is only applied when the colliding beams are defined in their CM frame ( Photon:thetaAMax Beams:frameType=1 ). Furthermore, in case of Photon:thetaAMax 2 &rarr; 1 processes with direct photons the scattered lepton kinematics is modified later in the event generation, so accurate rejection can be obtained only based on the final lepton momenta in the event record."},{"name":"Photon:thetaBMax","link":"Photoproduction.html#anchor12","text":"Photon:thetaBMax As above but for lepton B."},{"name":"Photon:Wmax","link":"Photoproduction.html#anchor10","text":"Photon:Wmax Upper limit for invariant mass of Photon:Wmax gamma-gamma ( Photon:Wmax gamma-hadron ) system in Photon:Wmax GeV. A value below Photon:Wmax Photon:Wmin means that the invariant mass of the original Photon:Wmax l+l- ( Photon:Wmax lepton-hadron ) system is used as an upper limit."},{"name":"Photon:Wmin","link":"Photoproduction.html#anchor9","text":"Photon:Wmin Lower limit for invariant mass of Photon:Wmin gamma-gamma system in Photon:Wmin GeV. In lepton-hadron collisions Photon:Wmin W corresponds to invariant mass of photon-hadron system."},{"name":"PhotonCollision:all","link":"ElectroweakProcesses.html#anchor31","text":"PhotonCollision:all Common switch for the group of six processes presented below."},{"name":"PhotonCollision:gmgm2bbbar","link":"ElectroweakProcesses.html#anchor34","text":"PhotonCollision:gmgm2bbbar Scattering PhotonCollision:gmgm2bbbar gamma gamma &rarr; b bbar. Code 263."},{"name":"PhotonCollision:gmgm2ccbar","link":"ElectroweakProcesses.html#anchor33","text":"PhotonCollision:gmgm2ccbar Scattering PhotonCollision:gmgm2ccbar gamma gamma &rarr; c cbar. Code 262."},{"name":"PhotonCollision:gmgm2ee","link":"ElectroweakProcesses.html#anchor35","text":"PhotonCollision:gmgm2ee Scattering PhotonCollision:gmgm2ee gamma gamma &rarr; e+ e-. Code 264."},{"name":"PhotonCollision:gmgm2mumu","link":"ElectroweakProcesses.html#anchor36","text":"PhotonCollision:gmgm2mumu Scattering PhotonCollision:gmgm2mumu gamma gamma &rarr; mu+ mu-. Code 265."},{"name":"PhotonCollision:gmgm2qqbar","link":"ElectroweakProcesses.html#anchor32","text":"PhotonCollision:gmgm2qqbar Scatterings PhotonCollision:gmgm2qqbar gamma gamma &rarr; q qbar , where PhotonCollision:gmgm2qqbar q is a light quark ( PhotonCollision:gmgm2qqbar u, d, s ). Code 261."},{"name":"PhotonCollision:gmgm2tautau","link":"ElectroweakProcesses.html#anchor37","text":"PhotonCollision:gmgm2tautau Scattering PhotonCollision:gmgm2tautau gamma gamma &rarr; tau+ tau-. Code 266."},{"name":"PhotonParton:all","link":"ElectroweakProcesses.html#anchor38","text":"PhotonParton:all Common switch for the processes 271-274 (also 281-284 when relevant)."},{"name":"PhotonParton:ggm2bbbar","link":"ElectroweakProcesses.html#anchor41","text":"PhotonParton:ggm2bbbar Scattering PhotonParton:ggm2bbbar g gamma &rarr; b bbar. Code 273 (283)."},{"name":"PhotonParton:ggm2ccbar","link":"ElectroweakProcesses.html#anchor40","text":"PhotonParton:ggm2ccbar Scattering PhotonParton:ggm2ccbar g gamma &rarr; c cbar. Code 272 (282)."},{"name":"PhotonParton:ggm2qqbar","link":"ElectroweakProcesses.html#anchor39","text":"PhotonParton:ggm2qqbar Scattering PhotonParton:ggm2qqbar g gamma &rarr; q qbar , where PhotonParton:ggm2qqbar q is a light quark ( PhotonParton:ggm2qqbar u, d, s ). Code 271 (281)."},{"name":"PhotonParton:qgm2qg","link":"ElectroweakProcesses.html#anchor42","text":"PhotonParton:qgm2qg Scattering PhotonParton:qgm2qg q gamma &rarr; q g. Code 274 (284)."},{"name":"PhotonParton:qgm2qgm","link":"ElectroweakProcesses.html#anchor43","text":"PhotonParton:qgm2qgm Scattering PhotonParton:qgm2qgm q gamma &rarr; q gamma. Code 275 (285)."},{"name":"PhotonPhoton:ecmPow","link":"Photoproduction.html#anchor6","text":"PhotonPhoton:ecmPow The PhotonPhoton:ecmPow ecmPow energy rescaling pace."},{"name":"PhotonPhoton:ecmRef","link":"Photoproduction.html#anchor4","text":"PhotonPhoton:ecmRef The PhotonPhoton:ecmRef ecmRef reference energy scale."},{"name":"PhotonPhoton:pT0parametrization","link":"Photoproduction.html#anchor3","text":"PhotonPhoton:pT0parametrization Choice of PhotonPhoton:pT0parametrization pT0 parametrization. See PhotonPhoton:pT0parametrization Multiparton Interactions for further details. PhotonPhoton:pT0parametrization Power law in PhotonPhoton:pT0parametrization eCM. PhotonPhoton:pT0parametrization Logarithmic in PhotonPhoton:pT0parametrization eCM."},{"name":"PhotonPhoton:pT0Ref","link":"Photoproduction.html#anchor5","text":"PhotonPhoton:pT0Ref The value of PhotonPhoton:pT0Ref pT0 at the reference energy scale."},{"name":"PhotonPhoton:pTmin","link":"Photoproduction.html#anchor7","text":"PhotonPhoton:pTmin More details in PhotonPhoton:pTmin Multiparton Interactions."},{"name":"POWHEG:emitted","link":"POWHEGMerging.html#anchor6","text":"POWHEG:emitted Selection of emitted parton for FSR. POWHEG:emitted The PYTHIA definition of emitted. POWHEG:emitted The PYTHIA definition of radiator. POWHEG:emitted A random selection of emitted or radiator. POWHEG:emitted Both emitted and radiator are tried."},{"name":"POWHEG:MPIveto","link":"POWHEGMerging.html#anchor8","text":"POWHEG:MPIveto MPI vetoing. POWHEG:MPIveto No MPI vetoing is done. POWHEG:MPIveto When there is no radiation, MPIs with a scale above POWHEG:MPIveto pT_1 are vetoed, else MPIs with a scale above POWHEG:MPIveto sum_i pT_i / 2 = (pT_1 + pT_2 + pT_3) / 2 are vetoed. This option is intended specifically for POWHEG simulations of POWHEG:MPIveto 2 &rarr; 2 + 2 &rarr; 3 QCD processes."},{"name":"POWHEG:nFinal","link":"POWHEGMerging.html#anchor1","text":"POWHEG:nFinal Number of outgoing particles of POWHEG Born level process, i.e. not counting additional POWHEG radiation."},{"name":"POWHEG:pTdef","link":"POWHEGMerging.html#anchor7","text":"POWHEG:pTdef Use of POWHEG:pTdef pT definitions. POWHEG:pTdef The POWHEG ISR POWHEG:pTdef pT definition for both ISR and FSR. POWHEG:pTdef The POWHEG ISR POWHEG:pTdef pT and FSR POWHEG:pTdef d_ij definitions. POWHEG:pTdef The PYTHIA definitions."},{"name":"POWHEG:pTemt","link":"POWHEGMerging.html#anchor5","text":"POWHEG:pTemt Selection of the POWHEG:pTemt pTemt scale. POWHEG:pTemt It is the POWHEG:pTemt pT of the emitted parton with respect to the radiating parton. POWHEG:pTemt The POWHEG:pTemt pT of the emission is checked against all incoming and outgoing partons, and then POWHEG:pTemt pTemt is set to the minimum of these values. POWHEG:pTemt The POWHEG:pTemt pT of all final-state partons is tested against all other incoming and outgoing partons, with the minimal value chosen. POWHEG:pTemt Warning: the choice here can give significant variations in the final distributions, notably in the tail to large POWHEG:pTemt pT values."},{"name":"POWHEG:pThard","link":"POWHEGMerging.html#anchor4","text":"POWHEG:pThard Selection of the POWHEG:pThard pThard scale. For events where there is no radiation, POWHEG:pThard pThard is always set to be the POWHEG:pThard SCALUP value of the LHA/LHEF standard. POWHEG:pThard Set POWHEG:pThard pThard equal to POWHEG:pThard SCALUP. POWHEG:pThard The POWHEG:pThard pT of the POWHEG emission is tested against all other incoming and outgoing partons, with the minimal value chosen. POWHEG:pThard The POWHEG:pThard pT of all final-state partons is tested against all other incoming and outgoing partons, with the minimal value chosen."},{"name":"POWHEG:QEDveto","link":"POWHEGMerging.html#anchor9","text":"POWHEG:QEDveto Treatment of non-QCD radiation. POWHEG:QEDveto Colorless partons are not included in POWHEG:QEDveto pT calculated from the shower for POWHEG:QEDveto pTemt>0. POWHEG:QEDveto Colorless partons ARE included for POWHEG:QEDveto pTemt>0. POWHEG:QEDveto Colorless partons ARE included for POWHEG:QEDveto pTemt>0.   Additionally, if a colorless parton is emitted with POWHEG:QEDveto pT > pThard in Born-level events, then the entire event is accepted.  This is relevant for all values of POWHEG:QEDveto pTemt."},{"name":"POWHEG:veto","link":"POWHEGMerging.html#anchor2","text":"POWHEG:veto Master switch to perform vetoing or not. POWHEG:veto No vetoing is performed (the user hooks is not loaded). POWHEG:veto Showers are started at the kinematical limit. Emissions are vetoed if POWHEG:veto pTemt > pThard. See also POWHEG:veto POWHEG:vetoCount below."},{"name":"POWHEG:vetoCount","link":"POWHEGMerging.html#anchor3","text":"POWHEG:vetoCount After this many accepted emissions in a row, no more emissions are checked. Value 0 means that no emissions are checked. Using a very large value (e.g. 100000) will mean that all emissions are checked."},{"name":"Print:quiet","link":"MasterSwitches.html#anchor17","text":"Print:quiet Can be set on to avoid the printing during program execution, to the largest extent possible. This flag acts by setting the relevant values for Print:quiet Init:showProcesses , Print:quiet Init:showMultipartonInteractions , Print:quiet Init:showChangedSettings , Print:quiet Init:showAllSettings , Print:quiet Init:showChangedParticleData , Print:quiet Init:showChangedResonanceData , Print:quiet Init:showAllParticleData , Print:quiet Init:showOneParticleData , Print:quiet Next:numberCount , Print:quiet Next:numberShowLHA , Print:quiet Next:numberShowInfo , Print:quiet Next:numberShowProcess , and Print:quiet Next:numberShowEvent. The change is to off or 0 for Print:quiet Print:quiet = off , and restores to the respective default value for Print:quiet = on. Those changes take effect immediately, so individual settings can be changed afterwards."},{"name":"ProcessLevel:all","link":"MasterSwitches.html#anchor1","text":"ProcessLevel:all If off, do not attempt to carry out any generation at all on the process level. For the parton level only final-state radiation is possible, using the ProcessLevel:all Pythia::forceTimeShower(...) method. Do allow parton configurations stored in the event record to hadronize and hadrons to decay, however, as set by the ProcessLevel:all HadronLevel switches. Further details are found ProcessLevel:all here."},{"name":"ProcessLevel:resonanceDecays","link":"MasterSwitches.html#anchor2","text":"ProcessLevel:resonanceDecays Master switch to allow resonance decays; on/off = true/false. Normal hadrons and leptons do not count as resonances, so this is aimed specifically towards ProcessLevel:resonanceDecays Z^0, W^+-, t, h^0 and similar objects beyond the Standard Model. Do not use this option if you may produce coloured resonances and intend to allow hadronization, since currently the program would not know how to handle this."},{"name":"PromptPhoton:all","link":"ElectroweakProcesses.html#anchor1","text":"PromptPhoton:all Common switch for the group of all prompt photon processes, as listed separately in the following."},{"name":"PromptPhoton:ffbar2gammagamma","link":"ElectroweakProcesses.html#anchor5","text":"PromptPhoton:ffbar2gammagamma Scattering PromptPhoton:ffbar2gammagamma q qbar &rarr; gamma gamma. Code 204."},{"name":"PromptPhoton:gg2gammagamma","link":"ElectroweakProcesses.html#anchor6","text":"PromptPhoton:gg2gammagamma Scattering PromptPhoton:gg2gammagamma g g &rarr; gamma gamma. PromptPhoton:gg2gammagamma Note: This is a box graph. The full quark-mass dependence in the loop leads to very complicated expressions. The current implementation is based on assuming five massless quarks (see below), and thus is questionable at small ( PromptPhoton:gg2gammagamma pT < m_b ) or large ( PromptPhoton:gg2gammagamma pT > m_t ) transverse momenta. Code 205."},{"name":"PromptPhoton:gg2ggamma","link":"ElectroweakProcesses.html#anchor4","text":"PromptPhoton:gg2ggamma Scattering PromptPhoton:gg2ggamma g g &rarr; g gamma. PromptPhoton:gg2ggamma Note: This is a box graph. The full quark-mass dependence in the loop leads to very complicated expressions. The current implementation is based on assuming five massless quarks (see below), and thus is questionable at small ( PromptPhoton:gg2ggamma pT < m_b ) or large ( PromptPhoton:gg2ggamma pT > m_t ) transverse momenta. Code 203."},{"name":"PromptPhoton:nQuarkLoop","link":"ElectroweakProcesses.html#anchor7","text":"PromptPhoton:nQuarkLoop Number of quark flavours included in the box graphs responsible for PromptPhoton:nQuarkLoop g g &rarr; g gamma and PromptPhoton:nQuarkLoop g g&rarr; gamma gamma processes. Owing to the complexity if the massive expressions, quarks are treated as massless. The default value should be applicable in the range of transverse momenta above the PromptPhoton:nQuarkLoop b mass but below the PromptPhoton:nQuarkLoop t one."},{"name":"PromptPhoton:qg2qgamma","link":"ElectroweakProcesses.html#anchor2","text":"PromptPhoton:qg2qgamma Scattering PromptPhoton:qg2qgamma q g &rarr; q gamma. Code 201."},{"name":"PromptPhoton:qqbar2ggamma","link":"ElectroweakProcesses.html#anchor3","text":"PromptPhoton:qqbar2ggamma Scattering PromptPhoton:qqbar2ggamma q qbar &rarr; g gamma. Code 202."},{"name":"Random:seed","link":"RandomNumberSeed.html#anchor2","text":"Random:seed The seed to be used, if Random:seed setSeed is on. Random:seed A negative value gives the default seed, Random:seed a value 0 gives a random seed based on the time, and Random:seed a value between 1 and 900,000,000 a unique different random number sequence."},{"name":"Random:setSeed","link":"RandomNumberSeed.html#anchor1","text":"Random:setSeed Indicates whether a user-set seed should be used every time the Random:setSeed Pythia::init routine is called. If off, the random number generator is initialized with its default seed at the beginning of the run, and never again. If on, each new Random:setSeed Pythia::init call (should several be made in the same run) results in the random number being re-initialized, thereby possibly starting over with the same sequence, if you do not watch out."},{"name":"ResonanceWidths:minThreshold","link":"ResonanceDecays.html#anchor2","text":"ResonanceWidths:minThreshold Used uniquely for ResonanceWidths:minThreshold meMode = 103 to set the minimal value assumed for the threshold factor, ResonanceWidths:minThreshold sqrt( (1 - m_1^2/m_2 - m_2^2/m^2)^2 - 4 m_1^2 m_2^2/m^4) for two-body decays and ResonanceWidths:minThreshold sqrt(1 - Sum_i m_i / m) for multibody ones. Thus the inverse of this number sets an upper limit for how much the partial width of a channel can increase from the on-shell value to the value for asymptotically large resonance masses. Is mainly intended as a safety measure, to avoid unintentionally large rescalings."},{"name":"ResonanceWidths:minWidth","link":"ResonanceDecays.html#anchor1","text":"ResonanceWidths:minWidth Minimal allowed width of a resonance, in GeV. If the width falls below this number the resonance is considered stable and will not be allowed to decay. This is mainly intended as a technical parameter, to avoid disasters in cases where no open decay channels exists at all. It could be used for real-life decisions as well, however. The default value corresponds to an average lifetime ResonanceWidths:minWidth c * tau of 1 km, meaning such a particle would only rarely decay inside a typical detector. Special caution would be needed if coloured resonance particles were made stable, since the program would not necessarily know how to hadronize them, and therefore fail at that stage (see further the ResonanceWidths:minWidth R-hadrons description )."},{"name":"RHadrons:allow","link":"RHadrons.html#anchor1","text":"RHadrons:allow Allows the gluino, stop and sbottom to hadronize if their respective widths are below the limit RHadrons:allow RHadrons:maxWidth."},{"name":"RHadrons:allowDecay","link":"RHadrons.html#anchor6","text":"RHadrons:allowDecay Allows the R-hadrons to decay or not. If the gluino/stop/sbottom is stable or too long-lived to decay inside the detector this switch has no real function, since then no decays will be performed anyway. If the sparticle is so short-lived that it decays before reaching the beam pipe then having the decay on is the logical choice. So the interesting region is when the decays happens after the R-hadron has passed through part of the detector, and changed its momentum and quite possibly its flavour content before it is to decay. Then normal decays should be switched off, and the R-hadron tracked through matter by a program like GEANT RHadrons:allowDecay Kra04,Mac07. After that, the new R-hadron info can be overwritten into the event record and the RHadrons:allowDecay Pythia::forceRHadronDecay() method can be called to force this modified R-hadron to decay."},{"name":"RHadrons:diquarkSpin1","link":"RHadrons.html#anchor11","text":"RHadrons:diquarkSpin1 Probability that a diquark extracted from the flavour code of a gluino R-hadron should be assigned spin 1, with the rest being spin 0. Does not apply for two identical quarks, where spin 1 is only possibility. Note that gluino R-hadron codes for simplicity are assigned as if spin is 1 always, and so give no guidance. For stop and sbottom the diquark spin is preserved in the particle code, so there is no corresponding issue."},{"name":"RHadrons:idGluino","link":"RHadrons.html#anchor3","text":"RHadrons:idGluino The gluino identity code. For other scenarios than SUSY this code could be changed to represent another long-lived uncharged colour octet particle, that then would be treated in the same spirit. Could be set to 0 to forbid any gluino R-hadron formation even when the above two criteria, RHadrons:idGluino RHadrons:allow and RHadrons:idGluino RHadrons:maxWidth , are met."},{"name":"RHadrons:idSbottom","link":"RHadrons.html#anchor5","text":"RHadrons:idSbottom The lightest sbottom identity code. For other scenarios than SUSY this code could be changed to represent another long-lived charge -1/3 colour triplet particle, that then would be treated in the same spirit. As above it could be set to 0 to forbid any sbottom R-hadron formation."},{"name":"RHadrons:idStop","link":"RHadrons.html#anchor4","text":"RHadrons:idStop The lightest stop identity code. For other scenarios than SUSY this code could be changed to represent another long-lived charge 2/3 colour triplet particle, that then would be treated in the same spirit. As above it could be set to 0 to forbid any stop R-hadron formation."},{"name":"RHadrons:maxWidth","link":"RHadrons.html#anchor2","text":"RHadrons:maxWidth The maximum width of the gluino for which it is possible to form R-hadrons, provided that RHadrons:maxWidth RHadrons:allow is on."},{"name":"RHadrons:mCollapse","link":"RHadrons.html#anchor10","text":"RHadrons:mCollapse A colour singlet system with an invariant mass less than this amount, above the R-hadron mass with the given flavour content, is assumed to collapse to this single R-hadron, whereas a full fragmentation handling is applied above this mass."},{"name":"RHadrons:mOffsetCloud","link":"RHadrons.html#anchor9","text":"RHadrons:mOffsetCloud Extra mass (in GeV) added to each of the one or two extra constituent masses in an R-hadron, to calculate the mass of a R-hadron. The same offset is also used when the R-hadron momentum and mass is split between the squark or gluino and the one or two light (di)quarks, one for a squark and two for a gluino. Thus once or twice this amount represents a part of the nominal squark or gluino mass that will not decay weakly, since it is taken to correspond to the cloud of gluons that surround the squark or gluino."},{"name":"RHadrons:probGluinoball","link":"RHadrons.html#anchor8","text":"RHadrons:probGluinoball The fraction of produced gluino R-hadrons that are contain a 'valence' gluon, with the rest containing a meson or baryon quark flavour content."},{"name":"RHadrons:setMasses","link":"RHadrons.html#anchor7","text":"RHadrons:setMasses Use simple mass formulae to construct all available R-hadron masses based on the currently initialized gluino/squark masses and the constituent masses of the other partons in the hadron. If you switch this off, it is your responsibility to set each of the R-hadron masses on your own, and set them in an internally consistent way. If you mess up on this you may generate accordingly crazy results. Specifically, it is to be assumed that none of the R-hadrons has a mass below its constituent sparticle, i.e. that the light degrees of freedom and the additional confinement gluon field gives a net positive contribution to the R-hadron mass."},{"name":"Ropewalk:alwaysHighest","link":"RopeHadronization.html#anchor19","text":"Ropewalk:alwaysHighest Setting this flag on will skip the random walk procedure for flavour ropes, and assume that one always ends up in the highest possible SU(3) multiplet. This would be adequate for situations where all lower multiplets are assumed handled by colour reconnection and junction formation."},{"name":"Ropewalk:beta","link":"RopeHadronization.html#anchor18","text":"Ropewalk:beta In the current implementation of the rope model, the theoretical ignorance about baryon production has been parameterized, assuming that the parameter Ropewalk:beta StringFlav:probQQtoQ will factorize into two parts, one which will scale with effective string tension, one which will not. This parameter controls how large a fraction of the parameter will scale with string tension."},{"name":"Ropewalk:deltat","link":"RopeHadronization.html#anchor11","text":"Ropewalk:deltat The size of the steps taken in time during shoving. Since the whole event needs to be retraced after every time step, this should not be too small."},{"name":"Ropewalk:deltay","link":"RopeHadronization.html#anchor9","text":"Ropewalk:deltay This value gives the width of the rapidity slices in which the event is split before shoving."},{"name":"Ropewalk:doBuffon","link":"RopeHadronization.html#anchor20","text":"Ropewalk:doBuffon Setting this flag on, enables a simpler treatment of flavour ropes. This is not reliant on vertex information, but string-string overlaps are decided randomly &aacute; la Buffon's needle Ropewalk:doBuffon Bie16c : All strings are thrown randomly into a circular area in transverse space to estimate overlaps."},{"name":"Ropewalk:doFlavour","link":"RopeHadronization.html#anchor3","text":"Ropewalk:doFlavour Enable the flavour ropes mechanism. In addition to this, the above Ropewalk:doFlavour Ropewalk:RopeHadronization flag must also be switched on."},{"name":"Ropewalk:doShoving","link":"RopeHadronization.html#anchor2","text":"Ropewalk:doShoving Enable the string shoving mechanism. In addition to this, the above Ropewalk:doShoving Ropewalk:RopeHadronization flag must also be switched on."},{"name":"Ropewalk:gAmplitude","link":"RopeHadronization.html#anchor7","text":"Ropewalk:gAmplitude The amplitude of the shoving force. Note that many traditional Min Bias/UE observables, such as multiplicity and Ropewalk:gAmplitude p_\perp , as well as transverse quantities, are sensitive to this parameter. As such, a change of this, in principle warrants a full retuning of the MPI framework."},{"name":"Ropewalk:gExponent","link":"RopeHadronization.html#anchor8","text":"Ropewalk:gExponent This value multiplies the string radius in the shoving force, allowing for a variation between string radius in the flavour rope treatment and the shoving treatment, if one wishes to run both simultaneously."},{"name":"Ropewalk:limitMom","link":"RopeHadronization.html#anchor16","text":"Ropewalk:limitMom It is possible to switch off shoving for dipoles with a Ropewalk:limitMom p_\perp above a given value. This is intended as a cut-off to disallow string segments moving so fast that they would anyway escape shoving from soft strings to have gluonic excitations added to them."},{"name":"Ropewalk:m0","link":"RopeHadronization.html#anchor5","text":"Ropewalk:m0 Imposed lower mass cutoff to allow for calculation of rapidities of dipoles composed of massless gluons."},{"name":"Ropewalk:presetKappa","link":"RopeHadronization.html#anchor24","text":"Ropewalk:presetKappa The effective string tension is normally calculated dynamically using overlaps of strings, based on Ropewalk:presetKappa Parton Vertex information. By setting Ropewalk:presetKappa Ropewalk:setFixedKappa , this information is ignored, and a preset value provided in the Ropewalk:presetKappa presetKappa variable is used."},{"name":"Ropewalk:pTcut","link":"RopeHadronization.html#anchor17","text":"Ropewalk:pTcut The value of Ropewalk:pTcut p_\perp at which shoving is turned off, if the flag Ropewalk:pTcut Ropewalk:limitMom is on."},{"name":"Ropewalk:r0","link":"RopeHadronization.html#anchor4","text":"Ropewalk:r0 The transverse radius of a string, in units of fm. This can be viewed as an overall strength parameter of the Rope Hadronization framework, as all effects scale with increasing string overlap. Notice that the value for the string radius must be seen compared to the parameters which determines string placement in the transverse plane, as described in Ropewalk:r0 Vertex Information."},{"name":"Ropewalk:rapiditySpan","link":"RopeHadronization.html#anchor22","text":"Ropewalk:rapiditySpan Only used if Ropewalk:rapiditySpan Ropewalk:buffonRope is enabled. Determines how far in rapidity from a string break overlaps are counted."},{"name":"Ropewalk:rCutOff","link":"RopeHadronization.html#anchor6","text":"Ropewalk:rCutOff This parameter gives the maximum cut-off radius, at which strings stops interacting. The purpose of the parameter is to decrease computation time by not calculating arbitrarily small pushes. In pp collisions at LHC energies, no significant variation in the results is observed by increasing this value above the default."},{"name":"Ropewalk:RopeHadronization","link":"RopeHadronization.html#anchor1","text":"Ropewalk:RopeHadronization Master switch for all aspects of rope hadronization. The Rope Hadronization framework is intended to work seamlessly with the rest of Pythia 8. It is, however, still a new model, and no Pythia tunes with ropes enabled exists yet. Therefore Rope Hadronization must be explicitly switched on, and it is up to the user to provide a sensible tune."},{"name":"Ropewalk:setFixedKappa","link":"RopeHadronization.html#anchor23","text":"Ropewalk:setFixedKappa Setting this flag gives the user the possibility to ignore the generator space-time information altogether, using only a provided string tension. This could be useful for (toy) studies of hadronization in very dense environments, such as central heavy ion collisions."},{"name":"Ropewalk:shoveGluonLoops","link":"RopeHadronization.html#anchor13","text":"Ropewalk:shoveGluonLoops Allow for shoving of strings which form a gluon loop. This is mainly a technical setting, and should be kept switched on, unless the user has a specific intention of switching it off."},{"name":"Ropewalk:shoveJunctionStrings","link":"RopeHadronization.html#anchor14","text":"Ropewalk:shoveJunctionStrings Allow for shoving of strings that includes a junction topology from eg. beam remnants. This is mainly a technical setting, and should be kept switched on, unless the user has a specific intention of switching it off."},{"name":"Ropewalk:shoveMiniStrings","link":"RopeHadronization.html#anchor15","text":"Ropewalk:shoveMiniStrings Allow for shoving of ministrings. This is mainly a technical setting, and should be kept switched on, unless the user has a specific intention of switching it off."},{"name":"Ropewalk:stringProtonRatio","link":"RopeHadronization.html#anchor21","text":"Ropewalk:stringProtonRatio Only used if Ropewalk:stringProtonRatio Ropewalk:buffonRope is enabled. The ratio of the string transverse area to a proton transverse area. Determines the amount of overlap in collisions."},{"name":"Ropewalk:tInit","link":"RopeHadronization.html#anchor12","text":"Ropewalk:tInit The strings are allowed to propagate for some time, given in fm/c by this parameter, before shoving takes place. This accounts for the fact that the strings are created with a vanishing transverse size, and only shove each other when their transverse size is large enough for interaction. Furthermore, the physical value of this parameter is largely connected to the values set for Ropewalk:tInit Vertex Information."},{"name":"Ropewalk:tShove","link":"RopeHadronization.html#anchor10","text":"Ropewalk:tShove The total shoving time in units of fm/c."},{"name":"Sdm:af","link":"DarkMatterProcesses.html#anchor4","text":"Sdm:af Pseudo-scalar coupling of SM fermions."},{"name":"Sdm:aX","link":"DarkMatterProcesses.html#anchor6","text":"Sdm:aX Pseudo-scalar coupling of DM fermion."},{"name":"Sdm:vf","link":"DarkMatterProcesses.html#anchor3","text":"Sdm:vf Scalar coupling of SM fermions."},{"name":"Sdm:vX","link":"DarkMatterProcesses.html#anchor5","text":"Sdm:vX Scalar coupling of DM fermion."},{"name":"SecondHard:Bottomonium","link":"ASecondHardProcess.html#anchor7","text":"SecondHard:Bottomonium Production of bottomonium via colour singlet and colour octet channels."},{"name":"SecondHard:Charmonium","link":"ASecondHardProcess.html#anchor6","text":"SecondHard:Charmonium Production of charmonium via colour singlet and colour octet channels."},{"name":"SecondHard:generate","link":"ASecondHardProcess.html#anchor1","text":"SecondHard:generate Generate two hard scatterings in a collision between hadron beams. The hardest process can be any combination of internal processes, available in the normal SecondHard:generate process selection machinery, or external input. Here you must further specify which set of processes to allow for the second hard one, see the following."},{"name":"SecondHard:GmZAndJet","link":"ASecondHardProcess.html#anchor10","text":"SecondHard:GmZAndJet Scattering SecondHard:GmZAndJet q qbar &rarr; gamma^*/Z^0 g and SecondHard:GmZAndJet q g &rarr; gamma^*/Z^0 q."},{"name":"SecondHard:maxPDFreweight","link":"ASecondHardProcess.html#anchor2","text":"SecondHard:maxPDFreweight The two scatterings are first generated as if independent, but then a weight is evaluated, that takes into account how the PDF of one is modified by the presence of the other, averaged over the two possibilities. This weight typically is a bit below unity, by momentum conservation, but has a tail towards larger weights by correlations between partons. The parameter tells how large such weights are compensated by standard hit-and miss. A large value implies inefficiency in the generation, while a small one means some events will be assigned a leftover weight above unity."},{"name":"SecondHard:PhotonAndJet","link":"ASecondHardProcess.html#anchor4","text":"SecondHard:PhotonAndJet A prompt photon recoiling against a quark or gluon jet."},{"name":"SecondHard:SingleGmZ","link":"ASecondHardProcess.html#anchor8","text":"SecondHard:SingleGmZ Scattering SecondHard:SingleGmZ q qbar &rarr; gamma^*/Z^0 , with full interference between the SecondHard:SingleGmZ gamma^* and SecondHard:SingleGmZ Z^0."},{"name":"SecondHard:SingleTop","link":"ASecondHardProcess.html#anchor13","text":"SecondHard:SingleTop Production of a single top, either via a SecondHard:SingleTop t- or an SecondHard:SingleTop s- channel SecondHard:SingleTop W^+- resonance."},{"name":"SecondHard:SingleW","link":"ASecondHardProcess.html#anchor9","text":"SecondHard:SingleW Scattering SecondHard:SingleW q qbar' &rarr; W^+-."},{"name":"SecondHard:TopPair","link":"ASecondHardProcess.html#anchor12","text":"SecondHard:TopPair Production of a top pair, either via QCD processes or via an intermediate SecondHard:TopPair gamma^*/Z^0 resonance."},{"name":"SecondHard:TwoBJets","link":"ASecondHardProcess.html#anchor14","text":"SecondHard:TwoBJets The SecondHard:TwoBJets q qbar &rarr; b bbar and SecondHard:TwoBJets g g &rarr; b bbar processes. These are already included in the SecondHard:TwoBJets TwoJets sample above, so it would be double-counting to include both, but we assume there may be cases where the SecondHard:TwoBJets b subsample will be of special interest. This subsample does not include flavour-excitation or gluon-splitting contributions to the SecondHard:TwoBJets b rate, however, so, depending on the topology if interest, it may or may not be a good approximation."},{"name":"SecondHard:TwoJets","link":"ASecondHardProcess.html#anchor3","text":"SecondHard:TwoJets Standard QCD SecondHard:TwoJets 2 &rarr; 2 processes involving gluons and SecondHard:TwoJets d, u, s, c, b quarks."},{"name":"SecondHard:TwoPhotons","link":"ASecondHardProcess.html#anchor5","text":"SecondHard:TwoPhotons Two prompt photons recoiling against each other."},{"name":"SecondHard:WAndJet","link":"ASecondHardProcess.html#anchor11","text":"SecondHard:WAndJet Scattering SecondHard:WAndJet q qbar' &rarr; W^+- g and SecondHard:WAndJet q g &rarr; W^+- q'."},{"name":"SigmaDiffractive:ABMSTbMinCD","link":"TotalCrossSections.html#anchor61","text":"SigmaDiffractive:ABMSTbMinCD Assume a minimal fall-off SigmaDiffractive:ABMSTbMinCD exp(b_min * (t_1 + t_2)) in the extension of the ABMST model to central diffraction, as described above."},{"name":"SigmaDiffractive:ABMSTbMinDD","link":"TotalCrossSections.html#anchor60","text":"SigmaDiffractive:ABMSTbMinDD Assume a minimal fall-off SigmaDiffractive:ABMSTbMinDD exp(b_min * t) in the extension of the ABMST model to double diffraction, as described above."},{"name":"SigmaDiffractive:ABMSTbMinSD","link":"TotalCrossSections.html#anchor59","text":"SigmaDiffractive:ABMSTbMinSD Assume a minimal fall-off SigmaDiffractive:ABMSTbMinSD exp(b_min * t) in the ABMST model for single diffraction, as described above."},{"name":"SigmaDiffractive:ABMSTdampenGap","link":"TotalCrossSections.html#anchor55","text":"SigmaDiffractive:ABMSTdampenGap Switch on damping of small rapidity gaps in single, double and central diffraction. The reason for this option, on by default, is that the the ABMST SD ansats contains terms that peak near SigmaDiffractive:ABMSTdampenGap xi = 1. This leads to very large integrated SD cross sections at higher energies, such that the diffractive cross section is larger than the nondiffractive one. It then becomes a challenge e.g. how to implement and interpret PDFs, which by definition are inclusive, but would have to be split consistently between the different contributions. (For the hard-jet subsample it can be done e.g. as in SigmaDiffractive:ABMSTdampenGap Ras16 , but it would be more complicated for softer jets in the MPI context.) Furthermore the separation between diffraction and nondiffraction is blurred for events with small gaps. Therefore a damping factor for small gaps is imposed with this option, of the form SigmaDiffractive:ABMSTdampenGap 1 / (1 + exp( -p * (y - y_gap))) = 1 / (1 + exp(p * y_gap) * (exp(-y))^p), where SigmaDiffractive:ABMSTdampenGap y is the rapidity gap(s) in the current event, and SigmaDiffractive:ABMSTdampenGap p and SigmaDiffractive:ABMSTdampenGap y_gap are two parameters. Thus the damping kicks in for SigmaDiffractive:ABMSTdampenGap y < y_gap , and the transition region from small to large damping is of order SigmaDiffractive:ABMSTdampenGap 1/p in SigmaDiffractive:ABMSTdampenGap y. The SigmaDiffractive:ABMSTdampenGap exp(-y) values are SigmaDiffractive:ABMSTdampenGap xi for SD, SigmaDiffractive:ABMSTdampenGap xi_1 * xi_2 * s / m_p^2 for DD, and SigmaDiffractive:ABMSTdampenGap xi_1 and SigmaDiffractive:ABMSTdampenGap xi_2 for CD. The two parameters of the damping are described below."},{"name":"SigmaDiffractive:ABMSTmMinCD","link":"TotalCrossSections.html#anchor54","text":"SigmaDiffractive:ABMSTmMinCD The smallest allowed central diffractive mass, with a sharp cut at this value."},{"name":"SigmaDiffractive:ABMSTmodeCD","link":"TotalCrossSections.html#anchor51","text":"SigmaDiffractive:ABMSTmodeCD Setup of central diffraction in the ABMST scenario. Note that ABMST does not provide any answer here, so the single-diffractive framework is extended by a simple factorized ansatz SigmaDiffractive:ABMSTmodeCD dsigma_CD( xi_1, xi_2, t_1, t_2) / (dxi_1 dxi_2 dt_1 dt2_)    = dsigma_SD (xi_1, t_1) / (dxi_1 dt_1)    * dsigma_SD (xi_2, t_2) / (dxi_2 dt_2) / sigma_total(s) , and again a variant is introduced below. SigmaDiffractive:ABMSTmodeCD Describe the central diffractive cross section by the simple factorized ansatz introduced above, within the allowed phase-space limits. Also here, we only allow for Pomerons in the total cross section. Note that the single diffractive cross section is affected by the choice made for SigmaDiffractive:ABMSTmodeCD SigmaDiffractive:ABMSTmodeSD. SigmaDiffractive:ABMSTmodeCD In addition to option 0, the central diffractive cross section can be rescaled by a factor SigmaDiffractive:ABMSTmodeCD k * (s / m_p^2)^q , where SigmaDiffractive:ABMSTmodeCD k is SigmaDiffractive:ABMSTmodeCD SigmaDiffractive:multCD and SigmaDiffractive:ABMSTmodeCD q is SigmaDiffractive:ABMSTmodeCD SigmaDiffractive:powCD. SigmaDiffractive:ABMSTmodeCD Note: also the SigmaDiffractive:ABMSTmodeCD SigmaDiffractive:ABMSTdampenGap and SigmaDiffractive:ABMSTmodeCD SigmaDiffractive:ABMSTuseBMin flags below very much affect the behaviour."},{"name":"SigmaDiffractive:ABMSTmodeDD","link":"TotalCrossSections.html#anchor48","text":"SigmaDiffractive:ABMSTmodeDD Setup of double diffraction in the ABMST scenario. Note that ABMST does not provide any answer here, so the single-diffractive framework is extended by a simple factorized ansatz SigmaDiffractive:ABMSTmodeDD dsigma_DD( xi_1, xi_2, t) / (dxi_1 dxi_2 dt)    = dsigma_SD (xi_1, t) / (dxi_1 dt) * dsigma_SD (xi_2, t) / (dxi_2 dt)    / (dsigma_El( t) / dt). The above ansatz is marred by the dip in SigmaDiffractive:ABMSTmodeDD dsigma_El / dt by destructive interference, however, so in this extension we only allow for Pomerons in the elastic cross section, which is intended to represent the bulk of the cross section. As such, the equation gives a parameter-free prediction for the double diffractive cross section. For flexibility we introduce a (default) option where the absolute normalization can be modified, while retaining the shape of the ansatz. SigmaDiffractive:ABMSTmodeDD Describe the double diffractive cross section by the simple factorized ansatz introduced above, within the allowed phase-space limits. Note that the single diffractive cross section is affected by the choice made for SigmaDiffractive:ABMSTmodeDD SigmaDiffractive:ABMSTmodeSD. SigmaDiffractive:ABMSTmodeDD The double diffractive cross section can be rescaled by a factor SigmaDiffractive:ABMSTmodeDD k * (s / m_p^2)^q , where SigmaDiffractive:ABMSTmodeDD k is SigmaDiffractive:ABMSTmodeDD SigmaDiffractive:multDD and SigmaDiffractive:ABMSTmodeDD q is SigmaDiffractive:ABMSTmodeDD SigmaDiffractive:powDD. SigmaDiffractive:ABMSTmodeDD Note: also the SigmaDiffractive:ABMSTmodeDD SigmaDiffractive:ABMSTdampenGap and SigmaDiffractive:ABMSTmodeDD SigmaDiffractive:ABMSTuseBMin flags below very much affect the behaviour."},{"name":"SigmaDiffractive:ABMSTmodeSD","link":"TotalCrossSections.html#anchor45","text":"SigmaDiffractive:ABMSTmodeSD Setup of single diffraction in the ABMST scenario. SigmaDiffractive:ABMSTmodeSD Keep the pure ABMST ansatz, which notably vanishes above SigmaDiffractive:ABMSTmodeSD |t| = 4 GeV^2 , and has a constant term up to that scale. SigmaDiffractive:ABMSTmodeSD Use a slightly modified ansatz without an upper SigmaDiffractive:ABMSTmodeSD |t| cut, but instead an exponential fall-off that gives the same integrated diffractive rate and average SigmaDiffractive:ABMSTmodeSD |t| value. In addition the low-mass background term is modified as a combination of a linear and a quadratic term, instead of a qudratic only. SigmaDiffractive:ABMSTmodeSD Option 0, with a scaling factor of SigmaDiffractive:ABMSTmodeSD k * (s / m_p^2)^q , where SigmaDiffractive:ABMSTmodeSD k is SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:multSD and SigmaDiffractive:ABMSTmodeSD q is SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:powSD SigmaDiffractive:ABMSTmodeSD Option 1, with a scaling factor of SigmaDiffractive:ABMSTmodeSD k * (s / m_p^2)^q , where SigmaDiffractive:ABMSTmodeSD k is SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:multSD and SigmaDiffractive:ABMSTmodeSD q is SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:powSD SigmaDiffractive:ABMSTmodeSD Note: also the SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:ABMSTdampenGap and SigmaDiffractive:ABMSTmodeSD SigmaDiffractive:ABMSTuseBMin flags below very much affect the behaviour; you have to switch them off and use option 0 above to recover the pure ABMST model."},{"name":"SigmaDiffractive:ABMSTmultCD","link":"TotalCrossSections.html#anchor52","text":"SigmaDiffractive:ABMSTmultCD possibility to rescale the central diffractive cross section by a factor SigmaDiffractive:ABMSTmultCD k as described above."},{"name":"SigmaDiffractive:ABMSTmultDD","link":"TotalCrossSections.html#anchor49","text":"SigmaDiffractive:ABMSTmultDD possibility to rescale the double diffractive cross section by a factor SigmaDiffractive:ABMSTmultDD k as described above."},{"name":"SigmaDiffractive:ABMSTmultSD","link":"TotalCrossSections.html#anchor46","text":"SigmaDiffractive:ABMSTmultSD possibility to rescale the double diffractive cross section by a factor SigmaDiffractive:ABMSTmultSD k as described above."},{"name":"SigmaDiffractive:ABMSTpowCD","link":"TotalCrossSections.html#anchor53","text":"SigmaDiffractive:ABMSTpowCD possibility to rescale the central diffractive cross section by a factor SigmaDiffractive:ABMSTpowCD (s / m_p^2)^q , as described above, with SigmaDiffractive:ABMSTpowCD q set here."},{"name":"SigmaDiffractive:ABMSTpowDD","link":"TotalCrossSections.html#anchor50","text":"SigmaDiffractive:ABMSTpowDD possibility to rescale the double diffractive cross section by a factor SigmaDiffractive:ABMSTpowDD (s / m_p^2)^q , as described above, with SigmaDiffractive:ABMSTpowDD q set here."},{"name":"SigmaDiffractive:ABMSTpowSD","link":"TotalCrossSections.html#anchor47","text":"SigmaDiffractive:ABMSTpowSD possibility to rescale the double diffractive cross section by a factor SigmaDiffractive:ABMSTpowSD (s / m_p^2)^q , as described above, with SigmaDiffractive:ABMSTpowSD q set here."},{"name":"SigmaDiffractive:ABMSTuseBMin","link":"TotalCrossSections.html#anchor58","text":"SigmaDiffractive:ABMSTuseBMin The slope SigmaDiffractive:ABMSTuseBMin b of an approximate SigmaDiffractive:ABMSTuseBMin exp(b * t) fall-off is SigmaDiffractive:ABMSTuseBMin xi -dependent in the ABMST model for single diffraction. In particular it can become close to zero for large SigmaDiffractive:ABMSTuseBMin xi , which means that the SigmaDiffractive:ABMSTuseBMin t -integrated cross section becomes very large. While the general trend is reasonable, the behaviour in the SigmaDiffractive:ABMSTuseBMin xi &rarr; 1 limit is questionable. Therefore it makes sense to impose some minimal SigmaDiffractive:ABMSTuseBMin b slope. For double diffraction such issues become even more pressing, since the division by the elastic cross section could even lead to a negative SigmaDiffractive:ABMSTuseBMin b slope, which would not be physical. The central diffractive cross section is more well-behaved, but for consistency it is meaningful to ensure a minimal fall-off also here. Therefore, when this flag is on, a minimal fall-off SigmaDiffractive:ABMSTuseBMin exp(b_min * t) is assumed for each of the three components, with the respective SigmaDiffractive:ABMSTuseBMin b_min value stored in the three parameters below. The fall-off is defined relative to the value at SigmaDiffractive:ABMSTuseBMin t = 0 , a point that is outside the physical region, but the parametrization of the diffractive cross sections can still be used there meaningfully. Only positive SigmaDiffractive:ABMSTuseBMin b_min values are acted on, so the SD/DD/CD components can be switched off individually even when this flag is on."},{"name":"SigmaDiffractive:ABMSTygap","link":"TotalCrossSections.html#anchor56","text":"SigmaDiffractive:ABMSTygap Assume a damping of small rapidity gaps in the ABMST model, as described above, to set in around the value SigmaDiffractive:ABMSTygap y_gap given by this parameter."},{"name":"SigmaDiffractive:ABMSTypow","link":"TotalCrossSections.html#anchor57","text":"SigmaDiffractive:ABMSTypow Assume a damping of small rapidity gaps in the ABMST model, as described above, to set in over a rapidity region of width SigmaDiffractive:ABMSTypow 1/p , with SigmaDiffractive:ABMSTypow p given by this parameter."},{"name":"SigmaDiffractive:dampen","link":"TotalCrossSections.html#anchor25","text":"SigmaDiffractive:dampen Allow a user to dampen diffractive cross sections; on/off = true/false."},{"name":"SigmaDiffractive:lowMEnhance","link":"TotalCrossSections.html#anchor20","text":"SigmaDiffractive:lowMEnhance Normalization factor for the contribution of low-mass resonances to the diffractive cross section ( SigmaDiffractive:lowMEnhance cRes in eq. (22) of SigmaDiffractive:lowMEnhance Sch94 )."},{"name":"SigmaDiffractive:maxAX","link":"TotalCrossSections.html#anchor27","text":"SigmaDiffractive:maxAX The above SigmaDiffractive:maxAX sigma_max for SigmaDiffractive:maxAX A + B &rarr; A + X in mb."},{"name":"SigmaDiffractive:maxAXB","link":"TotalCrossSections.html#anchor29","text":"SigmaDiffractive:maxAXB The above SigmaDiffractive:maxAXB sigma_max for SigmaDiffractive:maxAXB A + B &rarr; A + X + B in mb."},{"name":"SigmaDiffractive:maxXB","link":"TotalCrossSections.html#anchor26","text":"SigmaDiffractive:maxXB The above SigmaDiffractive:maxXB sigma_max for SigmaDiffractive:maxXB A + B &rarr; X + B in mb."},{"name":"SigmaDiffractive:maxXX","link":"TotalCrossSections.html#anchor28","text":"SigmaDiffractive:maxXX The above SigmaDiffractive:maxXX sigma_max for SigmaDiffractive:maxXX A + B &rarr; X_1 + X_2 in mb."},{"name":"SigmaDiffractive:MBRalpha","link":"TotalCrossSections.html#anchor32","text":"SigmaDiffractive:MBRalpha the parameters of the Pomeron trajectory."},{"name":"SigmaDiffractive:MBRbeta0","link":"TotalCrossSections.html#anchor33","text":"SigmaDiffractive:MBRbeta0"},{"name":"SigmaDiffractive:MBRdyminCD","link":"TotalCrossSections.html#anchor41","text":"SigmaDiffractive:MBRdyminCD the minimum width of the rapidity gap used in the calculation of cross sections, i.e. the parameter SigmaDiffractive:MBRdyminCD dy_S , which suppresses the cross section at low SigmaDiffractive:MBRdyminCD dy (non-diffractive region). The cross section is damped smoothly, such that it is suppressed by a factor of a half at around this scale."},{"name":"SigmaDiffractive:MBRdyminCDflux","link":"TotalCrossSections.html#anchor38","text":"SigmaDiffractive:MBRdyminCDflux the minimum width of the rapidity gap used in the calculation of SigmaDiffractive:MBRdyminCDflux Ngap(s) (flux renormalization)."},{"name":"SigmaDiffractive:MBRdyminDD","link":"TotalCrossSections.html#anchor40","text":"SigmaDiffractive:MBRdyminDD"},{"name":"SigmaDiffractive:MBRdyminDDflux","link":"TotalCrossSections.html#anchor37","text":"SigmaDiffractive:MBRdyminDDflux"},{"name":"SigmaDiffractive:MBRdyminSD","link":"TotalCrossSections.html#anchor39","text":"SigmaDiffractive:MBRdyminSD"},{"name":"SigmaDiffractive:MBRdyminSDflux","link":"TotalCrossSections.html#anchor36","text":"SigmaDiffractive:MBRdyminSDflux"},{"name":"SigmaDiffractive:MBRdyminSigCD","link":"TotalCrossSections.html#anchor44","text":"SigmaDiffractive:MBRdyminSigCD the parameter SigmaDiffractive:MBRdyminSigCD sigma_S , used for the cross section suppression at low SigmaDiffractive:MBRdyminSigCD dy (non-diffractive region). The smaller this value, the more narrow the rapidity region over which the suppression sets in."},{"name":"SigmaDiffractive:MBRdyminSigDD","link":"TotalCrossSections.html#anchor43","text":"SigmaDiffractive:MBRdyminSigDD"},{"name":"SigmaDiffractive:MBRdyminSigSD","link":"TotalCrossSections.html#anchor42","text":"SigmaDiffractive:MBRdyminSigSD"},{"name":"SigmaDiffractive:MBRepsilon","link":"TotalCrossSections.html#anchor31","text":"SigmaDiffractive:MBRepsilon"},{"name":"SigmaDiffractive:MBRm2Min","link":"TotalCrossSections.html#anchor35","text":"SigmaDiffractive:MBRm2Min the lowest value of the mass squared of the dissociated system, including central diffraction."},{"name":"SigmaDiffractive:MBRsigma0","link":"TotalCrossSections.html#anchor34","text":"SigmaDiffractive:MBRsigma0 the Pomeron-proton coupling, and the total Pomeron-proton cross section."},{"name":"SigmaDiffractive:mMin","link":"TotalCrossSections.html#anchor19","text":"SigmaDiffractive:mMin Lowest mass of a single or double diffractive system is set to be SigmaDiffractive:mMin mHadron + mMin."},{"name":"SigmaDiffractive:mMinCD","link":"TotalCrossSections.html#anchor22","text":"SigmaDiffractive:mMinCD The smallest allowed central diffractive mass, with a sharp cut at this value."},{"name":"SigmaDiffractive:mode","link":"TotalCrossSections.html#anchor2","text":"SigmaDiffractive:mode Choice of parametrization of diffractive cross sections: single, double and central ditto. Note that there is no option 4. SigmaDiffractive:mode Make your own choices, set as fixed values. SigmaDiffractive:mode The SaS parametrizations, available for a larger set of incoming hadron combinations. SigmaDiffractive:mode The MBR model for SigmaDiffractive:mode p p and SigmaDiffractive:mode p pbar , else as option 1. SigmaDiffractive:mode The ABMST parametrizations for SigmaDiffractive:mode p p and SigmaDiffractive:mode p pbar , else as option 1."},{"name":"SigmaDiffractive:mResMax","link":"TotalCrossSections.html#anchor21","text":"SigmaDiffractive:mResMax The contribution of low-mass resonances is dampened at around the scale SigmaDiffractive:mResMax mHadron + mResMax (the sum is SigmaDiffractive:mResMax Mres in eq. (22) of SigmaDiffractive:mResMax Sch94 ). To make sense, we should have SigmaDiffractive:mResMax mResMax > mMin."},{"name":"SigmaDiffractive:OwnbMinDD","link":"TotalCrossSections.html#anchor14","text":"SigmaDiffractive:OwnbMinDD In the options with a simple SigmaDiffractive:OwnbMinDD exp(b * t) falloff for the SigmaDiffractive:OwnbMinDD t spectrum, ensure that SigmaDiffractive:OwnbMinDD b is at least this large. (Recall that the SigmaDiffractive:OwnbMinDD b formula typically contains one term for each incoming hadron that does not break up, and for double diffraction such terms are absent. This leaves only the pomeron propagator part, which often vanishes in the limit of vanishing rapidity gap.)"},{"name":"SigmaDiffractive:OwndampenGap","link":"TotalCrossSections.html#anchor15","text":"SigmaDiffractive:OwndampenGap Switch on damping of small rapidity gaps in single, double and central diffraction. The reason for this option is that the separation between diffraction and nondiffraction is blurred for events with small gaps. Therefore a damping factor for small gaps is imposed with this option, of the form SigmaDiffractive:OwndampenGap 1 / (1 + exp( -p * (y - y_gap))) = 1 / (1 + exp(p * y_gap) * (exp(-y))^p), where SigmaDiffractive:OwndampenGap y is the rapidity gap(s) in the current event, and SigmaDiffractive:OwndampenGap p and SigmaDiffractive:OwndampenGap y_gap are two parameters. Thus the damping kicks in for SigmaDiffractive:OwndampenGap y < y_gap , and the transition region from small to large damping is of order SigmaDiffractive:OwndampenGap 1/p in SigmaDiffractive:OwndampenGap y. The SigmaDiffractive:OwndampenGap exp(-y) values are SigmaDiffractive:OwndampenGap xi for SD, SigmaDiffractive:OwndampenGap xi_1 * xi_2 * s / m_p^2 for DD, and SigmaDiffractive:OwndampenGap xi_1 and SigmaDiffractive:OwndampenGap xi_2 for CD. The two parameters of the damping are described below. SigmaDiffractive:OwndampenGap Note: if the integrated diffractive cross sections are kept fixed, switching on this option will increase the rate of diffractive events with large rapidity gaps, so do consistent changes."},{"name":"SigmaDiffractive:OwnmMinCD","link":"TotalCrossSections.html#anchor18","text":"SigmaDiffractive:OwnmMinCD The smallest allowed central diffractive mass, with a sharp cut at this value."},{"name":"SigmaDiffractive:Ownygap","link":"TotalCrossSections.html#anchor16","text":"SigmaDiffractive:Ownygap Assume a damping of small rapidity gaps, as described above, to set in around the value SigmaDiffractive:Ownygap y_gap given by this parameter."},{"name":"SigmaDiffractive:Ownypow","link":"TotalCrossSections.html#anchor17","text":"SigmaDiffractive:Ownypow Assume a damping of small rapidity gaps, as described above, to set in over a rapidity region of width SigmaDiffractive:Ownypow 1/p , with SigmaDiffractive:Ownypow p given by this parameter."},{"name":"SigmaDiffractive:PomFlux","link":"TotalCrossSections.html#anchor11","text":"SigmaDiffractive:PomFlux Parametrization of the Pomeron flux SigmaDiffractive:PomFlux f_Pom/p( x_Pom, t). SigmaDiffractive:PomFlux Schuler and Sj&ouml;strand SigmaDiffractive:PomFlux Sch94 : based on a critical Pomeron, giving a mass spectrum roughly like SigmaDiffractive:PomFlux dm^2/m^2 ; a mass-dependent exponential SigmaDiffractive:PomFlux t slope that reduces the rate of low-mass states. SigmaDiffractive:PomFlux Bruni and Ingelman SigmaDiffractive:PomFlux Bru93 : also a critical Pomeron giving close to SigmaDiffractive:PomFlux dm^2/m^2 ,  with a SigmaDiffractive:PomFlux t distribution the sum of two exponentials. SigmaDiffractive:PomFlux a conventional Pomeron description, in the RapGap manual SigmaDiffractive:PomFlux Jun95 attributed to Berger et al. and Streng SigmaDiffractive:PomFlux Ber87a , but there (and here) with values updated to a supercritical Pomeron with SigmaDiffractive:PomFlux epsilon > 0 (see below), which gives a stronger peaking towards low-mass diffractive states, and with a mass-dependent (the SigmaDiffractive:PomFlux alpha' below) exponential SigmaDiffractive:PomFlux t slope. SigmaDiffractive:PomFlux a conventional Pomeron description, attributed to Donnachie and Landshoff SigmaDiffractive:PomFlux Don84 , again with supercritical Pomeron, with the same two parameters as option 3 above, but this time with a power-law SigmaDiffractive:PomFlux t distribution. SigmaDiffractive:PomFlux the MBR simulation of (anti)proton-proton interactions SigmaDiffractive:PomFlux Cie12. The mass distribution follows a renormalized-Regge-theory model, successfully tested using CDF data. SigmaDiffractive:PomFlux The H1 Fit A parametrisation of the Pomeron flux SigmaDiffractive:PomFlux H1P06,H1P06a. The flux factors are motivated by Regge theory, assuming a Regge trajectory as in options 3 and 4. The flux has been normalised to 1 at SigmaDiffractive:PomFlux x_Pomeron = 0.003 and slope parameter and Pomeron intercept has been fitted to H1 data. SigmaDiffractive:PomFlux The H1 Fit B parametrisation of the Pomeron flux SigmaDiffractive:PomFlux H1P06,H1P06a."},{"name":"SigmaDiffractive:PomFluxAlphaPrime","link":"TotalCrossSections.html#anchor13","text":"SigmaDiffractive:PomFluxAlphaPrime The Pomeron trajectory slope SigmaDiffractive:PomFluxAlphaPrime alpha' above for the 1, 3 and 4 flux options."},{"name":"SigmaDiffractive:PomFluxEpsilon","link":"TotalCrossSections.html#anchor12","text":"SigmaDiffractive:PomFluxEpsilon The Pomeron trajectory intercept SigmaDiffractive:PomFluxEpsilon epsilon above for the 3 and 4 flux options. For technical reasons SigmaDiffractive:PomFluxEpsilon epsilon > 0 is necessary in the current implementation."},{"name":"SigmaDiffractive:SaSepsilon","link":"TotalCrossSections.html#anchor30","text":"SigmaDiffractive:SaSepsilon The SaS ansatz starts out from a SigmaDiffractive:SaSepsilon dM^2/M^2 shape of diffractive spectra, a shape that then is modified by SigmaDiffractive:SaSepsilon t -spectra integration and small-mass enhancement. For exploratory purposes it is possible to modify the base ansatz to be SigmaDiffractive:SaSepsilon dM^2/M^(2 * (1 + epsilon)). In principle the integrated diffractive cross sections ought to be recalculated accordingly, but for simplicity they are not modified."},{"name":"SigmaElastic:bSlope","link":"TotalCrossSections.html#anchor5","text":"SigmaElastic:bSlope The assumed slope SigmaElastic:bSlope b of the strong-interaction term SigmaElastic:bSlope exp(bt) , in units of GeV^-2."},{"name":"SigmaElastic:Coulomb","link":"TotalCrossSections.html#anchor62","text":"SigmaElastic:Coulomb Include Coulomb corrections to the elastic and total cross sections."},{"name":"SigmaElastic:lambda","link":"TotalCrossSections.html#anchor64","text":"SigmaElastic:lambda the main parameter of the electric form factor SigmaElastic:lambda G(t) = lambda^2 / (lambda + |t|)^2 , in units of GeV^2, as used in the own, SaS/DL and MBR models."},{"name":"SigmaElastic:phaseConst","link":"TotalCrossSections.html#anchor65","text":"SigmaElastic:phaseConst The Coulomb term is taken to contain a phase factor SigmaElastic:phaseConst exp(+- i alpha phi(t)) , with + for SigmaElastic:phaseConst p p and - for SigmaElastic:phaseConst pbar p , where SigmaElastic:phaseConst phi(t) = - phaseConst - ln(-B t/2). This constant is model dependent SigmaElastic:phaseConst Cah82. This expression is used in the own, SaS/DL and MBR models, where the hadronic cross section is modelled as a simple SigmaElastic:phaseConst exp(B t)."},{"name":"SigmaElastic:rho","link":"TotalCrossSections.html#anchor6","text":"SigmaElastic:rho The assumed ratio of the real to the imaginary parts of the nuclear scattering amplitude. This value is also used in the SaS/DL option."},{"name":"SigmaElastic:tAbsMin","link":"TotalCrossSections.html#anchor63","text":"SigmaElastic:tAbsMin since the Coulomb contribution is infinite a lower limit on SigmaElastic:tAbsMin |t| must be set to regularize the divergence, in units of GeV^2. This means that the elastic and total cross sections are reduced by the amount of the ordinary cross section in the cut-out region, but increased by the Coulomb contribution itself and the interference term (of either sign). This variable has no effect if Coulomb corrections are not switched on or not relevant (e.g. for neutral particles), i.e. then SigmaElastic:tAbsMin t = 0 sets the limit."},{"name":"SigmaProcess:alphaEMorder","link":"CouplingsAndScales.html#anchor3","text":"SigmaProcess:alphaEMorder The running of SigmaProcess:alphaEMorder alpha_em used in hard processes. SigmaProcess:alphaEMorder first-order running, constrained to agree with SigmaProcess:alphaEMorder StandardModel:alphaEMmZ at the SigmaProcess:alphaEMorder Z^0 mass. SigmaProcess:alphaEMorder zeroth order, i.e. SigmaProcess:alphaEMorder alpha_em is kept fixed at its value at vanishing momentum transfer. SigmaProcess:alphaEMorder zeroth order, i.e. SigmaProcess:alphaEMorder alpha_em is kept fixed, but at SigmaProcess:alphaEMorder StandardModel:alphaEMmZ , i.e. its value at the SigmaProcess:alphaEMorder Z^0 mass."},{"name":"SigmaProcess:alphaSorder","link":"CouplingsAndScales.html#anchor2","text":"SigmaProcess:alphaSorder Order at which SigmaProcess:alphaSorder alpha_strong runs, SigmaProcess:alphaSorder zeroth order, i.e. SigmaProcess:alphaSorder alpha_strong is kept fixed. SigmaProcess:alphaSorder first order, which is the normal value. SigmaProcess:alphaSorder second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"SigmaProcess:alphaSvalue","link":"CouplingsAndScales.html#anchor1","text":"SigmaProcess:alphaSvalue The SigmaProcess:alphaSvalue alpha_strong value at scale SigmaProcess:alphaSvalue M_Z^2."},{"name":"SigmaProcess:bMassiveME","link":"SemiInternalProcesses.html#anchor2","text":"SigmaProcess:bMassiveME Let the SigmaProcess:bMassiveME b quark be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"SigmaProcess:cMassiveME","link":"SemiInternalProcesses.html#anchor1","text":"SigmaProcess:cMassiveME Let the SigmaProcess:cMassiveME c quark be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"SigmaProcess:factorFixScale","link":"CouplingsAndScales.html#anchor16","text":"SigmaProcess:factorFixScale A fix SigmaProcess:factorFixScale Q^2 value used as factorization scale for SigmaProcess:factorFixScale 2 &rarr; 1 , SigmaProcess:factorFixScale 2 &rarr; 2 and SigmaProcess:factorFixScale 2 &rarr; 3 processes in some of the options above."},{"name":"SigmaProcess:factorMultFac","link":"CouplingsAndScales.html#anchor15","text":"SigmaProcess:factorMultFac The SigmaProcess:factorMultFac Q^2 factorization scale for SigmaProcess:factorMultFac 2 &rarr; 1 , SigmaProcess:factorMultFac 2 &rarr; 2 and SigmaProcess:factorMultFac 2 &rarr; 3 processes is multiplied by this factor relative to the scale described above (except for the options with a fix scale). Should be use sparingly for SigmaProcess:factorMultFac 2 &rarr; 1 processes."},{"name":"SigmaProcess:factorScale1","link":"CouplingsAndScales.html#anchor11","text":"SigmaProcess:factorScale1 The SigmaProcess:factorScale1 Q^2 factorization scale for SigmaProcess:factorScale1 2 &rarr; 1 processes. The same options also apply for those SigmaProcess:factorScale1 2 &rarr; 2 and SigmaProcess:factorScale1 2 &rarr; 3 processes that have been specially marked as proceeding only through an SigmaProcess:factorScale1 s -channel resonance. SigmaProcess:factorScale1 the squared invariant mass, i.e. SigmaProcess:factorScale1 sHat. SigmaProcess:factorScale1 fix scale set in SigmaProcess:factorScale1 SigmaProcess:factorFixScale below."},{"name":"SigmaProcess:factorScale2","link":"CouplingsAndScales.html#anchor12","text":"SigmaProcess:factorScale2 The SigmaProcess:factorScale2 Q^2 factorization scale for SigmaProcess:factorScale2 2 &rarr; 2 processes. SigmaProcess:factorScale2 the smaller of the squared transverse masses of the two outgoing particles. SigmaProcess:factorScale2 the geometric mean of the squared transverse masses of the two outgoing particles. SigmaProcess:factorScale2 the arithmetic mean of the squared transverse masses of the two outgoing particles. Useful for comparisons with PYTHIA 6, where this is the default. SigmaProcess:factorScale2 squared invariant mass of the system, i.e. SigmaProcess:factorScale2 sHat. Useful for processes dominated by SigmaProcess:factorScale2 s -channel exchange. SigmaProcess:factorScale2 fix scale set in SigmaProcess:factorScale2 SigmaProcess:factorFixScale below. SigmaProcess:factorScale2 Use squared invariant momentum transfer SigmaProcess:factorScale2 -tHat. This is a common choice for lepton-hadron scattering processes. In that case SigmaProcess:factorScale2 -tHat=Q^2."},{"name":"SigmaProcess:factorScale3","link":"CouplingsAndScales.html#anchor13","text":"SigmaProcess:factorScale3 The SigmaProcess:factorScale3 Q^2 factorization scale for 'normal' SigmaProcess:factorScale3 2 &rarr; 3 processes, i.e excepting the vector-boson-fusion processes below. SigmaProcess:factorScale3 the smaller of the squared transverse masses of the three outgoing particles. SigmaProcess:factorScale3 the geometric mean of the two smallest squared transverse masses of the three outgoing particles. SigmaProcess:factorScale3 the geometric mean of the squared transverse masses of the three outgoing particles. SigmaProcess:factorScale3 the arithmetic mean of the squared transverse masses of the three outgoing particles. SigmaProcess:factorScale3 squared invariant mass of the system, i.e. SigmaProcess:factorScale3 sHat. SigmaProcess:factorScale3 fix scale set in SigmaProcess:factorScale3 SigmaProcess:factorFixScale below."},{"name":"SigmaProcess:factorScale3VV","link":"CouplingsAndScales.html#anchor14","text":"SigmaProcess:factorScale3VV The SigmaProcess:factorScale3VV Q^2 factorization scale for SigmaProcess:factorScale3VV 2 &rarr; 3 vector-boson-fusion processes, i.e. SigmaProcess:factorScale3VV f_1 f_2 &rarr; H^0 f_3 f_4 with SigmaProcess:factorScale3VV Z^0 or SigmaProcess:factorScale3VV W^+- SigmaProcess:factorScale3VV t -channel propagators. Here we again introduce the combinations SigmaProcess:factorScale3VV mT_Vi^2 = m_V^2 + pT_i^2 as replacements for the normal squared transverse masses of the two outgoing quarks. SigmaProcess:factorScale3VV the squared mass SigmaProcess:factorScale3VV m_V^2 of the exchanged vector boson. SigmaProcess:factorScale3VV the geometric mean of the two propagator virtuality estimates. SigmaProcess:factorScale3VV the geometric mean of the three relevant squared transverse masses. SigmaProcess:factorScale3VV the arithmetic mean of the three relevant squared transverse masses. SigmaProcess:factorScale3VV squared invariant mass of the system, i.e. SigmaProcess:factorScale3VV sHat. SigmaProcess:factorScale3VV fix scale set in SigmaProcess:factorScale3VV SigmaProcess:factorFixScale below."},{"name":"SigmaProcess:Kfactor","link":"CouplingsAndScales.html#anchor4","text":"SigmaProcess:Kfactor Multiply almost all cross sections by this common fix factor. Excluded are only unresolved processes, where cross sections are better SigmaProcess:Kfactor set directly , and multiparton interactions, which have a separate SigmaProcess:Kfactor K factor SigmaProcess:Kfactor of their own. This degree of freedom is primarily intended for hadron colliders, and should not normally be used for SigmaProcess:Kfactor e^+e^- annihilation processes."},{"name":"SigmaProcess:muMassiveME","link":"SemiInternalProcesses.html#anchor3","text":"SigmaProcess:muMassiveME Let the SigmaProcess:muMassiveME mu lepton be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"SigmaProcess:renormFixScale","link":"CouplingsAndScales.html#anchor10","text":"SigmaProcess:renormFixScale A fix SigmaProcess:renormFixScale Q^2 value used as renormalization scale for SigmaProcess:renormFixScale 2 &rarr; 1 , SigmaProcess:renormFixScale 2 &rarr; 2 and SigmaProcess:renormFixScale 2 &rarr; 3 processes in some of the options above."},{"name":"SigmaProcess:renormMultFac","link":"CouplingsAndScales.html#anchor9","text":"SigmaProcess:renormMultFac The SigmaProcess:renormMultFac Q^2 renormalization scale for SigmaProcess:renormMultFac 2 &rarr; 1 , SigmaProcess:renormMultFac 2 &rarr; 2 and SigmaProcess:renormMultFac 2 &rarr; 3 processes is multiplied by this factor relative to the scale described above (except for the options with a fix scale). Should be use sparingly for SigmaProcess:renormMultFac 2 &rarr; 1 processes."},{"name":"SigmaProcess:renormScale1","link":"CouplingsAndScales.html#anchor5","text":"SigmaProcess:renormScale1 The SigmaProcess:renormScale1 Q^2 renormalization scale for SigmaProcess:renormScale1 2 &rarr; 1 processes. The same options also apply for those SigmaProcess:renormScale1 2 &rarr; 2 and SigmaProcess:renormScale1 2 &rarr; 3 processes that have been specially marked as proceeding only through an SigmaProcess:renormScale1 s -channel resonance, by the SigmaProcess:renormScale1 isSChannel() virtual method of SigmaProcess:renormScale1 SigmaProcess. SigmaProcess:renormScale1 the squared invariant mass, i.e. SigmaProcess:renormScale1 sHat. SigmaProcess:renormScale1 fix scale set in SigmaProcess:renormScale1 SigmaProcess:renormFixScale below."},{"name":"SigmaProcess:renormScale2","link":"CouplingsAndScales.html#anchor6","text":"SigmaProcess:renormScale2 The SigmaProcess:renormScale2 Q^2 renormalization scale for SigmaProcess:renormScale2 2 &rarr; 2 processes. SigmaProcess:renormScale2 the smaller of the squared transverse masses of the two outgoing particles, i.e. SigmaProcess:renormScale2 min(mT_3^2, mT_4^2) = pT^2 + min(m_3^2, m_4^2). SigmaProcess:renormScale2 the geometric mean of the squared transverse masses of the two outgoing particles, i.e. SigmaProcess:renormScale2 mT_3 * mT_4 = sqrt((pT^2 + m_3^2) * (pT^2 + m_4^2)). SigmaProcess:renormScale2 the arithmetic mean of the squared transverse masses of the two outgoing particles, i.e. SigmaProcess:renormScale2 (mT_3^2 + mT_4^2) / 2 = pT^2 + 0.5 * (m_3^2 + m_4^2). Useful for comparisons with PYTHIA 6, where this is the default. SigmaProcess:renormScale2 squared invariant mass of the system, i.e. SigmaProcess:renormScale2 sHat. Useful for processes dominated by SigmaProcess:renormScale2 s -channel exchange. SigmaProcess:renormScale2 fix scale set in SigmaProcess:renormScale2 SigmaProcess:renormFixScale below. SigmaProcess:renormScale2 Use squared invariant momentum transfer SigmaProcess:renormScale2 -tHat. This is a common choice for lepton-hadron scattering processes. In that case SigmaProcess:renormScale2 -tHat=Q^2."},{"name":"SigmaProcess:renormScale3","link":"CouplingsAndScales.html#anchor7","text":"SigmaProcess:renormScale3 The SigmaProcess:renormScale3 Q^2 renormalization scale for 'normal' SigmaProcess:renormScale3 2 &rarr; 3 processes, i.e excepting the vector-boson-fusion processes below. Here it is assumed that particle masses in the final state either match or are heavier than that of any SigmaProcess:renormScale3 t -channel propagator particle. (Currently only SigmaProcess:renormScale3 g g / q qbar &rarr; H^0 Q Qbar processes are implemented, where the 'match' criterion holds.) SigmaProcess:renormScale3 the smaller of the squared transverse masses of the three outgoing particles, i.e. min(mT_3^2, mT_4^2, mT_5^2). SigmaProcess:renormScale3 the geometric mean of the two smallest squared transverse masses of the three outgoing particles, i.e. SigmaProcess:renormScale3 sqrt( mT_3^2 * mT_4^2 * mT_5^2 / max(mT_3^2, mT_4^2, mT_5^2) ). SigmaProcess:renormScale3 the geometric mean of the squared transverse masses of the three outgoing particles, i.e. SigmaProcess:renormScale3 (mT_3^2 * mT_4^2 * mT_5^2)^(1/3). SigmaProcess:renormScale3 the arithmetic mean of the squared transverse masses of the three outgoing particles, i.e. SigmaProcess:renormScale3 (mT_3^2 + mT_4^2 + mT_5^2)/3. SigmaProcess:renormScale3 squared invariant mass of the system, i.e. SigmaProcess:renormScale3 sHat. SigmaProcess:renormScale3 fix scale set in SigmaProcess:renormScale3 SigmaProcess:renormFixScale below."},{"name":"SigmaProcess:renormScale3VV","link":"CouplingsAndScales.html#anchor8","text":"SigmaProcess:renormScale3VV The SigmaProcess:renormScale3VV Q^2 renormalization scale for SigmaProcess:renormScale3VV 2 &rarr; 3 vector-boson-fusion processes, i.e. SigmaProcess:renormScale3VV f_1 f_2 &rarr; H^0 f_3 f_4 with SigmaProcess:renormScale3VV Z^0 or SigmaProcess:renormScale3VV W^+- SigmaProcess:renormScale3VV t -channel propagators. Here the transverse masses of the outgoing fermions do not reflect the virtualities of the exchanged bosons. A better estimate is obtained by replacing the final-state fermion masses by the vector-boson ones in the definition of transverse masses. We denote these combinations SigmaProcess:renormScale3VV mT_Vi^2 = m_V^2 + pT_i^2. SigmaProcess:renormScale3VV the squared mass SigmaProcess:renormScale3VV m_V^2 of the exchanged vector boson. SigmaProcess:renormScale3VV the geometric mean of the two propagator virtuality estimates, i.e. SigmaProcess:renormScale3VV sqrt(mT_V3^2 * mT_V4^2). SigmaProcess:renormScale3VV the geometric mean of the three relevant squared transverse masses, i.e. SigmaProcess:renormScale3VV (mT_V3^2 * mT_V4^2 * mT_H^2)^(1/3). SigmaProcess:renormScale3VV the arithmetic mean of the three relevant squared transverse masses, i.e. SigmaProcess:renormScale3VV (mT_V3^2 + mT_V4^2 + mT_H^2)/3. SigmaProcess:renormScale3VV squared invariant mass of the system, i.e. SigmaProcess:renormScale3VV sHat. SigmaProcess:renormScale3VV fix scale set in SigmaProcess:renormScale3VV SigmaProcess:renormFixScale below."},{"name":"SigmaProcess:tauMassiveME","link":"SemiInternalProcesses.html#anchor4","text":"SigmaProcess:tauMassiveME Let the SigmaProcess:tauMassiveME tau lepton be massive or not in the kinematics set up for external matrix-element evaluation."},{"name":"SigmaTotal:mode","link":"TotalCrossSections.html#anchor1","text":"SigmaTotal:mode Choice of parametrization of the total and elastic cross sections. SigmaTotal:mode Make your own choices (the 'own model'), set as fixed values. SigmaTotal:mode The DL model for total cross sections, extended to more processes and to elastic cross sections according to SaS ('SaS/DL'). SigmaTotal:mode The MBR model for SigmaTotal:mode p p and SigmaTotal:mode p pbar , else as option 1. SigmaTotal:mode The ABMST parametrizations for SigmaTotal:mode p p and SigmaTotal:mode p pbar , else as option 1. SigmaTotal:mode The RPP2016 parametrizations for SigmaTotal:mode p p and SigmaTotal:mode p pbar , else as option 1."},{"name":"SigmaTotal:sigmaAX","link":"TotalCrossSections.html#anchor8","text":"SigmaTotal:sigmaAX Single Diffractive cross section SigmaTotal:sigmaAX A + B &rarr; A + X in mb."},{"name":"SigmaTotal:sigmaAXB","link":"TotalCrossSections.html#anchor10","text":"SigmaTotal:sigmaAXB Central Diffractive cross section SigmaTotal:sigmaAXB A + B &rarr; A + X + B in mb."},{"name":"SigmaTotal:sigmaAXB2TeV","link":"TotalCrossSections.html#anchor23","text":"SigmaTotal:sigmaAXB2TeV The CD cross section for SigmaTotal:sigmaAXB2TeV p p and SigmaTotal:sigmaAXB2TeV pbar p collisions, normalized to its value at 2 TeV CM energy, expressed in mb. The energy dependence is then parametrized, and behaves roughly like SigmaTotal:sigmaAXB2TeV ln^1.5(s)."},{"name":"SigmaTotal:sigmaEl","link":"TotalCrossSections.html#anchor4","text":"SigmaTotal:sigmaEl The assumed elastic cross section in mb."},{"name":"SigmaTotal:sigmaTot","link":"TotalCrossSections.html#anchor3","text":"SigmaTotal:sigmaTot The assumed total cross section in mb."},{"name":"SigmaTotal:sigmaXB","link":"TotalCrossSections.html#anchor7","text":"SigmaTotal:sigmaXB Single Diffractive cross section SigmaTotal:sigmaXB A + B &rarr; X + B in mb."},{"name":"SigmaTotal:sigmaXX","link":"TotalCrossSections.html#anchor9","text":"SigmaTotal:sigmaXX Double Diffractive cross section SigmaTotal:sigmaXX A + B &rarr; X_1 + X_2 in mb."},{"name":"SigmaTotal:zeroAXB","link":"TotalCrossSections.html#anchor24","text":"SigmaTotal:zeroAXB several existing SigmaTotal:zeroAXB tunes do not include CD. An inclusion of a nonvanishing CD cross section directly affects the nondiffractive phenomenology, even if not dramatically, and so this flag is used to forcibly set the CD cross section to vanish in such tunes. You can switch CD back on SigmaTotal:zeroAXB after the selection of a tune, if you so wish, by resetting SigmaTotal:zeroAXB SigmaTotal:zeroAXB = off."},{"name":"SLHA:allowUserOverride","link":"SUSYLesHouchesAccord.html#anchor5","text":"SLHA:allowUserOverride Flag to set whether the user is allowed to modify the parameters read from an SLHA spectrum. Is normally kept SLHA:allowUserOverride off to preserve the internal self-consistency of SLHA spectra. If this flag is switched SLHA:allowUserOverride on , the mass values read from the SLHA block MASS are allowed to be modified by the user, using PYTHIA's standard SLHA:allowUserOverride readString and related methods."},{"name":"SLHA:file","link":"SUSYLesHouchesAccord.html#anchor2","text":"SLHA:file Name of an SLHA (or LHEF) file containing the SUSY/BSM model definition, spectra, and (optionally) decay tables. Default SLHA:file void signals that no such file has been assigned."},{"name":"SLHA:keepSM","link":"SUSYLesHouchesAccord.html#anchor3","text":"SLHA:keepSM Some programs write SLHA output also for SM particles where normally one would not want to have masses and decay modes changed unwittingly. Therefore, by default, known SM particles are ignored in SLHA files. To be more specific, particle data for identity codes in the ranges 1 - 24 and 81 - 999,999 are ignored. Notably this includes SLHA:keepSM Z^0 , SLHA:keepSM W^+- and SLHA:keepSM t. The SM Higgs is modified by the SLHA input, as is other codes in the range 25 - 80 and 1,000,000 -. If you switch off this flag then also SM particles are modified by SLHA input."},{"name":"SLHA:meMode","link":"SUSYLesHouchesAccord.html#anchor7","text":"SLHA:meMode This value specifies how threshold, off-shell, and phase-space weighting effects for SLHA decay channels should be treated, using the same numbering scheme as for SLHA:meMode resonances. The default (100) is to use the branching fraction given in the SLHA DECAY tables without any modifications. The corresponding partial widths remain unchanged when the resonance fluctuates in mass. Specifically there are no threshold corrections. That is, if the resonance fluctuates down in mass, to below the nominal threshold for some decay mode, it is assumed that one of the daughters could also fluctuate down to keep the channel open. (If not, there may be problems later on.) Alternative options (with values 101+) documented under SLHA:meMode resonances allow for some flexibility to apply threshold factors expressing the closing of the on-shell phase space when the daughter masses approach or exceed the parent one. Note that modes that are extremely far off shell (defined as needing a fluctuation of more than 100 times the root-sum-square of the widths of the mother and daughter particles) will always be assigned SLHA:meMode meMode = 100 and should be switched off by hand if so desired. It is up to the user to ensure that the final behaviour is consistent with what is desired (and/or to apply suitable post facto reweightings). Plotting the generator-level resonance and decay-product mass distributions (and e.g., mass differences), effective branching fractions, etc, may be of assistance to validate the behaviour of the program."},{"name":"SLHA:minMassSM","link":"SUSYLesHouchesAccord.html#anchor4","text":"SLHA:minMassSM This parameter provides an alternative possibility to ignore SLHA input for all particles with identity codes below 1,000,000 (which mainly means SM particle, but also includes e.g. the Higgs bosons in two-Higgs-doublet scenarios) whose default masses in PYTHIA lie below some threshold value, given by this parameter. The default value of 100.0 allows SLHA input to modify the top quark, but not, e.g., the SLHA:minMassSM Z^0 and SLHA:minMassSM W^+- bosons."},{"name":"SLHA:NMSSM","link":"SUSYLesHouchesAccord.html#anchor9","text":"SLHA:NMSSM Corresponds to SLHA block MODSEL entry 3."},{"name":"SLHA:readFrom","link":"SUSYLesHouchesAccord.html#anchor1","text":"SLHA:readFrom Controls from where SLHA information is read. SLHA:readFrom is not read at all. Useful when SUSY is not simulated and normal particle properties should not be overwritten. SLHA:readFrom read in from the SLHA:readFrom <slha>...</slha> block of a LHEF, if such a file is read during initialization, and else from the SLHA:readFrom SLHA:file below. SLHA:readFrom read in from the SLHA:readFrom SLHA:file below."},{"name":"SLHA:useDecayTable","link":"SUSYLesHouchesAccord.html#anchor6","text":"SLHA:useDecayTable Switch to choose whether to read in SLHA SLHA:useDecayTable DECAY tables or not. If this switch is set to off, PYTHIA will ignore any decay tables found in the SLHA file, and all decay widths will be calculated internally by PYTHIA. If switched on, SLHA decay tables will be read in, and will then supersede PYTHIA's internal calculations, with PYTHIA only computing the decays for particles for which no SLHA decay table is found. (To set a particle stable, you may either omit an SLHA SLHA:useDecayTable DECAY table for it and then use PYTHIA's internal SLHA:useDecayTable id:MayDecay switch for that particle, or you may include an SLHA SLHA:useDecayTable DECAY table for it, with the width set explicitly to zero.)"},{"name":"SLHA:verbose","link":"SUSYLesHouchesAccord.html#anchor8","text":"SLHA:verbose Controls amount of text output written by the SLHA interface, with a value of 0 corresponding to the most quiet mode. The following variables are used internally by PYTHIA as local copies of SLHA information. User changes will generally have no effect, since these variables will be reset by the SLHA reader during initialization."},{"name":"SoftQCD:all","link":"QCDProcesses.html#anchor1","text":"SoftQCD:all Common switch for the group of all soft QCD processes, as listed separately in the following."},{"name":"SoftQCD:centralDiffractive","link":"QCDProcesses.html#anchor6","text":"SoftQCD:centralDiffractive Central diffractive scattering SoftQCD:centralDiffractive A B &rarr; A X B (a.k.a. double-Pomeron exchange, DPE). See pages on SoftQCD:centralDiffractive Total Cross Sections and on SoftQCD:centralDiffractive Diffraction for details. In particular note the SoftQCD:centralDiffractive SigmaTotal:zeroAXB flag, which is on in most tunes, meaning no central diffraction, and that therefore would need to be reset to off after the selection of a tune (even the default one) to get central diffraction. Code 106."},{"name":"SoftQCD:doubleDiffractive","link":"QCDProcesses.html#anchor5","text":"SoftQCD:doubleDiffractive Double diffractive scattering SoftQCD:doubleDiffractive A B &rarr; X_1 X_2. See pages on SoftQCD:doubleDiffractive Total Cross Sections and SoftQCD:doubleDiffractive Diffraction for details. Code 105."},{"name":"SoftQCD:elastic","link":"QCDProcesses.html#anchor3","text":"SoftQCD:elastic Elastic scattering SoftQCD:elastic A B &rarr; A B. Code 102. It is possible to include SoftQCD:elastic Coulomb corrections , but by default this is off."},{"name":"SoftQCD:inelastic","link":"QCDProcesses.html#anchor7","text":"SoftQCD:inelastic All of the above processes, except for elastic. Codes 101, 103, 104, 105 and 106."},{"name":"SoftQCD:nonDiffractive","link":"QCDProcesses.html#anchor2","text":"SoftQCD:nonDiffractive The inelastic nondiffrative part of the total cross section, i.e. what would often be called the 'minimum-bias component'. The formalism is based on an SoftQCD:nonDiffractive eikonalized description of all the hard QCD processes, so includes them in combination with low- SoftQCD:nonDiffractive pT events. Code 101. SoftQCD:nonDiffractive Since the current description is handled by the multiparton-interactions machinery as part of the parton-level processing, no hard process at all is defined at the process-level part of the event generation. Fortunately, in this case a special SoftQCD:nonDiffractive SoftQCD:nonDiffractive codeSub() method provides information on the first, i.e. hardest, subprocess selected by the multiparton-interactions machinery. SoftQCD:nonDiffractive Note : this event class is almost equivalent to the minimum-bias component of the total cross section. 'Minimum-bias' usually refers to the experimental selection procedure, however, while '(inelastic) non-diffractive' better relates to the way events are generated in the program code. (Although also what separates diffractive from nondiffractive physics can be a matter of definition, especially once colour reconnection is to be modelled.)"},{"name":"SoftQCD:singleDiffractive","link":"QCDProcesses.html#anchor4","text":"SoftQCD:singleDiffractive Single diffractive scattering SoftQCD:singleDiffractive A B &rarr; X B and SoftQCD:singleDiffractive A B &rarr; A X. See pages on SoftQCD:singleDiffractive Total Cross Sections and SoftQCD:singleDiffractive Diffraction for details. Codes 103 and 104."},{"name":"SpaceShower:alphaEMorder","link":"SpacelikeShowers.html#anchor9","text":"SpaceShower:alphaEMorder The running of SpaceShower:alphaEMorder alpha_em. SpaceShower:alphaEMorder first-order running, constrained to agree with SpaceShower:alphaEMorder StandardModel:alphaEMmZ at the SpaceShower:alphaEMorder Z^0 mass. SpaceShower:alphaEMorder zeroth order, i.e. SpaceShower:alphaEMorder alpha_em is kept fixed at its value at vanishing momentum transfer. SpaceShower:alphaEMorder zeroth order, i.e. SpaceShower:alphaEMorder alpha_em is kept fixed, but at SpaceShower:alphaEMorder StandardModel:alphaEMmZ , i.e. its value at the SpaceShower:alphaEMorder Z^0 mass."},{"name":"SpaceShower:alphaSorder","link":"SpacelikeShowers.html#anchor7","text":"SpaceShower:alphaSorder Order at which SpaceShower:alphaSorder alpha_strong runs, SpaceShower:alphaSorder zeroth order, i.e. SpaceShower:alphaSorder alpha_strong is kept fixed. SpaceShower:alphaSorder first order, which is the normal value. SpaceShower:alphaSorder second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"SpaceShower:alphaSuseCMW","link":"SpacelikeShowers.html#anchor8","text":"SpaceShower:alphaSuseCMW SpaceShower:alphaSuseCMW Do not apply the CMW rescaling. SpaceShower:alphaSuseCMW Apply the CMW rescaling, increasing SpaceShower:alphaSuseCMW Lambda_QCD for spacelike showers by a factor roughly 1.6."},{"name":"SpaceShower:alphaSvalue","link":"SpacelikeShowers.html#anchor6","text":"SpaceShower:alphaSvalue The SpaceShower:alphaSvalue alpha_strong value at scale SpaceShower:alphaSvalue M_Z^2."},{"name":"SpaceShower:dipoleRecoil","link":"SpacelikeShowers.html#anchor22","text":"SpaceShower:dipoleRecoil Option to switch on the dipole-recoil scheme as described above."},{"name":"SpaceShower:ecmPow","link":"SpacelikeShowers.html#anchor16","text":"SpaceShower:ecmPow The SpaceShower:ecmPow ecmPow energy rescaling pace introduced above."},{"name":"SpaceShower:ecmRef","link":"SpacelikeShowers.html#anchor15","text":"SpaceShower:ecmRef The SpaceShower:ecmRef ecmRef reference energy scale introduced above."},{"name":"SpaceShower:factorMultFac","link":"SpacelikeShowers.html#anchor11","text":"SpaceShower:factorMultFac The default SpaceShower:factorMultFac pT^2 factorization scale is multiplied by this prefactor."},{"name":"SpaceShower:fixedFacScale","link":"SpacelikeShowers.html#anchor37","text":"SpaceShower:fixedFacScale The fixed factorization scale, in GeV, that would be used in the evaluation of parton densities if the SpaceShower:fixedFacScale flag above is on."},{"name":"SpaceShower:MEafterFirst","link":"SpacelikeShowers.html#anchor30","text":"SpaceShower:MEafterFirst Use of matrix element corrections also after the first emission, for dipole ends of the same system that did not yet radiate. Only has a meaning if SpaceShower:MEafterFirst MEcorrections above is switched on."},{"name":"SpaceShower:MEcorrections","link":"SpacelikeShowers.html#anchor29","text":"SpaceShower:MEcorrections Use of matrix element corrections; on/off = true/false."},{"name":"SpaceShower:nQuarkIn","link":"SpacelikeShowers.html#anchor35","text":"SpaceShower:nQuarkIn Number of allowed quark flavours in SpaceShower:nQuarkIn g &rarr; q qbar branchings, when kinematically allowed, and thereby also in incoming beams. Changing it to 4 would forbid SpaceShower:nQuarkIn g &rarr; b bbar , etc."},{"name":"SpaceShower:phiIntAsym","link":"SpacelikeShowers.html#anchor33","text":"SpaceShower:phiIntAsym Azimuthal asymmetry induced by interference; on/off = true/false."},{"name":"SpaceShower:phiPolAsym","link":"SpacelikeShowers.html#anchor31","text":"SpaceShower:phiPolAsym Azimuthal asymmetry induced by gluon polarization; on/off = true/false."},{"name":"SpaceShower:phiPolAsymHard","link":"SpacelikeShowers.html#anchor32","text":"SpaceShower:phiPolAsymHard Extend the above azimuthal asymmetry (if on) also back to gluons produced in the hard process itself, where feasible; on/off = true/false."},{"name":"SpaceShower:pT0parametrization","link":"SpacelikeShowers.html#anchor13","text":"SpaceShower:pT0parametrization Choice of SpaceShower:pT0parametrization pT0 parametrization. SpaceShower:pT0parametrization Power law dependence on SpaceShower:pT0parametrization ecmNow : SpaceShower:pT0parametrization SpaceShower:pT0parametrization pT0 = pT0(ecmNow) = pT0Ref * (ecmNow / ecmRef)^ecmPow SpaceShower:pT0parametrization Logarithmic dependence on SpaceShower:pT0parametrization ecmNow : SpaceShower:pT0parametrization pT0 = pT0(ecmNow) = pT0Ref + ecmPow * log (ecmNow / ecmRef) where SpaceShower:pT0parametrization pT0Ref , SpaceShower:pT0parametrization ecmRef and SpaceShower:pT0parametrization ecmPow are the three parameters below."},{"name":"SpaceShower:pT0Ref","link":"SpacelikeShowers.html#anchor14","text":"SpaceShower:pT0Ref Regularization of the divergence of the QCD emission probability for SpaceShower:pT0Ref pT &rarr; 0 is obtained by a factor SpaceShower:pT0Ref pT^2 / (pT0^2 + pT^2) , and by using an SpaceShower:pT0Ref alpha_s(pT0^2 + pT^2). An energy dependence of the SpaceShower:pT0Ref pT0 choice is introduced by the next two parameters, so that SpaceShower:pT0Ref pT0Ref is the SpaceShower:pT0Ref pT0 value for the reference cm energy, SpaceShower:pT0Ref pT0Ref = pT0(ecmRef)."},{"name":"SpaceShower:pTdampFudge","link":"SpacelikeShowers.html#anchor5","text":"SpaceShower:pTdampFudge In cases 1 and 2 above, where a dampening is imposed at around the factorization or renormalization scale, respectively, this allows the SpaceShower:pTdampFudge pT scale of dampening of radiation by a half to be shifted by this factor relative to the default SpaceShower:pTdampFudge Q_fac or SpaceShower:pTdampFudge Q_ren. This number ought to be in the neighbourhood of unity, but variations away from this value could do better in some processes."},{"name":"SpaceShower:pTdampMatch","link":"SpacelikeShowers.html#anchor4","text":"SpaceShower:pTdampMatch These options only take effect when a process is allowed to radiate up to the kinematical limit by the above SpaceShower:pTdampMatch pTmaxMatch choice, and no matrix-element corrections are available. Then, in many processes, the fall-off in SpaceShower:pTdampMatch pT will be too slow by one factor of SpaceShower:pTdampMatch pT^2. That is, while showers have an approximate SpaceShower:pTdampMatch dpT^2/pT^2 shape, often it should become more like SpaceShower:pTdampMatch dpT^2/pT^4 at SpaceShower:pTdampMatch pT values above the scale of the hard process. Whether this actually is the case depends on the particular process studied, e.g. if SpaceShower:pTdampMatch t -channel gluon exchange is likely to dominate. If so, the options below could provide a reasonable high- SpaceShower:pTdampMatch pT behaviour without requiring higher-order calculations. SpaceShower:pTdampMatch emissions go up to the kinematical limit, with no special dampening. SpaceShower:pTdampMatch emissions go up to the kinematical limit, but dampened by a factor SpaceShower:pTdampMatch k^2 Q^2_fac/(pT^2 + k^2 Q^2_fac) , where SpaceShower:pTdampMatch Q_fac is the factorization scale and SpaceShower:pTdampMatch k is a multiplicative fudge factor stored in SpaceShower:pTdampMatch pTdampFudge below. SpaceShower:pTdampMatch emissions go up to the kinematical limit, but dampened by a factor SpaceShower:pTdampMatch k^2 Q^2_ren/(pT^2 + k^2 Q^2_ren) , where SpaceShower:pTdampMatch Q_ren is the renormalization scale and SpaceShower:pTdampMatch k is a multiplicative fudge factor stored in SpaceShower:pTdampMatch pTdampFudge below. SpaceShower:pTdampMatch as option 1, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include SpaceShower:pTdampMatch t tbar and SpaceShower:pTdampMatch squark gluino production. SpaceShower:pTdampMatch as option 2, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include SpaceShower:pTdampMatch t tbar and SpaceShower:pTdampMatch squark gluino production. SpaceShower:pTdampMatch Note: These options only apply to the hard interaction. Specifically, a 'second hard' interaction would not be affected. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of the process itself."},{"name":"SpaceShower:pTmaxFudge","link":"SpacelikeShowers.html#anchor2","text":"SpaceShower:pTmaxFudge In cases where the above SpaceShower:pTmaxFudge pTmaxMatch rules would imply that SpaceShower:pTmaxFudge pT_max = pT_factorization , SpaceShower:pTmaxFudge pTmaxFudge introduces a multiplicative factor SpaceShower:pTmaxFudge f such that instead SpaceShower:pTmaxFudge pT_max = f * pT_factorization. Only applies to the hardest interaction in an event, and a 'second hard' if there is such a one, cf. below. It is strongly suggested that SpaceShower:pTmaxFudge f = 1 , but variations around this default can be useful to test this assumption."},{"name":"SpaceShower:pTmaxFudgeMPI","link":"SpacelikeShowers.html#anchor3","text":"SpaceShower:pTmaxFudgeMPI A multiplicative factor SpaceShower:pTmaxFudgeMPI f such that SpaceShower:pTmaxFudgeMPI pT_max = f * pT_factorization , as above, but here for the non-hardest interactions (when multiparton interactions are allowed)."},{"name":"SpaceShower:pTmaxMatch","link":"SpacelikeShowers.html#anchor1","text":"SpaceShower:pTmaxMatch Way in which the maximum shower evolution scale is set to match the scale of the hard process itself. SpaceShower:pTmaxMatch SpaceShower:pTmaxMatch (i) if the final state of the hard process (not counting subsequent resonance decays) contains at least one quark ( SpaceShower:pTmaxMatch u, d, s, c ,b ), gluon or photon then SpaceShower:pTmaxMatch pT_max is chosen to be the factorization scale for internal processes and the SpaceShower:pTmaxMatch scale value for Les Houches input; SpaceShower:pTmaxMatch (ii) if not, emissions are allowed to go all the way up to the kinematical limit. The reasoning is that in the former set of processes the ISR emission of yet another quark, gluon or photon could lead to double-counting, while no such danger exists in the latter case. SpaceShower:pTmaxMatch always use the factorization scale for an internal process and the SpaceShower:pTmaxMatch scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some emissions that ought to have been simulated. (Also known as wimpy showers.) SpaceShower:pTmaxMatch always allow emissions up to the kinematical limit. This will simulate all possible event topologies, but may lead to double-counting. (Also known as power showers.) SpaceShower:pTmaxMatch Note 1: Some processes contain matrix-element matching to the first emission; this is the case notably for single SpaceShower:pTmaxMatch gamma^*/Z^0, W^+- and SpaceShower:pTmaxMatch H^0 production. Then default and option 2 give the correct result, while option 1 should never be used. SpaceShower:pTmaxMatch Note 2: as enumerated in the text, these options take effect both for internal and external processes. Whether a particular option makes sense depends on the context. For instance, if events for the same basic process to different orders are to be matched, then option 1 would be a reasonable first guess. Note, however, that a program like the POWHEG BOX uses a SpaceShower:pTmaxMatch pT definition for ISR and FSR that does not quite agree with the PYTHIA evolution scale, and thus there will be some amount of mismatch. In more sophisticated descriptions, therefore, option 2 could be combined with SpaceShower:pTmaxMatch UserHooks vetoes on emissions that would lead to double-counting, using more flexible phase space boundaries. Further details are found in the SpaceShower:pTmaxMatch Matching and Merging description, with an example in SpaceShower:pTmaxMatch examples/main31. Option 0, finally, may be most realistic when only Born-level processes are involved, possibly in combination with a nonzero SpaceShower:pTmaxMatch SpaceShower:pTdampMatch. The rules used for avoiding double-counting are not foolproof, however. As an example, for the SpaceShower:pTmaxMatch t -channel process SpaceShower:pTmaxMatch gamma gamma &rarr; e^+ e^- its SpaceShower:pTmaxMatch pT scale is the plausible upper shower limit, with only dampened emissions above it. But the initial state is not checked and, had only incoming quarks and gluons been taken into account, only the SpaceShower:pTmaxMatch s -channel process SpaceShower:pTmaxMatch q qbar &rarr; gamma^*/Z^0 &rarr; e^+ e^- would have been possible, where indeed the whole phase space should be populated. So this is erroneously used, giving too much emissions. SpaceShower:pTmaxMatch Note 3: These options only apply to the hard interaction. If a 'second hard' process is present, the two are analyzed and set separately for the default 0 option, while both are affected the same way for non-default options 1 and 2. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of each process itself."},{"name":"SpaceShower:pTmin","link":"SpacelikeShowers.html#anchor17","text":"SpaceShower:pTmin Lower cutoff in SpaceShower:pTmin pT , below which no further ISR branchings are allowed. Normally the SpaceShower:pTmin pT0 above would be used to provide the main regularization of the branching rate for SpaceShower:pTmin pT &rarr; 0 , in which case SpaceShower:pTmin pTmin is used  mainly for technical reasons. It is possible, however, to set SpaceShower:pTmin pT0Ref = 0 and use SpaceShower:pTmin pTmin to provide a step-function regularization, or to combine them in intermediate approaches. Currently SpaceShower:pTmin pTmin is taken to be energy-independent."},{"name":"SpaceShower:pTminChgL","link":"SpacelikeShowers.html#anchor19","text":"SpaceShower:pTminChgL Parton shower cut-off mass for pure QED branchings. Assumed smaller than (or equal to) SpaceShower:pTminChgL pTminChgQ."},{"name":"SpaceShower:pTminChgQ","link":"SpacelikeShowers.html#anchor18","text":"SpaceShower:pTminChgQ Parton shower cut-off SpaceShower:pTminChgQ pT for photon coupling to a coloured particle."},{"name":"SpaceShower:pTminWeak","link":"SpacelikeShowers.html#anchor25","text":"SpaceShower:pTminWeak Parton shower cut-off SpaceShower:pTminWeak pT for weak branchings."},{"name":"SpaceShower:QCDshower","link":"SpacelikeShowers.html#anchor26","text":"SpaceShower:QCDshower Allow a QCD shower; on/off = true/false."},{"name":"SpaceShower:QEDshowerByL","link":"SpacelikeShowers.html#anchor28","text":"SpaceShower:QEDshowerByL Allow leptons to radiate photons; on/off = true/false."},{"name":"SpaceShower:QEDshowerByQ","link":"SpacelikeShowers.html#anchor27","text":"SpaceShower:QEDshowerByQ Allow quarks to radiate photons; on/off = true/false."},{"name":"SpaceShower:rapidityOrder","link":"SpacelikeShowers.html#anchor20","text":"SpaceShower:rapidityOrder Force emissions, after the first,  to be ordered in rapidity, i.e. in terms of decreasing angles in a backwards-evolution sense. Could be used to probe sensitivity to unordered emissions. Only affects QCD emissions, and only the hard subcollision of an event. (For the case 'soft QCD' processes the first MPI counts as the hard subcollision.)"},{"name":"SpaceShower:rapidityOrderMPI","link":"SpacelikeShowers.html#anchor21","text":"SpaceShower:rapidityOrderMPI Same as the last switch, but this time only emissions in secondary scattering systems from MPIs are forced to be ordered in rapidity. Each MPI is ordered separately from the others."},{"name":"SpaceShower:renormMultFac","link":"SpacelikeShowers.html#anchor10","text":"SpaceShower:renormMultFac The default SpaceShower:renormMultFac pT^2 renormalization scale is multiplied by this prefactor. For QCD this is equivalent to a change of SpaceShower:renormMultFac Lambda^2 in the opposite direction, i.e. to a change of SpaceShower:renormMultFac alpha_strong(M_Z^2) (except that flavour thresholds remain at fixed scales). Below, when SpaceShower:renormMultFac pT^2 + pT_0^2 is used as scale, it is this whole expression that is multiplied by the prefactor."},{"name":"SpaceShower:samePTasMPI","link":"SpacelikeShowers.html#anchor12","text":"SpaceShower:samePTasMPI Regularize the SpaceShower:samePTasMPI pT &rarr; 0 divergence using the same sharp cutoff and smooth dampening parameters as used to describe multiparton interactions. That is, the SpaceShower:samePTasMPI MultipartonInteractions:pT0Ref , SpaceShower:samePTasMPI MultipartonInteractions:ecmRef , SpaceShower:samePTasMPI MultipartonInteractions:ecmPow and SpaceShower:samePTasMPI MultipartonInteractions:pTmin parameters are used to regularize all ISR QCD radiation, rather than the corresponding parameters below. This is a sensible physics ansatz, based on the assumption that colour screening effects influence both MPI and ISR in the same way. Photon radiation is regularized separately in either case. SpaceShower:samePTasMPI Note: For photon-photon collisions these parameters are set as in SpaceShower:samePTasMPI Photoproduction. SpaceShower:samePTasMPI Warning: if a large SpaceShower:samePTasMPI pT0 is picked for multiparton interactions, such that the integrated interaction cross section is below the nondiffractive inelastic one, this SpaceShower:samePTasMPI pT0 will automatically be scaled down to cope. Information on such a rescaling does NOT propagate to SpaceShower:samePTasMPI SpaceShower , however."},{"name":"SpaceShower:strengthIntAsym","link":"SpacelikeShowers.html#anchor34","text":"SpaceShower:strengthIntAsym Size of asymmetry induced by interference. Natural value of order 0.5; expression would blow up for a value of 1."},{"name":"SpaceShower:useFixedFacScale","link":"SpacelikeShowers.html#anchor36","text":"SpaceShower:useFixedFacScale Allow the possibility to use a fixed factorization scale, set by the SpaceShower:useFixedFacScale parm below. This option is unphysical and only intended for toy-model and debug studies."},{"name":"SpaceShower:weakShower","link":"SpacelikeShowers.html#anchor23","text":"SpaceShower:weakShower Allow a weak shower, yes or no."},{"name":"SpaceShower:weakShowerMode","link":"SpacelikeShowers.html#anchor24","text":"SpaceShower:weakShowerMode Determine which branchings are allowed. SpaceShower:weakShowerMode both SpaceShower:weakShowerMode W^+- and SpaceShower:weakShowerMode Z^0 branchings. SpaceShower:weakShowerMode only SpaceShower:weakShowerMode W^+- branchings. SpaceShower:weakShowerMode only SpaceShower:weakShowerMode Z^0 branchings."},{"name":"StandardModel:alphaEM0","link":"StandardModelParameters.html#anchor2","text":"StandardModel:alphaEM0 The StandardModel:alphaEM0 alpha_em value at vanishing momentum transfer (and also below StandardModel:alphaEM0 m_e )."},{"name":"StandardModel:alphaEMmZ","link":"StandardModelParameters.html#anchor3","text":"StandardModel:alphaEMmZ The StandardModel:alphaEMmZ alpha_em value at the StandardModel:alphaEMmZ M_Z mass scale. Default is taken from StandardModel:alphaEMmZ Yao06."},{"name":"StandardModel:alphaSnfmax","link":"StandardModelParameters.html#anchor1","text":"StandardModel:alphaSnfmax StandardModel:alphaSnfmax Use 5-flavour running for all scales above the StandardModel:alphaSnfmax b flavour threshold (old default). StandardModel:alphaSnfmax Use 6-flavour running above the StandardModel:alphaSnfmax t threshold (new default)."},{"name":"StandardModel:GF","link":"StandardModelParameters.html#anchor6","text":"StandardModel:GF The Fermi coupling constant, in units of GeV StandardModel:GF ^-2."},{"name":"StandardModel:sin2thetaW","link":"StandardModelParameters.html#anchor4","text":"StandardModel:sin2thetaW The sine-squared of the weak mixing angle, as used in all StandardModel:sin2thetaW Z^0 and StandardModel:sin2thetaW W^+- masses and couplings, except for the vector couplings of fermions to the StandardModel:sin2thetaW Z^0 , see below. Default is the MSbar value from StandardModel:sin2thetaW Yao06."},{"name":"StandardModel:sin2thetaWbar","link":"StandardModelParameters.html#anchor5","text":"StandardModel:sin2thetaWbar The sine-squared of the weak mixing angle, as used to derive the vector couplings of fermions to the StandardModel:sin2thetaWbar Z^0 , in the relation StandardModel:sin2thetaWbar v_f = a_f - 4 e_f sin^2(theta_W)bar. Default is the effective-angle value from StandardModel:sin2thetaWbar Yao06."},{"name":"StandardModel:Vcb","link":"StandardModelParameters.html#anchor12","text":"StandardModel:Vcb The StandardModel:Vcb V_cb CKM matrix element."},{"name":"StandardModel:Vcd","link":"StandardModelParameters.html#anchor10","text":"StandardModel:Vcd The StandardModel:Vcd V_cd CKM matrix element."},{"name":"StandardModel:Vcs","link":"StandardModelParameters.html#anchor11","text":"StandardModel:Vcs The StandardModel:Vcs V_cs CKM matrix element."},{"name":"StandardModel:Vtb","link":"StandardModelParameters.html#anchor15","text":"StandardModel:Vtb The StandardModel:Vtb V_tb CKM matrix element."},{"name":"StandardModel:Vtd","link":"StandardModelParameters.html#anchor13","text":"StandardModel:Vtd The StandardModel:Vtd V_td CKM matrix element."},{"name":"StandardModel:Vts","link":"StandardModelParameters.html#anchor14","text":"StandardModel:Vts The StandardModel:Vts V_ts CKM matrix element."},{"name":"StandardModel:Vub","link":"StandardModelParameters.html#anchor9","text":"StandardModel:Vub The StandardModel:Vub V_ub CKM matrix element."},{"name":"StandardModel:Vud","link":"StandardModelParameters.html#anchor7","text":"StandardModel:Vud The StandardModel:Vud V_ud CKM matrix element."},{"name":"StandardModel:Vus","link":"StandardModelParameters.html#anchor8","text":"StandardModel:Vus The StandardModel:Vus V_us CKM matrix element."},{"name":"Stat:reset","link":"MainProgramSettings.html#anchor19","text":"Stat:reset Reset the statistics of the above three kinds. The default is that all stored statistics information is unaffected by the Stat:reset pythia.stat() call. Counters are automatically reset in each new Stat:reset pythia.init() call, however, so the only time the reset option makes a difference is if Stat:reset stat() is called several times in a (sub)run."},{"name":"Stat:showErrors","link":"MainProgramSettings.html#anchor18","text":"Stat:showErrors Print the available statistics on number and types of aborts, errors and warnings."},{"name":"Stat:showPartonLevel","link":"MainProgramSettings.html#anchor17","text":"Stat:showPartonLevel Print the available statistics on number and types of multiparton interactions, where relevant."},{"name":"Stat:showProcessLevel","link":"MainProgramSettings.html#anchor16","text":"Stat:showProcessLevel Print the available statistics on number of generated events and cross sections, where relevant."},{"name":"StringFlav:BtoMratio","link":"FlavourSelection.html#anchor41","text":"StringFlav:BtoMratio Ratio of the relative rate of baryon to meson production, i.e. every baryon Clebsch-Gordan coefficient gets multiplied by this factor."},{"name":"StringFlav:decupletSup","link":"FlavourSelection.html#anchor34","text":"StringFlav:decupletSup the suppression, relative to default SU(6) factors, of decuplet baryon production. Default corresponds to no suppression, while 0 corresponds to no decuplet production at all."},{"name":"StringFlav:etaPrimeSup","link":"FlavourSelection.html#anchor13","text":"StringFlav:etaPrimeSup the additional suppression of StringFlav:etaPrimeSup eta' production, multiplying the normal production probability. Thus 0 means no StringFlav:etaPrimeSup eta' at all are produced, while 1 means full rate."},{"name":"StringFlav:etaSup","link":"FlavourSelection.html#anchor12","text":"StringFlav:etaSup the additional suppression of StringFlav:etaSup eta production, multiplying the normal production probability. Thus 0 means no StringFlav:etaSup eta at all are produced, while 1 means full rate."},{"name":"StringFlav:heavyLeadingBSup","link":"FlavourSelection.html#anchor40","text":"StringFlav:heavyLeadingBSup extra suppression of leading-baryon production for a heavy-quark jet, i.e. StringFlav:heavyLeadingBSup c or StringFlav:heavyLeadingBSup b , when StringFlav:heavyLeadingBSup suppressLeadingB = on. Thus 0 means no leading-baryon production at all, while 1 means full rate."},{"name":"StringFlav:kappa","link":"RopeHadronization.html#anchor25","text":"StringFlav:kappa A base value of the string tension can be added, and modified along with other parameters, to allow for studies of exotic quark production in the Rope model."},{"name":"StringFlav:lightLeadingBSup","link":"FlavourSelection.html#anchor39","text":"StringFlav:lightLeadingBSup extra suppression of leading-baryon production for a light-quark jet, i.e. StringFlav:lightLeadingBSup d , StringFlav:lightLeadingBSup u or StringFlav:lightLeadingBSup s , when StringFlav:lightLeadingBSup suppressLeadingB = on. Thus 0 means no leading-baryon production at all, while 1 means full rate."},{"name":"StringFlav:mesonBL1S0J1","link":"FlavourSelection.html#anchor26","text":"StringFlav:mesonBL1S0J1 the relative pseudovector production ratio StringFlav:mesonBL1S0J1 (L=1,S=0,J=1) /pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonBL1S1J0","link":"FlavourSelection.html#anchor27","text":"StringFlav:mesonBL1S1J0 the relative scalar production ratio StringFlav:mesonBL1S1J0 (L=1,S=1,J=0) /pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonBL1S1J1","link":"FlavourSelection.html#anchor28","text":"StringFlav:mesonBL1S1J1 the relative pseudovector production ratio StringFlav:mesonBL1S1J1 (L=1,S=1,J=1) /pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonBL1S1J2","link":"FlavourSelection.html#anchor29","text":"StringFlav:mesonBL1S1J2 the relative tensor production ratio StringFlav:mesonBL1S1J2 (L=1,S=1,J=2) /pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonBvector","link":"FlavourSelection.html#anchor9","text":"StringFlav:mesonBvector the relative production ratio vector/pseudoscalar for bottom mesons."},{"name":"StringFlav:mesonCL1S0J1","link":"FlavourSelection.html#anchor22","text":"StringFlav:mesonCL1S0J1 the relative pseudovector production ratio StringFlav:mesonCL1S0J1 (L=1,S=0,J=1) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCL1S1J0","link":"FlavourSelection.html#anchor23","text":"StringFlav:mesonCL1S1J0 the relative scalar production ratio StringFlav:mesonCL1S1J0 (L=1,S=1,J=0) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCL1S1J1","link":"FlavourSelection.html#anchor24","text":"StringFlav:mesonCL1S1J1 the relative pseudovector production ratio StringFlav:mesonCL1S1J1 (L=1,S=1,J=1) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCL1S1J2","link":"FlavourSelection.html#anchor25","text":"StringFlav:mesonCL1S1J2 the relative tensor production ratio StringFlav:mesonCL1S1J2 (L=1,S=1,J=2) /pseudoscalar for charm mesons."},{"name":"StringFlav:mesonCvector","link":"FlavourSelection.html#anchor8","text":"StringFlav:mesonCvector the relative production ratio vector/pseudoscalar for charm mesons."},{"name":"StringFlav:mesonNonetL1","link":"FlavourSelection.html#anchor44","text":"StringFlav:mesonNonetL1 Switch on to include the pseudovector, scalar, pseudovector, and tensor nonet (L=1)."},{"name":"StringFlav:mesonSL1S0J1","link":"FlavourSelection.html#anchor18","text":"StringFlav:mesonSL1S0J1 the relative pseudovector production ratio StringFlav:mesonSL1S0J1 (L=1,S=0,J=1) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSL1S1J0","link":"FlavourSelection.html#anchor19","text":"StringFlav:mesonSL1S1J0 the relative scalar production ratio StringFlav:mesonSL1S1J0 (L=1,S=1,J=0) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSL1S1J1","link":"FlavourSelection.html#anchor20","text":"StringFlav:mesonSL1S1J1 the relative pseudovector production ratio StringFlav:mesonSL1S1J1 (L=1,S=1,J=1) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSL1S1J2","link":"FlavourSelection.html#anchor21","text":"StringFlav:mesonSL1S1J2 the relative tensor production ratio StringFlav:mesonSL1S1J2 (L=1,S=1,J=2) /pseudoscalar for strange mesons."},{"name":"StringFlav:mesonSvector","link":"FlavourSelection.html#anchor7","text":"StringFlav:mesonSvector the relative production ratio vector/pseudoscalar for strange mesons."},{"name":"StringFlav:mesonUDL1S0J1","link":"FlavourSelection.html#anchor14","text":"StringFlav:mesonUDL1S0J1 the relative pseudovector production ratio StringFlav:mesonUDL1S0J1 (L=1,S=0,J=1) /pseudoscalar for light ( StringFlav:mesonUDL1S0J1 u , StringFlav:mesonUDL1S0J1 d ) mesons."},{"name":"StringFlav:mesonUDL1S1J0","link":"FlavourSelection.html#anchor15","text":"StringFlav:mesonUDL1S1J0 the relative scalar production ratio StringFlav:mesonUDL1S1J0 (L=1,S=1,J=0) /pseudoscalar for light ( StringFlav:mesonUDL1S1J0 u , StringFlav:mesonUDL1S1J0 d ) mesons."},{"name":"StringFlav:mesonUDL1S1J1","link":"FlavourSelection.html#anchor16","text":"StringFlav:mesonUDL1S1J1 the relative pseudovector production ratio StringFlav:mesonUDL1S1J1 (L=1,S=1,J=1) /pseudoscalar for light ( StringFlav:mesonUDL1S1J1 u , StringFlav:mesonUDL1S1J1 d ) mesons."},{"name":"StringFlav:mesonUDL1S1J2","link":"FlavourSelection.html#anchor17","text":"StringFlav:mesonUDL1S1J2 the relative tensor production ratio StringFlav:mesonUDL1S1J2 (L=1,S=1,J=2) /pseudoscalar for light ( StringFlav:mesonUDL1S1J2 u , StringFlav:mesonUDL1S1J2 d ) mesons."},{"name":"StringFlav:mesonUDvector","link":"FlavourSelection.html#anchor6","text":"StringFlav:mesonUDvector the relative production ratio vector/pseudoscalar for light ( StringFlav:mesonUDvector u , StringFlav:mesonUDvector d ) mesons."},{"name":"StringFlav:nQuark","link":"FlavourSelection.html#anchor43","text":"StringFlav:nQuark Selects the newly produced quark flavours that may be included in hadrons. The default corresponds to only include u/d/s quarks."},{"name":"StringFlav:popcornRate","link":"FlavourSelection.html#anchor35","text":"StringFlav:popcornRate gives the relative rates of StringFlav:popcornRate B Bbar and StringFlav:popcornRate B M Bbar production, roughly as StringFlav:popcornRate Prob(B M Bbar) / (Prob(B Bbar) + Prob(B M Bbar)) = popcornRate / (0.5 + popcornRate) (the complete expression depends on all the quark and diquark production parameters and is therefore not so useful)."},{"name":"StringFlav:popcornSmeson","link":"FlavourSelection.html#anchor37","text":"StringFlav:popcornSmeson extra suppression for having a strange meson StringFlav:popcornSmeson M in a StringFlav:popcornSmeson B M Bbar configuration."},{"name":"StringFlav:popcornSpair","link":"FlavourSelection.html#anchor36","text":"StringFlav:popcornSpair extra suppression for having an StringFlav:popcornSpair s sbar pair shared between the StringFlav:popcornSpair B and StringFlav:popcornSpair Bbar in a StringFlav:popcornSpair B M Bbar configuration."},{"name":"StringFlav:probQQ1toQQ0","link":"FlavourSelection.html#anchor4","text":"StringFlav:probQQ1toQQ0 the suppression of spin 1 diquark production relative to spin 0 one, apart from the factor of 3 enhancement of spin 1 from counting the number of states."},{"name":"StringFlav:probQQ1toQQ0join","link":"FlavourSelection.html#anchor5","text":"StringFlav:probQQ1toQQ0join when two already produced quarks are to be combined to a diquark, e.g. in the junction framework, these numbers give the suppression of spin 1 diquark production relative to spin 0 one, apart from the factor of 3 enhancement of spin 1 from counting the number of states. The four components give the suppression when the heaviest quark is StringFlav:probQQ1toQQ0join u/d , StringFlav:probQQ1toQQ0join s , StringFlav:probQQ1toQQ0join c or StringFlav:probQQ1toQQ0join b , respectively. These parameters are seldom used and currently not constrained by any data, so very much a guesswork. Character-string input of this vector should be as a comma-separated list, without any blanks."},{"name":"StringFlav:probQQtoQ","link":"FlavourSelection.html#anchor2","text":"StringFlav:probQQtoQ the suppression of diquark production relative to quark production, i.e. of baryon relative to meson production."},{"name":"StringFlav:probSQtoQQ","link":"FlavourSelection.html#anchor3","text":"StringFlav:probSQtoQQ the suppression of strange diquark production relative to light diquark production, over and above the one already given by StringFlav:probSQtoQQ probStoU."},{"name":"StringFlav:probStoUD","link":"FlavourSelection.html#anchor1","text":"StringFlav:probStoUD the suppression of StringFlav:probStoUD s quark production relative to ordinary StringFlav:probStoUD u or StringFlav:probStoUD d one."},{"name":"StringFlav:StrangeSuppression","link":"FlavourSelection.html#anchor42","text":"StringFlav:StrangeSuppression Extra suppression factor for strange quarks. Note that in case of more than one strange quark in the hadron the factor gets squared or tripled respectively."},{"name":"StringFlav:suppressLeadingB","link":"FlavourSelection.html#anchor38","text":"StringFlav:suppressLeadingB Suppress leading-baryon production. StringFlav:suppressLeadingB No suppression. StringFlav:suppressLeadingB Suppress the production of a diquark in the string breaking closest to a quark end of a string, by either of the factors below. This suppresses the production of first-rank baryons by the same amount. Indirectly also the second-rank and, if popcorn production is switched on, third-rank (anti)baryon production is affected."},{"name":"StringFlav:thetaL1S0J1","link":"FlavourSelection.html#anchor30","text":"StringFlav:thetaL1S0J1 gives the mixing angle StringFlav:thetaL1S0J1 theta in the StringFlav:thetaL1S0J1 (L=1,S=0,J=1) pseudovector meson sector, expressed in degrees."},{"name":"StringFlav:thetaL1S1J0","link":"FlavourSelection.html#anchor31","text":"StringFlav:thetaL1S1J0 gives the mixing angle StringFlav:thetaL1S1J0 theta in the StringFlav:thetaL1S1J0 (L=1,S=1,J=0) scalar meson sector, expressed in degrees."},{"name":"StringFlav:thetaL1S1J1","link":"FlavourSelection.html#anchor32","text":"StringFlav:thetaL1S1J1 gives the mixing angle StringFlav:thetaL1S1J1 theta in the StringFlav:thetaL1S1J1 (L=1,S=1,J=1) pseudovector meson sector, expressed in degrees."},{"name":"StringFlav:thetaL1S1J2","link":"FlavourSelection.html#anchor33","text":"StringFlav:thetaL1S1J2 gives the mixing angle StringFlav:thetaL1S1J2 theta in the StringFlav:thetaL1S1J2 (L=1,S=1,J=2) tensor meson sector, expressed in degrees."},{"name":"StringFlav:thetaPS","link":"FlavourSelection.html#anchor10","text":"StringFlav:thetaPS gives the mixing angle StringFlav:thetaPS theta_PS in the pseudoscalar meson sector (which is rather poorly determined), expressed in degrees. Here StringFlav:thetaPS f is associated with StringFlav:thetaPS eta' and StringFlav:thetaPS f' with StringFlav:thetaPS eta. (This standard but counterintuitive choice is fixed up in the code by replacing StringFlav:thetaPS alpha &rarr; 90^0 - alpha so that StringFlav:thetaPS eta &harr; eta' ; relative signs do not matter since we are interested in probabilities only.)"},{"name":"StringFlav:thetaV","link":"FlavourSelection.html#anchor11","text":"StringFlav:thetaV gives the mixing angle StringFlav:thetaV theta_V in the vector meson sector (which is somewhat better determined), expressed in degrees. Here StringFlav:thetaV f is associated with StringFlav:thetaV omega and StringFlav:thetaV f' with StringFlav:thetaV phi."},{"name":"StringFragmentation:eBothLeftJunction","link":"Fragmentation.html#anchor46","text":"StringFragmentation:eBothLeftJunction Retry (up to 10 times) when the first two considered strings in to a junction both have a remaining energy (in the junction rest frame) above this number."},{"name":"StringFragmentation:eMaxLeftJunction","link":"Fragmentation.html#anchor47","text":"StringFragmentation:eMaxLeftJunction Retry (up to 10 times) when the first two considered strings in to a junction has a highest remaining energy (in the junction rest frame) above a random energy evenly distributed between StringFragmentation:eMaxLeftJunction eBothLeftJunction and StringFragmentation:eMaxLeftJunction eBothLeftJunction + eMaxLeftJunction (drawn anew for each test)."},{"name":"StringFragmentation:eMinLeftJunction","link":"Fragmentation.html#anchor48","text":"StringFragmentation:eMinLeftJunction Retry (up to 10 times) when the invariant mass-squared of the final leg and the leftover momentum of the first two treated legs falls below StringFragmentation:eMinLeftJunction eMinLeftJunction times the energy of the final leg (in the junction rest frame)."},{"name":"StringFragmentation:eNormJunction","link":"Fragmentation.html#anchor45","text":"StringFragmentation:eNormJunction Used to find the effective rest frame of the junction, which is complicated when the three string legs may contain additional gluons between the junction and the endpoint. To this end, a pull is defined as a weighed sum of the momenta on each leg, where the weight is StringFragmentation:eNormJunction exp(- eSum / eNormJunction) , with StringFragmentation:eNormJunction eSum the summed energy of all partons closer to the junction than the currently considered one (in the junction rest frame). Should in principle be (close to) StringFragmentation:eNormJunction sqrt((1 + a) / b) , with StringFragmentation:eNormJunction a and StringFragmentation:eNormJunction b the parameters of the Lund symmetric fragmentation function."},{"name":"StringFragmentation:stopMass","link":"Fragmentation.html#anchor37","text":"StringFragmentation:stopMass Is used to define a StringFragmentation:stopMass W_min = m_q1 + m_q2 + stopMass , where StringFragmentation:stopMass m_q1 and StringFragmentation:stopMass m_q2 are the masses of the two current endpoint quarks or diquarks."},{"name":"StringFragmentation:stopNewFlav","link":"Fragmentation.html#anchor38","text":"StringFragmentation:stopNewFlav Add to StringFragmentation:stopNewFlav W_min an amount StringFragmentation:stopNewFlav stopNewFlav * m_q_last , where StringFragmentation:stopNewFlav q_last is the last StringFragmentation:stopNewFlav q qbar pair produced between the final two hadrons."},{"name":"StringFragmentation:stopSmear","link":"Fragmentation.html#anchor39","text":"StringFragmentation:stopSmear The StringFragmentation:stopSmear W_min above is then smeared uniformly in the range StringFragmentation:stopSmear W_min_smeared = W_min * [ 1 - stopSmear, 1 + stopSmear ]."},{"name":"StringFragmentation:TraceColours","link":"Fragmentation.html#anchor40","text":"StringFragmentation:TraceColours In some cases it is interesting to trace the primary hadrons back to the string pieces from which they were formed. If StringFragmentation:TraceColours StringFragmentation:TraceColours is switched StringFragmentation:TraceColours on , this is done by setting colour and anticolour indices for the primary hadrons to the indices of the string piece where the corresponding break-ups are assumed to have happened. To avoid the possible confusion of having colour indices on colour singlet particles, this flag is by default StringFragmentation:TraceColours off."},{"name":"StringPT:closePacking","link":"Fragmentation.html#anchor34","text":"StringPT:closePacking If switched on then the two following parameters modify either StringPT:closePacking StringPT:sigma or StringPT:closePacking StringPT:temperature , respectively. Normally only one of the options below would be used, but technically both are allowed and then combine multiplicatively."},{"name":"StringPT:enhancedFraction","link":"Fragmentation.html#anchor27","text":"StringPT:enhancedFraction StringPT:enhancedFraction enhancedFraction ,the fraction of string breaks with enhanced width."},{"name":"StringPT:enhancedWidth","link":"Fragmentation.html#anchor28","text":"StringPT:enhancedWidth StringPT:enhancedWidth enhancedWidth ,the enhancement of the width in this fraction."},{"name":"StringPT:expMPI","link":"Fragmentation.html#anchor35","text":"StringPT:expMPI Exponent to the number of MPIs. The width/temparture will get the prefactor StringPT:expMPI N(MPI)^expMPI."},{"name":"StringPT:expNSP","link":"Fragmentation.html#anchor36","text":"StringPT:expNSP Exponent for the number of effective nearby string pieces, calculated as StringPT:expNSP N(NSP) =1 + (N StringPT:expNSP string -1)/(1+p StringPT:expNSP 2 StringPT:expNSP T had /    p StringPT:expNSP 2 StringPT:expNSP T 0 ) , where StringPT:expNSP p StringPT:expNSP 2 StringPT:expNSP T had is the transverse momentum of the next produced hadron, estimated based on an educated guess of its momentum, and StringPT:expNSP p StringPT:expNSP 2 StringPT:expNSP T 0 is the MPI regularization parameter StringPT:expNSP MultipartonInteractions:pT0Ref. The width/temperature will get the prefactor StringPT:expNSP N(NSP)^expNSP."},{"name":"StringPT:mT2suppression","link":"Fragmentation.html#anchor31","text":"StringPT:mT2suppression If switched on the flavour composition is chosen based on the hadronic transverse mass, StringPT:mT2suppression mT^2_had , and not based on the quark masses. This implies a mass suppression factor StringPT:mT2suppression exp(-m_had^2 / 2 sigma^2)."},{"name":"StringPT:sigma","link":"Fragmentation.html#anchor26","text":"StringPT:sigma the width StringPT:sigma sigma in the fragmentation process."},{"name":"StringPT:temperature","link":"Fragmentation.html#anchor32","text":"StringPT:temperature the temperature StringPT:temperature T in the fragmentation process."},{"name":"StringPT:tempPreFactor","link":"Fragmentation.html#anchor33","text":"StringPT:tempPreFactor Temperature prefactor for strange quarks and diquarks. Default is determined to have the same average StringPT:tempPreFactor pT in StringPT:tempPreFactor u/d &rarr; s and StringPT:tempPreFactor s &rarr; u/d transistions."},{"name":"StringPT:thermalModel","link":"Fragmentation.html#anchor25","text":"StringPT:thermalModel If switched off the quark StringPT:thermalModel pT is generated according to the traditional Gaussion distribution in StringPT:thermalModel p_x and StringPT:thermalModel p_y separately. If switched on, the new 'thermal model' StringPT:thermalModel Fis16 is instead used, wherein the quark StringPT:thermalModel pT is generated such that the resulting hadron receives a StringPT:thermalModel pT according to an exponential distribution. Also the hadronic composition is affected, see further below."},{"name":"StringPT:widthPreDiquark","link":"Fragmentation.html#anchor30","text":"StringPT:widthPreDiquark Prefactor multiplying the Gaussian width for diquarks. In case of diquarks with one or two strange quarks the prefactor is calculated by multiplying StringPT:widthPreDiquark widthPreDiquark once or twice respectively with StringPT:widthPreDiquark widthPreStrange."},{"name":"StringPT:widthPreStrange","link":"Fragmentation.html#anchor29","text":"StringPT:widthPreStrange Prefactor multiplying the Gaussian width for strange quarks."},{"name":"StringZ:aExtraDiquark","link":"Fragmentation.html#anchor6","text":"StringZ:aExtraDiquark allows a larger StringZ:aExtraDiquark a for diquarks, with total StringZ:aExtraDiquark a = aLund + aExtraDiquark."},{"name":"StringZ:aExtraSQuark","link":"Fragmentation.html#anchor5","text":"StringZ:aExtraSQuark allows a larger StringZ:aExtraSQuark a for s quarks, with total StringZ:aExtraSQuark a = aLund + aExtraSQuark."},{"name":"StringZ:aLund","link":"Fragmentation.html#anchor1","text":"StringZ:aLund The StringZ:aLund a parameter of the Lund symmetric fragmentation function."},{"name":"StringZ:aNonstandardB","link":"Fragmentation.html#anchor14","text":"StringZ:aNonstandardB The StringZ:aNonstandardB a parameter in the nonstandard Lund ansatz for StringZ:aNonstandardB b quarks."},{"name":"StringZ:aNonstandardC","link":"Fragmentation.html#anchor13","text":"StringZ:aNonstandardC The StringZ:aNonstandardC a parameter in the nonstandard Lund ansatz for StringZ:aNonstandardC c quarks."},{"name":"StringZ:aNonstandardH","link":"Fragmentation.html#anchor15","text":"StringZ:aNonstandardH The StringZ:aNonstandardH a parameter in the nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"StringZ:avgZLund","link":"Fragmentation.html#anchor4","text":"StringZ:avgZLund When StringZ:avgZLund StringZ:deriveBLund is set to StringZ:avgZLund on , this parameter specifies the average of the fragmentation function for primary rho mesons, evaluated at StringZ:avgZLund mT^2 = mRho^2 + 2 StringZ:avgZLund StringPT:sigma ^2. The appropriate StringZ:avgZLund b -parameter value is computed automatically during initialisation and the StringZ:avgZLund StringZ:bLund parameter is updated accordingly. Note that the derived value is allowed to exceed the nominal limits given for StringZ:avgZLund bLund above. This is intended to allow fits to see the functional behaviour even outside the nominal limits."},{"name":"StringZ:bLund","link":"Fragmentation.html#anchor2","text":"StringZ:bLund The StringZ:bLund b parameter of the Lund symmetric fragmentation function."},{"name":"StringZ:bNonstandardB","link":"Fragmentation.html#anchor17","text":"StringZ:bNonstandardB The StringZ:bNonstandardB b parameter in the nonstandard Lund ansatz for StringZ:bNonstandardB b quarks."},{"name":"StringZ:bNonstandardC","link":"Fragmentation.html#anchor16","text":"StringZ:bNonstandardC The StringZ:bNonstandardC b parameter in the nonstandard Lund ansatz for StringZ:bNonstandardC c quarks."},{"name":"StringZ:bNonstandardH","link":"Fragmentation.html#anchor18","text":"StringZ:bNonstandardH The StringZ:bNonstandardH b parameter in the nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"StringZ:deriveBLund","link":"Fragmentation.html#anchor3","text":"StringZ:deriveBLund When set to StringZ:deriveBLund on , the StringZ:deriveBLund b parameter is treated as a derived quantity; i.e., the value of StringZ:deriveBLund StringZ:bLund is ignored in favour of the StringZ:deriveBLund StringZ:avgZLund parameter below. (The StringZ:deriveBLund StringZ:bLund parameter is then also reset to the derived value so that it can be queried after initialisation, if desired.)"},{"name":"StringZ:epsilonB","link":"Fragmentation.html#anchor23","text":"StringZ:epsilonB StringZ:epsilonB epsilon_b , i.e. the above parameter for StringZ:epsilonB b quarks."},{"name":"StringZ:epsilonC","link":"Fragmentation.html#anchor22","text":"StringZ:epsilonC StringZ:epsilonC epsilon_c , i.e. the above parameter for StringZ:epsilonC c quarks."},{"name":"StringZ:epsilonH","link":"Fragmentation.html#anchor24","text":"StringZ:epsilonH StringZ:epsilonH epsilon_h , i.e. the above parameter for hypothetical heavier quarks, normalized to the case where StringZ:epsilonH m_h = m_b. The actually used parameter is then StringZ:epsilonH epsilon = epsilon_h * (m_b^2 / m_h^2). This allows a sensible scaling to a particle with an unknown higher mass without the need for a user intervention."},{"name":"StringZ:rFactB","link":"Fragmentation.html#anchor8","text":"StringZ:rFactB StringZ:rFactB r_b , i.e. the above parameter for StringZ:rFactB b quarks."},{"name":"StringZ:rFactC","link":"Fragmentation.html#anchor7","text":"StringZ:rFactC StringZ:rFactC r_c , i.e. the above parameter for StringZ:rFactC c quarks."},{"name":"StringZ:rFactH","link":"Fragmentation.html#anchor9","text":"StringZ:rFactH StringZ:rFactH r_h , i.e. the above parameter for heavier hypothetical quarks, or in general any new coloured particle long-lived enough to hadronize."},{"name":"StringZ:useNonstandardB","link":"Fragmentation.html#anchor11","text":"StringZ:useNonstandardB use the above nonstandard Lund ansatz for StringZ:useNonstandardB b quarks."},{"name":"StringZ:useNonstandardC","link":"Fragmentation.html#anchor10","text":"StringZ:useNonstandardC use the above nonstandard Lund ansatz for StringZ:useNonstandardC c quarks."},{"name":"StringZ:useNonstandardH","link":"Fragmentation.html#anchor12","text":"StringZ:useNonstandardH use the above nonstandard Lund ansatz for hypothetical heavier quarks."},{"name":"StringZ:usePetersonB","link":"Fragmentation.html#anchor20","text":"StringZ:usePetersonB use Peterson for StringZ:usePetersonB b quarks."},{"name":"StringZ:usePetersonC","link":"Fragmentation.html#anchor19","text":"StringZ:usePetersonC use Peterson for StringZ:usePetersonC c quarks."},{"name":"StringZ:usePetersonH","link":"Fragmentation.html#anchor21","text":"StringZ:usePetersonH use Peterson for hypothetical heavier quarks."},{"name":"SuppressSmallPT : public UserHooks","link":"UserHooks.html#anchor31","text":"SuppressSmallPT : public UserHooks suppress small- SuppressSmallPT : public UserHooks pT production for SuppressSmallPT : public UserHooks 2 &rarr; 2 processes only, while leaving other processes unaffected. The basic suppression factor is SuppressSmallPT : public UserHooks pT^4 / ((k*pT0)^2 + pT^2)^2 , where SuppressSmallPT : public UserHooks pT refers to the current hard subprocess and SuppressSmallPT : public UserHooks pT0 is the same energy-dependent dampening scale as used for SuppressSmallPT : public UserHooks multiparton interactions. This class contains SuppressSmallPT : public UserHooks canModifySigma() and SuppressSmallPT : public UserHooks multiplySigmaBy() methods that overload the base class ones."},{"name":"SUSY:all","link":"SUSYProcesses.html#anchor1","text":"SUSY:all Common switch for production of supersymmetric particles, i.e. particles with R-parity -1."},{"name":"SUSY:gg2gluinogluino","link":"SUSYProcesses.html#anchor7","text":"SUSY:gg2gluinogluino Pair production of gluinos by gluon-gluon initial states."},{"name":"SUSY:gg2squarkantisquark","link":"SUSYProcesses.html#anchor10","text":"SUSY:gg2squarkantisquark Pair production of a scalar quark together with a scalar antiquark by gluon annihilation via SUSY:gg2squarkantisquark s -channel gluon exchange, SUSY:gg2squarkantisquark t - and SUSY:gg2squarkantisquark u -channel squark exchange, and the direct 4-point coupling. The cross section expression follows SUSY:gg2squarkantisquark Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:idA","link":"SUSYProcesses.html#anchor2","text":"SUSY:idA Option to limit the sum over possible outgoing states in SUSY SUSY:idA 2 &rarr; 2 processes to ones including a specific particle identity code. The default corresponds to summing over all possible indices. A non-zero value of SUSY:idA SUSY:idA selects only processes that contain the state corresponding to that particular particle identity code in the fundamental SUSY:idA 2 &rarr; 2 scattering process (summed over particle/antiparticle). It is the user's responsibility to ensure that (a subset of) the processes to be simulated actually include this particle at the SUSY:idA 2 &rarr; 2 level; thus, asking for the lightest neutralino (code 1000021) to be present in a squark-squark production process will give no match."},{"name":"SUSY:idB","link":"SUSYProcesses.html#anchor3","text":"SUSY:idB As for SUSY:idB SUSY:idA , but requires an additional particle with PDG code SUSY:idB SUSY:idB to be present in the SUSY:idB 2 &rarr; 2 process. Thus, using SUSY:idB SUSY:idA and SUSY:idB SUSY:idB a specific subprocess can be selected. Again only the absolute sign is used, i.e. the summation over particle and antiparticle is retained. Also the order of SUSY:idB SUSY:idA and SUSY:idB SUSY:idB is irrelevant; since both possible orderings are checked for a match with the two outgoing particles. (Although not recommended, should SUSY:idB SUSY:idA be zero and SUSY:idB SUSY:idB nonzero a match is searched for just like in the normal case with SUSY:idB SUSY:idA nonzero and SUSY:idB SUSY:idB zero.)"},{"name":"SUSY:idVecA","link":"SUSYProcesses.html#anchor4","text":"SUSY:idVecA As for SUSY:idVecA SUSY:idA , but as a vector of PDG codes. Thus, it selects only processes that have a final-state particle corresponding to one of the identity codes in this vector. Note that, to activate this, SUSY:idVecA SUSY:idA must be equal to zero; if not then the match to SUSY:idVecA SUSY:idA takes precedence. Character-string input of this vector should be as a comma-separated list, without any blanks."},{"name":"SUSY:idVecB","link":"SUSYProcesses.html#anchor5","text":"SUSY:idVecB As for SUSY:idVecB SUSY:idB , but as a vector of PDG codes. As above, to activate this, SUSY:idVecB SUSY:idB must be equal to zero; if not then the match to SUSY:idVecB SUSY:idB takes precedence. For the matching, either of SUSY:idVecB SUSY:idA and SUSY:idVecB SUSY:idVecA may be combined with either of SUSY:idVecB SUSY:idB and SUSY:idVecB SUSY:idVecB. As above one of the two outgoing SUSY particles must match one of the particles in SUSY:idVecB SUSY:id(Vec)A and the other one of the particles in SUSY:idVecB SUSY:id(Vec)B when both are nonzero. Character-string input of this vector  should be as a comma-separated list, without any blanks."},{"name":"SUSY:qg2chi+-squark","link":"SUSYProcesses.html#anchor19","text":"SUSY:qg2chi+-squark Associated chargino-squark production from quark-gluon initial states. annihilation. The cross section expressions follow SUSY:qg2chi+-squark Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:qg2chi0squark","link":"SUSYProcesses.html#anchor18","text":"SUSY:qg2chi0squark Pair production of neutralinos from quark-gluon initial states. The cross section expressions follow SUSY:qg2chi0squark Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:qg2squarkgluino","link":"SUSYProcesses.html#anchor9","text":"SUSY:qg2squarkgluino Associated production of a squark with a gluino. The cross section expression follows SUSY:qg2squarkgluino Fuk11 and include the possibility of non-minimal flavour violation through misalignment of quarks with squarks. Only the MFV case has been explicitly validated."},{"name":"SUSY:qq2antisquark","link":"SUSYProcesses.html#anchor23","text":"SUSY:qq2antisquark Resonant squark production via R-parity violating UDD couplings. The couplings must be input using the SLHA2 structure."},{"name":"SUSY:qq2squarksquark","link":"SUSYProcesses.html#anchor13","text":"SUSY:qq2squarksquark Pair production of scalar quarks (squark-squark and its charge conjugate process; for squark-antisquark production see above) by SUSY:qq2squarksquark t - and SUSY:qq2squarksquark u -channel gluino, neutralino, and chargino exchange. The cross section expressions follow SUSY:qq2squarksquark Boz07. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: PYTHIA 6 only included the gluino exchange contribution, which typically dominates due to the size of the strong coupling; for counterchecks, the flag SUSY:qq2squarksquark SUSY:qq2squarksquark:onlyQCD below can be switched on to eliminate the chargino and neutralino contributions.)"},{"name":"SUSY:qq2squarksquark:onlyQCD","link":"SUSYProcesses.html#anchor14","text":"SUSY:qq2squarksquark:onlyQCD When switched SUSY:qq2squarksquark:onlyQCD on this flag causes the SUSY:qq2squarksquark:onlyQCD t - or SUSY:qq2squarksquark:onlyQCD u -channel neutralino and chargino contributions to be ignored in the calculation of squark pair production cross sections. Intended for reference only. For the most accurate physics simulation, leave this flag in the SUSY:qq2squarksquark:onlyQCD off position."},{"name":"SUSY:qqbar2chi+-chi0","link":"SUSYProcesses.html#anchor16","text":"SUSY:qqbar2chi+-chi0 Associated chargino-neutralino production by quark-antiquark annihilation. With four neutralino species, two chargino ones, and maintaining charge conjugate processes separate, this gives 16 separate processes, codes 1221 - 1236. The cross section expressions follow SUSY:qqbar2chi+-chi0 Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:qqbar2chi+-gluino","link":"SUSYProcesses.html#anchor21","text":"SUSY:qqbar2chi+-gluino Associated chargino-gluino production by quark-antiquark annihilation. The cross section expressions follow SUSY:qqbar2chi+-gluino Fuk11. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: small differences between this implementation and PYTHIA 6 arise due to slightly different treatments of the weak mixing angle, which is fixed in PYTHIA 6, while it is computed from the SLHA input in PYTHIA 8; see SUSY:qqbar2chi+-gluino SUSY:sin2thetaWMode above.)"},{"name":"SUSY:qqbar2chi+chi-","link":"SUSYProcesses.html#anchor17","text":"SUSY:qqbar2chi+chi- Pair production of charginos by quark-antiquark annihilation. With two chargino species and maintaining mutually charge conjugate processes separate, this gives four separate processes, codes 1241 - 1244. The cross section expressions follow SUSY:qqbar2chi+chi- Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:qqbar2chi0chi0","link":"SUSYProcesses.html#anchor15","text":"SUSY:qqbar2chi0chi0 Pair production of neutralinos by quark-antiquark annihilation. With four neutralino species this gives ten separate processes, codes 1201 - 1210. The cross section expressions follow SUSY:qqbar2chi0chi0 Boz07. Only the MFV case has been explicitly validated."},{"name":"SUSY:qqbar2chi0gluino","link":"SUSYProcesses.html#anchor20","text":"SUSY:qqbar2chi0gluino Associated neutralino-gluino production by quark-antiquark annihilation. The cross section expressions follow SUSY:qqbar2chi0gluino Fuk11. Only the MFV case has been explicitly validated."},{"name":"SUSY:qqbar2gluinogluino","link":"SUSYProcesses.html#anchor8","text":"SUSY:qqbar2gluinogluino Pair production of gluinos by quark-antiquark annihilation and SUSY:qqbar2gluinogluino t -channel squark exchange.  The cross section expression follows SUSY:qqbar2gluinogluino Fuk11 and include the possibility of non-minimal flavour violation through misalignment of quarks with squarks. Only the MFV case has been explicitly validated."},{"name":"SUSY:qqbar2sleptonantislepton","link":"SUSYProcesses.html#anchor22","text":"SUSY:qqbar2sleptonantislepton Pair production of slepton-antislepton via s-channel W, Z and gamma exchange.  Includes both charged sleptons and sneutrinos but right handed sneutrinos currently not supported."},{"name":"SUSY:qqbar2squarkantisquark","link":"SUSYProcesses.html#anchor11","text":"SUSY:qqbar2squarkantisquark Pair production of a scalar quark together with a scalar antiquark by quark-antiquark annihilation. For same-isospin SUSY:qqbar2squarkantisquark ~q~q* production (i.e., SUSY:qqbar2squarkantisquark ~u~u* , SUSY:qqbar2squarkantisquark ~u~c* , ...), the SUSY:qqbar2squarkantisquark s -channel gluon, photon, and SUSY:qqbar2squarkantisquark Z and SUSY:qqbar2squarkantisquark t -channel gluino contributions have so far been implemented (i.e., the SUSY:qqbar2squarkantisquark t -channel neutralino contributions are neglected). For opposite-isospin SUSY:qqbar2squarkantisquark ~q~q* production ( SUSY:qqbar2squarkantisquark ~u~d* , SUSY:qqbar2squarkantisquark ~u~s* , ...), the SUSY:qqbar2squarkantisquark s -channel SUSY:qqbar2squarkantisquark W and SUSY:qqbar2squarkantisquark t -channel gluino contributions have been implemented (i.e., the SUSY:qqbar2squarkantisquark t -channel neutralino contributions are neglected). The cross section expressions follow SUSY:qqbar2squarkantisquark Boz07. Only the MFV case has been explicitly validated. (Note to PYTHIA 6 users: in older PYTHIA 6 versions, a bug caused the SUSY:qqbar2squarkantisquark ~t1~t2* cross to be overcounted by a factor of 2. Starting from version 6.4.24, that generator now agrees with the implementation here.)"},{"name":"SUSY:qqbar2squarkantisquark:onlyQCD","link":"SUSYProcesses.html#anchor12","text":"SUSY:qqbar2squarkantisquark:onlyQCD When switched SUSY:qqbar2squarkantisquark:onlyQCD on this flag switches off all but the SUSY:qqbar2squarkantisquark:onlyQCD s -channel gluon contribution in the calculation of same-isospin squark-antisquark production cross sections. Intended for reference only. For the most accurate physics simulation, leave this flag in the SUSY:qqbar2squarkantisquark:onlyQCD off position."},{"name":"SUSY:sin2thetaWMode","link":"SUSYProcesses.html#anchor6","text":"SUSY:sin2thetaWMode The value of SUSY:sin2thetaWMode sin2(thetaW) should be taken from SUSY:sin2thetaWMode SM value, defined at SUSY:sin2thetaWMode M_Z , taken from PYTHIA's SUSY:sin2thetaWMode StandardModel:sin2thetaW parameter. SUSY:sin2thetaWMode SUSY value, defined at SUSY:sin2thetaWMode M_SUSY , derived from the running gauge couplings in SUSY:sin2thetaWMode BLOCK GAUGE in the SLHA file. Note: if no such block is present in the input file, this option will default back to option 1 above, i.e., the SM value. SUSY:sin2thetaWMode Pole value, defined by SUSY:sin2thetaWMode 1 - M_W^2/M_Z^2 , using the pole masses stored in the SLHA SUSY:sin2thetaWMode BLOCK MASS , or, alternatively, PYTHIA's internal pole masses if no such block is present."},{"name":"SUSYResonance:3BodyMatrixElement","link":"SUSYProcesses.html#anchor25","text":"SUSYResonance:3BodyMatrixElement When 'on', the spin-averaged, squared matrix element is used to sample the phase space for resonance decay.  Currently, only possible for a heavy neutralino decay to a light neutralino and a fermion-antifermion pair."},{"name":"TauDecays:externalMode","link":"ParticleDecays.html#anchor13","text":"TauDecays:externalMode Choice of the external polarization and correlation mechanism for correlated TauDecays:externalMode tau pairs. TauDecays:externalMode all correlated pairs are treated as single uncorrelated TauDecays:externalMode tau leptons. Their polarization is still set via SPINUP. TauDecays:externalMode the mother of the TauDecays:externalMode tau pair is found. If the mother is from the list of available internal correlated processes, a correlated decay is performed. If the SPINUP for the mother is valid, this is used to set the mother polarization, otherwise the mother is assumed to be unpolarized. TauDecays:externalMode nothing is done. TauDecays:externalMode Note : option TauDecays:externalMode 1 has limited functionality as SPINUP is intended primarily for particles with 2 spin states. For massive vector bosons SPINUP is interpreted here as the transverse polarization and so the diagonal for the vector boson helicity density matrix is set as TauDecays:externalMode [(1 - SPINUP)/3, 1/3, (1 + SPINUP)/3]."},{"name":"TauDecays:mode","link":"ParticleDecays.html#anchor14","text":"TauDecays:mode Choice of TauDecays:mode tau decay model. TauDecays:mode old decay model, with isotropic decays. TauDecays:mode sophisticated decays where external and then internal determination is applied. TauDecays:mode sophisticated decays as above, but now TauDecays:mode tau s with a mother TauDecays:mode TauDecays:tauMother are forced into an uncorrelated decay with a polarization set by TauDecays:mode TauDecays:tauPolarization. TauDecays:mode sophisticated decays where all TauDecays:mode tau s, regardless of mother, are forced into an uncorrelated decay with a polarization set by TauDecays:mode TauDecays:tauPolarization. TauDecays:mode sophisticated decays where only internal determination is applied. TauDecays:mode sophisticated decays where only external (SPINUP) determination is applied. TauDecays:mode Warning 1 : options TauDecays:mode 2 and TauDecays:mode 3 , to force a specific TauDecays:mode tau polarization, only affect the decay of the TauDecays:mode tau. The angular distribution of the TauDecays:mode tau itself, given by its production, is not modified by these options. If you want, e.g., a righthanded TauDecays:mode W , or a SUSY decay chain, the kinematics should be handled by the corresponding cross section class(es), supplemented by the resonance decay one(s). The options here could then still be used to ensure the correct polarization at the TauDecays:mode tau decay stage. TauDecays:mode Warning 2 : for options TauDecays:mode 1 through TauDecays:mode 5 , if the polarization and correlation mechanism for the TauDecays:mode tau cannot be determined (internally or externally) then the default behaviour described above is applied."},{"name":"TauDecays:tauMother","link":"ParticleDecays.html#anchor16","text":"TauDecays:tauMother Mother of the TauDecays:tauMother tau for forced polarization when mode TauDecays:tauMother 2 of TauDecays:tauMother TauDecays:mode is selected. You should give the positive identity code; to the extent an antiparticle exists it will automatically obtain the inverse polarization."},{"name":"TauDecays:tauPolarization","link":"ParticleDecays.html#anchor15","text":"TauDecays:tauPolarization Polarization of the TauDecays:tauPolarization tau when mode TauDecays:tauPolarization 2 or TauDecays:tauPolarization 3 of TauDecays:tauPolarization TauDecays:mode is selected."},{"name":"TimeShower:allowBeamRecoil","link":"TimelikeShowers.html#anchor17","text":"TimeShower:allowBeamRecoil If on, the final-state shower is allowed to borrow energy from the beam remnants as described above, thereby changing the mass of the scattering subsystem. If off, the partons in the scattering subsystem are constrained to borrow energy from each other, such that the total four-momentum of the system is preserved. This flag has no effect on resonance decays, where the shower always preserves the resonance mass, cf. the comment above about showers for resonances never being interleaved."},{"name":"TimeShower:allowMPIdipole","link":"TimelikeShowers.html#anchor19","text":"TimeShower:allowMPIdipole If on, and if interleaving is off, then dipoles are allowed to be formed between matching final-state colour-anticolour pairs also between two different MPIs. Else dipoles can normally only form inside the same MPI, and the could-have-been dipoles between different MPIs instead appear as dipoles stretched to the beam remnants. In either case a dipole can still form between two MPIs if a final-state colour cannot be matched inside the same MPI. This should normally not happen, except if rescattering is allowed, whereby two or more MPIs get interconnected."},{"name":"TimeShower:alphaEMorder","link":"TimelikeShowers.html#anchor9","text":"TimeShower:alphaEMorder The running of TimeShower:alphaEMorder alpha_em. TimeShower:alphaEMorder first-order running, constrained to agree with TimeShower:alphaEMorder StandardModel:alphaEMmZ at the TimeShower:alphaEMorder Z^0 mass. TimeShower:alphaEMorder zeroth order, i.e. TimeShower:alphaEMorder alpha_em is kept fixed at its value at vanishing momentum transfer. TimeShower:alphaEMorder zeroth order, i.e. TimeShower:alphaEMorder alpha_em is kept fixed, but at TimeShower:alphaEMorder StandardModel:alphaEMmZ , i.e. its value at the TimeShower:alphaEMorder Z^0 mass."},{"name":"TimeShower:alphaSorder","link":"TimelikeShowers.html#anchor7","text":"TimeShower:alphaSorder Order at which TimeShower:alphaSorder alpha_strong runs, TimeShower:alphaSorder zeroth order, i.e. TimeShower:alphaSorder alpha_strong is kept fixed. TimeShower:alphaSorder first order, which is the normal value. TimeShower:alphaSorder second order. Since other parts of the code do not go to second order there is no strong reason to use this option, but there is also nothing wrong with it."},{"name":"TimeShower:alphaSuseCMW","link":"TimelikeShowers.html#anchor8","text":"TimeShower:alphaSuseCMW TimeShower:alphaSuseCMW Do not apply the CMW rescaling. TimeShower:alphaSuseCMW Apply the CMW rescaling, increasing TimeShower:alphaSuseCMW Lambda_QCD for timelike showers by a factor roughly 1.6."},{"name":"TimeShower:alphaSvalue","link":"TimelikeShowers.html#anchor6","text":"TimeShower:alphaSvalue The TimeShower:alphaSvalue alpha_strong value at scale TimeShower:alphaSvalue M_Z^2. The default value corresponds to a crude tuning to LEP data, to be improved."},{"name":"TimeShower:dampenBeamRecoil","link":"TimelikeShowers.html#anchor18","text":"TimeShower:dampenBeamRecoil When beam recoil is allowed there is still some ambiguity how far into the beam end of the dipole that emission should be allowed. It is dampened in the beam region, but probably not enough. When on an additional suppression factor TimeShower:dampenBeamRecoil 4 pT2_hard / (4 pT2_hard + m2) is multiplied on to the emission probability. Here TimeShower:dampenBeamRecoil pT_hard is the transverse momentum of the radiating parton and TimeShower:dampenBeamRecoil m the off-shell mass it acquires by the branching, TimeShower:dampenBeamRecoil m2 = pT2/(z(1-z)). Note that TimeShower:dampenBeamRecoil m2 = 4 pT2_hard is the kinematical limit for a scattering at 90 degrees without beam recoil."},{"name":"TimeShower:factorMultFac","link":"TimelikeShowers.html#anchor11","text":"TimeShower:factorMultFac The default TimeShower:factorMultFac pT^2 factorization scale is multiplied by this prefactor."},{"name":"TimeShower:fixedFacScale","link":"TimelikeShowers.html#anchor49","text":"TimeShower:fixedFacScale The fixed factorization scale, in GeV, that would be used in the evaluation of parton densities if the TimeShower:fixedFacScale flag above is on."},{"name":"TimeShower:globalRecoil","link":"TimelikeShowers.html#anchor20","text":"TimeShower:globalRecoil Alternative approach as above, where all final-state particles share the recoil of an emission. TimeShower:globalRecoil If off, then use the standard dipole-recoil approach. TimeShower:globalRecoil If on, use the alternative global recoil, but only for the first interaction, and only while the number of particles in the final state is at most TimeShower:globalRecoil TimeShower:nMaxGlobalRecoil before the branching."},{"name":"TimeShower:globalRecoilMode","link":"TimelikeShowers.html#anchor22","text":"TimeShower:globalRecoilMode Choice which splittings are produced with the global recoil approach. TimeShower:globalRecoilMode Global recoil mode as outlined above, i.e. using global recoils until the number of final state particles exceeds TimeShower:globalRecoilMode TimeShower:nMaxGlobalRecoil. TimeShower:globalRecoilMode Global recoil only for the first branching of final state legs that have an ancestor in the hard process, and if the maximal number of branchings generated according to the global recoil scheme (see TimeShower:globalRecoilMode TimeShower:nMaxGlobalBranch below) has not yet been reached. TimeShower:globalRecoilMode Global recoil only if the first branching in the whole evolution is a timelike splitting of a parton in an event with Born-like kinematics (i.e.\ an S-event). The impact of global recoils should be minimal in this case. This option is only sensible for interleaved evolution."},{"name":"TimeShower:interleave","link":"TimelikeShowers.html#anchor16","text":"TimeShower:interleave If on, final-state emissions are interleaved in the same decreasing- TimeShower:interleave pT chain as multiparton interactions and initial-state emissions. If off, final-state emissions are only addressed after the multiparton interactions and initial-state radiation have been considered."},{"name":"TimeShower:limitPTmaxGlobal","link":"TimelikeShowers.html#anchor25","text":"TimeShower:limitPTmaxGlobal If on, limit the maximal pT produced in branchings in the global recoil scheme exactly as in the default (local) scheme. This means that the mass of the splitting dipole will set an upper bound for the pT of an emission. To be more explicit, this disallows emissions with pT larger than TimeShower:limitPTmaxGlobal min{&mu; TimeShower:limitPTmaxGlobal start TimeShower:limitPTmaxGlobal 2 , m TimeShower:limitPTmaxGlobal D TimeShower:limitPTmaxGlobal 2 /4} , with TimeShower:limitPTmaxGlobal m TimeShower:limitPTmaxGlobal D TimeShower:limitPTmaxGlobal 2 = (&radic; TimeShower:limitPTmaxGlobal &nbsp;(p TimeShower:limitPTmaxGlobal r +p TimeShower:limitPTmaxGlobal s ) TimeShower:limitPTmaxGlobal 2 &nbsp; -m TimeShower:limitPTmaxGlobal 0,s ) TimeShower:limitPTmaxGlobal 2 - m TimeShower:limitPTmaxGlobal 0,r TimeShower:limitPTmaxGlobal 2 , where the shower starting scale is TimeShower:limitPTmaxGlobal &mu; TimeShower:limitPTmaxGlobal start (i.e. SCALUP when reading LHE files, and TimeShower:limitPTmaxGlobal Info.QFac() otherwise), TimeShower:limitPTmaxGlobal r the radiating parton, and TimeShower:limitPTmaxGlobal s the recoiling particle that would have been used in the local recoil scheme. This option is only used if wimpy showers are enabled."},{"name":"TimeShower:MEafterFirst","link":"TimelikeShowers.html#anchor44","text":"TimeShower:MEafterFirst Use of matrix element corrections also after the first emission, for dipole ends of the same system that did not yet radiate. Only has a meaning if TimeShower:MEafterFirst MEcorrections above is switched on. Switching off this option currently does not take effect for a few rare types of secondary branchings, where ME corrections play a central role."},{"name":"TimeShower:MEcorrections","link":"TimelikeShowers.html#anchor42","text":"TimeShower:MEcorrections Use of matrix element corrections where available; on/off = true/false."},{"name":"TimeShower:MEextended","link":"TimelikeShowers.html#anchor43","text":"TimeShower:MEextended Use matrix element corrections also for TimeShower:MEextended 1 &rarr; n and TimeShower:MEextended 2 &rarr; n processes where no matrix elements are encoded, by an attempt to match on to one of the TimeShower:MEextended 1 &rarr; 2 processes that are implemented. This should at least provide relevant mass dampening for massive radiators and recoilers. Only has a meaning if TimeShower:MEextended MEcorrections above is switched on."},{"name":"TimeShower:mMaxGamma","link":"TimelikeShowers.html#anchor15","text":"TimeShower:mMaxGamma Maximum invariant mass allowed for the created fermion pair in a TimeShower:mMaxGamma gamma &rarr; f fbar branching in the shower."},{"name":"TimeShower:nGammaToLepton","link":"TimelikeShowers.html#anchor41","text":"TimeShower:nGammaToLepton Number of allowed lepton flavours in TimeShower:nGammaToLepton gamma &rarr; l+ l- branchings (phase space permitting). A change to 2 would exclude TimeShower:nGammaToLepton gamma &rarr; tau+ tau- , and a change to 1 also TimeShower:nGammaToLepton gamma &rarr; mu+ mu-."},{"name":"TimeShower:nGammaToQuark","link":"TimelikeShowers.html#anchor40","text":"TimeShower:nGammaToQuark Number of allowed quark flavours in TimeShower:nGammaToQuark gamma &rarr; q qbar branchings (phase space permitting). A change to 4 would exclude TimeShower:nGammaToQuark g &rarr; b bbar , etc."},{"name":"TimeShower:nGluonToQuark","link":"TimelikeShowers.html#anchor32","text":"TimeShower:nGluonToQuark Number of allowed quark flavours in TimeShower:nGluonToQuark g &rarr; q qbar branchings (phase space permitting). A change to 4 would exclude TimeShower:nGluonToQuark g &rarr; b bbar , etc."},{"name":"TimeShower:nMaxGlobalBranch","link":"TimelikeShowers.html#anchor23","text":"TimeShower:nMaxGlobalBranch The maximum number of splittings in the final state for which the next final-state emission can be performed with the global recoil strategy. This number has to be set if TimeShower:nMaxGlobalBranch TimeShower:globalRecoilMode = 1 or TimeShower:nMaxGlobalBranch TimeShower:globalRecoilMode = 2"},{"name":"TimeShower:nMaxGlobalRecoil","link":"TimelikeShowers.html#anchor21","text":"TimeShower:nMaxGlobalRecoil Represents the maximum number of particles in the final state for which the next final-state emission can be performed with the global recoil strategy. This number counts all particles, whether they are allowed to radiate or not, e.g. also TimeShower:nMaxGlobalRecoil Z^0. Also partons created by initial-state radiation emissions counts towards this sum, as part of the interleaved evolution. Without interleaved evolution this option would not make sense, since then a varying and large number of partons could already have been created by the initial-state radiation before the first final-state one, and then there is not likely to be any matrix elements available for matching."},{"name":"TimeShower:nPartonsInBorn","link":"TimelikeShowers.html#anchor24","text":"TimeShower:nPartonsInBorn The number of partons for Born-like phase space points. This number needs to be set if a different treatment of S-events (with Born-like kinematics) and H-events (with real-emission kinematics) is desired. This number has to be set if TimeShower:nPartonsInBorn TimeShower:globalRecoilMode = 2."},{"name":"TimeShower:octetOniumColFac","link":"TimelikeShowers.html#anchor27","text":"TimeShower:octetOniumColFac The colour factor used used in the splitting kernel for those octet onium states that are allowed to radiate, normalized to the TimeShower:octetOniumColFac q &rarr; q g splitting kernel. Thus the default corresponds to twice the radiation off a quark. The physically preferred range would be between 1 and 9/4."},{"name":"TimeShower:octetOniumFraction","link":"TimelikeShowers.html#anchor26","text":"TimeShower:octetOniumFraction Allow colour-octet charmonium and bottomonium states to radiate gluons. 0 means that no octet-onium states radiate, 1 that all do, with possibility to interpolate between these two extremes."},{"name":"TimeShower:phiPolAsym","link":"TimelikeShowers.html#anchor45","text":"TimeShower:phiPolAsym Azimuthal asymmetry induced by gluon polarization; on/off = true/false."},{"name":"TimeShower:phiPolAsymHard","link":"TimelikeShowers.html#anchor46","text":"TimeShower:phiPolAsymHard Extend the above azimuthal asymmetry (if on) also back to gluons produced in the hard process itself, where feasible; on/off = true/false."},{"name":"TimeShower:pTdampFudge","link":"TimelikeShowers.html#anchor5","text":"TimeShower:pTdampFudge In cases 1 and 2 above, where a dampening is imposed at around the factorization or renormalization scale, respectively, this allows the TimeShower:pTdampFudge pT scale of dampening of radiation by a half to be shifted by this factor relative to the default TimeShower:pTdampFudge Q_fac or TimeShower:pTdampFudge Q_ren. This number ought to be in the neighbourhood of unity, but variations away from this value could do better in some processes."},{"name":"TimeShower:pTdampMatch","link":"TimelikeShowers.html#anchor4","text":"TimeShower:pTdampMatch These options only take effect when a process is allowed to radiate up to the kinematical limit by the above TimeShower:pTdampMatch pTmaxMatch choice, and no matrix-element corrections are available. Then, in many processes, the fall-off in TimeShower:pTdampMatch pT will be too slow by one factor of TimeShower:pTdampMatch pT^2. That is, while showers have an approximate TimeShower:pTdampMatch dpT^2/pT^2 shape, often it should become more like TimeShower:pTdampMatch dpT^2/pT^4 at TimeShower:pTdampMatch pT values above the scale of the hard process. This argument is more obvious and relevant for ISR, where emissions could go the the kinematical limit, whereas they are constrained by the respective dipole mass for FSR. Nevertheless this matching option is offered for FSR to have a (semi-)symmetric description. Note that a dampening factor is applied to all dipoles in the final state of the hard process, which is somewhat different from the ISR implementation. TimeShower:pTdampMatch emissions go up to the kinematical limit, with no special dampening. TimeShower:pTdampMatch emissions go up to the kinematical limit, but dampened by a factor TimeShower:pTdampMatch k^2 Q^2_fac/(pT^2 + k^2 Q^2_fac) , where TimeShower:pTdampMatch Q_fac is the factorization scale and TimeShower:pTdampMatch k is a multiplicative fudge factor stored in TimeShower:pTdampMatch pTdampFudge below. TimeShower:pTdampMatch emissions go up to the kinematical limit, but dampened by a factor TimeShower:pTdampMatch k^2 Q^2_ren/(pT^2 + k^2 Q^2_ren) , where TimeShower:pTdampMatch Q_ren is the renormalization scale and TimeShower:pTdampMatch k is a multiplicative fudge factor stored in TimeShower:pTdampMatch pTdampFudge below. TimeShower:pTdampMatch as option 1, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include TimeShower:pTdampMatch t tbar and TimeShower:pTdampMatch squark gluino production. TimeShower:pTdampMatch as option 2, but in addition to the standard requirements for dampening it is further necessary to have ar least two top or beyond-the-Standard-Model coloured particles in the final state. Examples include TimeShower:pTdampMatch t tbar and TimeShower:pTdampMatch squark gluino production. TimeShower:pTdampMatch Note: These options only apply to the hard interaction. Specifically, a 'second hard' interaction would not be affected. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of the process itself."},{"name":"TimeShower:pTmaxFudge","link":"TimelikeShowers.html#anchor2","text":"TimeShower:pTmaxFudge In cases where the above TimeShower:pTmaxFudge pTmaxMatch rules would imply that TimeShower:pTmaxFudge pT_max = pT_factorization , TimeShower:pTmaxFudge pTmaxFudge introduces a multiplicative factor TimeShower:pTmaxFudge f such that instead TimeShower:pTmaxFudge pT_max = f * pT_factorization. Only applies to the hardest interaction in an event, and a 'second hard' if there is such a one, cf. below. It is strongly suggested that TimeShower:pTmaxFudge f = 1 , but variations around this default can be useful to test this assumption. TimeShower:pTmaxFudge Note: Scales for resonance decays are not affected, but can be set separately by TimeShower:pTmaxFudge user hooks."},{"name":"TimeShower:pTmaxFudgeMPI","link":"TimelikeShowers.html#anchor3","text":"TimeShower:pTmaxFudgeMPI A multiplicative factor TimeShower:pTmaxFudgeMPI f such that TimeShower:pTmaxFudgeMPI pT_max = f * pT_factorization , as above, but here for the non-hardest interactions (when multiparton interactions are allowed)."},{"name":"TimeShower:pTmaxMatch","link":"TimelikeShowers.html#anchor1","text":"TimeShower:pTmaxMatch Way in which the maximum shower evolution scale is set to match the scale of the hard process itself. TimeShower:pTmaxMatch TimeShower:pTmaxMatch (i) if the final state of the hard process (not counting subsequent resonance decays) contains at least one quark ( TimeShower:pTmaxMatch u, d, s, c ,b ), gluon or photon then TimeShower:pTmaxMatch pT_max is chosen to be the factorization scale for internal processes and the TimeShower:pTmaxMatch scale value for Les Houches input; TimeShower:pTmaxMatch (ii) if not, emissions are allowed to go all the way up to the kinematical limit (i.e. to half the dipole mass). This option agrees with the corresponding one for TimeShower:pTmaxMatch spacelike showers. There the reasoning is that in the former set of processes the ISR emission of yet another quark, gluon or photon could lead to double-counting, while no such danger exists in the latter case. The argument is less compelling for timelike showers, but could be a reasonable starting point. TimeShower:pTmaxMatch always use the factorization scale for an internal process and the TimeShower:pTmaxMatch scale value for Les Houches input, i.e. the lower value. This should avoid double-counting, but may leave out some emissions that ought to have been simulated. (Also known as wimpy showers.) TimeShower:pTmaxMatch always allow emissions up to the kinematical limit (i.e. to half the dipole mass). This will simulate all possible event topologies, but may lead to double-counting. (Also known as power showers.) TimeShower:pTmaxMatch Note 1: as enumerated in the text, these options take effect both for internal and external processes. Whether a particular option makes sense depends on the context. For instance, if events for the same basic process to different orders are to be matched, then option 1 would be a reasonable first guess. But in more sophisticated descriptions option 2 could be combined with TimeShower:pTmaxMatch UserHooks vetoes on emissions that would lead to double-counting, using more flexible phase space boundaries. Further details are found in the TimeShower:pTmaxMatch Matching and Merging description, with an example in TimeShower:pTmaxMatch examples/main31. Option 0, finally, may be most realistic when only Born-level processes are involved, possibly in combination with a nonzero TimeShower:pTmaxMatch TimeShower:pTdampMatch. TimeShower:pTmaxMatch Note 2: These options only apply to the hard interaction. If a 'second hard' process is present, the two are analyzed and set separately for the default 0 option, while both are affected the same way for non-default options 1 and 2. Emissions off subsequent multiparton interactions are always constrained to be below the factorization scale of each process itself. The options also assume that you use interleaved evolution, so that FSR is in direct competition with ISR for the hardest emission. If you already generated a number of ISR partons at low TimeShower:pTmaxMatch pT , it would not make sense to have a later FSR shower up to the kinematical limit for all of them. TimeShower:pTmaxMatch Note 3: Recall that resonance decays are not affected by this mode, but that showers there are always set to fill the full phase space, often with built-in matrix-element-matching that give a NLO accuracy. A modification of this behaviour would require you to work with TimeShower:pTmaxMatch UserHooks. However, for Les Houches input the optional TimeShower:pTmaxMatch TimeShower:pTmaxMatch Beams:strictLHEFscale = on setting restricts all emissions, also in resonance decays, to be below the input TimeShower:pTmaxMatch scale value."},{"name":"TimeShower:pTmin","link":"TimelikeShowers.html#anchor12","text":"TimeShower:pTmin Parton shower cut-off TimeShower:pTmin pT for QCD emissions."},{"name":"TimeShower:pTminChgL","link":"TimelikeShowers.html#anchor14","text":"TimeShower:pTminChgL Parton shower cut-off TimeShower:pTminChgL pT for pure QED branchings. Assumed smaller than (or equal to) TimeShower:pTminChgL pTminChgQ."},{"name":"TimeShower:pTminChgQ","link":"TimelikeShowers.html#anchor13","text":"TimeShower:pTminChgQ Parton shower cut-off TimeShower:pTminChgQ pT for photon coupling to coloured particle."},{"name":"TimeShower:pTminWeak","link":"TimelikeShowers.html#anchor30","text":"TimeShower:pTminWeak Parton shower cut-off TimeShower:pTminWeak pT for weak branchings."},{"name":"TimeShower:QCDshower","link":"TimelikeShowers.html#anchor31","text":"TimeShower:QCDshower Allow a QCD shower, i.e. branchings TimeShower:QCDshower q &rarr; q g , TimeShower:QCDshower g &rarr; g g and TimeShower:QCDshower g &rarr; q qbar ; on/off = true/false."},{"name":"TimeShower:QEDshowerByGamma","link":"TimelikeShowers.html#anchor39","text":"TimeShower:QEDshowerByGamma Allow photons to branch into lepton or quark pairs, i.e. branchings TimeShower:QEDshowerByGamma gamma &rarr; l+ l- and TimeShower:QEDshowerByGamma gamma &rarr; q qbar ; on/off = true/false."},{"name":"TimeShower:QEDshowerByL","link":"TimelikeShowers.html#anchor37","text":"TimeShower:QEDshowerByL Allow leptons to radiate photons, i.e. branchings TimeShower:QEDshowerByL l &rarr; l gamma ; on/off = true/false."},{"name":"TimeShower:QEDshowerByOther","link":"TimelikeShowers.html#anchor38","text":"TimeShower:QEDshowerByOther Allow charged resonances to radiate photons, i.e. branchings TimeShower:QEDshowerByOther q&sim; &rarr; q&sim; gamma ; on/off = true/false. This will also allow the W boson to radiate."},{"name":"TimeShower:QEDshowerByQ","link":"TimelikeShowers.html#anchor36","text":"TimeShower:QEDshowerByQ Allow quarks to radiate photons, i.e. branchings TimeShower:QEDshowerByQ q &rarr; q gamma ; on/off = true/false."},{"name":"TimeShower:recoilDeadCone","link":"TimelikeShowers.html#anchor35","text":"TimeShower:recoilDeadCone For topologies where a gluon recoils against a massive quark (or another massive coloured particle) there are no suitable ME corrections implemented into PYTHIA. When the dipole radiation pattern is split into two ends, with a smooth transition between the two, this means that the  gluon end can radiate into the quark hemisphere as if the quark were massless. The 'dead cone' effect, that radiation collinear with a massive quark is strongly suppressed, thereby is not fully respected. (Unlike  radiation from the quark end itself, where mass effects are included.) With this switch on, a further suppression is therefore introduced for TimeShower:recoilDeadCone g &rarr; g g branchings, derived as the massive/massless ratio of the eikonal expression for dipole radiation, which kills radiation collinear with the quark. The TimeShower:recoilDeadCone g &rarr; q qbar branchings currently are not affected; the absence of a soft singularity implies that there is hardly any radiation into the recoiler hemisphere anyway."},{"name":"TimeShower:recoilToColoured","link":"TimelikeShowers.html#anchor47","text":"TimeShower:recoilToColoured In the decays of coloured resonances, say TimeShower:recoilToColoured t &rarr; b W , it is not possible to set up dipoles with matched colours. Originally the TimeShower:recoilToColoured b radiator therefore has TimeShower:recoilToColoured W as recoiler, and that choice is unique. Once a gluon has been radiated, however, it is possible either to have the unmatched colour (inherited by the gluon) still recoiling against the TimeShower:recoilToColoured W ( TimeShower:recoilToColoured off ), or else let it recoil against the TimeShower:recoilToColoured b also for this dipole ( TimeShower:recoilToColoured on ). Before version 8.160 the former was the only possibility, which could give unphysical radiation patterns. It is kept as an option to check backwards compatibility. The same issue exists for QED radiation, but obviously is less significant. Consider the example TimeShower:recoilToColoured W &rarr; e nu , where originally the TimeShower:recoilToColoured nu takes the recoil. In the old ( TimeShower:recoilToColoured off ) scheme the TimeShower:recoilToColoured nu would remain recoiler, while in the new ( TimeShower:recoilToColoured on ) instead each newly emitted photon becomes the new recoiler."},{"name":"TimeShower:renormMultFac","link":"TimelikeShowers.html#anchor10","text":"TimeShower:renormMultFac The default TimeShower:renormMultFac pT^2 renormalization scale is multiplied by this prefactor. For QCD this is equivalent to a change of TimeShower:renormMultFac Lambda^2 in the opposite direction, i.e. to a change of TimeShower:renormMultFac alpha_strong(M_Z^2) (except that flavour thresholds remain at fixed scales)."},{"name":"TimeShower:scaleGluonToQuark","link":"TimelikeShowers.html#anchor34","text":"TimeShower:scaleGluonToQuark Extra scale parameter TimeShower:scaleGluonToQuark k for TimeShower:scaleGluonToQuark TimeShower:weightGluonToQuark options 5 - 8. Comes on top of TimeShower:scaleGluonToQuark TimeShower:renormMultFac , which affects TimeShower:scaleGluonToQuark alpha_s(pT^2) alike."},{"name":"TimeShower:useFixedFacScale","link":"TimelikeShowers.html#anchor48","text":"TimeShower:useFixedFacScale Allow the possibility to use a fixed factorization scale, set by the TimeShower:useFixedFacScale parm below. This option is unphysical and only intended for toy-model and debug studies."},{"name":"TimeShower:weakShower","link":"TimelikeShowers.html#anchor28","text":"TimeShower:weakShower Allow a weak shower, yes or no."},{"name":"TimeShower:weakShowerMode","link":"TimelikeShowers.html#anchor29","text":"TimeShower:weakShowerMode Determine which branchings are allowed. TimeShower:weakShowerMode both TimeShower:weakShowerMode W^+- and TimeShower:weakShowerMode Z^0 branchings. TimeShower:weakShowerMode only TimeShower:weakShowerMode W^+- branchings. TimeShower:weakShowerMode only TimeShower:weakShowerMode Z^0 branchings."},{"name":"TimeShower:weightGluonToQuark","link":"TimelikeShowers.html#anchor33","text":"TimeShower:weightGluonToQuark Different options to assign kinematics distributions and weights for TimeShower:weightGluonToQuark g &rarr; q qbar branchings, notably for charm and bottom quarks. These options also have the corresponding effect on TimeShower:weightGluonToQuark gamma &rarr; f fbar branchings. The rationale for the options is described in TimeShower:weightGluonToQuark this note. TimeShower:weightGluonToQuark Notation: TimeShower:weightGluonToQuark r_q = m_q^2/m_qq^2 , TimeShower:weightGluonToQuark beta = sqrt(1 - 4r_q) , with TimeShower:weightGluonToQuark m_q the quark mass and TimeShower:weightGluonToQuark m_qq the TimeShower:weightGluonToQuark q qbar pair invariant mass. The scale factor TimeShower:weightGluonToQuark k is described below, TimeShower:weightGluonToQuark TimeShower:scaleGluonToQuark. TimeShower:weightGluonToQuark same splitting kernel TimeShower:weightGluonToQuark (1/2) (z^2 + (1-z)^2) for massive as massless quarks, only with an extra TimeShower:weightGluonToQuark beta phase space factor. TimeShower:weightGluonToQuark a splitting kernel TimeShower:weightGluonToQuark (beta/2) (z^2 + (1-z)^2 + 8r_q z(1-z)). TimeShower:weightGluonToQuark a splitting kernel TimeShower:weightGluonToQuark z^2 + (1-z)^2 + 8r_q z(1-z) , normalized so that the TimeShower:weightGluonToQuark z -integrated rate is TimeShower:weightGluonToQuark (beta/3) (1 + r/2). TimeShower:weightGluonToQuark same as 3, but additionally a suppression factor TimeShower:weightGluonToQuark (1 - m_qq^2/m_dipole^2)^3 , which reduces the rate of high-mass TimeShower:weightGluonToQuark q qbar pairs. TimeShower:weightGluonToQuark same as 1, but reweighted to an TimeShower:weightGluonToQuark alpha_s(k m_qq^2) rather than the normal TimeShower:weightGluonToQuark alpha_s(pT^2). TimeShower:weightGluonToQuark same as 2, but reweighted to an TimeShower:weightGluonToQuark alpha_s(k m_qq^2) rather than the normal TimeShower:weightGluonToQuark alpha_s(pT^2). TimeShower:weightGluonToQuark same as 3, but reweighted to an TimeShower:weightGluonToQuark alpha_s(k m_qq^2) rather than the normal TimeShower:weightGluonToQuark alpha_s(pT^2). TimeShower:weightGluonToQuark same as 4, but reweighted to an TimeShower:weightGluonToQuark alpha_s(k m_qq^2) rather than the normal TimeShower:weightGluonToQuark alpha_s(pT^2)."},{"name":"Top:all","link":"TopProcesses.html#anchor1","text":"Top:all Common switch for the group of top production."},{"name":"Top:ffbar2tqbar(s:W)","link":"TopProcesses.html#anchor6","text":"Top:ffbar2tqbar(s:W) Scatterings Top:ffbar2tqbar(s:W) f fbar' &rarr; t q'' by Top:ffbar2tqbar(s:W) s -channel exchange of a Top:ffbar2tqbar(s:W) W^+- boson. Code 605."},{"name":"Top:ffbar2ttbar(s:gmZ)","link":"TopProcesses.html#anchor5","text":"Top:ffbar2ttbar(s:gmZ) Scatterings Top:ffbar2ttbar(s:gmZ) f fbar &rarr; t tbar by Top:ffbar2ttbar(s:gmZ) s -channel exchange of a Top:ffbar2ttbar(s:gmZ) gamma^*/Z^0 boson. Code 604."},{"name":"Top:gg2ttbar","link":"TopProcesses.html#anchor2","text":"Top:gg2ttbar Scatterings Top:gg2ttbar g g &rarr; t tbar. Code 601."},{"name":"Top:ggm2ttbar","link":"TopProcesses.html#anchor8","text":"Top:ggm2ttbar Scatterings Top:ggm2ttbar g gamma &rarr; t tbar. Code 607 when Top:ggm2ttbar g gamma &rarr; t tbar and 617 when Top:ggm2ttbar gamma g &rarr; t tbar."},{"name":"Top:gmgm2ttbar","link":"TopProcesses.html#anchor7","text":"Top:gmgm2ttbar Scatterings Top:gmgm2ttbar gamma gamma &rarr; t tbar. Code 606."},{"name":"Top:qq2tq(t:W)","link":"TopProcesses.html#anchor4","text":"Top:qq2tq(t:W) Scatterings Top:qq2tq(t:W) q q' &rarr; t q'' by Top:qq2tq(t:W) t -channel exchange of a Top:qq2tq(t:W) W^+- boson. Code 603."},{"name":"Top:qqbar2ttbar","link":"TopProcesses.html#anchor3","text":"Top:qqbar2ttbar Scatterings Top:qqbar2ttbar q qbar &rarr; t tbar by gluon exchange. Code 602."},{"name":"Tune:ee","link":"Tunes.html#anchor1","text":"Tune:ee Choice of tune to Tune:ee e^+e^- data, mainly for the hadronization and timelike-showering aspects of PYTHIA. You should study the Tune:ee Settings::initTuneEE(...) method to find exactly which are the settings for the respective tune. Tune:ee reset all values that are affected by any of the Tune:ee e^+e^- tunes to the default values. This option can be used on its own, but is also automatically used as a first step for either of the positive tune values below, to undo the effect of previous tune settings. Tune:ee no values are overwritten during the initial setup, step 2 above. Note that changing to Tune:ee 0 in the user code has no effect; if you want to restore the individual settings you should instead use Tune:ee -1. Tune:ee the original PYTHIA 8 parameter set, based on some very old flavour studies (with JETSET around 1990) and a simple tune Tune:ee of alpha_strong to three-jet shapes to the new Tune:ee pT -ordered shower. These were the default values before version 8.125. Tune:ee a tune by Marc Montull to the LEP 1 particle composition, as published in the RPP (August 2007). No related (re)tune to event shapes has been performed, however. Tune:ee a tune to a wide selection of LEP1 data by Hendrik Hoeth within the Rivet + Professor framework, both to hadronization and timelike-shower parameters (June 2009). These were the default values starting from version 8.125. Tune:ee a tune to LEP data by Peter Skands, by hand, both to hadronization and timelike-shower parameters (September 2013). Note the use of the CMW convention for the shower Tune:ee alpha_s scale. Tune:ee first tune to LEP data by Nadine Fischer (September 2013), based on the default flavour-composition parameters. Input is event shapes (ALEPH and DELPHI), identified particle spectra (ALEPH), multiplicities (PDG), and B hadron fragmentation functions (ALEPH). Tune:ee second tune to LEP data by Nadine Fischer (September 2013). Similar to the first one, but event shapes are weighted up significantly, and multiplicites not included. Tune:ee the Monash 2013 tune by Peter Skands at al. Tune:ee Ska14 , to both Tune:ee e^+e^- and Tune:ee pp/pbarp data."},{"name":"Tune:pp","link":"Tunes.html#anchor3","text":"Tune:pp Choice of tune to Tune:pp pp/ppbar data, mainly for the initial-state-radiation, multiparton-interactions and  beam-remnants aspects of PYTHIA. You should study the Tune:pp Settings::initTunePP(...) method to find exactly which are the settings for the respective tune. Note that all early tunes, including those done by the LHC collaborations based on tune 4C, imply the settings of Tune:pp Tune:ee = 3 , while the Monash 2013 tune and the further tunes based on it imply Tune:pp Tune:ee = 7. This is set automatically, and has to be overridden afterwards if not the wanted behaviour. Tune:pp reset all values that are affected by any of the Tune:pp pp/ppbar tunes to the default values. This option can be used on its own, but is also automatically used as a first step for either of the positive tune values below, to undo the effect of previous tune settings. Tune:pp no values are overwritten during the initial setup, step 2 above. Note that changing to Tune:pp 0 in the user code has no effect; if you want to restore the individual settings you should instead use Tune:pp -1. Tune:pp default used up to version 8.126, based on some early and primitive comparisons with data. Tune:pp 'Tune 1', default in 8.127 - 8.139, based on some data comparisons by Peter Skands. Largely but not wholly overlaps with the default option 0. Tune:pp 'Tune 2C', introduced with 8.140 Tune:pp Cor10a. It uses the CTEQ 6L1 PDF, and is intended to give good agreement with much of the published CDF data. Tune:pp 'Tune 2M', introduced with 8.140 Tune:pp Cor10a. It is uses the MRST LO** PDF, which has a momentum sum somewhat above unity, which is compensated by a smaller Tune:pp alpha_s than in the previous tune. Again it is intended to give good agreement with much of the published CDF data. Tune:pp 'Tune 4C', newer tune, introduced with 8.145 Tune:pp Cor10a. Starts out from tune 2C, but with a reduced cross section for diffraction, plus modified multiparton interactions parameters to give a higher and more rapidly increasing charged pseudorapidity plateau, for better agreement with some early key LHC numbers. See also the comparative study in Tune:pp Buc11. The starting point for many later tunes. Tune:pp 'Tune 4Cx', based on tune 4C, but using the x-dependent matter profile, Tune:pp MultipartonInteractions:bProfile = 4 and an increased Tune:pp MultipartonInteractions:pT0Ref Tune:pp Cor11. Tune:pp 'ATLAS MB Tune A2-CTEQ6L1', a minimum-bias tune based on tune 4Cx, but without rapidity-ordered spacelike emissions Tune:pp ATL12. Uses CTEQ 6L1, by default from LHAPDF. Tune:pp 'ATLAS MB Tune A2-MSTW2008LO', as above, but uses MSTW 2008 LO, by default from LHAPDF. Tune:pp 'ATLAS UE Tune AU2-CTEQ6L1', an underlying-event tune based on tune 4Cx, but without rapidity-ordered spacelike emissions Tune:pp ATL12. Uses CTEQ 6L1, by default from LHAPDF. Tune:pp 'ATLAS UE Tune AU2-MSTW2008LO', as above, but uses MSTW 2008 LO, by default from LHAPDF. Tune:pp 'ATLAS UE Tune AU2-CT10', as above, but uses CT 10, which is not currently implemented in PYTHIA, so you must link LHAPDF. Tune:pp 'ATLAS UE Tune AU2-MRST2007LO*', as above, but uses MRST 2007 LO*, by default from LHAPDF. Tune:pp 'ATLAS UE Tune AU2-MRST2007LO**', as above, but uses MRST 2007 LO**, by default from LHAPDF. Tune:pp the Monash 2013 tune by Peter Skands at al. Tune:pp Ska14 , to both Tune:pp e^+e^- and Tune:pp pp/pbarp data. The starting point for many later tunes. Tune:pp 'CMS UE Tune CUETP8S1-CTEQ6L1', an underlying-event tune based on tune 4C Tune:pp CMS14. Uses CTEQ 6L1, by default from LHAPDF. Tune:pp 'CMS UE Tune CUETP8S1-HERAPDF1.5LO', an underlying-event tune based on tune 4C Tune:pp CMS14. Uses HERAPDF1.5LO, which is not currently implemented in PYTHIA, so you must link LHAPDF. Tune:pp 'ATLAS Tune AZ', is tuned to the Tune:pp pT spectrum of the Tune:pp Z^/gamma^*0 boson in a set of rapidity bins Tune:pp ATL14. Tune:pp 'CMS Tune MonashStar', alias CUETP8M1-NNPDF2.3LO, an underlying-event tune based on the Monash 2013 tune. Tune:pp 'ATLAS A14 central tune with CTEQL1', a full-scale tune to most ATLAS jet and underlying-event observables Tune:pp ATL14a , starting out from the Monash 2013 tune. The following tunes 20 - 32 belong to the same group. Tune:pp 'ATLAS A14 central tune with MSTW2008LO', see above tune 19. Tune:pp 'ATLAS A14 central tune with NNPDF2.3LO', see above tune 19. Defines the center of the 23 - 32 variations, so would be a good choice if you only want to study one tune from the A14 family. Tune:pp 'ATLAS A14 central tune with HERAPDF1.5LO', see above tune 19. Uses HERAPDF1.5LO, which is not currently implemented in PYTHIA, so you must link LHAPDF. Tune:pp 'ATLAS A14 variation 1+' of tune 21. Tune:pp 'ATLAS A14 variation 1-' of tune 21. Tune:pp 'ATLAS A14 variation 2+' of tune 21. Tune:pp 'ATLAS A14 variation 2-' of tune 21. Tune:pp 'ATLAS A14 variation 3a+' of tune 21. Tune:pp 'ATLAS A14 variation 3a-' of tune 21. Tune:pp 'ATLAS A14 variation 3b+' of tune 21. Tune:pp 'ATLAS A14 variation 3b-' of tune 21. Tune:pp 'ATLAS A14 variation 3c+' of tune 21. Tune:pp 'ATLAS A14 variation 3c-' of tune 21. Tune:pp tune that includes close-packing of strings and hadron rescattering, Gaussian model for pT and flavour selection Tune:pp Fis16. Based on Monash tune, mainly tuned to pT spectra. Tune:pp tune that includes close-packing of strings and hadron rescattering, thermodynamical model for pT and flavour selection Tune:pp Fis16. Based on Monash tune, mainly tuned to pT spectra."},{"name":"Tune:preferLHAPDF","link":"Tunes.html#anchor2","text":"Tune:preferLHAPDF Tunes made by experimental collaborations typically use the LHAPDF package to obtain their PDF values, and so PYTHIA must be built accordingly. See the Tune:preferLHAPDF PDF documentation for more information. For PDFs implemented natively in PYTHIA it is possible to use the respective tunes, without having to use LHAPDF, if you set Tune:preferLHAPDF Tune:preferLHAPDF = 0 Tune:preferLHAPDF before the Tune:preferLHAPDF Tune:pp choice. Tune:preferLHAPDF Use the internal PYTHIA PDFs. Tune:preferLHAPDF Use LHAPDF5 PDFs. Tune:preferLHAPDF Use LHAPDF6 PDFs."},{"name":"UncertaintyBands:cNSpTmin","link":"Variations.html#anchor3","text":"UncertaintyBands:cNSpTmin Variations of non-singular terms will not be performed for branchings occurring below this threshold."},{"name":"UncertaintyBands:deltaAlphaSmax","link":"Variations.html#anchor2","text":"UncertaintyBands:deltaAlphaSmax The allowed range of variation of alphaS, interpreted as abs(alphaSprime  - alphaS) < deltaAlphaSmax."},{"name":"UncertaintyBands:doVariations","link":"Variations.html#anchor1","text":"UncertaintyBands:doVariations Master switch to perform variations."},{"name":"UncertaintyBands:FSRpTmin2Fac","link":"Variations.html#anchor6","text":"UncertaintyBands:FSRpTmin2Fac Variations will not be performed for FSR branchings occurring below the threshold fixed by UncertaintyBands:FSRpTmin2Fac UncertaintyBands:FSRpTmin2Fac times UncertaintyBands:FSRpTmin2Fac TimeShower:pTmin^2."},{"name":"UncertaintyBands:ISRpTmin2Fac","link":"Variations.html#anchor5","text":"UncertaintyBands:ISRpTmin2Fac Variations will not be performed for ISR branchings occurring below the threshold fixed by UncertaintyBands:ISRpTmin2Fac UncertaintyBands:ISRpTmin2Fac times UncertaintyBands:ISRpTmin2Fac SpaceShower:pT0Ref^2."},{"name":"UncertaintyBands:List","link":"Variations.html#anchor10","text":"UncertaintyBands:List Vector of uncertainty-variation strings defining which variations will be calculated by Pythia when UncertaintyBands:List UncertaintyBands:doVariations is switched on."},{"name":"UncertaintyBands:MPIshowers","link":"Variations.html#anchor4","text":"UncertaintyBands:MPIshowers Flag specifying whether the automated shower variations include showers off MPI systems or not. Note that substantially larger weight fluctuations must be expected when including shower variations for MPI, due to the (many) more systems which then enter in the reweightings."},{"name":"UncertaintyBands:muSoftCorr","link":"Variations.html#anchor12","text":"UncertaintyBands:muSoftCorr This flags tells the shower to apply an O(&alpha;S UncertaintyBands:muSoftCorr 2 ) compensation term to the renormalization-scale variations, which reduces their magnitude for soft emissions, as described in UncertaintyBands:muSoftCorr Mre16."},{"name":"UncertaintyBands:nFlavQ","link":"Variations.html#anchor14","text":"UncertaintyBands:nFlavQ Number of quark flavours controlled via UncertaintyBands:nFlavQ Q2QG keywords, with higher ID codes controlled by UncertaintyBands:nFlavQ X2XG keywords. Thus a change to 5 would mean that top-quark variations would use UncertaintyBands:nFlavQ X2XG keyword values instead of the corresponding UncertaintyBands:nFlavQ Q2QG ones."},{"name":"UncertaintyBands:overSampleFSR","link":"Variations.html#anchor7","text":"UncertaintyBands:overSampleFSR The QCD FSR Sudakov is artificially increased by this factor. The increase is compensated for in the veto algorithm."},{"name":"UncertaintyBands:overSampleISR","link":"Variations.html#anchor8","text":"UncertaintyBands:overSampleISR The similar parameter for the QCD ISR Sudakov."},{"name":"UncertaintyBands:type","link":"Variations.html#anchor9","text":"UncertaintyBands:type UncertaintyBands:type Variations are calculated where allowed; UncertaintyBands:type only for the process (including ISR and FSR); UncertaintyBands:type only for resonance decay and showering;"},{"name":"WeakBosonAndParton:all","link":"ElectroweakProcesses.html#anchor22","text":"WeakBosonAndParton:all Common switch for the group of production of a single electroweak gauge boson, i.e. a WeakBosonAndParton:all gamma^*/Z^0 or a WeakBosonAndParton:all W^+- , in association with a parton, i.e. a quark, gluon, photon or lepton. These processes give first-order corrections to the ones in the WeakBosonAndParton:all WeakSingleBoson class, and both sets cannot be used simultaneously without unphysical double-counting. The current class should only be used to study the high- WeakBosonAndParton:all pT tail of the gauge-boson production processes (for LHC applications at least WeakBosonAndParton:all pT > 20 GeV), while the ones in WeakBosonAndParton:all WeakSingleBoson should be used for inclusive production."},{"name":"WeakBosonAndParton:ffbar2gmZgm","link":"ElectroweakProcesses.html#anchor25","text":"WeakBosonAndParton:ffbar2gmZgm Scattering WeakBosonAndParton:ffbar2gmZgm f fbar &rarr; gamma^*/Z^0 gamma. Code 243."},{"name":"WeakBosonAndParton:ffbar2Wgm","link":"ElectroweakProcesses.html#anchor29","text":"WeakBosonAndParton:ffbar2Wgm Scattering WeakBosonAndParton:ffbar2Wgm f fbar &rarr; W^+- gamma. Code 253."},{"name":"WeakBosonAndParton:fgm2gmZf","link":"ElectroweakProcesses.html#anchor26","text":"WeakBosonAndParton:fgm2gmZf Scattering WeakBosonAndParton:fgm2gmZf f gamma &rarr;  gamma^*/Z^0 f. Code 244."},{"name":"WeakBosonAndParton:fgm2Wf","link":"ElectroweakProcesses.html#anchor30","text":"WeakBosonAndParton:fgm2Wf Scattering WeakBosonAndParton:fgm2Wf f gamma &rarr; W^+- f. Code 254."},{"name":"WeakBosonAndParton:qg2gmZq","link":"ElectroweakProcesses.html#anchor24","text":"WeakBosonAndParton:qg2gmZq Scattering WeakBosonAndParton:qg2gmZq q g &rarr; gamma^*/Z^0 q. Code 242."},{"name":"WeakBosonAndParton:qg2Wq","link":"ElectroweakProcesses.html#anchor28","text":"WeakBosonAndParton:qg2Wq Scattering WeakBosonAndParton:qg2Wq q g &rarr; W^+- q. Code 252."},{"name":"WeakBosonAndParton:qqbar2gmZg","link":"ElectroweakProcesses.html#anchor23","text":"WeakBosonAndParton:qqbar2gmZg Scattering WeakBosonAndParton:qqbar2gmZg q qbar &rarr; gamma^*/Z^0 g. Code 241."},{"name":"WeakBosonAndParton:qqbar2Wg","link":"ElectroweakProcesses.html#anchor27","text":"WeakBosonAndParton:qqbar2Wg Scattering WeakBosonAndParton:qqbar2Wg q qbar &rarr; W^+- g. Code 251."},{"name":"WeakBosonExchange:all","link":"ElectroweakProcesses.html#anchor9","text":"WeakBosonExchange:all Common switch for the group of WeakBosonExchange:all gamma^*/Z^0 or WeakBosonExchange:all W^+- exchange between two fermions."},{"name":"WeakBosonExchange:ff2ff(t:gmZ)","link":"ElectroweakProcesses.html#anchor10","text":"WeakBosonExchange:ff2ff(t:gmZ) Scattering WeakBosonExchange:ff2ff(t:gmZ) f f' &rarr; f f' via WeakBosonExchange:ff2ff(t:gmZ) gamma^*/Z^0 WeakBosonExchange:ff2ff(t:gmZ) t -channel exchange, with full interference between the WeakBosonExchange:ff2ff(t:gmZ) gamma^* and WeakBosonExchange:ff2ff(t:gmZ) Z^0. Code 211."},{"name":"WeakBosonExchange:ff2ff(t:W)","link":"ElectroweakProcesses.html#anchor11","text":"WeakBosonExchange:ff2ff(t:W) Scattering WeakBosonExchange:ff2ff(t:W) f_1 f_2 &rarr; f_3 f_4 via WeakBosonExchange:ff2ff(t:W) W^+- WeakBosonExchange:ff2ff(t:W) t -channel exchange. Code 212."},{"name":"WeakDoubleBoson:all","link":"ElectroweakProcesses.html#anchor18","text":"WeakDoubleBoson:all Common switch for the group of pair production of WeakDoubleBoson:all gamma^*/Z^0 and WeakDoubleBoson:all W^+-."},{"name":"WeakDoubleBoson:ffbar2gmZgmZ","link":"ElectroweakProcesses.html#anchor19","text":"WeakDoubleBoson:ffbar2gmZgmZ Scattering WeakDoubleBoson:ffbar2gmZgmZ f fbar' &rarr; gamma^*/Z^0 gamma^*/Z^0. Code 231."},{"name":"WeakDoubleBoson:ffbar2WW","link":"ElectroweakProcesses.html#anchor21","text":"WeakDoubleBoson:ffbar2WW Scattering WeakDoubleBoson:ffbar2WW f fbar &rarr; W^+ W^-. Code 233."},{"name":"WeakDoubleBoson:ffbar2ZW","link":"ElectroweakProcesses.html#anchor20","text":"WeakDoubleBoson:ffbar2ZW Scattering WeakDoubleBoson:ffbar2ZW f fbar' &rarr; Z^0 W^+-. Note that here the WeakDoubleBoson:ffbar2ZW gamma^* contribution is not (currently) included. Code 232."},{"name":"WeakShower:enhancement","link":"WeakShowers.html#anchor1","text":"WeakShower:enhancement Enhancement factor for the weak shower. This is used to increase the statistics of weak shower emissions. Remember afterwards to correct for the additional weak emissions (i.e. divide the rate of weak emissions by the same factor)."},{"name":"WeakShower:externalSetup","link":"WeakShowers.html#anchor6","text":"WeakShower:externalSetup This flags tells the shower to use an external setup stored in the info pointer. This is mainly expected to be used in conjunction with the weak merging, and has to be switched on when the weak merging is used."},{"name":"WeakShower:singleEmission","link":"WeakShowers.html#anchor2","text":"WeakShower:singleEmission This parameter allows to stop the weak shower after a single emission. WeakShower:singleEmission If on, only a single weak emission is allowed. WeakShower:singleEmission If off, an unlimited number of weak emissions possible."},{"name":"WeakShower:vetoQCDjets","link":"WeakShowers.html#anchor4","text":"WeakShower:vetoQCDjets This flag vetoes some QCD emission for Drell-Yan weak production to avoid doublecounting with weak emission in QCD hard processes. For more information see WeakShower:vetoQCDjets WeakShower:vetoWeakJets above. Note that this flag only affects the process codes 221 and 222, i.e. the main built-in processes for WeakShower:vetoQCDjets gamma^*/Z^0/W^+- production, and not other internal or external processes."},{"name":"WeakShower:vetoWeakDeltaR","link":"WeakShowers.html#anchor5","text":"WeakShower:vetoWeakDeltaR The WeakShower:vetoWeakDeltaR delta R parameter used in the WeakShower:vetoWeakDeltaR kT clustering for the veto algorithm used to avoid double counting. Relates to the relative importance given to ISR and FSR emissionbs."},{"name":"WeakShower:vetoWeakJets","link":"WeakShowers.html#anchor3","text":"WeakShower:vetoWeakJets There are two ways to produce weak bosons in association with jets, namely Drell-Yan weak production with QCD radiation and QCD hard process with weak radiation. In order to avoid double counting between the two production channels, a veto procedure built on the WeakShower:vetoWeakJets kT jet algorithm is implemented in the evolution starting from a WeakShower:vetoWeakJets 2 &rarr; 2 QCD process, process codes in the range 111 - 129. The veto algorithm finds the first cluster step, and if it does not involve a weak boson the radiation of the weak boson is vetoed when WeakShower:vetoWeakJets WeakShower:vetoWeakJets is on. Note that this flag does not affect other internal or external processes, only the 111 - 129 ones. For the Drell-Yan process the same veto algorithm is used, but this time the event should be vetoed if the first clustering does contain a weak boson, see WeakShower:vetoWeakJets WeakShower:vetoQCDjets below."},{"name":"WeakSingleBoson:all","link":"ElectroweakProcesses.html#anchor12","text":"WeakSingleBoson:all Common switch for the group of a single WeakSingleBoson:all gamma^*/Z^0 or WeakSingleBoson:all W^+- production."},{"name":"WeakSingleBoson:ffbar2ffbar(s:gm)","link":"ElectroweakProcesses.html#anchor15","text":"WeakSingleBoson:ffbar2ffbar(s:gm) Scattering WeakSingleBoson:ffbar2ffbar(s:gm) f fbar &rarr; gamma^* &rarr; f' fbar'. Subset of process 221, but written as a WeakSingleBoson:ffbar2ffbar(s:gm) 2 &rarr; 2 process, so that WeakSingleBoson:ffbar2ffbar(s:gm) pT can be used as ordering variable, e.g. in multiparton interactions. Hardcoded for the final state being either of the five quark flavours or three lepton ones. Not included in the WeakSingleBoson:ffbar2ffbar(s:gm) WeakSingleBoson:all set, but included in the multiparton-interactions framework. Code 223."},{"name":"WeakSingleBoson:ffbar2ffbar(s:gmZ)","link":"ElectroweakProcesses.html#anchor16","text":"WeakSingleBoson:ffbar2ffbar(s:gmZ) Scattering WeakSingleBoson:ffbar2ffbar(s:gmZ) f fbar &rarr; gamma^*/Z^0 &rarr; f' fbar'. Equivalent to process 221, but written as a WeakSingleBoson:ffbar2ffbar(s:gmZ) 2 &rarr; 2 process, so that WeakSingleBoson:ffbar2ffbar(s:gmZ) pT could be used as cut or ordering variable. Final-state flavour selection is based on the WeakSingleBoson:ffbar2ffbar(s:gmZ) Z^0 allowed decay modes, and the WeakSingleBoson:ffbar2ffbar(s:gmZ) WeakZ0:gmZmode options are implemented. Not included in the WeakSingleBoson:ffbar2ffbar(s:gmZ) WeakSingleBoson:all set. Code 224."},{"name":"WeakSingleBoson:ffbar2ffbar(s:W)","link":"ElectroweakProcesses.html#anchor17","text":"WeakSingleBoson:ffbar2ffbar(s:W) Scattering WeakSingleBoson:ffbar2ffbar(s:W) f_1 fbar_2 &rarr; W+- &rarr; f_3 f_4. Almost equivalent to process 222, but written as a WeakSingleBoson:ffbar2ffbar(s:W) 2 &rarr; 2 process, so that WeakSingleBoson:ffbar2ffbar(s:W) pT could be used as cut or ordering variable. Final-state flavour selection is based on the WeakSingleBoson:ffbar2ffbar(s:W) W allowed decay modes. There are two simplifications relative to the implementation in process 222. Firstly, it is not possible to set different decay modes for the WeakSingleBoson:ffbar2ffbar(s:W) W^+ and the WeakSingleBoson:ffbar2ffbar(s:W) W^- ; instead the allowed WeakSingleBoson:ffbar2ffbar(s:W) W^+ ones will be used throughout, with charge conjugation for the WeakSingleBoson:ffbar2ffbar(s:W) W^-. Secondly, quark mass corrections are neglected in the decay angular distribution. Not included in the WeakSingleBoson:ffbar2ffbar(s:W) WeakSingleBoson:all set. Code 225."},{"name":"WeakSingleBoson:ffbar2gmZ","link":"ElectroweakProcesses.html#anchor13","text":"WeakSingleBoson:ffbar2gmZ Scattering WeakSingleBoson:ffbar2gmZ f fbar &rarr; gamma^*/Z^0 , with full interference between the WeakSingleBoson:ffbar2gmZ gamma^* and WeakSingleBoson:ffbar2gmZ Z^0. Code 221."},{"name":"WeakSingleBoson:ffbar2W","link":"ElectroweakProcesses.html#anchor14","text":"WeakSingleBoson:ffbar2W Scattering WeakSingleBoson:ffbar2W f fbar' &rarr; W^+-. Code 222."},{"name":"WeakZ0:gmZmode","link":"ElectroweakProcesses.html#anchor8","text":"WeakZ0:gmZmode Choice of full WeakZ0:gmZmode gamma^*/Z^0 structure or not in relevant processes. WeakZ0:gmZmode full WeakZ0:gmZmode gamma^*/Z^0 structure, with interference included. WeakZ0:gmZmode only pure WeakZ0:gmZmode gamma^* contribution. WeakZ0:gmZmode only pure WeakZ0:gmZmode Z^0 contribution. WeakZ0:gmZmode Note : irrespective of the option used, the particle produced will always be assigned code 23 for WeakZ0:gmZmode Z^0 , and open decay channels is purely dictated by what is set for the WeakZ0:gmZmode Z^0."},{"name":"Wprime:al","link":"NewGaugeBosonProcesses.html#anchor43","text":"Wprime:al axial coupling of leptons."},{"name":"Wprime:anglesWZ","link":"NewGaugeBosonProcesses.html#anchor45","text":"Wprime:anglesWZ in the decay chain Wprime:anglesWZ W'^+- &rarr; W^+- Z^0 &rarr;f_1 fbar_2 f_3 fbar_4 the decay angular distributions is taken to be a mixture of two possible shapes. This parameter gives the fraction that is distributed as in Higgs Wprime:anglesWZ H^+- &rarr; W^+- Z^0 (longitudinal bosons), with the remainder (by default all) is taken to be the same as for Wprime:anglesWZ W^+- &rarr; W^+- Z^0 (a mixture of transverse and longitudinal bosons)."},{"name":"Wprime:aq","link":"NewGaugeBosonProcesses.html#anchor41","text":"Wprime:aq axial coupling of quarks."},{"name":"Wprime:coup2WZ","link":"NewGaugeBosonProcesses.html#anchor44","text":"Wprime:coup2WZ the coupling Wprime:coup2WZ W'^0 &rarr; W^+- Z^0 is taken to be this number times Wprime:coup2WZ m_W^2 / m_W'^2 times the Wprime:coup2WZ W^+- &rarr; W^+- Z^0 coupling. Thus a unit value corresponds to the Wprime:coup2WZ W^+- &rarr; W^+- Z^0 coupling, scaled down by a factor Wprime:coup2WZ m_W^2 / m_W'^2 , and gives a Wprime:coup2WZ W'^+- partial width into this channel that increases linearly with the Wprime:coup2WZ W'^+- mass. If you cancel this behaviour, by letting Wprime:coup2WZ Wprime:coup2WZ be proportional to Wprime:coup2WZ m_W'^2 / m_W^2 , you instead obtain a partial width that goes like the fifth power of the Wprime:coup2WZ W'^+- mass. These two extremes correspond to the 'extended gauge model' and the 'reference model', respectively, of Wprime:coup2WZ Alt89."},{"name":"Wprime:vl","link":"NewGaugeBosonProcesses.html#anchor42","text":"Wprime:vl vector coupling of leptons."},{"name":"Wprime:vq","link":"NewGaugeBosonProcesses.html#anchor40","text":"Wprime:vq vector coupling of quarks."},{"name":"Zp:ad","link":"DarkMatterProcesses.html#anchor19","text":"Zp:ad Axial coupling of down-type quarks."},{"name":"Zp:al","link":"DarkMatterProcesses.html#anchor21","text":"Zp:al Axial coupling of charged leptons."},{"name":"Zp:au","link":"DarkMatterProcesses.html#anchor17","text":"Zp:au Axial coupling of up-type quarks."},{"name":"Zp:av","link":"DarkMatterProcesses.html#anchor23","text":"Zp:av Axial coupling of neutrinos."},{"name":"Zp:aX","link":"DarkMatterProcesses.html#anchor13","text":"Zp:aX Axial coupling of DM fermion."},{"name":"Zp:coupH","link":"DarkMatterProcesses.html#anchor25","text":"Zp:coupH Coupling to the SM higgs when kinetic mixing is off. When on the coupling is instead set by Zp:coupH Zp:epsilon."},{"name":"Zp:decayMode","link":"DarkMatterProcesses.html#anchor7","text":"Zp:decayMode Switch to change decay of the Zp:decayMode Z'. Zp:decayMode Zp:decayMode X Xbar Zp:decayMode Zp:decayMode q qbar (dijets) Zp:decayMode Zp:decayMode l lbar (charged dileptons) Zp:decayMode Zp:decayMode nu nubar + X Xbar (invisible)"},{"name":"Zp:epsilon","link":"DarkMatterProcesses.html#anchor24","text":"Zp:epsilon Kinetic mixing parameter between the dark Zp:epsilon U(1) and the SM hypercharge Zp:epsilon U(1). In the implemented case the Zp:epsilon Z'^0 mass is larger than the SM Zp:epsilon Z^0 one. The fermionic current for Zp:epsilon Z'^0 is described in Zp:epsilon Cli184."},{"name":"Zp:gZp","link":"DarkMatterProcesses.html#anchor15","text":"Zp:gZp Gauge coupling of a new Zp:gZp U(1). This parameter also sets the coupling of the DM to the Zp:gZp Z' , whether kinetic mixing is on or not."},{"name":"Zp:kineticMixing","link":"DarkMatterProcesses.html#anchor14","text":"Zp:kineticMixing Flag for the two main options to set the couplings of the Zp:kineticMixing Z' to SM quarks and leptons. In the default off option the overall coupling strength of the new Zp:kineticMixing U(1) gauge group is given by Zp:kineticMixing Zp:gZp and the separate fermion couplings by Zp:kineticMixing Zp:vu through Zp:kineticMixing Zp:av. In the alternative, with kinetic mixing on, the coupling to the DM is still given by Zp:kineticMixing Zp:gZp , but the mixing parameter Zp:kineticMixing Zp:epsilon now specifies how the separate fermion couplings are related to their Zp:kineticMixing U(1)_Y values."},{"name":"Zp:vd","link":"DarkMatterProcesses.html#anchor18","text":"Zp:vd Vector coupling of down-type quarks."},{"name":"Zp:vl","link":"DarkMatterProcesses.html#anchor20","text":"Zp:vl Vector coupling of charged leptons."},{"name":"Zp:vu","link":"DarkMatterProcesses.html#anchor16","text":"Zp:vu Vector coupling of up-type quarks."},{"name":"Zp:vv","link":"DarkMatterProcesses.html#anchor22","text":"Zp:vv Vector coupling of neutrinos."},{"name":"Zp:vX","link":"DarkMatterProcesses.html#anchor12","text":"Zp:vX Vector coupling of DM fermion."},{"name":"Zprime:ab","link":"NewGaugeBosonProcesses.html#anchor21","text":"Zprime:ab axial coupling of Zprime:ab b quarks."},{"name":"Zprime:abPrime","link":"NewGaugeBosonProcesses.html#anchor32","text":"Zprime:abPrime axial coupling of Zprime:abPrime b' quarks."},{"name":"Zprime:ac","link":"NewGaugeBosonProcesses.html#anchor15","text":"Zprime:ac axial coupling of Zprime:ac c quarks."},{"name":"Zprime:ad","link":"NewGaugeBosonProcesses.html#anchor5","text":"Zprime:ad axial coupling of Zprime:ad d quarks."},{"name":"Zprime:ae","link":"NewGaugeBosonProcesses.html#anchor9","text":"Zprime:ae axial coupling of Zprime:ae e leptons."},{"name":"Zprime:amu","link":"NewGaugeBosonProcesses.html#anchor17","text":"Zprime:amu axial coupling of Zprime:amu mu leptons."},{"name":"Zprime:anglesWW","link":"NewGaugeBosonProcesses.html#anchor29","text":"Zprime:anglesWW in the decay chain Zprime:anglesWW Z'^0 &rarr; W^+ W^- &rarr;f_1 fbar_2 f_3 fbar_4 the decay angular distributions is taken to be a mixture of two possible shapes. This parameter gives the fraction that is distributed as in Higgs Zprime:anglesWW h^0 &rarr; W^+ W^- (longitudinal bosons), with the remainder (by default all) is taken to be the same as for Zprime:anglesWW Z^0 &rarr; W^+ W^- (a mixture of transverse and longitudinal bosons)."},{"name":"Zprime:anue","link":"NewGaugeBosonProcesses.html#anchor11","text":"Zprime:anue axial coupling of Zprime:anue nu_e neutrinos."},{"name":"Zprime:anumu","link":"NewGaugeBosonProcesses.html#anchor19","text":"Zprime:anumu axial coupling of Zprime:anumu nu_mu neutrinos."},{"name":"Zprime:anutau","link":"NewGaugeBosonProcesses.html#anchor27","text":"Zprime:anutau axial coupling of Zprime:anutau nu_tau neutrinos."},{"name":"Zprime:anutauPrime","link":"NewGaugeBosonProcesses.html#anchor38","text":"Zprime:anutauPrime axial coupling of Zprime:anutauPrime nu_tau' neutrinos."},{"name":"Zprime:as","link":"NewGaugeBosonProcesses.html#anchor13","text":"Zprime:as axial coupling of Zprime:as s quarks."},{"name":"Zprime:at","link":"NewGaugeBosonProcesses.html#anchor23","text":"Zprime:at axial coupling of Zprime:at t quarks."},{"name":"Zprime:atau","link":"NewGaugeBosonProcesses.html#anchor25","text":"Zprime:atau axial coupling of Zprime:atau tau leptons."},{"name":"Zprime:atauPrime","link":"NewGaugeBosonProcesses.html#anchor36","text":"Zprime:atauPrime axial coupling of Zprime:atauPrime tau' leptons."},{"name":"Zprime:atPrime","link":"NewGaugeBosonProcesses.html#anchor34","text":"Zprime:atPrime axial coupling of Zprime:atPrime t' quarks."},{"name":"Zprime:au","link":"NewGaugeBosonProcesses.html#anchor7","text":"Zprime:au axial coupling of Zprime:au u quarks."},{"name":"Zprime:coup2gen4","link":"NewGaugeBosonProcesses.html#anchor30","text":"Zprime:coup2gen4 Zprime:coup2gen4 Z'^0 couples to 4th generation fermions."},{"name":"Zprime:coup2WW","link":"NewGaugeBosonProcesses.html#anchor28","text":"Zprime:coup2WW the coupling Zprime:coup2WW Z'^0 &rarr; W^+ W^- is taken to be this number times Zprime:coup2WW m_W^2 / m_Z'^2 times the Zprime:coup2WW Z^0 &rarr; W^+ W^- coupling. Thus a unit value corresponds to the Zprime:coup2WW Z^0 &rarr; W^+ W^- coupling, scaled down by a factor Zprime:coup2WW m_W^2 / m_Z'^2 , and gives a Zprime:coup2WW Z'^0 partial width into this channel that again increases linearly. If you cancel this behaviour, by letting Zprime:coup2WW Zprime:coup2WW be proportional to Zprime:coup2WW m_Z'^2 / m_W^2 , you instead obtain a partial width that goes like the fifth power of the Zprime:coup2WW Z'^0 mass. These two extremes correspond to the 'extended gauge model' and the 'reference model', respectively, of Zprime:coup2WW Alt89. Note that this channel only includes the pure Zprime:coup2WW Z' part, while Zprime:coup2WW f fbar &rarr; gamma^*/Z^*0 &rarr; W^+ W^- is available as a separate electroweak process. Furthermore, we have left some amount of freedom in the choice of decay angular correlations in this channel, but obviously alternative shapes could be imagined."},{"name":"Zprime:gmZmode","link":"NewGaugeBosonProcesses.html#anchor2","text":"Zprime:gmZmode Choice of full Zprime:gmZmode gamma^*/Z^0/Z'^0 structure or not in the above process. Note that, with the Zprime:gmZmode Z'^0 part switched off, this process is reduced to what already exists among Zprime:gmZmode electroweak processes , so those options are here only for crosschecks. Zprime:gmZmode full Zprime:gmZmode gamma^*/Z^0/Z'^0 structure, with interference included. Zprime:gmZmode only pure Zprime:gmZmode gamma^* contribution. Zprime:gmZmode only pure Zprime:gmZmode Z^0 contribution. Zprime:gmZmode only pure Zprime:gmZmode Z'^0 contribution. Zprime:gmZmode only the Zprime:gmZmode gamma^*/Z^0 contribution, including interference. Zprime:gmZmode only the Zprime:gmZmode gamma^*/Z'^0 contribution, including interference. Zprime:gmZmode only the Zprime:gmZmode Z^0/Z'^0 contribution, including interference. Zprime:gmZmode Note : irrespective of the option used, the particle produced will always be assigned code 32 for Zprime:gmZmode Z'^0 , and open decay channels is purely dictated by what is set for the Zprime:gmZmode Z'^0."},{"name":"Zprime:universality","link":"NewGaugeBosonProcesses.html#anchor3","text":"Zprime:universality If on then you need only set the first-generation couplings below, and these are automatically also used for the second and third generation. If off, then couplings can be chosen separately for each generation."},{"name":"Zprime:vb","link":"NewGaugeBosonProcesses.html#anchor20","text":"Zprime:vb vector coupling of Zprime:vb b quarks."},{"name":"Zprime:vbPrime","link":"NewGaugeBosonProcesses.html#anchor31","text":"Zprime:vbPrime vector coupling of Zprime:vbPrime b' quarks."},{"name":"Zprime:vc","link":"NewGaugeBosonProcesses.html#anchor14","text":"Zprime:vc vector coupling of Zprime:vc c quarks."},{"name":"Zprime:vd","link":"NewGaugeBosonProcesses.html#anchor4","text":"Zprime:vd vector coupling of Zprime:vd d quarks."},{"name":"Zprime:ve","link":"NewGaugeBosonProcesses.html#anchor8","text":"Zprime:ve vector coupling of Zprime:ve e leptons."},{"name":"Zprime:vmu","link":"NewGaugeBosonProcesses.html#anchor16","text":"Zprime:vmu vector coupling of Zprime:vmu mu leptons."},{"name":"Zprime:vnue","link":"NewGaugeBosonProcesses.html#anchor10","text":"Zprime:vnue vector coupling of Zprime:vnue nu_e neutrinos."},{"name":"Zprime:vnumu","link":"NewGaugeBosonProcesses.html#anchor18","text":"Zprime:vnumu vector coupling of Zprime:vnumu nu_mu neutrinos."},{"name":"Zprime:vnutau","link":"NewGaugeBosonProcesses.html#anchor26","text":"Zprime:vnutau vector coupling of Zprime:vnutau nu_tau neutrinos."},{"name":"Zprime:vnutauPrime","link":"NewGaugeBosonProcesses.html#anchor37","text":"Zprime:vnutauPrime vector coupling of Zprime:vnutauPrime nu_tau' neutrinos."},{"name":"Zprime:vs","link":"NewGaugeBosonProcesses.html#anchor12","text":"Zprime:vs vector coupling of Zprime:vs s quarks."},{"name":"Zprime:vt","link":"NewGaugeBosonProcesses.html#anchor22","text":"Zprime:vt vector coupling of Zprime:vt t quarks."},{"name":"Zprime:vtau","link":"NewGaugeBosonProcesses.html#anchor24","text":"Zprime:vtau vector coupling of Zprime:vtau tau leptons."},{"name":"Zprime:vtauPrime","link":"NewGaugeBosonProcesses.html#anchor35","text":"Zprime:vtauPrime vector coupling of Zprime:vtauPrime tau' leptons."},{"name":"Zprime:vtPrime","link":"NewGaugeBosonProcesses.html#anchor33","text":"Zprime:vtPrime vector coupling of Zprime:vtPrime t' quarks."},{"name":"Zprime:vu","link":"NewGaugeBosonProcesses.html#anchor6","text":"Zprime:vu vector coupling of Zprime:vu u quarks."},{"name":"AlpgenHooks(Pythia &amp;pythia)","link":"AlpgenEventInterface.html#anchor15","text":"AlpgenHooks(Pythia &amp;pythia) The constructor takes a PYTHIA object as input, so that the beam parameter settings can be overridden if the AlpgenHooks(Pythia &amp;pythia) Alpgen:file option is given. If this is the case, an AlpgenHooks(Pythia &amp;pythia) LHAupAlpgen instance is automatically created and passed to PYTHIA."},{"name":"AlpgenPar::AlpgenPar(Info *infoPtrIn = NULL)","link":"AlpgenEventInterface.html#anchor9","text":"AlpgenPar::AlpgenPar(Info *infoPtrIn = NULL) The constructor does nothing except for store the PYTHIA Info pointer, if given. This is used for warning/error message printing."},{"name":"BeamShape::BeamShape()","link":"BeamShape.html#anchor1","text":"BeamShape::BeamShape()"},{"name":"bool  JetMatchingMadgraph::getExclusive()","link":"JetMatching.html#anchor31","text":"bool  JetMatchingMadgraph::getExclusive() Return flag to identify if exclusive or inclusive vetoes should be applied to this event."},{"name":"bool AlpgenPar::haveParam(const string &amp;paramIn)","link":"AlpgenEventInterface.html#anchor11","text":"bool AlpgenPar::haveParam(const string &amp;paramIn) Method to check if a parameter with key bool AlpgenPar::haveParam(const string &amp;paramIn) paramIn is present. Returns true if present, else false."},{"name":"bool AlpgenPar::parse(const string paramStr)","link":"AlpgenEventInterface.html#anchor10","text":"bool AlpgenPar::parse(const string paramStr) This method parses an ALPGEN parameter file. The parameter file is passed as a single string, mainly intended to be read out from the PYTHIA Info object using the header information methods."},{"name":"bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5)","link":"EventAnalysis.html#anchor29","text":"bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) performs a jet finding analysis, where bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) is an object of the bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) Event class, most likely the bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) pythia.event one. bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) is the minimum transverse energy inside a cone for this to be accepted as a jet. bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) is the size of the cone in bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) (eta, phi) space drawn around the geometric center of the jet. bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) the minimum bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) eT in a cell for this to be acceptable as the trial center of a jet. bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) If the routine returns bool CellJet::analyze( const Event& event,  double eTjetMin = 20., double coneRadius = 0.7, double eTseed = 1.5) false the analysis failed, but currently this is not foreseen ever to happen."},{"name":"bool DecayChannel::contains(int id1)","link":"ParticleDataScheme.html#anchor186","text":"bool DecayChannel::contains(int id1)"},{"name":"bool DecayChannel::contains(int id1, int id2)","link":"ParticleDataScheme.html#anchor187","text":"bool DecayChannel::contains(int id1, int id2)"},{"name":"bool DecayChannel::contains(int id1, int id2, int id3)","link":"ParticleDataScheme.html#anchor188","text":"bool DecayChannel::contains(int id1, int id2, int id3) find if the decay product list contains the one, two or three particle identities provided. If the same code is repeated then so must it be in the products list. Matching also requires correct sign."},{"name":"bool DecayChannel::hasChanged()","link":"ParticleDataScheme.html#anchor185","text":"bool DecayChannel::hasChanged() used for internal purposes, to know which decay modes have been changed."},{"name":"bool Hist::getLinX()","link":"Histograms.html#anchor21","text":"bool Hist::getLinX() return true if the histogram has a linear bool Hist::getLinX() x scale and false if a logarithmic one."},{"name":"bool Hist::sameSize(const Hist&amp; h)","link":"Histograms.html#anchor24","text":"bool Hist::sameSize(const Hist&amp; h) checks that the number of bins and upper and lower limits are the same as in the histogram in the argument."},{"name":"bool Info::atEndOfFile()","link":"EventInformation.html#anchor25","text":"bool Info::atEndOfFile() true if a linked Les Houches class refuses to return any further events, presumably because it has reached the end of the file from which events have been read in."},{"name":"bool Info::hasHistory()","link":"EventInformation.html#anchor109","text":"bool Info::hasHistory() set/get knowledge whether the likely shower history of an event has been traced."},{"name":"bool Info::hasSub()","link":"EventInformation.html#anchor26","text":"bool Info::hasSub() does the process have a subprocess classification? Currently only true for nondiffractive and Les Houches events, where it allows the hardest collision to be identified."},{"name":"bool Info::isDiffractiveA()","link":"EventInformation.html#anchor17","text":"bool Info::isDiffractiveA()"},{"name":"bool Info::isDiffractiveB()","link":"EventInformation.html#anchor18","text":"bool Info::isDiffractiveB() is either beam soft diffractively excited?"},{"name":"bool Info::isDiffractiveC()","link":"EventInformation.html#anchor19","text":"bool Info::isDiffractiveC() is there soft central diffraction (a.k.a. double Pomeron exchange)?"},{"name":"bool Info::isHardDiffractiveA()","link":"EventInformation.html#anchor20","text":"bool Info::isHardDiffractiveA()"},{"name":"bool Info::isHardDiffractiveB()","link":"EventInformation.html#anchor21","text":"bool Info::isHardDiffractiveB() is either beam hard diffractively excited?"},{"name":"bool Info::isLHA()","link":"EventInformation.html#anchor24","text":"bool Info::isLHA() has the process been generated from external Les Houches Accord information?"},{"name":"bool Info::isMinBias()","link":"EventInformation.html#anchor23","text":"bool Info::isMinBias() the same as above, retained for backwards compatibility, but to be removed in PYTHIA 8.2."},{"name":"bool Info::isNonDiffractive()","link":"EventInformation.html#anchor22","text":"bool Info::isNonDiffractive() is the process the bool Info::isNonDiffractive() SoftQCD:nonDiffractive one, i.e. corresponding to the full inelastic nondiffractive part of the total cross section. (Note that a hard process, say bool Info::isNonDiffractive() Z^0 production, normally is nondiffractive, but this is not what we aim at here, and so the method would return bool Info::isNonDiffractive() false , unless the bool Info::isNonDiffractive() Z^0 had been generated as part of the MPI machinery for the bool Info::isNonDiffractive() SoftQCD:nonDiffractive component.)"},{"name":"bool Info::isResolved()","link":"EventInformation.html#anchor16","text":"bool Info::isResolved() are beam particles resolved, i.e. were PDF's used for the process?"},{"name":"bool Info::isValence1()","link":"EventInformation.html#anchor36","text":"bool Info::isValence1()"},{"name":"bool Info::isValence2()","link":"EventInformation.html#anchor37","text":"bool Info::isValence2() bool Info::isValence2() true if the two hard incoming partons have been picked to belong to the valence piece of the parton-density distribution, else bool Info::isValence2() false. Should be interpreted with caution. Information is not set if you switch off parton-level processing."},{"name":"bool Info::tooLowPTmin()","link":"EventInformation.html#anchor12","text":"bool Info::tooLowPTmin() normally false, but true if the proposed bool Info::tooLowPTmin() pTmin scale was too low in timelike or spacelike showers, or in multiparton interactions. In the former case the bool Info::tooLowPTmin() pTmin is raised to some minimal value, in the latter the initialization fails (it is impossible to obtain a minijet cross section bigger than the nondiffractive one by reducing bool Info::tooLowPTmin() pTmin )."},{"name":"bool init(istream& is, bool append = false)","link":"SettingsScheme.html#anchor4","text":"bool init(istream& is, bool append = false) read in the settings from an input stream. This allows initialization without reading the xml files directly, which is useful for initialization of multiple copies of Pythia8."},{"name":"bool initAfterBeams()","link":"AlpgenEventInterface.html#anchor16","text":"bool initAfterBeams() This is the only UserHooks method that is overridden. It is called directly after PYTHIA has initialised the beams, and therefore the header information should be present in the PYTHIA Info object. The bool initAfterBeams() AlpgenPar class is used to parse ALPGEN parameters, if present, which are then used to set further PYTHIA settings."},{"name":"bool LHAup::closeLHEF(bool updateInit = false)","link":"LesHouchesAccord.html#anchor88","text":"bool LHAup::closeLHEF(bool updateInit = false) Writes the closing tag and closes the file. Optionally, if bool LHAup::closeLHEF(bool updateInit = false) updateInit = true , this routine will reopen the file from the beginning, rewrite the same header as bool LHAup::closeLHEF(bool updateInit = false) openLHEF() did, and then call bool LHAup::closeLHEF(bool updateInit = false) initLHEF() again to overwrite the old information. This is especially geared towards programs, such as PYTHIA itself, where the cross section information is not available at the beginning of the run, but only is obtained by Monte Carlo integration in parallel with the event generation itself. Then the bool LHAup::closeLHEF(bool updateInit = false) setXSec( i, xSec) , bool LHAup::closeLHEF(bool updateInit = false) setXErr( i, xSec) and bool LHAup::closeLHEF(bool updateInit = false) setXMax( i, xSec) can be used to update the relevant information before bool LHAup::closeLHEF(bool updateInit = false) closeLHEF is called. bool LHAup::closeLHEF(bool updateInit = false) Warning: overwriting the beginning of a file without upsetting anything is a delicate operation. It only works when the new lines require exactly as much space as the old ones did. Thus, if you add another process in between, the file will be corrupted."},{"name":"bool LHAup::eventLHEF(bool verbose = true)","link":"LesHouchesAccord.html#anchor87","text":"bool LHAup::eventLHEF(bool verbose = true) Writes event information to the file above. Such information should already have been set with the methods described in the 'Event input' section above. This call should be repeated once for each event to be stored. By default the event information is lined up in columns. To save space, the alternative bool LHAup::eventLHEF(bool verbose = true) verbose = false only leaves a single blank between the information fields."},{"name":"bool LHAup::fileFound()","link":"LesHouchesAccord.html#anchor78","text":"bool LHAup::fileFound() always returns true in the base class, but in bool LHAup::fileFound() LHAupLHEF it returns false if the LHEF provided in the constructor is not found and opened correctly."},{"name":"bool LHAup::initLHEF()","link":"LesHouchesAccord.html#anchor86","text":"bool LHAup::initLHEF() Writes initialization information to the file above. Such information should already have been set with the methods described in the 'Initialization' section above."},{"name":"bool LHAup::newEventFile(const char* fileIn)","link":"LesHouchesAccord.html#anchor81","text":"bool LHAup::newEventFile(const char* fileIn) close current event input file/stream and open a new one, to continue reading events of the same kind as before."},{"name":"bool LHAup::openLHEF(string filename)","link":"LesHouchesAccord.html#anchor85","text":"bool LHAup::openLHEF(string filename) Opens a file with the filename indicated, and writes a header plus a brief comment with date and time information."},{"name":"bool LHAup::pdfIsSet()","link":"LesHouchesAccord.html#anchor59","text":"bool LHAup::pdfIsSet()"},{"name":"bool LHAup::setInitLHEF(ifstream& is,  bool readHeaders = false)","link":"LesHouchesAccord.html#anchor75","text":"bool LHAup::setInitLHEF(ifstream& is,  bool readHeaders = false) read in and set all required initialization information from the specified stream. With second argument true it will also read and store header information, as described above. Return false if it fails."},{"name":"bool LHAup::setNewEventLHEF(ifstream& is)","link":"LesHouchesAccord.html#anchor76","text":"bool LHAup::setNewEventLHEF(ifstream& is) read in event information from the specified stream into a staging area where it can be reused by bool LHAup::setNewEventLHEF(ifstream& is) setOldEventLHEF."},{"name":"bool LHAup::setOldEventLHEF()","link":"LesHouchesAccord.html#anchor77","text":"bool LHAup::setOldEventLHEF() store the event information from the staging area into the normal location. Thus a single bool LHAup::setOldEventLHEF() setNewEventLHEF call can be followed by several bool LHAup::setOldEventLHEF() setOldEventLHEF ones, so as to process the same configuration several times. This method currently only returns true, i.e. any errors should be caught by the preceding bool LHAup::setOldEventLHEF() setNewEventLHEF call."},{"name":"bool LHAup::useExternal()","link":"LesHouchesAccord.html#anchor79","text":"bool LHAup::useExternal() always returns false in the base class, but in bool LHAup::useExternal() LHAupLHEF it returns false if the bool LHAup::useExternal() LHAupLHEF instance is constructed to work on an input LHE file, while it returns true if the bool LHAup::useExternal() LHAupLHEF instance is constructed to use externally provided input streams instead. For the latter, the bool LHAup::useExternal() LHAupLHEF instance should have been constructed with the class constructor bool LHAup::useExternal() LHAupLHEF(Info* infoPtrIn, istream* isIn, istream* isHeadIn, bool readHeadersIn, bool setScalesFromLHEFIn)."},{"name":"bool LHAupAlpgen::addResonances()","link":"AlpgenEventInterface.html#anchor7","text":"bool LHAupAlpgen::addResonances() This is a private method used when an event is read in. The information read from the event file does not always contain a complete listing of all particles and four-momenta, and so various details must be reconstructed. Exactly which details are filled in can vary based on the ALPGEN process in question."},{"name":"bool LHAupAlpgen::rescaleMomenta()","link":"AlpgenEventInterface.html#anchor8","text":"bool LHAupAlpgen::rescaleMomenta() This is another private method used when an event is read in. It shuffles and rescales momenta in an event to ensure energy-momentum conservation.  First, bool LHAupAlpgen::rescaleMomenta() pT is made to balance by splitting any imbalance between all outgoing particles with their energies also scaled. Second, the bool LHAupAlpgen::rescaleMomenta() e/pZ of the two incoming particles are scaled to balance the outgoing particles. Finally, any intermediate resonances are recalculated from their decay products."},{"name":"bool LHAupHelaconia::readString(string line)","link":"HelacOniaProcesses.html#anchor2","text":"bool LHAupHelaconia::readString(string line) allows the user to send commands to HelacOnia. bool LHAupHelaconia::readString(string line) the command to be sent to HelacOnia. For example, the following will produce bool LHAupHelaconia::readString(string line) J/psi events events from 13 TeV proton proton collisions: bool LHAupHelaconia::readString(string line) bool LHAupHelaconia::readString(string line) readString('generate u u~ > cc~(3S11) g'); bool LHAupHelaconia::readString(string line) A special case is the generation of colour-octet states. In PYTHIA these are evolved to colour-singlet states through the emission of a soft gluon with the mass splitting set by bool LHAupHelaconia::readString(string line) Onia:massSplit. To ensure the colour-octet states in HelacOnia are produced with the correct masses needed for this splitting, the specific colour-octet state for the process must be set. For example: bool LHAupHelaconia::readString(string line) bool LHAupHelaconia::readString(string line) readString('generate u u~ > cc~(3S18) g'); bool LHAupHelaconia::readString(string line) requires that the colour-singlet state into which the colour-octet state should decay be set. This could be set via: bool LHAupHelaconia::readString(string line) bool LHAupHelaconia::readString(string line) readString('set state = 443'); bool LHAupHelaconia::readString(string line) for the case where a final state bool LHAupHelaconia::readString(string line) J/psi is requested. Note that this is not a command passed to HelacOnia, but rather a command which PYTHIA uses to set the heavy quark mass in HelacOnia and then translate the HelacOnia output to the correct colour-singlet state."},{"name":"bool LHAupMadgraph::readString(string line,  Stage stage = Auto)","link":"MadGraph5Processes.html#anchor2","text":"bool LHAupMadgraph::readString(string line,  Stage stage = Auto) allows the user to send commands to MadGraph. bool LHAupMadgraph::readString(string line,  Stage stage = Auto) the command to be sent to MadGraph. Any string begining with bool LHAupMadgraph::readString(string line,  Stage stage = Auto) 'configure ' is used for the initial MadGraph configuration with bool LHAupMadgraph::readString(string line,  Stage stage = Auto) 'configure ' stripped from the begining. In general, only the process and run settings need to be provided. Run settings must begin with bool LHAupMadgraph::readString(string line,  Stage stage = Auto) ' set' ; note the leading space. The output and launch commands, random seed, and shower choice are automatically handled. For example, the following will produce di-muon events from 13 TeV proton proton collisions at NLO in QCD: bool LHAupMadgraph::readString(string line,  Stage stage = Auto) bool LHAupMadgraph::readString(string line,  Stage stage = Auto) readString('generate p p > mu+ mu- [QCD]'); bool LHAupMadgraph::readString(string line,  Stage stage = Auto) if the stage is set to Auto, commands beginning with bool LHAupMadgraph::readString(string line,  Stage stage = Auto) ' set' are used in the launch stage, commands begining with bool LHAupMadgraph::readString(string line,  Stage stage = Auto) 'configure' are used in the configuration stage, and all remaining commands (excluding bool LHAupMadgraph::readString(string line,  Stage stage = Auto) output and bool LHAupMadgraph::readString(string line,  Stage stage = Auto) launch ) are used in the generate stage. Output, launch, seed, and shower commands are automatically handled. If the user wishes to override commands, then the stage can be specified. This will prevent any automatically generated commands from being used for that stage. This should only be done if the user understands what additional commands are needed."},{"name":"bool Particle::canDecay()","link":"ParticleProperties.html#anchor82","text":"bool Particle::canDecay() flag whether decay modes have been declared for a particle, so that it could be decayed, should that be requested."},{"name":"bool Particle::doExternalDecay()","link":"ParticleProperties.html#anchor83","text":"bool Particle::doExternalDecay() particles that are decayed by an external program."},{"name":"bool Particle::hasVertex()","link":"ParticleProperties.html#anchor37","text":"bool Particle::hasVertex() production vertex has been set; if false then production at the origin is assumed."},{"name":"bool Particle::isAncestor(int iAncestor)","link":"ParticleProperties.html#anchor102","text":"bool Particle::isAncestor(int iAncestor) traces the particle upwards through mother, grandmother, and so on, until either bool Particle::isAncestor(int iAncestor) iAncestor is found or the top of the record is reached. Normally one unique mother is required, as is the case e.g. in decay chains or in parton showers, so that e.g. the tracing through a hard scattering would not work. For hadronization, first-rank hadrons are identified with the respective string endpoint quark, which may be useful e.g. for bool Particle::isAncestor(int iAncestor) b physics, while higher-rank hadrons give bool Particle::isAncestor(int iAncestor) false. Currently also ministrings that collapsed to one single hadron and junction topologies give bool Particle::isAncestor(int iAncestor) false."},{"name":"bool Particle::isCharged()","link":"ParticleProperties.html#anchor71","text":"bool Particle::isCharged()"},{"name":"bool Particle::isDiquark()","link":"ParticleProperties.html#anchor89","text":"bool Particle::isDiquark() true for a diquark or an antidiquark."},{"name":"bool Particle::isFinal()","link":"ParticleProperties.html#anchor34","text":"bool Particle::isFinal() true for a remaining particle, i.e. one with positive status code, else false. Thus, after an event has been fully generated, it separates the final-state particles from intermediate-stage ones. (If used earlier in the generation process, a particle then considered final may well decay later.)"},{"name":"bool Particle::isFinalPartonLevel()","link":"ParticleProperties.html#anchor103","text":"bool Particle::isFinalPartonLevel() is true if the particle belonged to the final state (i.e. with positive status code) right before hadronization is invoked. This is intended to further simple comparisons between parton-level and hadron-level properties, say the number of jets. This method makes use of the event record size set when bool Particle::isFinalPartonLevel() HadronLevel::next() is invoked, so would not work otherwise (unless bool Particle::isFinalPartonLevel() Event::savePartonLevelSize() is called by hand). Note that what should be counted as parton level is not always unique. For instance, R-hadron formation is part of the hadron level machinery, even though a subsequent R-hadron decay could well give rise to new activity on the parton level, which thereby is missed."},{"name":"bool Particle::isGluon()","link":"ParticleProperties.html#anchor88","text":"bool Particle::isGluon() true for a gluon."},{"name":"bool Particle::isHadron()","link":"ParticleProperties.html#anchor91","text":"bool Particle::isHadron() true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"bool Particle::isLepton()","link":"ParticleProperties.html#anchor86","text":"bool Particle::isLepton() true for a lepton or an antilepton (including neutrinos)."},{"name":"bool Particle::isNeutral()","link":"ParticleProperties.html#anchor72","text":"bool Particle::isNeutral() charge different from or equal to 0."},{"name":"bool Particle::isParton()","link":"ParticleProperties.html#anchor90","text":"bool Particle::isParton() true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"bool Particle::isQuark()","link":"ParticleProperties.html#anchor87","text":"bool Particle::isQuark() true for a quark or an antiquark."},{"name":"bool Particle::isRescatteredIncoming()","link":"ParticleProperties.html#anchor36","text":"bool Particle::isRescatteredIncoming() true for particles with a status code -34, -45, -46 or -54, else false. This singles out partons that have been created in a previous scattering but here are bookkept as belonging to the incoming state of another scattering."},{"name":"bool Particle::isResonance()","link":"ParticleProperties.html#anchor84","text":"bool Particle::isResonance() particles where the decay is to be treated as part of the hard process, typically with nominal mass above 20 GeV ( bool Particle::isResonance() W^+-, Z^0, t, ... )."},{"name":"bool Particle::isVisible()","link":"ParticleProperties.html#anchor85","text":"bool Particle::isVisible() particles with strong or electric charge, or composed of ones having it, which thereby should be considered visible in a normal detector."},{"name":"bool Particle::mayDecay()","link":"ParticleProperties.html#anchor81","text":"bool Particle::mayDecay() flag whether particle has been declared unstable or not, offering the main user switch to select which particle species to decay."},{"name":"bool Particle::undoDecay()","link":"ParticleProperties.html#anchor105","text":"bool Particle::undoDecay() removes the decay chain of the particle and thus restores it to its undecayed state. It is only intended for 'normal' particle decay chains, and will return false in other cases, notably if the particle is coloured. The procedure would not work if non-local momentum shifts have been performed, such as with a Bose-Einstein shift procedure (or for a dipole shower recoiler). As the decay products are erased from the event record, mother and daughter indices are updated to retain a correct history for the remaining particles."},{"name":"bool ParticleData::canDecay(int id)","link":"ParticleDataScheme.html#anchor69","text":"bool ParticleData::canDecay(int id) true for a particle with at least one decay channel defined."},{"name":"bool ParticleData::doExternalDecay(int id)","link":"ParticleDataScheme.html#anchor58","text":"bool ParticleData::doExternalDecay(int id) a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the bool ParticleData::doExternalDecay(int id) bool ParticleData::doExternalDecay(int id) pythia.decayPtr method should be provided with the list of relevant particles."},{"name":"bool ParticleData::doForceWidth(int id)","link":"ParticleDataScheme.html#anchor62","text":"bool ParticleData::doForceWidth(int id) a flag applicable only for resonances (see bool ParticleData::doForceWidth(int id) isResonance above), whereby it is possible to force resonances to retain their assigned widths, whatever that is, see bool ParticleData::doForceWidth(int id) Resonance Decays for details. The normal behaviour is bool ParticleData::doForceWidth(int id) false , i.e. the width is based on hardcoded calculations whenever available."},{"name":"bool ParticleData::getIsInit()","link":"ParticleDataScheme.html#anchor92","text":"bool ParticleData::getIsInit() return true if the database has been initialized, else false."},{"name":"bool ParticleData::hasAnti(int id)","link":"ParticleDataScheme.html#anchor29","text":"bool ParticleData::hasAnti(int id) bool whether a distinct antiparticle exists or not. Is true if an antiparticle name has been set (and is different from bool ParticleData::hasAnti(int id) void )."},{"name":"bool ParticleData::hasChanged(int id)","link":"ParticleDataScheme.html#anchor64","text":"bool ParticleData::hasChanged(int id) keep track of whether the data for a particle has been changed in any respect between initialization and the current status. Is used e.g. by the bool ParticleData::hasChanged(int id) listChanged method to determine which particles to list."},{"name":"bool ParticleData::init(const ParticleData& particleDataIn","link":"ParticleDataScheme.html#anchor5","text":"bool ParticleData::init(const ParticleData& particleDataIn copy particle data from information stored in an existing bool ParticleData::init(const ParticleData& particleDataIn ParticleData instance."},{"name":"bool ParticleData::init(istream& is","link":"ParticleDataScheme.html#anchor6","text":"bool ParticleData::init(istream& is copy particle data from a stream (rather than from a file)."},{"name":"bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;)","link":"ParticleDataScheme.html#anchor4","text":"bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) read in an XML-style file with particle data and initialize the particle data tables accordingly. This command is executed in the bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) Pythia constructor, i.e. is mainly for internal use. bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) the name of the data file to be read. When called from the bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) Pythia constructor the directory is provided by the bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) bool ParticleData::init(string  startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;) PYTHIA8DATA environment variable, if set, else by the argument of this constructor, which has the default value &quot;../share/Pythia8/xmldoc&quot;."},{"name":"bool ParticleData::isBaryon(int id)","link":"ParticleDataScheme.html#anchor77","text":"bool ParticleData::isBaryon(int id) true for a baryon or antibaryon."},{"name":"bool ParticleData::isDiquark(int id)","link":"ParticleDataScheme.html#anchor73","text":"bool ParticleData::isDiquark(int id) true for a diquark or antidiquark."},{"name":"bool ParticleData::isGluon(int id)","link":"ParticleDataScheme.html#anchor72","text":"bool ParticleData::isGluon(int id) true for a gluon."},{"name":"bool ParticleData::isHadron(int id)","link":"ParticleDataScheme.html#anchor75","text":"bool ParticleData::isHadron(int id) true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"bool ParticleData::isLepton(int id)","link":"ParticleDataScheme.html#anchor70","text":"bool ParticleData::isLepton(int id) true for a lepton or an antilepton (including neutrinos)."},{"name":"bool ParticleData::isMeson(int id)","link":"ParticleDataScheme.html#anchor76","text":"bool ParticleData::isMeson(int id) true for a meson."},{"name":"bool ParticleData::isOctetHadron(int id)","link":"ParticleDataScheme.html#anchor79","text":"bool ParticleData::isOctetHadron(int id) true for an intermediate hadron-like state with a colour octet charge as used in the colour octet model for bool ParticleData::isOctetHadron(int id) onia production."},{"name":"bool ParticleData::isOnium(int id)","link":"ParticleDataScheme.html#anchor78","text":"bool ParticleData::isOnium(int id) true for a charmonium, bottomonium or (hypothetical) toponium state, i.e any state composed of bool ParticleData::isOnium(int id) c cbar , bool ParticleData::isOnium(int id) b bbar or bool ParticleData::isOnium(int id) t tbar irrespective of colour (singlet or octet) and spin, angular momentum or radial excitation."},{"name":"bool ParticleData::isParticle(int id)","link":"ParticleDataScheme.html#anchor25","text":"bool ParticleData::isParticle(int id) query whether the particle data table contains the particle of the identity code."},{"name":"bool ParticleData::isParton()","link":"ParticleDataScheme.html#anchor74","text":"bool ParticleData::isParton() true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"bool ParticleData::isQuark(int id)","link":"ParticleDataScheme.html#anchor71","text":"bool ParticleData::isQuark(int id) true for a quark or an antiquark."},{"name":"bool ParticleData::isResonance(int id)","link":"ParticleDataScheme.html#anchor54","text":"bool ParticleData::isResonance(int id) a flag telling whether a particle species are considered as a resonance or not. Here bool ParticleData::isResonance(int id) 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the bool ParticleData::isResonance(int id) b bbar bound systems in mass, i.e. for bool ParticleData::isResonance(int id) W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with bool ParticleData::isResonance(int id) m0 above 20 GeV are by default initialized to be considered as resonances."},{"name":"bool ParticleData::isVisible(int id)","link":"ParticleDataScheme.html#anchor60","text":"bool ParticleData::isVisible(int id) a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector."},{"name":"bool ParticleData::mayDecay(int id)","link":"ParticleDataScheme.html#anchor56","text":"bool ParticleData::mayDecay(int id) a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for bool ParticleData::mayDecay(int id) particle decays (or bool ParticleData::mayDecay(int id) resonance decays ). All particles with bool ParticleData::mayDecay(int id) tau0 below 1000 mm are by default initialized to allow decays."},{"name":"bool ParticleData::readFF(string inFile,  bool reset = true)","link":"ParticleDataScheme.html#anchor11","text":"bool ParticleData::readFF(string inFile,  bool reset = true)"},{"name":"bool ParticleData::readString(string line,  bool warn = true)","link":"ParticleDataScheme.html#anchor13","text":"bool ParticleData::readString(string line,  bool warn = true) read in a string and interpret is as a new or changed particle data. The possibilities are extensively described above. It is normally used indirectly, via bool ParticleData::readString(string line,  bool warn = true) Pythia::readString(...) and bool ParticleData::readString(string line,  bool warn = true) Pythia::readFile(...). bool ParticleData::readString(string line,  bool warn = true) the string to be interpreted as an instruction. bool ParticleData::readString(string line,  bool warn = true) write a warning message or not whenever the instruction does not make sense, e.g. if the particle does not exist in the database. bool ParticleData::readString(string line,  bool warn = true) Note: the method returns false if it fails to make sense out of the input string."},{"name":"bool ParticleData::readXML(string inFile,  bool reset = true)","link":"ParticleDataScheme.html#anchor9","text":"bool ParticleData::readXML(string inFile,  bool reset = true)"},{"name":"bool ParticleData::reInit(string startFile,  bool xmlFormat = true)","link":"ParticleDataScheme.html#anchor7","text":"bool ParticleData::reInit(string startFile,  bool xmlFormat = true) overwrite the existing database by reading from the specified file. Unlike bool ParticleData::reInit(string startFile,  bool xmlFormat = true) init above this method is not called by the bool ParticleData::reInit(string startFile,  bool xmlFormat = true) Pythia constructor, but is entirely intended for users who want to replace the existing particle data with their own. bool ParticleData::reInit(string startFile,  bool xmlFormat = true) the path and name of file to be read. bool ParticleData::reInit(string startFile,  bool xmlFormat = true) if true read the same kind of XML-style file as used by bool ParticleData::reInit(string startFile,  bool xmlFormat = true) init , if not use an alternative 'free format' file (i.e. without any XML tags, but with well-defined rules specifying in which order properties are stored)."},{"name":"bool ParticleData::useBreitWigner(int id)","link":"ParticleDataScheme.html#anchor65","text":"bool ParticleData::useBreitWigner(int id) tells whether a particle will have a Breit-Wigner mass distribution or not. Is determined by an internal logic based on the particle width and on the value of the bool ParticleData::useBreitWigner(int id) bool ParticleData::useBreitWigner(int id) ParticleData:modeBreitWigner switch."},{"name":"bool ParticleDataEntry::canDecay(int id)","link":"ParticleDataScheme.html#anchor142","text":"bool ParticleDataEntry::canDecay(int id) true for a particle with at least one decay channel defined."},{"name":"bool ParticleDataEntry::doExternalDecay()","link":"ParticleDataScheme.html#anchor130","text":"bool ParticleDataEntry::doExternalDecay() a flag telling whether a particle should be handled by an external decay package or not, with the latter default. Can be manipulated as described on this page, but should normally not be. Instead the bool ParticleDataEntry::doExternalDecay() bool ParticleDataEntry::doExternalDecay() pythia.decayPtr method should be provided with the list of relevant particles."},{"name":"bool ParticleDataEntry::doForceWidth()","link":"ParticleDataScheme.html#anchor134","text":"bool ParticleDataEntry::doForceWidth() a flag applicable only for resonances (see bool ParticleDataEntry::doForceWidth() isResonance above), whereby it is possible to force resonances to retain their assigned widths, whatever that is, see bool ParticleDataEntry::doForceWidth() Resonance Decays for details. The normal behaviour is bool ParticleDataEntry::doForceWidth() false , i.e. the width is based on hardcoded calculations whenever available."},{"name":"bool ParticleDataEntry::hasAnti()","link":"ParticleDataScheme.html#anchor101","text":"bool ParticleDataEntry::hasAnti() tell whether a separate antiparticle exists."},{"name":"bool ParticleDataEntry::isBaryon()","link":"ParticleDataScheme.html#anchor150","text":"bool ParticleDataEntry::isBaryon() true for a baryon or antibaryon."},{"name":"bool ParticleDataEntry::isDiquark()","link":"ParticleDataScheme.html#anchor146","text":"bool ParticleDataEntry::isDiquark() true for a diquark or antidiquark."},{"name":"bool ParticleDataEntry::isGluon()","link":"ParticleDataScheme.html#anchor145","text":"bool ParticleDataEntry::isGluon() true for a gluon."},{"name":"bool ParticleDataEntry::isHadron()","link":"ParticleDataScheme.html#anchor148","text":"bool ParticleDataEntry::isHadron() true for a hadron (made up out of normal quarks and gluons, i.e. not for R-hadrons and other exotic states)."},{"name":"bool ParticleDataEntry::isLepton()","link":"ParticleDataScheme.html#anchor143","text":"bool ParticleDataEntry::isLepton() true for a lepton or an antilepton (including neutrinos)."},{"name":"bool ParticleDataEntry::isMeson()","link":"ParticleDataScheme.html#anchor149","text":"bool ParticleDataEntry::isMeson() true for a meson."},{"name":"bool ParticleDataEntry::isOctetHadron()","link":"ParticleDataScheme.html#anchor151","text":"bool ParticleDataEntry::isOctetHadron() true for an intermediate hadron-like state with a colour octet charge as used in the colour octet model for bool ParticleDataEntry::isOctetHadron() onia production."},{"name":"bool ParticleDataEntry::isParton()","link":"ParticleDataScheme.html#anchor147","text":"bool ParticleDataEntry::isParton() true for a gluon, a quark or antiquark up to the b (but excluding top), and a diquark or antidiquark consisting of quarks up to the b."},{"name":"bool ParticleDataEntry::isQuark()","link":"ParticleDataScheme.html#anchor144","text":"bool ParticleDataEntry::isQuark() true for a quark or an antiquark."},{"name":"bool ParticleDataEntry::isResonance()","link":"ParticleDataScheme.html#anchor126","text":"bool ParticleDataEntry::isResonance() a flag telling whether a particle species are considered as a resonance or not. Here bool ParticleDataEntry::isResonance() 'resonance' is used as shorthand for any massive particle where the decay process should be counted as part of the hard process itself, and thus be performed before showers and other event aspects are added. Restrictions on allowed decay channels is also directly reflected in the cross section of simulated processes, while those of normal hadrons and other light particles are not. In practice, it is reserved for states above the bool ParticleDataEntry::isResonance() b bbar bound systems in mass, i.e. for bool ParticleDataEntry::isResonance() W, Z, t , Higgs states, supersymmetric states and (most?) other states in any new theory. All particles with bool ParticleDataEntry::isResonance() m0 above 20 GeV are by default initialized to be considered as resonances."},{"name":"bool ParticleDataEntry::isVisible()","link":"ParticleDataScheme.html#anchor132","text":"bool ParticleDataEntry::isVisible() a flag telling whether a particle species is to be considered as visible in a detector or not, as used e.g. in analysis routines. By default the invisibles include neutrinos, Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, neutralinos) that have neither strong nor electromagnetic charge, and are not made up of constituents that have it. The value of this flag is only relevant if a particle is long-lived enough actually to make it to a detector."},{"name":"bool ParticleDataEntry::mayDecay()","link":"ParticleDataScheme.html#anchor128","text":"bool ParticleDataEntry::mayDecay() a flag telling whether a particle species may decay or not, offering the main user switch. Whether a given particle of this kind then actually will decay also depends on it having allowed decay channels, and on other flags for bool ParticleDataEntry::mayDecay() particle decays (or bool ParticleDataEntry::mayDecay() resonance decays ). All particles with bool ParticleDataEntry::mayDecay() tau0 below 1000 mm are by default initialized to allow decays."},{"name":"bool ParticleDataEntry::preparePick(int idSgn,  double mHat = 0., int idInFlav = 0)","link":"ParticleDataScheme.html#anchor160","text":"bool ParticleDataEntry::preparePick(int idSgn,  double mHat = 0., int idInFlav = 0) prepare to pick a decay channel."},{"name":"bool ParticleDataEntry::useBreitWigner()","link":"ParticleDataScheme.html#anchor141","text":"bool ParticleDataEntry::useBreitWigner() tells whether a particle will have a Breit-Wigner mass distribution or not. Is determined by an internal logic based on the particle width and on the value of the bool ParticleDataEntry::useBreitWigner() bool ParticleDataEntry::useBreitWigner() ParticleData:modeBreitWigner switch."},{"name":"bool Pythia8ToHepMC::convert_gluon_to_0()","link":"HepMCInterface.html#anchor10","text":"bool Pythia8ToHepMC::convert_gluon_to_0() the normal gluon identity code 21 is used also when parton density information is stored, unless this optional argument is set true to have gluons represented by a 0. This choice does not affect the normal event record, where a gluon is always 21."},{"name":"bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1)","link":"HepMCInterface.html#anchor4","text":"bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) convert a bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia event to a bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC one. Will return true if succeeded. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the input bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia event that is to be converted to HepMC format. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the output bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) GenEvt event, in its standard form. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) set the event number of the current event. If negative then the internal event number is used, which is incremented by one for each new event. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) pointer to the bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia Info object, which is used to extract PFD values, and process and cross section information. Without such a pointer this information therefore cannot be stored, i.e. it is equivalent to the three bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) set_store methods below being set false. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) pointer to the bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia Settings object, which is used to decide whether hadronization is carried out, and therefore whether to warn about unhadronized partons. Without such a pointer the bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) set_free_parton_warnings method below uniquely controls the behaviour. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) if bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) true then the input event is appended to the current bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC event record, rather than starting a new one. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the root particle that defines the new production vertex for the particles to be added in the bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) append = true option. bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) used to set the bar code when bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) append = true. If positive then start from bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) iBarcode itself, if negative then start from the current size of the bool Pythia8ToHepMC::fill_next_event( Pythia8::Event& pyev,  GenEvent* evt, int ievnum = -1, Pythia8::Info* pyinfo = 0,  Pythia8::Settings* pyset = 0, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC event record, and if 0 then set all bar codes to vanish."},{"name":"bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1)","link":"HepMCInterface.html#anchor3","text":"bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) convert a bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia event to a bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC one. Will return true if succeeded. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the input bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) Pythia generator object, from which both the event and other information can be obtained. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the output bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) GenEvt event, in its standard form. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) set the event number of the current event. If negative then the internal event number is used, which is incremented by one for each new event. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) if bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) true then the input event is appended to the current bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC event record, rather than starting a new one. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) the root particle that defines the new production vertex for the particles to be added in the bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) append = true option. bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) used to set the bar code when bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) append = true. If positive then start from bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) iBarcode itself, if negative then start from the current size of the bool Pythia8ToHepMC::fill_next_event( Pythia8::Pythia& pythia,  GenEvent* evt, int ievnum = -1, bool append = false,  GenParticle* rootParticle = 0, int iBarcode = -1) HepMC event record, and if 0 then set all bar codes to vanish."},{"name":"bool Pythia8ToHepMC::free_parton_exception()","link":"HepMCInterface.html#anchor8","text":"bool Pythia8ToHepMC::free_parton_exception() check and throw an exception when unhadronized gluons or quarks are encountered in the event record. Does not apply when Pythia hadronization is switched off. Default is to do this check. If an exception is thrown the bool Pythia8ToHepMC::free_parton_exception() PartonEndVertexException class will return a warning message. The calling code can choose action to take, also having access to the location ( bool Pythia8ToHepMC::free_parton_exception() index() ) and species ( bool Pythia8ToHepMC::free_parton_exception() pdg_id() ) of a bad parton."},{"name":"bool Pythia8ToHepMC::print_inconsistency()","link":"HepMCInterface.html#anchor6","text":"bool Pythia8ToHepMC::print_inconsistency() print a warning line, on bool Pythia8ToHepMC::print_inconsistency() cerr , when inconsistent mother and daughter information is encountered."},{"name":"bool Pythia8ToHepMC::store_pdf()","link":"HepMCInterface.html#anchor12","text":"bool Pythia8ToHepMC::store_pdf() for each event store information on the two incoming flavours, their x values and common factorization scale, and the values of the two parton distributions, bool Pythia8ToHepMC::store_pdf() xf(x,Q)."},{"name":"bool Pythia8ToHepMC::store_proc()","link":"HepMCInterface.html#anchor14","text":"bool Pythia8ToHepMC::store_proc() for each event store information on the Pythia process code, the renormalization scale, and bool Pythia8ToHepMC::store_proc() alpha_em and bool Pythia8ToHepMC::store_proc() alpha_s values used for the hard process."},{"name":"bool Pythia8ToHepMC::store_xsec()","link":"HepMCInterface.html#anchor16","text":"bool Pythia8ToHepMC::store_xsec() for each event store information on the Pythia cross section and its error, in pb, and the event weight. If events also come with a dimensional weight, like in some Les Houches strategies, this weight is in units of pb."},{"name":"bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr)","link":"ProgramFlow.html#anchor18","text":"bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr) offers the possibility to add further user hooks, see bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr) setUserHooksPtr above for further information. bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr) Note: The method currently always returns true. bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr) Warning: usually it is meaningful to combine several requirements, but there are examples where not. It is the responsibility of the user to check that a particular combination works as intended. Also see bool Pythia::addUserHooksPtr( UserHooks* userHooksPtr) here."},{"name":"bool Pythia::checkVersion()","link":"ProgramFlow.html#anchor6","text":"bool Pythia::checkVersion() helper methods, that collects common tasks of the two constructors."},{"name":"bool Pythia::flag(string key)","link":"ProgramFlow.html#anchor38","text":"bool Pythia::flag(string key) read in a boolean variable from the bool Pythia::flag(string key) Settings database. bool Pythia::flag(string key) the name of the variable to be read."},{"name":"bool Pythia::forceHadronLevel(bool findJunctions = true)","link":"ProgramFlow.html#anchor32","text":"bool Pythia::forceHadronLevel(bool findJunctions = true) hadronize the existing event record, i.e. perform string fragmentation and particle decays. There are two main applications. Firstly, you can use the same parton-level content as a basis for repeated hadronization attempts, in schemes intended to save computer time. Secondly, you may have an external program that can simulate the full partonic level of the event - hard process, parton showers, multiparton interactions, beam remnants, colour flow, and so on - but not hadronization. Further details are found bool Pythia::forceHadronLevel(bool findJunctions = true) here. bool Pythia::forceHadronLevel(bool findJunctions = true) normally this routine will search through the event record and try to figure out if any colour junctions are present. If so, the colour topology of such junctions must be sorted out. In tricky cases this might fail, and then hadronization will not work. A user who is aware of this and knows the intended colour flow can set up the junction information (if any) in the event record, and then call bool Pythia::forceHadronLevel(bool findJunctions = true) forceHadronLevel(false) so as not to have this information overwritten. (If the event record contains no unhadronized partons then no junction search will be performed in any case.) bool Pythia::forceHadronLevel(bool findJunctions = true) Note: The method returns false if the hadronization fails. The event record is then not consistent and should not be studied."},{"name":"bool Pythia::forceRHadronDecays()","link":"ProgramFlow.html#anchor34","text":"bool Pythia::forceRHadronDecays() perform decays of R-hadrons that were previously considered stable. This could be if an R-hadron is sufficiently long-lived that it may interact in the detector between production and decay, so that its four-momentum is changed. Further details are found bool Pythia::forceRHadronDecays() here. bool Pythia::forceRHadronDecays() Note: The method returns false if the decays fail. The event record is then not consistent and should not be studied."},{"name":"bool Pythia::init()","link":"ProgramFlow.html#anchor26","text":"bool Pythia::init() initialize for collisions. The beams are not specified by input arguments, but instead by the settings in the bool Pythia::init() Beam Parameters section. This allows the beams to be specified in the same file as other run instructions. The default settings give pp collisions at 14 TeV. bool Pythia::init() Note: The method returns false if the initialization fails. It is then not possible to generate any events."},{"name":"bool Pythia::LHAeventSkip(int nSkip)","link":"ProgramFlow.html#anchor36","text":"bool Pythia::LHAeventSkip(int nSkip) skip ahead a number of events in the Les Houches generation sequence, without doing anything further with them, see bool Pythia::LHAeventSkip(int nSkip) bool Pythia::LHAeventSkip(int nSkip) LHAup::skipEvent(nSkip). Mainly intended for debug purposes, e.g. when an event at a known location in a Les Houches Event File is causing problems. bool Pythia::LHAeventSkip(int nSkip) number of events to skip. bool Pythia::LHAeventSkip(int nSkip) Note: The method returns false if the operation fails, specifically if the end of a LHEF has been reached, cf. bool Pythia::LHAeventSkip(int nSkip) next() above."},{"name":"bool Pythia::moreDecays()","link":"ProgramFlow.html#anchor33","text":"bool Pythia::moreDecays() perform decays of all particles in the event record that have not been decayed but should have been done so. This can be used e.g. for repeated decay attempts, in schemes intended to save computer time. Further details are found bool Pythia::moreDecays() here. bool Pythia::moreDecays() Note: The method returns false if the decays fail. The event record is then not consistent and should not be studied."},{"name":"bool Pythia::next()","link":"ProgramFlow.html#anchor27","text":"bool Pythia::next() generate the next event. No input parameters are required; all instructions have already been set up in the initialization stage. bool Pythia::next() Note: The method returns false if the event generation fails. The event record is then not consistent and should not be studied. When reading in hard collisions from a Les Houches Event File the problem may be that the end of the file has been reached. This can be checked with the bool Pythia::next() bool Pythia::next() Info::atEndOfFile() method."},{"name":"bool Pythia::next(double eA, double eB)","link":"ProgramFlow.html#anchor29","text":"bool Pythia::next(double eA, double eB) bool Pythia::next(double eA, double eB) events created by the collision of two particles coming in along the bool Pythia::next(double eA, double eB) +-z axis, with the respective energies as arguments, to be used for bool Pythia::next(double eA, double eB) Beams:frameType = 2."},{"name":"bool Pythia::next(double eCM)","link":"ProgramFlow.html#anchor28","text":"bool Pythia::next(double eCM) bool Pythia::next(double eCM) events created by the collision of two particles coming in along the bool Pythia::next(double eCM) +-z axis in their common rest frame, with the CM energy as argument, to be used for bool Pythia::next(double eCM) Beams:frameType = 1."},{"name":"bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB)","link":"ProgramFlow.html#anchor30","text":"bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB) These three methods can only be used when variable event-energy has been switched on, see the bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB) Beam Parameters description. Then they can be used to give in the new event CM energy, the two back-to-back incoming particle energies, or the full three-momentum of the incoming particles, for bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB) Beams:frameType set to 1, 2 or 3, respectively. bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB) events created by two incoming particles with arbitrary three-momenta, to be used for bool Pythia::next(double pxA, double pyA, double pzA,  double pxB, double pyB, double pzB) Beams:frameType = 3."},{"name":"bool Pythia::readFile(istream& inStream = cin,  bool warn = true, int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor10","text":"bool Pythia::readFile(istream& inStream = cin,  bool warn = true, int subrun = SUBRUNDEFAULT)"},{"name":"bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor11","text":"bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) reads in a whole file, where each line is interpreted as an instruction to modify the value of a bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) setting or bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) particle data , cf. the above bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) readString method. All four forms of the bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) readFile command share code for actually reading a file. bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) the file from which instructions are read. bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) an istream from which instructions are read. bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. In the command forms where bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) warn is omitted it is true. bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) allows you have several optional sets of commands within the same file. Only those sections of the file before any bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) Main:subrun = ... line or following such a line with matching subrun number will be read. The subrun number should not be negative; negative codes like bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) SUBRUNDEFAULT corresponds to no specific subrun. bool Pythia::readFile(istream& inStream = cin,  int subrun = SUBRUNDEFAULT) Note: the method returns false if it fails to make sense out of any one line."},{"name":"bool Pythia::readFile(string fileName,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor9","text":"bool Pythia::readFile(string fileName,  int subrun = SUBRUNDEFAULT)"},{"name":"bool Pythia::readFile(string fileName, bool warn = true,  int subrun = SUBRUNDEFAULT)","link":"ProgramFlow.html#anchor8","text":"bool Pythia::readFile(string fileName, bool warn = true,  int subrun = SUBRUNDEFAULT)"},{"name":"bool Pythia::readString(string line, bool warn = true)","link":"ProgramFlow.html#anchor7","text":"bool Pythia::readString(string line, bool warn = true) reads in a single string, that is interpreted as an instruction to modify the value of a bool Pythia::readString(string line, bool warn = true) setting or bool Pythia::readString(string line, bool warn = true) particle data , as already described above. bool Pythia::readString(string line, bool warn = true) the string to be interpreted as an instruction. bool Pythia::readString(string line, bool warn = true) write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. bool Pythia::readString(string line, bool warn = true) Note: the method returns false if it fails to make sense out of the string."},{"name":"bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr)","link":"ProgramFlow.html#anchor19","text":"bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) offers the possibility to provide your own shape of the momentum and space-time spread of the incoming beams. The rules for constructing your own class from the bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) BeamShape base class are described bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) here. bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) pointer to a bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) BeamShape -derived object. This object must be instantiated by you in your program. bool Pythia::setBeamShapePtr( BeamShape* beamShapePtr) Note: The method currently always returns true."},{"name":"bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector&lt;int&gt; handledParticles)","link":"ProgramFlow.html#anchor15","text":"bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) offers the possibility to link to an external program that can do some of the particle decays, instead of using the internal decay machinery. With particles we here mean the normal hadrons and leptons, not top quarks, electroweak bosons or new particles in BSM scenarios. The rules for constructing your own class from the bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) DecayHandler base class are described bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) here. Note that you can only provide one external object, but this object in its turn could very well hand on different particles to separate decay libraries. bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) pointer to a bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) DecayHandler -derived object. This object must be instantiated by you in your program. bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) vector with the PDG identity codes of the particles that should be handled by the external decay package. You should only give the particle (positive) codes; the respective antiparticle is always included as well. bool Pythia::setDecayPtr( DecayHandler* decayHandlePtr,  vector<int> handledParticles) Note: The method currently always returns true."},{"name":"bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr)","link":"ProgramFlow.html#anchor23","text":"bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) offers the possibility to feed in an external Heavy Ion generator that can use the internal bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) Pythia machinery for its tasks, see further bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) here. bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) pointer to a bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) HeavyIons -derived object for doing Heavy Ions collisions. bool Pythia::setHeavyIonsPtr( HeavyIons* heavyIonsPtr) Note: The method currently always returns true."},{"name":"bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn)","link":"ProgramFlow.html#anchor14","text":"bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) offers linkage to an external generator that feeds in events in the LHA format, see bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) Les Houches Accord , assuming that bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) Beams:frameType = 5 has been set. bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) pointer to a bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) LHAup -derived object. bool Pythia::setLHAupPtr( LHAup* lhaUpPtrIn) Note: The method currently always returns true."},{"name":"bool Pythia::setPartonVertexPtr( PartonVertex*  partonVertexPtrIn)","link":"ProgramFlow.html#anchor25","text":"bool Pythia::setPartonVertexPtr( PartonVertex*  partonVertexPtrIn) offers the possibility to set production vertices for the MPI, FSR and ISR parton-level evolution, instead of the default framework, see further bool Pythia::setPartonVertexPtr( PartonVertex*  partonVertexPtrIn) here. This part of the program is still in the early stages, and is likely to evolve further. Currently it is only used for the bool Pythia::setPartonVertexPtr( PartonVertex*  partonVertexPtrIn) Rope Hadronization framework. bool Pythia::setPartonVertexPtr( PartonVertex*  partonVertexPtrIn) Note: The method currently always returns true."},{"name":"bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0)","link":"ProgramFlow.html#anchor12","text":"bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) offers the possibility to link in external PDF sets for usage inside the program. The rules for constructing your own class from the bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF base class are described bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) here. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. The two objects have to be instantiated by you in your program. Even if the two beam particles are the same (protons, say) two separate instances are required, since current information is cached in the objects. If both arguments are zero then any previous linkage to external PDF's is disconnected, see further Note 2 below. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. Normally only the first two arguments above would be used, and then the same PDF sets would be invoked everywhere. If you provide these two further pointers then two different sets of PDF's are used. This second set is then exclusively for the generation of the hard process from the process matrix elements library. The first set above is for everything else, notably parton showers and multiparton interactions. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. These define the pomeron PDFs used in hard diffraction. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. These define the photon PDFs when photons are emitted from lepton beams. With resolved photon beams some additional methods are required for initial state radiation and multiparton interactions and to sample valence content. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. As above, but now these are used for hard-process generation only, the parton showers and multiparton interactions uses the bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pdfGamAPtr and bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pdfGamBPtr PDFs. Unlike above, no additional methods are needed for these. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. Additional PDF pointers when the beam particle has also unresolved PDFs in addition to usual resolved one. Currently used only when mixing direct and resolved photon-initiated processes. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) pointers to two further bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) PDF -derived objects, one for each of the incoming beams. Additional PDF pointers when having resolved and unresolved photons coming from lepton beams. Currently used only when mixing direct and resolved photon-initiated processes in lepton-lepton or lepton-hadron collisions. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) Note 1: The method returns false if the input is obviously incorrect, e.g. if two (nonzero) pointers agree. bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) Note 2: If you want to combine several subruns you can call bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) setPDFPtr with new arguments before each bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) Pythia::init() call. To revert from external PDF's to the normal internal PDF selection you must call bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) setPDFPtr(0, 0) before bool Pythia::setPDFPtr( PDF* pdfAPtr, PDF* pdfBPtr,  PDF* pdfHardAPtr = 0, PDF* pdfHardBPtr = 0, PDF* pdfPomAPtr = 0,  PDF* pdfPomBPtr = 0, PDF* pdfGamAPtr = 0, PDF* pdfGamBPtr = 0,  PDF* pdfHardGamAPtr = 0, PDF* pdfHardGamBPtr = 0, PDF* pdfUnresAPtr = 0,  PDF* pdfUnresBPtr = 0, PDF* pdfUnresGamAPtr = 0, PDF* pdfUnresGamBPtrIn = 0) Pythia::init()."},{"name":"bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn)","link":"ProgramFlow.html#anchor13","text":"bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn) offers the possibility to link in external photon fluxes for usage inside the program. The rules for constructing your own class from the bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn) PDF base class are described bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn) here. bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn) pointers to two bool Pythia::setPhotonFluxPtr( PDF* photonFluxAIn,  PDF* photonFluxBIn) PDF -derived objects, one for each of the incoming beams. The two objects have to be instantiated by you in your program."},{"name":"bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr)","link":"ProgramFlow.html#anchor21","text":"bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) offers the possibility to link your own implementation of the calculation of partial resonance widths, to make it a part of the normal process generation machinery, without having to recompile the bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) Pythia library itself.  This allows the decay of new resonances to be handled internally, when combined with new particle data. Note that the decay of normal hadrons cannot be modeled here; this is for New Physics resonances. The rules for constructing your own class from the bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) ResonanceWidths base class are described bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) here. You may call this routine repeatedly, to add as many new resonances as you wish. bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) pointer to a bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) ResonanceWidths -derived object. This object must be instantiated by you in your program. bool Pythia::setResonancePtr( ResonanceWidths* resonancePtr) Note: The method currently always returns true."},{"name":"bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr)","link":"ProgramFlow.html#anchor16","text":"bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) offers the possibility to link to an external random number generator. The rules for constructing your own class from the bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) RndmEngine base class are described bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) here. bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) pointer to a bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) RndmEngine -derived object. This object must be instantiated by you in your program. bool Pythia::setRndmEnginePtr( RndmEngine* rndmEnginePtr) Note: The method returns true if the pointer is different from 0."},{"name":"bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0)","link":"ProgramFlow.html#anchor22","text":"bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) offers the possibility to link your own parton shower routines as replacements for the default ones. This is much more complicated since the showers are so central and are so interlinked with other parts of the program. Therefore it is also possible to do the replacement in stages, from the more independent to the more intertwined. The rules for constructing your own classes from the bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) TimeShower and bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) SpaceShower base classes are described bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) here. These objects must be instantiated by you in your program. bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) pointer to a bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) TimeShower -derived object for doing timelike shower evolution in resonance decays, e.g. of a bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) Z^0. This is decoupled from beam remnants and parton distributions, and is therefore the simplest kind of shower to write. If you provide a value 0 then the internal shower routine will be used. bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) pointer to a bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) TimeShower -derived object for doing all other timelike shower evolution, which is normally interleaved with multiparton interactions and spacelike showers, introducing both further physics and further technical issues. If you retain the default value 0 then the internal shower routine will be used. You are allowed to use the same pointer as above for the bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) timesDecPtr if the same shower can fulfill both tasks. bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) pointer to a bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) SpaceShower -derived object for doing all spacelike shower evolution, which is normally interleaved with multiparton interactions and timelike showers. If you retain the default value 0 then the internal shower routine will be used. bool Pythia::setShowerPtr( TimeShower* timesDecPtr,  TimeShower* timesPtr = 0, SpaceShower* spacePtr = 0) Note: The method currently always returns true."},{"name":"bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0)","link":"ProgramFlow.html#anchor20","text":"bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) offers the possibility to link your own implementation of a process and its cross section, to make it a part of the normal process generation machinery, without having to recompile the bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) Pythia library itself.  The rules for constructing your own class from the bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) SigmaProcess base class are described bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) here. You may call this routine repeatedly, to add as many new processes as you wish. bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) pointer to a bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) SigmaProcess -derived object. This object must be instantiated by you in your program. bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) pointer to a bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) PhaseSpace -derived object. When not provided the internal phase-space selection machinery wll be used. Then bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) sigmaPtr should be an instance of a class derived from one of the bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) Sigma1Process , bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) Sigma2Process and bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) Sigma3Process classes for 1-, 2- and 3- particle production, in their turn derived from bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) SigmaProcess. When provided, this object must be instantiated by you in your program. bool Pythia::setSigmaPtr( SigmaProcess* sigmaPtr,  PhaseSpace* phaseSpacePtrIn = 0) Note: The method currently always returns true."},{"name":"bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr)","link":"ProgramFlow.html#anchor17","text":"bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) offers the possibility to interact with the generation process at a few different specified points, e.g. to reject undesirable events at an early stage to save computer time. The rules for constructing your own class from the bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) UserHooks base class are described bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) here. You can only hand in one such pointer, but this may be to a class that implements several of the different allowed possibilities. bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) pointer to a bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) userHooks -derived object. This object must be instantiated by you in your program. bool Pythia::setUserHooksPtr( UserHooks* userHooksPtr) Note: The method currently always returns true."},{"name":"bool ResonanceWidths::allowCalc()","link":"SemiInternalResonances.html#anchor5","text":"bool ResonanceWidths::allowCalc() can normally be left dummy (and then always returns bool ResonanceWidths::allowCalc() true ) but can optionally be used to determine whether to force dynamical width calculation to be switched off (return bool ResonanceWidths::allowCalc() false ). An example is provided by the bool ResonanceWidths::allowCalc() SUSYResonanceWidths class, in which the implementation of this method checks for the existence of SLHA decay tables for the particular resonance in question, and checks if those tables should be given precedence over the internal width calculation."},{"name":"bool ResonanceWidths::initBSM()","link":"SemiInternalResonances.html#anchor6","text":"bool ResonanceWidths::initBSM() can normally be left dummy, but for advanced implementations it provides a possibility to initialize data members of the derived class at a very early stage during initialization, before any of the other members are called. An example is provided by the bool ResonanceWidths::initBSM() SUSYResonanceWidths class, in which an internal pointer to a derived bool ResonanceWidths::initBSM() Couplings class must be (re)set before any of the other methods are used. A return value of bool ResonanceWidths::initBSM() false can be used to signal that this initialization step failed."},{"name":"bool Rndm::dumpState(string fileName)","link":"RandomNumbers.html#anchor12","text":"bool Rndm::dumpState(string fileName) save the current state of the random number generator to a binary file. This involves two integers and 100 double-precision numbers. Intended for debug purposes. Note that binary files may be platform-dependent and thus not transportable."},{"name":"bool Rndm::readState(string fileName)","link":"RandomNumbers.html#anchor13","text":"bool Rndm::readState(string fileName) set the state of the random number generator by reading in a binary file saved by the above command. Comments as above."},{"name":"bool Rndm::rndmEnginePtr( RndmEngine* rndmPtr)","link":"RandomNumbers.html#anchor4","text":"bool Rndm::rndmEnginePtr( RndmEngine* rndmPtr) pass in pointer for external random number generation."},{"name":"bool Settings::flag(string key)","link":"SettingsScheme.html#anchor33","text":"bool Settings::flag(string key)"},{"name":"bool Settings::flagDefault(string key)","link":"SettingsScheme.html#anchor41","text":"bool Settings::flagDefault(string key)"},{"name":"bool Settings::getIsInit()","link":"SettingsScheme.html#anchor77","text":"bool Settings::getIsInit() return true if the database has been initialized, else false."},{"name":"bool Settings::init(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;,  bool append = false)","link":"SettingsScheme.html#anchor3","text":"bool Settings::init(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;,  bool append = false) read in the settings database. bool Settings::init(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;,  bool append = false) read in the settings from all the files listed in this file, and assumed to be located in the same subdirectory. bool Settings::init(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;,  bool append = false) By default nothing is done if the method has already been called once. If true the further settings read in are added to the current database. bool Settings::init(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;,  bool append = false) Note: The method returns false if it fails."},{"name":"bool Settings::initPtr(Info* infoPtrIn)","link":"SettingsScheme.html#anchor2","text":"bool Settings::initPtr(Info* infoPtrIn) initialize pointer to error-message database. Internal."},{"name":"bool Settings::isFlag(string key)","link":"SettingsScheme.html#anchor17","text":"bool Settings::isFlag(string key)"},{"name":"bool Settings::isFVec(string key)","link":"SettingsScheme.html#anchor21","text":"bool Settings::isFVec(string key)"},{"name":"bool Settings::isMode(string key)","link":"SettingsScheme.html#anchor18","text":"bool Settings::isMode(string key)"},{"name":"bool Settings::isMVec(string key)","link":"SettingsScheme.html#anchor22","text":"bool Settings::isMVec(string key)"},{"name":"bool Settings::isParm(string key)","link":"SettingsScheme.html#anchor19","text":"bool Settings::isParm(string key)"},{"name":"bool Settings::isPVec(string key)","link":"SettingsScheme.html#anchor23","text":"bool Settings::isPVec(string key)"},{"name":"bool Settings::isWord(string key)","link":"SettingsScheme.html#anchor20","text":"bool Settings::isWord(string key)"},{"name":"bool Settings::isWVec(string key)","link":"SettingsScheme.html#anchor24","text":"bool Settings::isWVec(string key) return true if an entry of the given name and kind exists, else false."},{"name":"bool Settings::onlySoftQCD()","link":"SettingsScheme.html#anchor80","text":"bool Settings::onlySoftQCD() return true if the only processes switched on for generation belong to the bool Settings::onlySoftQCD() SoftQCD category, else false. Since the method contains a hardcoding of what other process types exist, in order to detect if any is on, it could be broken by the addition of new internal processes. It is therefore mainly useful for warning purposes, not for hard decisions."},{"name":"bool Settings::readingFailed()","link":"SettingsScheme.html#anchor78","text":"bool Settings::readingFailed() return true if some input could not be parsed, else false."},{"name":"bool Settings::readString(string line, bool warn = true)","link":"SettingsScheme.html#anchor6","text":"bool Settings::readString(string line, bool warn = true) read in a string, and change the relevant quantity in the database. It is normally used indirectly, via bool Settings::readString(string line, bool warn = true) Pythia::readString(...) and bool Settings::readString(string line, bool warn = true) Pythia::readFile(...). bool Settings::readString(string line, bool warn = true) the string to be interpreted as an instruction. bool Settings::readString(string line, bool warn = true) write a warning message or not whenever the instruction does not make sense, e.g. if the variable does not exist in the databases. bool Settings::readString(string line, bool warn = true) Note: the method returns false if it fails to make sense out of the input string."},{"name":"bool Settings::reInit(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;)","link":"SettingsScheme.html#anchor5","text":"bool Settings::reInit(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;) overwrite the existing database. bool Settings::reInit(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;) read in the settings from all the files listed in this file, and assumed to be located in the same subdirectory. bool Settings::reInit(string  startFile = &quot;../share/Pythia8/xmldoc/Index.xml&quot;) Note: The method returns false if it fails."},{"name":"bool Settings::unfinishedInput()","link":"SettingsScheme.html#anchor79","text":"bool Settings::unfinishedInput() return true if input of a vector has been begun with am open brace { but no matching closing brace } has been found (so far), else false."},{"name":"bool Settings::writeFile(ostream& os = cout,  bool writeAll = false)","link":"SettingsScheme.html#anchor8","text":"bool Settings::writeFile(ostream& os = cout,  bool writeAll = false) write current settings to a file or to an bool Settings::writeFile(ostream& os = cout,  bool writeAll = false) ostream. bool Settings::writeFile(ostream& os = cout,  bool writeAll = false) file or stream on which settings are written. bool Settings::writeFile(ostream& os = cout,  bool writeAll = false) normally only settings that have been changed are written, but if true then all settings are output. bool Settings::writeFile(ostream& os = cout,  bool writeAll = false) Note: the method returns false if it fails."},{"name":"bool Settings::writeFile(string toFile,  bool writeAll = false)","link":"SettingsScheme.html#anchor7","text":"bool Settings::writeFile(string toFile,  bool writeAll = false)"},{"name":"bool Settings::writeFileXML(ostream& os = cout)","link":"SettingsScheme.html#anchor9","text":"bool Settings::writeFileXML(ostream& os = cout) write out the information stored in xmldoc to be used later to initialize Settings through an input stream."},{"name":"bool SigmaProcess::convert2mb()","link":"SemiInternalProcesses.html#anchor15","text":"bool SigmaProcess::convert2mb() it is assumed that cross sections normally come in dimensions such that they, when integrated over the relevant phase space, obtain the dimension GeV^-2, and therefore need to be converted to mb. If the cross section is already encoded as mb then bool SigmaProcess::convert2mb() convert2mb() should be overloaded to instead return bool SigmaProcess::convert2mb() false."},{"name":"bool SigmaProcess::convertM2()","link":"SemiInternalProcesses.html#anchor16","text":"bool SigmaProcess::convertM2() it is assumed that bool SigmaProcess::convertM2() 2 &rarr; 1 cross sections are encoded as bool SigmaProcess::convertM2() sigmaHat(sHat) , and bool SigmaProcess::convertM2() 2 &rarr; 2 ones as bool SigmaProcess::convertM2() d(sigmaHat)/d(tHat) in the bool SigmaProcess::convertM2() SigmaProcess::sigmaHat() methods. If bool SigmaProcess::convertM2() convertM2() is overloaded to instead return bool SigmaProcess::convertM2() true then the return value is instead assumed to be the squared matrix element bool SigmaProcess::convertM2() |M|^2 , and bool SigmaProcess::convertM2() SigmaProcess::sigmaHatWrap(...) converts to bool SigmaProcess::convertM2() sigmaHat(sHat) or bool SigmaProcess::convertM2() d(sigmaHat)/d(tHat) , respectively. This switch has no effect on bool SigmaProcess::convertM2() 2 &rarr; 3 processes, where bool SigmaProcess::convertM2() |M|^2 is the only allowed input anyway."},{"name":"bool SigmaProcess::isSChannel()","link":"SemiInternalProcesses.html#anchor22","text":"bool SigmaProcess::isSChannel() normally the choice of renormalization and factorization scales in bool SigmaProcess::isSChannel() 2 &rarr; 2 and bool SigmaProcess::isSChannel() 2 &rarr; 3 processes is based on the assumption that bool SigmaProcess::isSChannel() t - and bool SigmaProcess::isSChannel() u -channel exchanges dominates the cross section. In cases such as bool SigmaProcess::isSChannel() f fbar &rarr; gamma* &rarr; f' fbar' a bool SigmaProcess::isSChannel() 2 &rarr; 2 process actually ought to be given scales as a bool SigmaProcess::isSChannel() 2 &rarr; 1 one, in the sense that it proceeds entirely through an bool SigmaProcess::isSChannel() s -channel resonance. This can be achieved if you override the default bool SigmaProcess::isSChannel() false to return bool SigmaProcess::isSChannel() true. See further the page on bool SigmaProcess::isSChannel() couplings and scales."},{"name":"bool SigmaProcess::setupForME()","link":"SemiInternalProcesses.html#anchor8","text":"bool SigmaProcess::setupForME() to be called by the user from inside bool SigmaProcess::setupForME() sigmaHat() (or possibly bool SigmaProcess::setupForME() sigmaKin() ) to setup alternative kinematics in the bool SigmaProcess::setupForME() mME[5] and bool SigmaProcess::setupForME() pME[5] arrays, better suited for matrix-element calculations. See the end of the previous section for a more detailed description. Should the method return bool SigmaProcess::setupForME() false then the conversion did not work, and bool SigmaProcess::setupForME() sigmaHat() (or bool SigmaProcess::setupForME() sigmaKin() ) should be set to vanish."},{"name":"bool SigmaProcess::useMirrorWeight()","link":"SemiInternalProcesses.html#anchor29","text":"bool SigmaProcess::useMirrorWeight() in bool SigmaProcess::useMirrorWeight() 2 &rarr; 3 processes the phase space selection used here involves a twofold ambiguity basically corresponding to a flipping of the positions of last two outgoing particles. These are assumed equally likely by default, bool SigmaProcess::useMirrorWeight() false , but for processes proceeding entirely through bool SigmaProcess::useMirrorWeight() t -channel exchange the Monte Carlo efficiency can be improved by making a preselection based on the relative propagator weights, bool SigmaProcess::useMirrorWeight() true."},{"name":"bool SlowJet::analyze( const Event& event)","link":"EventAnalysis.html#anchor43","text":"bool SlowJet::analyze( const Event& event) performs a jet finding analysis, where bool SlowJet::analyze( const Event& event) is an object of the bool SlowJet::analyze( const Event& event) Event class, most likely the bool SlowJet::analyze( const Event& event) pythia.event one. bool SlowJet::analyze( const Event& event) If the routine returns bool SlowJet::analyze( const Event& event) false the analysis failed, but currently this is not foreseen ever to happen."},{"name":"bool SlowJet::doNSteps(int nStep)","link":"EventAnalysis.html#anchor59","text":"bool SlowJet::doNSteps(int nStep) calls the bool SlowJet::doNSteps(int nStep) doStep() method bool SlowJet::doNSteps(int nStep) nStep times, if possible. Will return bool SlowJet::doNSteps(int nStep) false if the list of clusters is emptied before then. The stored jet information is still perfectly fine; it is only the number of steps that is wrong. Will also return bool SlowJet::doNSteps(int nStep) false if bool SlowJet::doNSteps(int nStep) useFJcore = true."},{"name":"bool SlowJet::doStep()","link":"EventAnalysis.html#anchor58","text":"bool SlowJet::doStep() do the next step of the clustering. This can either be that two clusters are joined to one, or that a cluster is promoted to a jet (which is discarded if its bool SlowJet::doStep() pT value is below bool SlowJet::doStep() pTjetMin ). bool SlowJet::doStep() The routine will only return bool SlowJet::doStep() false if there are no clusters left, or if bool SlowJet::doStep() useFJcore = true."},{"name":"bool SlowJet::setup( const Event& event)","link":"EventAnalysis.html#anchor57","text":"bool SlowJet::setup( const Event& event) selects the particles to be analyzed, calculates initial distances, and finds the initial smallest distance. bool SlowJet::setup( const Event& event) is an object of the bool SlowJet::setup( const Event& event) Event class, most likely the bool SlowJet::setup( const Event& event) pythia.event one. bool SlowJet::setup( const Event& event) If the routine returns bool SlowJet::setup( const Event& event) false the setup failed, but currently this is not foreseen ever to happen."},{"name":"bool SlowJet::stopAtN(int nStop)","link":"EventAnalysis.html#anchor60","text":"bool SlowJet::stopAtN(int nStop) calls the bool SlowJet::stopAtN(int nStop) doStep() method until a total of bool SlowJet::stopAtN(int nStop) nStop jet and cluster objects remain. Will return bool SlowJet::stopAtN(int nStop) false if this is not possible, specifically if the number of objects already is smaller than bool SlowJet::stopAtN(int nStop) nStop when the method is called. The stored jet and cluster information is still perfectly fine; it only does not have the expected multiplicity. Will also return bool SlowJet::stopAtN(int nStop) false if bool SlowJet::stopAtN(int nStop) useFJcore = true."},{"name":"bool SpaceShower::doRestart()","link":"ImplementNewShowers.html#anchor39","text":"bool SpaceShower::doRestart() This method is not virtual. If bool SpaceShower::doRestart() branch(...) above fails to construct a branching, and the conditions are such that the whole parton-level description should be restarted, then it should return true, else not. Currently only the rescattering description can give this kind of failures, and so the internal bool SpaceShower::doRestart() rescatterFail boolean must be set true when this should happen, and else false."},{"name":"bool SpaceShower::getHasWeaklyRadiated()","link":"ImplementNewShowers.html#anchor40","text":"bool SpaceShower::getHasWeaklyRadiated() This method is not virtual. It is used to tell whether a weak gauge boson has been emitted in the shower evolution."},{"name":"bool Sphericity::analyze( const Event& event)","link":"EventAnalysis.html#anchor2","text":"bool Sphericity::analyze( const Event& event) perform a sphericity analysis, where bool Sphericity::analyze( const Event& event) is an object of the bool Sphericity::analyze( const Event& event) Event class, most likely the bool Sphericity::analyze( const Event& event) pythia.event one. bool Sphericity::analyze( const Event& event) If the routine returns bool Sphericity::analyze( const Event& event) false the analysis failed, e.g. if too few particles are present to analyze."},{"name":"bool Thrust::analyze( const Event& event)","link":"EventAnalysis.html#anchor10","text":"bool Thrust::analyze( const Event& event) perform a thrust analysis, where bool Thrust::analyze( const Event& event) is an object of the bool Thrust::analyze( const Event& event) Event class, most likely the bool Thrust::analyze( const Event& event) pythia.event one. bool Thrust::analyze( const Event& event) If the routine returns bool Thrust::analyze( const Event& event) false the analysis failed, e.g. if too few particles are present to analyze."},{"name":"bool TimeShower::getHasWeaklyRadiated()","link":"ImplementNewShowers.html#anchor19","text":"bool TimeShower::getHasWeaklyRadiated() This method is not virtual. It is used to tell whether a weak gauge boson has been emitted in the shower evolution."},{"name":"CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0)","link":"EventAnalysis.html#anchor28","text":"CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) create a CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) CellJet instance, where CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) the maximum +-pseudorapidity that the detector is assumed to cover. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) the number of equal-sized bins that the CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) +-etaMax range is assumed to be divided into. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) the number of equal-sized bins that the CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) phi range CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) +-pi is assumed to be divided into. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) tells which particles are analyzed, CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) all final-state particles, CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) isVisible() particle method), and CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) only charged final-state particles. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) strategy to smear the actual CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) eT bin by bin, CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) no smearing, CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) smear the CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) eT according to a Gaussian with width CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) resolution * sqrt(eT) , with the Gaussian truncated at 0 and CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) upperCut * eT , CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) smear the CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) e = eT * cosh(eta) according to a Gaussian with width CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) resolution * sqrt(e) , with the Gaussian truncated at 0 and CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) upperCut * e. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) see above. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) see above. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) completely neglect all bins with an CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) eT < threshold. CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) the random-number generator used to select the smearing described above. Must be handed in for smearing to be possible. If your CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) Pythia class instance is named CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) pythia , then CellJet::CellJet(double etaMax = 5., int nEta = 50,  int nPhi = 32, int select = 2, int smear = 0, double resolution = 0.5,  double upperCut = 2., double threshold = 0., Rndm* rndmPtr = 0) &pythia.rndm would be the logical choice."},{"name":"ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0)","link":"EventAnalysis.html#anchor19","text":"ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) performs a jet finding analysis, where ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) is an object of the ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) Event class, most likely the ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pythia.event one. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) is the cutoff joining scale, below which jets are joined. Is given in quadratic dimensionless quantities. Either ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) yScale or ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pTscale must be set nonvanishing, and the larger of the two dictates the actual value. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) is the cutoff joining scale, below which jets are joined. Is given in linear quantities, such as ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pT or ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) m depending on the measure used, but always in units of GeV. Either ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) yScale or ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pTscale must be set nonvanishing, and the larger of the two dictates the actual value. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) the minimum number of jets to be reconstructed. If used, it can override the ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) yScale and ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pTscale values. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) the maximum number of jets to be reconstructed. Is not used if below ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) nJetMin. If used, it can override the ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) yScale and ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) pTscale values. Thus e.g. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) nJetMin = nJetMax = 3 can be used to reconstruct exactly 3 jets. ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) If the routine returns ClusterJet::analyze( const Event& event, double yScale,  double pTscale, int nJetMin = 1, int nJetMax = 0) false the analysis failed, e.g. because the number of particles was smaller than the minimum number of jets requested."},{"name":"ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false)","link":"EventAnalysis.html#anchor18","text":"ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) create a ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) ClusterJet instance, where ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) distance measure, to be provided as a character string (actually, only the first character is necessary) ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) the Lund ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) pT distance, ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) the JADE mass distance, and ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) the Durham ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) kT measure. ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) tells which particles are analyzed, ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) all final-state particles, ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) isVisible() particle method), and ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) only charged final-state particles. ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) masses assumed for the particles used in the analysis ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) all massless, ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) photons are massless while all others are assigned the ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) pi+- mass, and ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) all given their correct masses. ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) perform or not a early preclustering step, where nearby particles are lumped together so as to speed up the subsequent normal clustering. ClusterJet::ClusterJet(string measure = &quot;Lund&quot;,  int select = 2, int massSet = 2, bool precluster = false,  bool reassign = false) reassign all particles to the nearest jet each time after two jets have been joined."},{"name":"const DecayChannel& ParticleDataEntry::channel(int i)","link":"ParticleDataScheme.html#anchor158","text":"const DecayChannel& ParticleDataEntry::channel(int i) gain access to a specified channel in the decay table."},{"name":"const Particle& Event::operator[](int i)","link":"EventRecord.html#anchor2","text":"const Particle& Event::operator[](int i) returns a ( const Particle& Event::operator[](int i) const ) reference to the const Particle& Event::operator[](int i) i 'th particle in the event record, which can be used to get (or set) all the const Particle& Event::operator[](int i) properties of this particle."},{"name":"const ParticleDataEntry* ParticleData::findParticle(int id)","link":"ParticleDataScheme.html#anchor27","text":"const ParticleDataEntry* ParticleData::findParticle(int id) query whether the particle data table contains the particle of the identity code, and if so return a (const) iterator to it."},{"name":"CoupSM Pythia::coupSM","link":"ProgramFlow.html#anchor49","text":"CoupSM Pythia::coupSM Standard Model couplings and mixing matrices, see CoupSM Pythia::coupSM here for further details."},{"name":"CoupSM::CoupSM()","link":"StandardModelParameters.html#anchor16","text":"CoupSM::CoupSM() the constructor does nothing. Internal."},{"name":"DecayChannel& operator=( const DecayChannel& decayChannelIn)","link":"ParticleDataScheme.html#anchor172","text":"DecayChannel& operator=( const DecayChannel& decayChannelIn) copy the values stored in an existing DecayChannel& operator=( const DecayChannel& decayChannelIn) DecayChannel object."},{"name":"DecayChannel& ParticleDataEntry::channel(int i)","link":"ParticleDataScheme.html#anchor157","text":"DecayChannel& ParticleDataEntry::channel(int i)"},{"name":"DecayChannel& ParticleDataEntry::pickChannel()","link":"ParticleDataScheme.html#anchor161","text":"DecayChannel& ParticleDataEntry::pickChannel() pick a decay channel according to branching ratios from DecayChannel& ParticleDataEntry::pickChannel() preparePick."},{"name":"DecayChannel::DecayChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0, int prod7 = 0)","link":"ParticleDataScheme.html#anchor171","text":"DecayChannel::DecayChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0, int prod7 = 0) the constructor for a decay channel. Internal."},{"name":"double AlpgenPar::getParam(const string &amp;paramIn)","link":"AlpgenEventInterface.html#anchor12","text":"double AlpgenPar::getParam(const string &amp;paramIn)"},{"name":"double CellJet::eT(i)","link":"EventAnalysis.html#anchor31","text":"double CellJet::eT(i) gives the double CellJet::eT(i) eT of the double CellJet::eT(i) i 'th jet, where jets have been ordered with decreasing double CellJet::eT(i) eT values,"},{"name":"double CellJet::etaCenter(int i)","link":"EventAnalysis.html#anchor32","text":"double CellJet::etaCenter(int i)"},{"name":"double CellJet::etaWeighted(int i)","link":"EventAnalysis.html#anchor34","text":"double CellJet::etaWeighted(int i)"},{"name":"double CellJet::m(int i)","link":"EventAnalysis.html#anchor39","text":"double CellJet::m(int i) gives the invariant mass of the double CellJet::m(int i) i 'th jet, defined by the double CellJet::m(int i) pMassive above,"},{"name":"double CellJet::phiCenter(int i)","link":"EventAnalysis.html#anchor33","text":"double CellJet::phiCenter(int i) gives the double CellJet::phiCenter(int i) eta and double CellJet::phiCenter(int i) phi coordinates of the geometrical center of the double CellJet::phiCenter(int i) i 'th jet,"},{"name":"double CellJet::phiWeighted(int i)","link":"EventAnalysis.html#anchor35","text":"double CellJet::phiWeighted(int i) gives the double CellJet::phiWeighted(int i) eta and double CellJet::phiWeighted(int i) phi coordinates of the double CellJet::phiWeighted(int i) eT -weighted center of the double CellJet::phiWeighted(int i) i 'th jet,"},{"name":"double ClusterJet::distance(int i)","link":"EventAnalysis.html#anchor26","text":"double ClusterJet::distance(int i) clustering scales, with double ClusterJet::distance(int i) distance(0) being the most recent one, i.e. normally the highest, up to double ClusterJet::distance(int i) distance(4) being the fifth most recent. That is, with double ClusterJet::distance(int i) n being the final number of jets, double ClusterJet::distance(int i) ClusterJet::size() , the scales at which double ClusterJet::distance(int i) n+1 jets become double ClusterJet::distance(int i) n , double ClusterJet::distance(int i) n+2 become double ClusterJet::distance(int i) n+1 , and so on till double ClusterJet::distance(int i) n+5 become double ClusterJet::distance(int i) n+4. Nonexisting clustering scales are returned as zero. The physical interpretation of a scale is as provided by the respective distance measure (Lund, JADE, Durham)."},{"name":"double CoupSM::af(int idAbs)","link":"StandardModelParameters.html#anchor31","text":"double CoupSM::af(int idAbs) the vector and axial charges of a fermion, by the absolute sign of the PDF code ( double CoupSM::af(int idAbs) a_f = +-1, v_f = a_f - 4. * sin2thetaWbar * e_f )."},{"name":"double CoupSM::af2(int idAbs)","link":"StandardModelParameters.html#anchor37","text":"double CoupSM::af2(int idAbs)"},{"name":"double CoupSM::alphaEM(double scale2)","link":"StandardModelParameters.html#anchor24","text":"double CoupSM::alphaEM(double scale2) the double CoupSM::alphaEM(double scale2) alpha_em value at the quadratic scale double CoupSM::alphaEM(double scale2) scale2."},{"name":"double CoupSM::alphaS(double scale2)","link":"StandardModelParameters.html#anchor18","text":"double CoupSM::alphaS(double scale2) the double CoupSM::alphaS(double scale2) alpha_strong value at the quadratic scale double CoupSM::alphaS(double scale2) scale2."},{"name":"double CoupSM::alphaS1Ord(double scale2)","link":"StandardModelParameters.html#anchor19","text":"double CoupSM::alphaS1Ord(double scale2) a first-order overestimate of the full second-order double CoupSM::alphaS1Ord(double scale2) alpha_strong value at the quadratic scale double CoupSM::alphaS1Ord(double scale2) scale2."},{"name":"double CoupSM::alphaS2OrdCorr(double scale2)","link":"StandardModelParameters.html#anchor20","text":"double CoupSM::alphaS2OrdCorr(double scale2) a multiplicative correction factor, below unity, that brings the first-order overestimate above into agreement with the full second-order double CoupSM::alphaS2OrdCorr(double scale2) alpha_strong value at the quadratic scale double CoupSM::alphaS2OrdCorr(double scale2) scale2."},{"name":"double CoupSM::cos2thetaW()","link":"StandardModelParameters.html#anchor26","text":"double CoupSM::cos2thetaW() the sine-squared and cosine-squared of the weak mixing angle, as used in the gauge-boson sector."},{"name":"double CoupSM::ef(int idAbs)","link":"StandardModelParameters.html#anchor29","text":"double CoupSM::ef(int idAbs) the electrical charge of a fermion, by the absolute sign of the PDF code, i.e. double CoupSM::ef(int idAbs) idAbs must be in the range between 1 and 18."},{"name":"double CoupSM::ef2(int idAbs)","link":"StandardModelParameters.html#anchor35","text":"double CoupSM::ef2(int idAbs)"},{"name":"double CoupSM::efvf(int idAbs)","link":"StandardModelParameters.html#anchor38","text":"double CoupSM::efvf(int idAbs)"},{"name":"double CoupSM::GF()","link":"StandardModelParameters.html#anchor28","text":"double CoupSM::GF() the Fermi constant of weak decays, in GeV double CoupSM::GF() ^-2."},{"name":"double CoupSM::Lambda3()","link":"StandardModelParameters.html#anchor21","text":"double CoupSM::Lambda3()"},{"name":"double CoupSM::Lambda4()","link":"StandardModelParameters.html#anchor22","text":"double CoupSM::Lambda4()"},{"name":"double CoupSM::Lambda5()","link":"StandardModelParameters.html#anchor23","text":"double CoupSM::Lambda5() the three-, four-, and five-flavour double CoupSM::Lambda5() Lambda scale."},{"name":"double CoupSM::lf(int idAbs)","link":"StandardModelParameters.html#anchor33","text":"double CoupSM::lf(int idAbs)"},{"name":"double CoupSM::rf(int idAbs)","link":"StandardModelParameters.html#anchor34","text":"double CoupSM::rf(int idAbs) the weak isospin, left- and righthanded charges of a fermion, by the absolute sign of the PDF code ( double CoupSM::rf(int idAbs) t^3_f = a_f/2, l_f = (v_f + a_f)/2, r_f = (v_f - a_f)/2 ; you may find other conventions in the literature that differ by a factor of 2)."},{"name":"double CoupSM::sin2thetaW()","link":"StandardModelParameters.html#anchor25","text":"double CoupSM::sin2thetaW()"},{"name":"double CoupSM::sin2thetaWbar()","link":"StandardModelParameters.html#anchor27","text":"double CoupSM::sin2thetaWbar() the sine-squared of the weak mixing angle, as used to derive the vector couplings of fermions to the double CoupSM::sin2thetaWbar() Z^0."},{"name":"double CoupSM::t3f(int idAbs)","link":"StandardModelParameters.html#anchor32","text":"double CoupSM::t3f(int idAbs)"},{"name":"double CoupSM::V2CKMgen(int genU, int genD)","link":"StandardModelParameters.html#anchor41","text":"double CoupSM::V2CKMgen(int genU, int genD) the CKM mixing element,or the square of it, for up-type generation index double CoupSM::V2CKMgen(int genU, int genD) genU ( double CoupSM::V2CKMgen(int genU, int genD) 1 = u, 2 = c, 3 = t, 4 = t' ) and down-type generation index double CoupSM::V2CKMgen(int genU, int genD) genD ( double CoupSM::V2CKMgen(int genU, int genD) 1 = d, 2 = s, 3 = b, 4 = b' )."},{"name":"double CoupSM::V2CKMid(int id1, int id2)","link":"StandardModelParameters.html#anchor43","text":"double CoupSM::V2CKMid(int id1, int id2) the CKM mixing element,or the square of it, for flavours double CoupSM::V2CKMid(int id1, int id2) id1 and double CoupSM::V2CKMid(int id1, int id2) id2 , both in the range from double CoupSM::V2CKMid(int id1, int id2) -18 to double CoupSM::V2CKMid(int id1, int id2) +18. The sign is here not checked (so it can be used both for double CoupSM::V2CKMid(int id1, int id2) u + dbar &rarr; W+ and double CoupSM::V2CKMid(int id1, int id2) u &rarr; d + W+ , say), but impossible flavour combinations evaluate to zero. The neutrino sector is numbered by flavor eigenstates, so there is no mixing in the lepton-neutrino system."},{"name":"double CoupSM::V2CKMsum(int id)","link":"StandardModelParameters.html#anchor44","text":"double CoupSM::V2CKMsum(int id) the sum of squared CKM mixing element that a given flavour can couple to, excluding the top quark and fourth generation. Is close to unity for the first two generations. Returns unity for the lepton-neutrino sector."},{"name":"double CoupSM::VCKMgen(int genU, int genD)","link":"StandardModelParameters.html#anchor40","text":"double CoupSM::VCKMgen(int genU, int genD)"},{"name":"double CoupSM::VCKMid(int id1, int id2)","link":"StandardModelParameters.html#anchor42","text":"double CoupSM::VCKMid(int id1, int id2)"},{"name":"double CoupSM::vf(int idAbs)","link":"StandardModelParameters.html#anchor30","text":"double CoupSM::vf(int idAbs)"},{"name":"double CoupSM::vf2(int idAbs)","link":"StandardModelParameters.html#anchor36","text":"double CoupSM::vf2(int idAbs)"},{"name":"double CoupSM::vf2af2(int idAbs)","link":"StandardModelParameters.html#anchor39","text":"double CoupSM::vf2af2(int idAbs) common quadratic combinations of the above couplings: double CoupSM::vf2af2(int idAbs) e_f^2, v_f^2, a_f^2, e_f * v_f, v_f^2 + a_f^2."},{"name":"double DecayChannel::bRatio()","link":"ParticleDataScheme.html#anchor176","text":"double DecayChannel::bRatio() set or get the branching ratio of the channel. Second argument only for internal use."},{"name":"double DecayChannel::currentBR()","link":"ParticleDataScheme.html#anchor190","text":"double DecayChannel::currentBR() set or get the current branching ratio, taking into account on/off switches and dynamic width for resonances. For internal use."},{"name":"double DecayChannel::onShellWidth()","link":"ParticleDataScheme.html#anchor192","text":"double DecayChannel::onShellWidth() set or get the current partial width of the channel; intended for resonances where the widths are recalculated based on the current resonance mass. For internal use."},{"name":"double DecayChannel::openSec(nt idSgn)","link":"ParticleDataScheme.html#anchor195","text":"double DecayChannel::openSec(nt idSgn) set or get the fraction of secondary open widths, separately for positive and negative particles. For internal use."},{"name":"double Event::detaAbs(int i1, int i2)","link":"EventRecord.html#anchor35","text":"double Event::detaAbs(int i1, int i2)"},{"name":"double Event::dphiAbs(int i1, int i2)","link":"EventRecord.html#anchor36","text":"double Event::dphiAbs(int i1, int i2)"},{"name":"double Event::dyAbs(int i1, int i2)","link":"EventRecord.html#anchor34","text":"double Event::dyAbs(int i1, int i2)"},{"name":"double Event::REtaPhi(int i1, int i2)","link":"EventRecord.html#anchor38","text":"double Event::REtaPhi(int i1, int i2) return the separation between two particles in the event record, in true rapidity, in pseudorapidity, in phi angle, and in the double Event::REtaPhi(int i1, int i2) R combination of true or pseudorapidity with phi, when required with absolute sign so as to avoid negative numbers."},{"name":"double Event::RRapPhi(int i1, int i2)","link":"EventRecord.html#anchor37","text":"double Event::RRapPhi(int i1, int i2)"},{"name":"double Event::scale()","link":"EventRecord.html#anchor9","text":"double Event::scale() set or get the scale (in GeV) of the hardest process in the event. Matches the function of the double Event::scale() scale variable in the double Event::scale() Les Houches Accord."},{"name":"double Event::scaleSecond()","link":"EventRecord.html#anchor11","text":"double Event::scaleSecond() set or get the scale (in GeV) of a second hard process in the event, in those cases where such a one double Event::scaleSecond() has been requested."},{"name":"double getEnhancedEventWeight()","link":"UserHooks.html#anchor45","text":"double getEnhancedEventWeight() If you use enhanced emissions, it is paramount to attribute a corrective weight to each event containing enhanced emissions. This function returns this weight. In the presence of enhancements, all histograms and output events must account for this weight."},{"name":"double Hist::getBinContent(int iBin)","link":"Histograms.html#anchor22","text":"double Hist::getBinContent(int iBin) return the value in bin double Hist::getBinContent(int iBin) iBin , ranging from 1 through double Hist::getBinContent(int iBin) numberOfBins , with double Hist::getBinContent(int iBin) 0 for underflow and double Hist::getBinContent(int iBin) numberOfBins + 1 for overflow."},{"name":"double Hist::smallestAbsValue()","link":"Histograms.html#anchor27","text":"double Hist::smallestAbsValue() returns the smallest absolute value (above 1e-20, to sidestep bins with zero content) in any of the bins."},{"name":"double Info::a0MPI()","link":"EventInformation.html#anchor85","text":"double Info::a0MPI() The value of a0 when an x-dependent matter profile is used, double Info::a0MPI() MultipartonInteractions:bProfile = 4."},{"name":"double Info::alphaEM()","link":"EventInformation.html#anchor47","text":"double Info::alphaEM() the double Info::alphaEM() alpha_strong and double Info::alphaEM() alpha_electromagnetic values used for the hard process."},{"name":"double Info::alphaS()","link":"EventInformation.html#anchor46","text":"double Info::alphaS()"},{"name":"double Info::bMPI()","link":"EventInformation.html#anchor86","text":"double Info::bMPI() The impact parameter double Info::bMPI() b assumed for the current collision when multiparton interactions are simulated. Is not expressed in any physical size (like fm), but only rescaled so that the average should be unity for minimum-bias events (meaning less than that for events with hard processes)."},{"name":"double Info::bMPIold()","link":"EventInformation.html#anchor95","text":"double Info::bMPIold()"},{"name":"double Info::eA()","link":"EventInformation.html#anchor6","text":"double Info::eA()"},{"name":"double Info::eB()","link":"EventInformation.html#anchor7","text":"double Info::eB() the energies of the two beam particles."},{"name":"double Info::eCM()","link":"EventInformation.html#anchor10","text":"double Info::eCM()"},{"name":"double Info::eCMsub()","link":"EventInformation.html#anchor65","text":"double Info::eCMsub() Collision energy of the double Info::eCMsub() gamma-gamma sub-system."},{"name":"double Info::eMPI(int i)","link":"EventInformation.html#anchor94","text":"double Info::eMPI(int i) The enhancement or depletion of the rate of the double Info::eMPI(int i) i 'th subprocess. Is primarily of interest for the double Info::eMPI(int i) MultipartonInteractions:bProfile = 4 option, where the size of the proton depends on the double Info::eMPI(int i) x values of the colliding partons. Note that double Info::eMPI(int i) eMPI(0) = enhanceMPI()."},{"name":"double Info::enhanceMPI()","link":"EventInformation.html#anchor87","text":"double Info::enhanceMPI() The choice of impact parameter implies an enhancement or depletion of the rate of subsequent interactions, as given by this number. Again the average is normalized to be unity for minimum-bias events (meaning more than that for events with hard processes)."},{"name":"double Info::enhanceMPIavg()","link":"EventInformation.html#anchor88","text":"double Info::enhanceMPIavg() The average enhancement factor expected for hard processes, in those cases where it can be calculated already at initialization, i.e. excluding the double Info::enhanceMPIavg() x -dependent double Info::enhanceMPIavg() b profile. The normalization is here chosen to apply to cases with two hard interactions double Info::enhanceMPIavg() A and double Info::enhanceMPIavg() B preselected in the process level, and there multiplies double Info::enhanceMPIavg() sigma_A * sigma_B / sigma_{nondiff} to give the joint cross section. (Additional corrections from joint PDF weights somewhat reduce the final number.) The normalization is slightly different (typically around 5%) from the average of the double Info::enhanceMPIavg() enhanceMPI() method above, which instead is normalized to average value unity for nondiffractive events. As used internally the two are consistent."},{"name":"double Info::enhanceMPIold()","link":"EventInformation.html#anchor96","text":"double Info::enhanceMPIold()"},{"name":"double Info::enhanceMPIoldavg()","link":"EventInformation.html#anchor97","text":"double Info::enhanceMPIoldavg() These methods are only relevant for hard diffraction with the requirement of no MPI in the hadron-hadron collision. Then an impact parameter and associated enhancement factor is picked for this collision, but afterwards overwritten when the Pomeron-hadron subcollision is considered. In such cases the old hadron-hadron values can be found here, while double Info::enhanceMPIoldavg() bMPI , double Info::enhanceMPIoldavg() enhanceMPI and double Info::enhanceMPIoldavg() enhanceMPIavg provide the new Pomeron-hadron ones."},{"name":"double Info::getScalesAttribute(string key)","link":"EventInformation.html#anchor128","text":"double Info::getScalesAttribute(string key) Return the value of the double Info::getScalesAttribute(string key) <scales> tag's attribute named double Info::getScalesAttribute(string key) key. Not-a-number will be returned if the attribute named double Info::getScalesAttribute(string key) key does not exist."},{"name":"double Info::getWeightsCompressedValue(unsigned int n)","link":"EventInformation.html#anchor125","text":"double Info::getWeightsCompressedValue(unsigned int n)"},{"name":"double Info::getWeightsDetailedValue(string n)","link":"EventInformation.html#anchor122","text":"double Info::getWeightsDetailedValue(string n) Return the value of the n'th double Info::getWeightsDetailedValue(string n) <wgt> tag in the event."},{"name":"double Info::m3Hat()","link":"EventInformation.html#anchor57","text":"double Info::m3Hat()"},{"name":"double Info::m4Hat()","link":"EventInformation.html#anchor58","text":"double Info::m4Hat() the masses of the two outgoing particles in a double Info::m4Hat() 2 &rarr; 2 processes."},{"name":"double Info::mA()","link":"EventInformation.html#anchor8","text":"double Info::mA()"},{"name":"double Info::mB()","link":"EventInformation.html#anchor9","text":"double Info::mB() the masses of the two beam particles."},{"name":"double Info::mergingWeight()","link":"EventInformation.html#anchor83","text":"double Info::mergingWeight() combined leading-order merging weight assigned to the current event, if tree-level multi-jet merging (i.e. double Info::mergingWeight() CKKW-L or double Info::mergingWeight() UMEPS merging) is attempted. If tree-level multi-jet merging is performed, all histograms should be filled with this weight, as discussed in double Info::mergingWeight() CKKW-L Merging and double Info::mergingWeight() UMEPS Merging."},{"name":"double Info::mergingWeightNLO()","link":"EventInformation.html#anchor84","text":"double Info::mergingWeightNLO() combined NLO merging weight assigned to the current event, if NLO multi-jet merging (i.e. double Info::mergingWeightNLO() NL double Info::mergingWeightNLO() 3 or double Info::mergingWeightNLO() UNLOPS merging) is attempted. If NLO multi-jet merging is performed, all histograms should be filled with this weight, as discussed in double Info::mergingWeightNLO() NLO Merging."},{"name":"double Info::mHat()","link":"EventInformation.html#anchor51","text":"double Info::mHat()"},{"name":"double Info::pdf1()","link":"EventInformation.html#anchor42","text":"double Info::pdf1()"},{"name":"double Info::pdf2()","link":"EventInformation.html#anchor43","text":"double Info::pdf2() parton densities double Info::pdf2() x*f(x,Q^2) evaluated for the two incoming partons; could be used e.g. for reweighting purposes in conjunction with the double Info::pdf2() idpdf , double Info::pdf2() xpdf and double Info::pdf2() QFac methods. Events obtained from external programs or files may not contain this information and, if so, 0 is returned."},{"name":"double Info::phiHat()","link":"EventInformation.html#anchor60","text":"double Info::phiHat() the polar and azimuthal scattering angles in the rest frame of a double Info::phiHat() 2 &rarr; 2 process."},{"name":"double Info::pT2Hat()","link":"EventInformation.html#anchor56","text":"double Info::pT2Hat() transverse momentum and its square in the rest frame of a double Info::pT2Hat() 2 &rarr; 2 processes."},{"name":"double Info::pT2NowISR()","link":"EventInformation.html#anchor113","text":"double Info::pT2NowISR() set/get value of double Info::pT2NowISR() pT^2 in latest ISR branching."},{"name":"double Info::pTHat()","link":"EventInformation.html#anchor55","text":"double Info::pTHat()"},{"name":"double Info::pTmaxFSR()","link":"EventInformation.html#anchor81","text":"double Info::pTmaxFSR() Maximum double Info::pTmaxFSR() pT scales set for MPI, ISR and FSR, given the process type and scale choice for the hard interactions. The actual evolution will run down from these scales."},{"name":"double Info::pTmaxISR()","link":"EventInformation.html#anchor80","text":"double Info::pTmaxISR()"},{"name":"double Info::pTmaxMPI()","link":"EventInformation.html#anchor79","text":"double Info::pTmaxMPI()"},{"name":"double Info::pTMPI(int i)","link":"EventInformation.html#anchor91","text":"double Info::pTMPI(int i) the process code and transverse momentum of the double Info::pTMPI(int i) i 'th subprocess, with double Info::pTMPI(int i) i in the range from 0 to double Info::pTMPI(int i) nMPI() - 1. The values for subprocess 0 is redundant with information already provided above."},{"name":"double Info::pTnow()","link":"EventInformation.html#anchor82","text":"double Info::pTnow() The current double Info::pTnow() pT scale in the combined MPI, ISR and FSR evolution. Useful for classification in double Info::pTnow() user hooks , but not once the event has been evolved."},{"name":"double Info::pzA()","link":"EventInformation.html#anchor4","text":"double Info::pzA()"},{"name":"double Info::pzB()","link":"EventInformation.html#anchor5","text":"double Info::pzB() the longitudinal momenta of the two beam particles."},{"name":"double Info::Q2Fac()","link":"EventInformation.html#anchor45","text":"double Info::Q2Fac() the double Info::Q2Fac() Q or double Info::Q2Fac() Q^2 factorization scale at which the densities were evaluated."},{"name":"double Info::Q2GammaA()","link":"EventInformation.html#anchor68","text":"double Info::Q2GammaA()"},{"name":"double Info::Q2GammaB()","link":"EventInformation.html#anchor69","text":"double Info::Q2GammaB() Virtualities of the photons emitted by the leptons."},{"name":"double Info::Q2Ren()","link":"EventInformation.html#anchor49","text":"double Info::Q2Ren() the double Info::Q2Ren() Q or double Info::Q2Ren() Q^2 renormalization scale at which double Info::Q2Ren() alpha_strong and double Info::Q2Ren() alpha_electromagnetic were evaluated."},{"name":"double Info::QFac()","link":"EventInformation.html#anchor44","text":"double Info::QFac()"},{"name":"double Info::QRen()","link":"EventInformation.html#anchor48","text":"double Info::QRen()"},{"name":"double Info::s()","link":"EventInformation.html#anchor11","text":"double Info::s() the CM energy and its square for the two beams."},{"name":"double Info::scalup()","link":"EventInformation.html#anchor50","text":"double Info::scalup() returns the stored double Info::scalup() SCALUP value for Les Houches events, and else zero. It may agree with both the double Info::scalup() QFac() and double Info::scalup() QRen() values, as explained above. However, to repeat, should the input double Info::scalup() SCALUP scale be negative, separate positive factorization and renormalization scales are calculated and set as for internally generated events. Furthermore, when PDF info is supplied for the Les Houches event, the factorization scale is set by this PDF info ( double Info::scalup() scalePDF ), which can disagree with double Info::scalup() SCALUP."},{"name":"double Info::sHat()","link":"EventInformation.html#anchor52","text":"double Info::sHat() the invariant mass and its square for the hard process."},{"name":"double Info::sigmaErr(int i = 0)","link":"EventInformation.html#anchor104","text":"double Info::sigmaErr(int i = 0) the estimated cross section and its estimated error, summed over all allowed processes ( double Info::sigmaErr(int i = 0) i = 0 ) or for the given process, in units of mb. The numbers refer to the accepted event sample above, i.e. after any user veto."},{"name":"double Info::sigmaGen(int i = 0)","link":"EventInformation.html#anchor103","text":"double Info::sigmaGen(int i = 0)"},{"name":"double Info::sigmaLHEF(int iProcess)","link":"EventInformation.html#anchor120","text":"double Info::sigmaLHEF(int iProcess) return the cross section of the double Info::sigmaLHEF(int iProcess) iProcess 'th process."},{"name":"double Info::tau()","link":"EventInformation.html#anchor35","text":"double Info::tau() rapidity and scaled mass-squared of the hard-process subsystem, as defined by the above double Info::tau() x values."},{"name":"double Info::tHat()","link":"EventInformation.html#anchor53","text":"double Info::tHat()"},{"name":"double Info::thetaHat()","link":"EventInformation.html#anchor59","text":"double Info::thetaHat()"},{"name":"double Info::thetaScatLepA()","link":"EventInformation.html#anchor70","text":"double Info::thetaScatLepA()"},{"name":"double Info::thetaScatLepB()","link":"EventInformation.html#anchor71","text":"double Info::thetaScatLepB() Scattering angles of the leptons wrt. the beam direction."},{"name":"double Info::tPomeronA()","link":"EventInformation.html#anchor63","text":"double Info::tPomeronA()"},{"name":"double Info::tPomeronB()","link":"EventInformation.html#anchor64","text":"double Info::tPomeronB() The momentum transfer double Info::tPomeronB() t in the hard diffractive process."},{"name":"double Info::uHat()","link":"EventInformation.html#anchor54","text":"double Info::uHat() the remaining two Mandelstam variables; only defined for double Info::uHat() 2 &rarr; 2 processes."},{"name":"double Info::weight()","link":"EventInformation.html#anchor73","text":"double Info::weight() weight assigned to the current event. Is normally 1 and thus uninteresting. However, there are several cases where one may have nontrivial event weights. These weights must the be used e.g. when filling histograms. double Info::weight() (i) In the double Info::weight() double Info::weight() PhaseSpace:increaseMaximum = off default strategy, an event with a differential cross-section above the assumed one (in a given phase-space point) is assigned a weight correspondingly above unity. This should happen only very rarely, if at all, and so could normally be disregarded. double Info::weight() (ii) The double Info::weight() User Hooks class offers the possibility to bias the selection of phase space points, which means that events come with a compensating weight, stored here. double Info::weight() (iii) For Les Houches events some strategies allow negative weights, which then after unweighting lead to events with weight -1. There are also Les Houches strategies where no unweighting is done, so events come with a weight. Specifically, for strategies double Info::weight() +4 and double Info::weight() -4 , the event weight is in units of pb. (Internally in mb, but converted at output.)"},{"name":"double Info::weightSum()","link":"EventInformation.html#anchor74","text":"double Info::weightSum() Sum of weights accumulated during the run. For unweighted events this agrees with the number of generated events. In order to obtain histograms normalized 'per event', at the end of a run, histogram contents should be divided by this weight. (And additionally divided by the bin width.) Normalization to cross section also required multiplication by double Info::weightSum() sigmaGen() below."},{"name":"double Info::x1()","link":"EventInformation.html#anchor32","text":"double Info::x1()"},{"name":"double Info::x1pdf()","link":"EventInformation.html#anchor40","text":"double Info::x1pdf()"},{"name":"double Info::x2()","link":"EventInformation.html#anchor33","text":"double Info::x2() double Info::x2() x fractions of the two partons coming in to the hard process."},{"name":"double Info::x2pdf()","link":"EventInformation.html#anchor41","text":"double Info::x2pdf() double Info::x2pdf() x fractions of the two partons for which parton density values are defined."},{"name":"double Info::xGammaA()","link":"EventInformation.html#anchor66","text":"double Info::xGammaA()"},{"name":"double Info::xGammaB()","link":"EventInformation.html#anchor67","text":"double Info::xGammaB() double Info::xGammaB() x fractions of lepton momenta carried by the photons."},{"name":"double Info::xPomeronA()","link":"EventInformation.html#anchor61","text":"double Info::xPomeronA()"},{"name":"double Info::xPomeronB()","link":"EventInformation.html#anchor62","text":"double Info::xPomeronB() double Info::xPomeronB() x fractions of momenta carried by the Pomeron in the hard diffractive process."},{"name":"double Info::y()","link":"EventInformation.html#anchor34","text":"double Info::y()"},{"name":"double Info::zNowISR()","link":"EventInformation.html#anchor111","text":"double Info::zNowISR() set/get value of double Info::zNowISR() z in latest ISR branching."},{"name":"double JetMatchingMadgraph::getPTfirst()","link":"JetMatching.html#anchor32","text":"double JetMatchingMadgraph::getPTfirst() Return the transverse momentum (w.r.t. the beam) of the first parton shower emission, as needed for the shower-kT scheme."},{"name":"double LHAup::alphaQCD()","link":"LesHouchesAccord.html#anchor37","text":"double LHAup::alphaQCD() scale and couplings at that scale."},{"name":"double LHAup::alphaQED()","link":"LesHouchesAccord.html#anchor36","text":"double LHAup::alphaQED()"},{"name":"double LHAup::e(int i)","link":"LesHouchesAccord.html#anchor48","text":"double LHAup::e(int i)"},{"name":"double LHAup::eBeamA()","link":"LesHouchesAccord.html#anchor15","text":"double LHAup::eBeamA()"},{"name":"double LHAup::eBeamB()","link":"LesHouchesAccord.html#anchor16","text":"double LHAup::eBeamB()"},{"name":"double LHAup::m(int i)","link":"LesHouchesAccord.html#anchor49","text":"double LHAup::m(int i)"},{"name":"double LHAup::pdf1()","link":"LesHouchesAccord.html#anchor65","text":"double LHAup::pdf1()"},{"name":"double LHAup::pdf2()","link":"LesHouchesAccord.html#anchor66","text":"double LHAup::pdf2() where the first one tells whether this optional information has been set for the current event. ( double LHAup::pdf2() setPdf(...) must be called after the double LHAup::pdf2() setProcess(...) call of the event for this to work.) Note that the flavour and double LHAup::pdf2() x values usually but not always agree with those obtained by the same methods without double LHAup::pdf2() pdf in their names, see explanation in the double LHAup::pdf2() Event Information description."},{"name":"double LHAup::px(int i)","link":"LesHouchesAccord.html#anchor45","text":"double LHAup::px(int i)"},{"name":"double LHAup::py(int i)","link":"LesHouchesAccord.html#anchor46","text":"double LHAup::py(int i)"},{"name":"double LHAup::pz(int i)","link":"LesHouchesAccord.html#anchor47","text":"double LHAup::pz(int i)"},{"name":"double LHAup::scale()","link":"LesHouchesAccord.html#anchor35","text":"double LHAup::scale()"},{"name":"double LHAup::scale(int i)","link":"LesHouchesAccord.html#anchor52","text":"double LHAup::scale(int i) for particle double LHAup::scale(int i) i in the range double LHAup::scale(int i) 0 <= i < sizePart(). (But again note that double LHAup::scale(int i) i = 0 is an empty line, so the true range begins at 1.)"},{"name":"double LHAup::scalePDF()","link":"LesHouchesAccord.html#anchor64","text":"double LHAup::scalePDF()"},{"name":"double LHAup::spin(int i)","link":"LesHouchesAccord.html#anchor51","text":"double LHAup::spin(int i)"},{"name":"double LHAup::tau(int i)","link":"LesHouchesAccord.html#anchor50","text":"double LHAup::tau(int i)"},{"name":"double LHAup::weight()","link":"LesHouchesAccord.html#anchor34","text":"double LHAup::weight(). Note that the weight stored in double LHAup::weight() Info::weight() as a rule is not the same as the above double LHAup::weight() weight() : the method here gives the value before unweighting while the one in double LHAup::weight() info gives the one after unweighting and thus normally is 1 or -1. Only with strategy options +-3 and +-4 would the value in double LHAup::weight() info be the same as here, except for a conversion from pb to mb for +-4."},{"name":"double LHAup::x1()","link":"LesHouchesAccord.html#anchor56","text":"double LHAup::x1()"},{"name":"double LHAup::x1pdf()","link":"LesHouchesAccord.html#anchor62","text":"double LHAup::x1pdf()"},{"name":"double LHAup::x2()","link":"LesHouchesAccord.html#anchor57","text":"double LHAup::x2() the flavour and double LHAup::x2() x values of the two initiators."},{"name":"double LHAup::x2pdf()","link":"LesHouchesAccord.html#anchor63","text":"double LHAup::x2pdf()"},{"name":"double LHAup::xErr(i)","link":"LesHouchesAccord.html#anchor25","text":"double LHAup::xErr(i)"},{"name":"double LHAup::xErrSum()","link":"LesHouchesAccord.html#anchor28","text":"double LHAup::xErrSum() the sum of the cross sections and errors (the latter added quadratically). Note that cross section errors are only meaningful for strategies +-3."},{"name":"double LHAup::xMax(i)","link":"LesHouchesAccord.html#anchor26","text":"double LHAup::xMax(i) for process double LHAup::xMax(i) i in the range double LHAup::xMax(i) 0 <= i < sizeProc()."},{"name":"double LHAup::xSec(i)","link":"LesHouchesAccord.html#anchor24","text":"double LHAup::xSec(i)"},{"name":"double LHAup::xSecSum()","link":"LesHouchesAccord.html#anchor27","text":"double LHAup::xSecSum()"},{"name":"double m(const Particle& pp1, const Particle& pp2)","link":"ParticleProperties.html#anchor64","text":"double m(const Particle& pp1, const Particle& pp2)"},{"name":"double m2(const Particle& pp1, const Particle& pp2)","link":"ParticleProperties.html#anchor65","text":"double m2(const Particle& pp1, const Particle& pp2) the (squared) invariant mass of two particles."},{"name":"double MergingHooks::tms()","link":"CKKWLMerging.html#anchor25","text":"double MergingHooks::tms() Returns the value used as the merging scale."},{"name":"double Particle::charge()","link":"ParticleProperties.html#anchor69","text":"double Particle::charge()"},{"name":"double Particle::constituentMass()","link":"ParticleProperties.html#anchor79","text":"double Particle::constituentMass() will give the constituent masses for quarks and diquarks, else the same masses as with double Particle::constituentMass() m0()."},{"name":"double Particle::e()","link":"ParticleProperties.html#anchor12","text":"double Particle::e() the particle four-momentum components."},{"name":"double Particle::eCalc()","link":"ParticleProperties.html#anchor41","text":"double Particle::eCalc() energy calculated from the mass and three-momentum; should agree with double Particle::eCalc() e() up to roundoff. For spacelike partons a positive-energy  solution is picked. This need not be the correct one, so it is recommended not to use the method in such cases."},{"name":"double Particle::eT()","link":"ParticleProperties.html#anchor48","text":"double Particle::eT()"},{"name":"double Particle::eT2()","link":"ParticleProperties.html#anchor49","text":"double Particle::eT2() (squared) transverse energy, double Particle::eT2() eT = e * sin(theta) = e * pT / pAbs."},{"name":"double Particle::eta()","link":"ParticleProperties.html#anchor56","text":"double Particle::eta() rapidity and pseudorapidity."},{"name":"double Particle::m()","link":"ParticleProperties.html#anchor14","text":"double Particle::m() the particle mass, stored with a minus sign (times the absolute value) for spacelike virtual particles."},{"name":"double Particle::m0()","link":"ParticleProperties.html#anchor74","text":"double Particle::m0() the nominal mass of the particle, according to the data tables."},{"name":"double Particle::m2()","link":"ParticleProperties.html#anchor38","text":"double Particle::m2() squared mass, which can be negative for spacelike partons."},{"name":"double Particle::m2Calc()","link":"ParticleProperties.html#anchor40","text":"double Particle::m2Calc() (squared) mass calculated from the four-momentum; should agree with double Particle::m2Calc() m(), m2() up to roundoff. Negative for spacelike virtualities."},{"name":"double Particle::mCalc()","link":"ParticleProperties.html#anchor39","text":"double Particle::mCalc()"},{"name":"double Particle::mMax()","link":"ParticleProperties.html#anchor77","text":"double Particle::mMax() the width of the particle, and the minimum and maximum allowed mass value for particles with a width, according to the data tables."},{"name":"double Particle::mMin()","link":"ParticleProperties.html#anchor76","text":"double Particle::mMin()"},{"name":"double Particle::mSel()","link":"ParticleProperties.html#anchor78","text":"double Particle::mSel() the mass of the particle, picked according to a Breit-Wigner distribution for particles with width. It is different each time called, and is therefore only used once per particle to set its mass double Particle::mSel() m()."},{"name":"double Particle::mT()","link":"ParticleProperties.html#anchor44","text":"double Particle::mT()"},{"name":"double Particle::mT2()","link":"ParticleProperties.html#anchor45","text":"double Particle::mT2() (squared) transverse mass. If double Particle::mT2() m_T^2 is negative, which can happen for a spacelike parton, then double Particle::mT2() mT() returns double Particle::mT2() -sqrt(-m_T^2) , by analogy with the negative sign used to store spacelike masses."},{"name":"double Particle::mWidth()","link":"ParticleProperties.html#anchor75","text":"double Particle::mWidth()"},{"name":"double Particle::pAbs()","link":"ParticleProperties.html#anchor46","text":"double Particle::pAbs()"},{"name":"double Particle::pAbs2()","link":"ParticleProperties.html#anchor47","text":"double Particle::pAbs2() (squared) three-momentum size."},{"name":"double Particle::phi()","link":"ParticleProperties.html#anchor51","text":"double Particle::phi() polar and azimuthal angle."},{"name":"double Particle::pNeg()","link":"ParticleProperties.html#anchor54","text":"double Particle::pNeg() double Particle::pNeg() E +- p_z."},{"name":"double Particle::pol()","link":"ParticleProperties.html#anchor16","text":"double Particle::pol() the polarization/spin/helicity of a particle. Currently Pythia does not use this variable for internal operations, except for double Particle::pol() W/Z polarization states in weak showers, so its meaning is not uniquely defined. The LHA standard sets double Particle::pol() SPINUP to be the cosine of the angle between the spin vector and the 3-momentum of the decaying particle in the lab frame, i.e. restricted to be between +1 and -1. A more convenient choice could be the same quantity in the rest frame of the particle production, either the hard subprocess or the mother particle of a decay. Unknown or unpolarized particles should be assigned the value 9."},{"name":"double Particle::pPos()","link":"ParticleProperties.html#anchor53","text":"double Particle::pPos()"},{"name":"double Particle::pT()","link":"ParticleProperties.html#anchor42","text":"double Particle::pT()"},{"name":"double Particle::pT2()","link":"ParticleProperties.html#anchor43","text":"double Particle::pT2() (squared) transverse momentum."},{"name":"double Particle::px()","link":"ParticleProperties.html#anchor9","text":"double Particle::px()"},{"name":"double Particle::py()","link":"ParticleProperties.html#anchor10","text":"double Particle::py()"},{"name":"double Particle::pz()","link":"ParticleProperties.html#anchor11","text":"double Particle::pz()"},{"name":"double Particle::scale()","link":"ParticleProperties.html#anchor15","text":"double Particle::scale() the scale at which a parton was produced, which can be used to restrict its radiation to lower scales in subsequent steps of the shower evolution. Note that scale is linear in momenta, not quadratic (i.e. double Particle::scale() Q , not double Particle::scale() Q^2 )."},{"name":"double Particle::tau()","link":"ParticleProperties.html#anchor22","text":"double Particle::tau() the proper lifetime, in mm/c. (Since c = 3 * 10^11 mm/s, double Particle::tau() Particle::tau() /(3 * 10^11) is the lifetime in seconds.) It is assigned for all hadrons with positive nominal double Particle::tau() tau , double Particle::tau() tau_0 > 0 , because it can be used by PYTHIA to decide whether a particle should or should not be allowed to decay, e.g. based on the decay vertex distance to the primary interaction vertex."},{"name":"double Particle::tau0()","link":"ParticleProperties.html#anchor80","text":"double Particle::tau0() the nominal lifetime double Particle::tau0() tau_0 > 0 , in mm/c, of the particle species. It is used to assign the actual lifetime double Particle::tau0() tau."},{"name":"double Particle::tDec()","link":"ParticleProperties.html#anchor62","text":"double Particle::tDec()"},{"name":"double Particle::theta()","link":"ParticleProperties.html#anchor50","text":"double Particle::theta()"},{"name":"double Particle::thetaXZ()","link":"ParticleProperties.html#anchor52","text":"double Particle::thetaXZ() angle in the double Particle::thetaXZ() (p_x, p_z) plane, between double Particle::thetaXZ() -pi and double Particle::thetaXZ() +pi , with 0 along the double Particle::thetaXZ() +z axis"},{"name":"double Particle::tProd()","link":"ParticleProperties.html#anchor20","text":"double Particle::tProd() the production vertex coordinates, in mm or mm/c."},{"name":"double Particle::xDec()","link":"ParticleProperties.html#anchor59","text":"double Particle::xDec()"},{"name":"double Particle::xProd()","link":"ParticleProperties.html#anchor17","text":"double Particle::xProd()"},{"name":"double Particle::y()","link":"ParticleProperties.html#anchor55","text":"double Particle::y()"},{"name":"double Particle::y(double mCut)","link":"ParticleProperties.html#anchor57","text":"double Particle::y(double mCut)"},{"name":"double Particle::y(double mCut, RotBstMatrix& M)","link":"ParticleProperties.html#anchor58","text":"double Particle::y(double mCut, RotBstMatrix& M) rapidity, but calculated assuming that the particle transverse mass is at least double Particle::y(double mCut, RotBstMatrix& M) mCut , and optionally if the particle were first to be boosted and rotated by double Particle::y(double mCut, RotBstMatrix& M) M."},{"name":"double Particle::yDec()","link":"ParticleProperties.html#anchor60","text":"double Particle::yDec()"},{"name":"double Particle::yProd()","link":"ParticleProperties.html#anchor18","text":"double Particle::yProd()"},{"name":"double Particle::zDec()","link":"ParticleProperties.html#anchor61","text":"double Particle::zDec()"},{"name":"double Particle::zProd()","link":"ParticleProperties.html#anchor19","text":"double Particle::zProd()"},{"name":"double ParticleData::charge(int id)","link":"ParticleDataScheme.html#anchor38","text":"double ParticleData::charge(int id) the electrical charge of a particle, equal to double ParticleData::charge(int id) chargeType(id)/3."},{"name":"double ParticleData::constituentMass(int id)","link":"ParticleDataScheme.html#anchor66","text":"double ParticleData::constituentMass(int id) is the constituent mass for a quark, hardcoded as double ParticleData::constituentMass(int id) m_u = m_d = 0.325 , double ParticleData::constituentMass(int id) m_s = 0.50 , double ParticleData::constituentMass(int id) m_c = 1.60 and double ParticleData::constituentMass(int id) m_b = 5.0 GeV, for a diquark the sum of quark constituent masses, and for everything else the same as the ordinary mass."},{"name":"double ParticleData::m0(int id)","link":"ParticleDataScheme.html#anchor42","text":"double ParticleData::m0(int id) the nominal mass double ParticleData::m0(int id) m_0 (in GeV)."},{"name":"double ParticleData::m0Max(int id)","link":"ParticleDataScheme.html#anchor50","text":"double ParticleData::m0Max(int id) similar to double ParticleData::m0Max(int id) mMax() above, except that for particles with no width the double ParticleData::m0Max(int id) m0(id) value is returned."},{"name":"double ParticleData::m0Min(int id)","link":"ParticleDataScheme.html#anchor49","text":"double ParticleData::m0Min(int id) similar to double ParticleData::m0Min(int id) mMin() above, except that for particles with no width the double ParticleData::m0Min(int id) m0(id) value is returned."},{"name":"double ParticleData::mMax(int id)","link":"ParticleDataScheme.html#anchor48","text":"double ParticleData::mMax(int id) the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If double ParticleData::mMax(int id) mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there."},{"name":"double ParticleData::mMin(int id)","link":"ParticleDataScheme.html#anchor46","text":"double ParticleData::mMin(int id) the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there."},{"name":"double ParticleData::mRun(int id, double mH)","link":"ParticleDataScheme.html#anchor68","text":"double ParticleData::mRun(int id, double mH) calculate the running mass of species double ParticleData::mRun(int id, double mH) id when probed at a hard mass scale of double ParticleData::mRun(int id, double mH) mH. Only applied to obtain the running quark masses; for all other particle the normal fixed mass is used."},{"name":"double ParticleData::mSel(int id)","link":"ParticleDataScheme.html#anchor67","text":"double ParticleData::mSel(int id) returns a mass distributed according to a truncated Breit-Wigner, with parameters as described here. Is equal to double ParticleData::mSel(int id) m0(id) for particles without width."},{"name":"double ParticleData::mWidth(int id)","link":"ParticleDataScheme.html#anchor44","text":"double ParticleData::mWidth(int id) the width double ParticleData::mWidth(int id) Gamma of the Breit-Wigner distribution (in GeV)."},{"name":"double ParticleData::resOpenFrac(int id1, int id2 = 0,  int id3 = 0)","link":"ParticleDataScheme.html#anchor88","text":"double ParticleData::resOpenFrac(int id1, int id2 = 0,  int id3 = 0) calculate the fraction of the full branching ratio that is left open by the user choice of allowed decay channels. Can be applied to a final state with up to three resonances. Since the procedure is multiplicative, it would be easy to generalize also to more."},{"name":"double ParticleData::resWidth(int id, double mHat,  int idInFlav = 0, bool openOnly = false, bool setBR = false)","link":"ParticleDataScheme.html#anchor85","text":"double ParticleData::resWidth(int id, double mHat,  int idInFlav = 0, bool openOnly = false, bool setBR = false) calculate the total with for a resonance of a given current mass, optionally including coupling to incoming flavour state (consider the double ParticleData::resWidth(int id, double mHat,  int idInFlav = 0, bool openOnly = false, bool setBR = false) gamma*/Z^0 combination), optionally excluding decay channels that have been closed by the user, and optionally storing the results in the normal decay table."},{"name":"double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0)","link":"ParticleDataScheme.html#anchor90","text":"double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0) special case to calculate one final-state width; currently only used for Higgs decay to double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0) q qbar , double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0) g g or double ParticleData::resWidthChan(int id,  double mHat, int idAbs1 = 0, int idAbs2 = 0) gamma gamma."},{"name":"double ParticleData::resWidthOpen(int id, double mHat,  int idInFlav = 0)","link":"ParticleDataScheme.html#anchor86","text":"double ParticleData::resWidthOpen(int id, double mHat,  int idInFlav = 0) special case of double ParticleData::resWidthOpen(int id, double mHat,  int idInFlav = 0) resWidth , where only open channels are included, but results are not stored in the normal decay table."},{"name":"double ParticleData::resWidthRescaleFactor(int id)","link":"ParticleDataScheme.html#anchor89","text":"double ParticleData::resWidthRescaleFactor(int id) the factor used to rescale all partial widths in case the total width is being forced to a specific value by the user."},{"name":"double ParticleData::resWidthStore(int id, double mHat,  int idInFlav = 0)","link":"ParticleDataScheme.html#anchor87","text":"double ParticleData::resWidthStore(int id, double mHat,  int idInFlav = 0) special case of double ParticleData::resWidthStore(int id, double mHat,  int idInFlav = 0) resWidth , where only open channels are included, and results are stored in the normal decay table."},{"name":"double ParticleData::tau0(int id)","link":"ParticleDataScheme.html#anchor52","text":"double ParticleData::tau0(int id) the nominal proper lifetime double ParticleData::tau0(int id) tau_0 (in mm/c)."},{"name":"double ParticleDataEntry::charge(int id = 1)","link":"ParticleDataScheme.html#anchor110","text":"double ParticleDataEntry::charge(int id = 1) set or get the particle charge type, i.e. three times the charge, or the charge itself. Only the sign of double ParticleDataEntry::charge(int id = 1) id is needed to distinguish particle/antiparticle."},{"name":"double ParticleDataEntry::constituentMass()","link":"ParticleDataScheme.html#anchor138","text":"double ParticleDataEntry::constituentMass() is the constituent mass for a quark, hardcoded as double ParticleDataEntry::constituentMass() m_u = m_d = 0.325 , double ParticleDataEntry::constituentMass() m_s = 0.50 , double ParticleDataEntry::constituentMass() m_c = 1.60 and double ParticleDataEntry::constituentMass() m_b = 5.0 GeV, for a diquark the sum of quark constituent masses, and for everything else the same as the ordinary mass."},{"name":"double ParticleDataEntry::m0()","link":"ParticleDataScheme.html#anchor114","text":"double ParticleDataEntry::m0() the nominal mass double ParticleDataEntry::m0() m_0 (in GeV)."},{"name":"double ParticleDataEntry::m0Max()","link":"ParticleDataScheme.html#anchor122","text":"double ParticleDataEntry::m0Max() similar to double ParticleDataEntry::m0Max() mMax() above, except that for particles with no width the double ParticleDataEntry::m0Max() m0(id) value is returned."},{"name":"double ParticleDataEntry::m0Min()","link":"ParticleDataScheme.html#anchor121","text":"double ParticleDataEntry::m0Min() similar to double ParticleDataEntry::m0Min() mMin() above, except that for particles with no width the double ParticleDataEntry::m0Min() m0(id) value is returned."},{"name":"double ParticleDataEntry::mMax()","link":"ParticleDataScheme.html#anchor120","text":"double ParticleDataEntry::mMax() the upper limit of the allowed mass range generated by the Breit-Wigner (in GeV). If double ParticleDataEntry::mMax() mMax < mMin then no upper limit is imposed. Has no meaning for particles without width, and would typically be 0 there."},{"name":"double ParticleDataEntry::mMin()","link":"ParticleDataScheme.html#anchor118","text":"double ParticleDataEntry::mMin() the lower limit of the allowed mass range generated by the Breit-Wigner (in GeV). Has no meaning for particles without width, and would typically be 0 there."},{"name":"double ParticleDataEntry::mRun(double mH)","link":"ParticleDataScheme.html#anchor140","text":"double ParticleDataEntry::mRun(double mH) calculate the running quark mass at a hard scale double ParticleDataEntry::mRun(double mH) mH. For other particles the on-shell mass is given."},{"name":"double ParticleDataEntry::mSel()","link":"ParticleDataScheme.html#anchor139","text":"double ParticleDataEntry::mSel() give the mass of a particle, either at the nominal value or picked according to a (linear or quadratic) Breit-Wigner."},{"name":"double ParticleDataEntry::mWidth()","link":"ParticleDataScheme.html#anchor116","text":"double ParticleDataEntry::mWidth() the width double ParticleDataEntry::mWidth() Gamma of the Breit-Wigner distribution (in GeV)."},{"name":"double ParticleDataEntry::resOpenFrac(int idSgn)","link":"ParticleDataScheme.html#anchor168","text":"double ParticleDataEntry::resOpenFrac(int idSgn) calculate the fraction of the full branching ratio that is left open by the user choice of allowed decay channels."},{"name":"double ParticleDataEntry::resWidth(int idSgn,  double mHat, int idInFlav = 0, bool openOnly = false,  bool setBR = false)","link":"ParticleDataScheme.html#anchor165","text":"double ParticleDataEntry::resWidth(int idSgn,  double mHat, int idInFlav = 0, bool openOnly = false,  bool setBR = false) calculate the total with for a resonance of a given current mass, optionally including coupling to incoming flavour state (consider the double ParticleDataEntry::resWidth(int idSgn,  double mHat, int idInFlav = 0, bool openOnly = false,  bool setBR = false) gamma*/Z^0 combination), optionally excluding decay channels that have been closed by the user, and optionally storing the results in the normal decay table. For the first argument only the sign is relevant."},{"name":"double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0)","link":"ParticleDataScheme.html#anchor170","text":"double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0) special case to calculate one final-state width; currently only used for Higgs decay to double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0) q qbar , double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0) g g or double ParticleDataEntry::resWidthChan(double mHat,  int idAbs1 = 0, int idAbs2 = 0) gamma gamma."},{"name":"double ParticleDataEntry::resWidthOpen(int idSgn,  double mHat, int idInFlav = 0)","link":"ParticleDataScheme.html#anchor166","text":"double ParticleDataEntry::resWidthOpen(int idSgn,  double mHat, int idInFlav = 0) special case of double ParticleDataEntry::resWidthOpen(int idSgn,  double mHat, int idInFlav = 0) resWidth , where only open channels are included, but results are not stored in the normal decay table."},{"name":"double ParticleDataEntry::resWidthRescaleFactor()","link":"ParticleDataScheme.html#anchor169","text":"double ParticleDataEntry::resWidthRescaleFactor() the factor used to rescale all partial widths in case the total width is being forced to a specific value by the user."},{"name":"double ParticleDataEntry::resWidthStore(int idSgn,  double mHat, int idInFlav = 0)","link":"ParticleDataScheme.html#anchor167","text":"double ParticleDataEntry::resWidthStore(int idSgn,  double mHat, int idInFlav = 0) special case of double ParticleDataEntry::resWidthStore(int idSgn,  double mHat, int idInFlav = 0) resWidth , where only open channels are included, and results are stored in the normal decay table."},{"name":"double ParticleDataEntry::tau0()","link":"ParticleDataScheme.html#anchor124","text":"double ParticleDataEntry::tau0() the nominal proper lifetime double ParticleDataEntry::tau0() tau_0 (in mm/c). Second argument of input method for internal use only."},{"name":"double Pythia::parm(string key)","link":"ProgramFlow.html#anchor40","text":"double Pythia::parm(string key) read in a double-precision variable from the double Pythia::parm(string key) Settings database. double Pythia::parm(string key) the name of the variable to be read."},{"name":"double ResonanceWidths::widthChan( double mHat,  int idAbs1, int idAbs2)","link":"SemiInternalResonances.html#anchor4","text":"double ResonanceWidths::widthChan( double mHat,  int idAbs1, int idAbs2) is not normally used. In PYTHIA the only exception is Higgs decays, where it is used to define the width (except for colour factors) associated with a specific incoming/outgoing state. It allows the results of some loop expressions to be pretabulated."},{"name":"double Rndm::exp()","link":"RandomNumbers.html#anchor7","text":"double Rndm::exp() generate random numbers according to double Rndm::exp() exp(-x)."},{"name":"double Rndm::flat()","link":"RandomNumbers.html#anchor6","text":"double Rndm::flat() generate next random number uniformly between 0 and 1."},{"name":"double Rndm::gauss()","link":"RandomNumbers.html#anchor9","text":"double Rndm::gauss() generate random numbers according to double Rndm::gauss() exp(-x^2/2)."},{"name":"double Rndm::xexp()","link":"RandomNumbers.html#anchor8","text":"double Rndm::xexp() generate random numbers according to double Rndm::xexp() x exp(-x)."},{"name":"double RotBstMatrix::deviation()","link":"FourVectors.html#anchor91","text":"double RotBstMatrix::deviation() crude estimate how much a matrix deviates from the unit matrix: the sum of the absolute values of all non-diagonal matrix elements plus the sum of the absolute deviation of the diagonal matrix elements from unity."},{"name":"double RotBstMatrix::value(int i, int j)","link":"FourVectors.html#anchor90","text":"double RotBstMatrix::value(int i, int j) return the value of the (i,j) = [i][j] matrix element."},{"name":"double Settings::parm(string key)","link":"SettingsScheme.html#anchor35","text":"double Settings::parm(string key)"},{"name":"double Settings::parmDefault(string key)","link":"SettingsScheme.html#anchor43","text":"double Settings::parmDefault(string key)"},{"name":"double SigmaProcess::sigmaHat()","link":"SemiInternalProcesses.html#anchor7","text":"double SigmaProcess::sigmaHat() is the key method for cross section calculations and returns a cross section value, as described in the previous section. It is called when also a preliminary set of incoming flavours has been picked, in addition to the kinematical ones already available for double SigmaProcess::sigmaHat() sigmaKin. Typically double SigmaProcess::sigmaHat() sigmaHat is called inside a loop over all allowed incoming flavour combinations, stored in double SigmaProcess::sigmaHat() id1 and double SigmaProcess::sigmaHat() id2 , with fixed kinematics, as already illustrated above. The sum over the different flavour combinations provides the total cross section, while their relative size is used to make a selection of a specific incoming state."},{"name":"double SigmaProcess::tChanFracPow1()","link":"SemiInternalProcesses.html#anchor27","text":"double SigmaProcess::tChanFracPow1()"},{"name":"double SigmaProcess::tChanFracPow2()","link":"SemiInternalProcesses.html#anchor28","text":"double SigmaProcess::tChanFracPow2() in the above kind of double SigmaProcess::tChanFracPow2() 2 &rarr; 3 phase-space selection, the sampling of double SigmaProcess::tChanFracPow2() pT^2 is done with one part flat, one part weighted like double SigmaProcess::tChanFracPow2() 1 / (pT^2 + m_R^2) and one part  like double SigmaProcess::tChanFracPow2() 1 / (pT^2 + m_R^2)^2. The above values provide the relative amount put in the latter two channels, respectively, with the first obtaining the rest. Thus the sum of double SigmaProcess::tChanFracPow2() tChanFracPow1() and double SigmaProcess::tChanFracPow2() tChanFracPow2() must be below unity. The final results should be independent of these numbers, but the Monte Carlo efficiency may be quite low for a bad choice. Here double SigmaProcess::tChanFracPow2() m_R is the mass of the exchanged resonance specified by double SigmaProcess::tChanFracPow2() idTchan1() or double SigmaProcess::tChanFracPow2() idTchan2(). Note that the order of the final-state listing is important in the above double SigmaProcess::tChanFracPow2() q qbar' &rarr; H^0 q qbar' example, i.e. the double SigmaProcess::tChanFracPow2() H^0 must be returned by double SigmaProcess::tChanFracPow2() id3Mass() , since it is actually the double SigmaProcess::tChanFracPow2() pT^2 of the latter two that are selected independently, with the first double SigmaProcess::tChanFracPow2() pT then fixed by transverse-momentum conservation."},{"name":"double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd)","link":"SemiInternalProcesses.html#anchor11","text":"double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) is called when the basic process has one or several resonances, after each set of related resonances in double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) process[i] , double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) iResBeg <= double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) i <= double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) iResEnd , has been allowed to decay. The calculated weight, to be normalized to the range between 0 and 1, is used to decide whether to accept the decay(s) or try for a new decay configuration. The base-class version of this method returns unity, i.e. gives isotropic decays by default. This method may be called repeatedly for a single event. For instance, in double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) q qbar &rarr; H^0 Z^0 with double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) H^0 &rarr; W^+ W^- , a first call would be made after the double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) H^0 and double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) Z^0 decays, and then depend only on the double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) Z^0 decay angles since the double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) H^0 decays isotropically. The second call would be after the double SigmaProcess::weightDecay( Event& process,  int iResBeg, int iResEnd) W^+ W^- decays and then involve correlations between the four daughter fermions."},{"name":"double SigmaProcess::weightDecayFlav( Event& process)","link":"SemiInternalProcesses.html#anchor10","text":"double SigmaProcess::weightDecayFlav( Event& process) is called to allow a reweighting of the simultaneous flavour choices of resonance decay products. Is currently only used for the double SigmaProcess::weightDecayFlav( Event& process) q qbar &rarr; gamma*/Z^0 gamma*/Z^0 process, and will likely not be of interest for you."},{"name":"double SlowJet::dNext()","link":"EventAnalysis.html#anchor65","text":"double SlowJet::dNext() if the next step is to join two clusters, then the methods give the double SlowJet::dNext() (i,j, d_ij) values, if instead to promote a cluster to a jet then double SlowJet::dNext() (i, -1, d_iB). If no clusters remain then double SlowJet::dNext() (-1, -1, 0.). Note that the cluster numbers are offset as described above, i.e. they begin at double SlowJet::dNext() sizeJet() , which of course easily could be subtracted off. Also note that the jet and cluster lists are (moderately) reshuffled in each new step. When double SlowJet::dNext() useFJcore = true there are no intermediate steps, and thus these methods do not return meaningul information."},{"name":"double SlowJet::m(int i)","link":"EventAnalysis.html#anchor50","text":"double SlowJet::m(int i) gives a double SlowJet::m(int i) Vec4 corresponding to the four-momentum sum of the particles assigned to the double SlowJet::m(int i) i 'th jet, and the invariant mass of this four-vector,"},{"name":"double SlowJet::phi(int i)","link":"EventAnalysis.html#anchor48","text":"double SlowJet::phi(int i) gives the rapidity double SlowJet::phi(int i) y and azimuthal angle double SlowJet::phi(int i) phi of the center of the double SlowJet::phi(int i) i 'th jet (defined by the vector sum of constituent four-momenta),"},{"name":"double SlowJet::pT(i)","link":"EventAnalysis.html#anchor46","text":"double SlowJet::pT(i) gives the transverse momentum double SlowJet::pT(i) pT of the double SlowJet::pT(i) i 'th jet,"},{"name":"double SlowJet::y(int i)","link":"EventAnalysis.html#anchor47","text":"double SlowJet::y(int i)"},{"name":"double Sphericity::aplanarity()","link":"EventAnalysis.html#anchor4","text":"double Sphericity::aplanarity() gives the aplanarity (with the same comment),"},{"name":"double Sphericity::eigenValue(int i)","link":"EventAnalysis.html#anchor5","text":"double Sphericity::eigenValue(int i) gives one of the three eigenvalues for double Sphericity::eigenValue(int i) i = 1, 2 or 3, in descending order,"},{"name":"double Sphericity::sphericity()","link":"EventAnalysis.html#anchor3","text":"double Sphericity::sphericity() gives the sphericity (or equivalent if double Sphericity::sphericity() r is not 2),"},{"name":"double Thrust::oblateness()","link":"EventAnalysis.html#anchor14","text":"double Thrust::oblateness() gives the thrust, major, minor and oblateness values, respectively,"},{"name":"double Thrust::thrust()","link":"EventAnalysis.html#anchor11","text":"double Thrust::thrust()"},{"name":"double Thrust::tMajor()","link":"EventAnalysis.html#anchor12","text":"double Thrust::tMajor()"},{"name":"double Thrust::tMinor()","link":"EventAnalysis.html#anchor13","text":"double Thrust::tMinor()"},{"name":"double TimeShower::enhancePTmax()","link":"ImplementNewShowers.html#anchor6","text":"double TimeShower::enhancePTmax() Relative to the default double TimeShower::enhancePTmax() pT_max evolution scale of the process, it may still be convenient to vary the matching slightly for the hardest interaction in an event, to probe the sensitivity to such details. The base-class implementation returns the value of the double TimeShower::enhancePTmax() TimeShower:pTmaxFudge parameter."},{"name":"double TimeShower::pTLastInShower()","link":"ImplementNewShowers.html#anchor10","text":"double TimeShower::pTLastInShower() Can be used to return the double TimeShower::pTLastInShower() pT evolution scale of the last branching in the cascade generated with the above double TimeShower::pTLastInShower() shower(...) method. Is to be set in the internal double TimeShower::pTLastInShower() pTLastInShower variable, and should be 0 if there were no branchings. Can be useful for matching studies."},{"name":"double Vec4::e()","link":"FourVectors.html#anchor15","text":"double Vec4::e() gets the respective component."},{"name":"double Vec4::eT()","link":"FourVectors.html#anchor23","text":"double Vec4::eT()"},{"name":"double Vec4::eT2()","link":"FourVectors.html#anchor24","text":"double Vec4::eT2() the (squared) transverse energy, double Vec4::eT2() eT = e * sin(theta) = e * pT / pAbs."},{"name":"double Vec4::eta()","link":"FourVectors.html#anchor31","text":"double Vec4::eta() true rapidity double Vec4::eta() y and pseudorapidity double Vec4::eta() eta."},{"name":"double Vec4::m2Calc()","link":"FourVectors.html#anchor18","text":"double Vec4::m2Calc() the (squared) mass, calculated from the four-vectors. If double Vec4::m2Calc() m^2 < 0 the mass is given with a minus sign, double Vec4::m2Calc() -sqrt(-m^2).  Note the possible loss of precision in the calculation of double Vec4::m2Calc() E^2 - p^2 ; for particles the correct mass is stored separately to avoid such problems."},{"name":"double Vec4::mCalc()","link":"FourVectors.html#anchor17","text":"double Vec4::mCalc()"},{"name":"double Vec4::pAbs()","link":"FourVectors.html#anchor21","text":"double Vec4::pAbs()"},{"name":"double Vec4::pAbs2()","link":"FourVectors.html#anchor22","text":"double Vec4::pAbs2() the (squared) absolute momentum."},{"name":"double Vec4::phi()","link":"FourVectors.html#anchor26","text":"double Vec4::phi() the azimuthal angle, in the range double Vec4::phi() -pi through double Vec4::phi() pi."},{"name":"double Vec4::pNeg()","link":"FourVectors.html#anchor29","text":"double Vec4::pNeg() the combinations double Vec4::pNeg() E+-p_z."},{"name":"double Vec4::pPos()","link":"FourVectors.html#anchor28","text":"double Vec4::pPos()"},{"name":"double Vec4::pT()","link":"FourVectors.html#anchor19","text":"double Vec4::pT()"},{"name":"double Vec4::pT2()","link":"FourVectors.html#anchor20","text":"double Vec4::pT2() the (squared) transverse momentum."},{"name":"double Vec4::px()","link":"FourVectors.html#anchor12","text":"double Vec4::px()"},{"name":"double Vec4::py()","link":"FourVectors.html#anchor13","text":"double Vec4::py()"},{"name":"double Vec4::pz()","link":"FourVectors.html#anchor14","text":"double Vec4::pz()"},{"name":"double Vec4::rap()","link":"FourVectors.html#anchor30","text":"double Vec4::rap()"},{"name":"double Vec4::theta()","link":"FourVectors.html#anchor25","text":"double Vec4::theta() the polar angle, in the range 0 through double Vec4::theta() pi."},{"name":"double Vec4::thetaXZ()","link":"FourVectors.html#anchor27","text":"double Vec4::thetaXZ() the angle in the double Vec4::thetaXZ() xz plane, in the range double Vec4::thetaXZ() -pi through double Vec4::thetaXZ() pi , with 0 along the double Vec4::thetaXZ() +z axis."},{"name":"double& operator[](int i)","link":"FourVectors.html#anchor16","text":"double& operator[](int i) returns component by index, where 1 gives double& operator[](int i) p_x , 2 gives double& operator[](int i) p_y , 3 gives double& operator[](int i) p_z , and anything else gives double& operator[](int i) e."},{"name":"Event JetMatchingMadgraph::getProcessSubset()","link":"JetMatching.html#anchor30","text":"Event JetMatchingMadgraph::getProcessSubset() Return the event record containing the hard process, without resonance decay products and particles that should not be included in the jet matching, as necessary to implement the vetoes in the shower-kT and kT-MLM schemes. In the former, this event is needed to find the lowest pT in the ME inputs. In the latter, the event record is used to count the number of hard-process partons, minimal hard process pT, and to perform the matching of hard-process particles to shower jets."},{"name":"Event JetMatchingMadgraph::getWorkEventJet()","link":"JetMatching.html#anchor29","text":"Event JetMatchingMadgraph::getWorkEventJet() Return the event after parton showering, without resonance decay products and particles that should not be included in the jet matching, as necessary to implement the vetoes in the kT-MLM scheme."},{"name":"Event Pythia::event","link":"ProgramFlow.html#anchor44","text":"Event Pythia::event the complete event record, see Event Pythia::event here for further details."},{"name":"Event Pythia::process","link":"ProgramFlow.html#anchor43","text":"Event Pythia::process the hard-process event record, see Event Pythia::process here for further details."},{"name":"Event UserHooks::workEvent","link":"UserHooks.html#anchor6","text":"Event UserHooks::workEvent This protected class member contains the outcome of the above Event UserHooks::workEvent omitResonanceDecays(...) and Event UserHooks::workEvent subEvent(...) methods. Alternatively you can use it for whatever temporary purposes you wish. You are free to use standard operations, e.g. to boost the event to its rest frame before analysis, or remove particles that should not be analyzed. The Event UserHooks::workEvent workEvent can also be sent on to a Event UserHooks::workEvent jet clustering algorithm."},{"name":"Event& Event::operator+=(const Event& addEvent)","link":"EventRecord.html#anchor18","text":"Event& Event::operator+=(const Event& addEvent) appends an event to an existing one. For the appended particles mother, daughter and colour tags are shifted to make a consistent record. The zeroth particle of the appended event is not copied, but the zeroth particle of the combined event is updated to the full energy-momentum content."},{"name":"Event& Event::operator=(const Event& oldEvent)","link":"EventRecord.html#anchor17","text":"Event& Event::operator=(const Event& oldEvent) copies the input event record."},{"name":"Event::Event(int capacity = 100)","link":"EventRecord.html#anchor16","text":"Event::Event(int capacity = 100) creates an empty event record, but with a reserved size Event::Event(int capacity = 100) capacity for the Event::Event(int capacity = 100) Particle vector."},{"name":"friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New)","link":"FourVectors.html#anchor46","text":"friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New) transfer four-momentum between the two four-vectors so that they get the masses friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New) m1New and friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New) m2New , respectively. Note that friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New) p1Move and friend bool pShift( Vec4& p1Move, Vec4& p2Move,  double m1New, double m2New) p2Move act both as input and output arguments. The method will return false if the invariant mass of the four-vectors is too small to accommodate the new masses, and then the four-vectors are not changed."},{"name":"friend double cosphi(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor41","text":"friend double cosphi(const Vec4& v1, const Vec4& v2) the (cosine) of the azimuthal angle between the vectors around the friend double cosphi(const Vec4& v1, const Vec4& v2) z axis, in the range 0 through friend double cosphi(const Vec4& v1, const Vec4& v2) pi."},{"name":"friend double cosphi(const Vec4& v1, const Vec4& v2,  const Vec4& v3)","link":"FourVectors.html#anchor43","text":"friend double cosphi(const Vec4& v1, const Vec4& v2,  const Vec4& v3) the (cosine) of the azimuthal angle between the first two vectors around the direction of the third, in the range 0 through friend double cosphi(const Vec4& v1, const Vec4& v2,  const Vec4& v3) pi."},{"name":"friend double costheta(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor39","text":"friend double costheta(const Vec4& v1, const Vec4& v2) the (cosine) of the opening angle between the vectors, in the range 0 through friend double costheta(const Vec4& v1, const Vec4& v2) pi."},{"name":"friend double cross3(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor36","text":"friend double cross3(const Vec4& v1, const Vec4& v2) the cross-product."},{"name":"friend double cross4(const Vec4& v1, const Vec4& v2,  const Vec4& v3)","link":"FourVectors.html#anchor37","text":"friend double cross4(const Vec4& v1, const Vec4& v2,  const Vec4& v3) the cross-product of three four-vectors: friend double cross4(const Vec4& v1, const Vec4& v2,  const Vec4& v3) v_i = epsilon_{iabc} v1_a v2_b v3_c."},{"name":"friend double dot3(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor35","text":"friend double dot3(const Vec4& v1, const Vec4& v2) the three-product."},{"name":"friend double m(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor33","text":"friend double m(const Vec4& v1, const Vec4& v2)"},{"name":"friend double m2(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor34","text":"friend double m2(const Vec4& v1, const Vec4& v2) the (squared) invariant mass."},{"name":"friend double operator*(const Vec4& v1, const Vec4 v2)","link":"FourVectors.html#anchor58","text":"friend double operator*(const Vec4& v1, const Vec4 v2) four-vector product."},{"name":"friend double phi(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor40","text":"friend double phi(const Vec4& v1, const Vec4& v2)"},{"name":"friend double phi(const Vec4& v1, const Vec4& v2,  const Vec4& v3)","link":"FourVectors.html#anchor42","text":"friend double phi(const Vec4& v1, const Vec4& v2,  const Vec4& v3)"},{"name":"friend double REtaPhi(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor45","text":"friend double REtaPhi(const Vec4& v1, const Vec4& v2) the friend double REtaPhi(const Vec4& v1, const Vec4& v2) R distance measure, in friend double REtaPhi(const Vec4& v1, const Vec4& v2) (y, phi) or friend double REtaPhi(const Vec4& v1, const Vec4& v2) (eta, phi) cylindrical coordinates, i.e. friend double REtaPhi(const Vec4& v1, const Vec4& v2) R^2 = (y_1 - y_2)^2 + (phi_1 - phi_2)^2 and equivalent."},{"name":"friend double RRapPhi(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor44","text":"friend double RRapPhi(const Vec4& v1, const Vec4& v2)"},{"name":"friend double theta(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor38","text":"friend double theta(const Vec4& v1, const Vec4& v2)"},{"name":"friend Hist operator*(const Hist&amp; h1, const Hist h2)","link":"Histograms.html#anchor44","text":"friend Hist operator*(const Hist&amp; h1, const Hist h2) multiply a constant by a histogram or two histograms by each other, bin by bin."},{"name":"friend Hist operator*(const Hist&amp; h1, double f)","link":"Histograms.html#anchor43","text":"friend Hist operator*(const Hist&amp; h1, double f)"},{"name":"friend Hist operator*(double f, const Hist&amp; h1)","link":"Histograms.html#anchor42","text":"friend Hist operator*(double f, const Hist&amp; h1)"},{"name":"friend Hist operator+(const Hist&amp; h1, const Hist h2)","link":"Histograms.html#anchor38","text":"friend Hist operator+(const Hist&amp; h1, const Hist h2) add a constant to a histogram or two histograms to each other, bin by bin."},{"name":"friend Hist operator+(const Hist&amp; h1, double f)","link":"Histograms.html#anchor37","text":"friend Hist operator+(const Hist&amp; h1, double f)"},{"name":"friend Hist operator+(double f, const Hist&amp; h1)","link":"Histograms.html#anchor36","text":"friend Hist operator+(double f, const Hist&amp; h1)"},{"name":"friend Hist operator-(const Hist&amp; h1, const Hist h2)","link":"Histograms.html#anchor41","text":"friend Hist operator-(const Hist&amp; h1, const Hist h2) subtract a histogram from a constant, a constant from a histogram, or two histograms from each other, bin by bin."},{"name":"friend Hist operator-(const Hist&amp; h1, double f)","link":"Histograms.html#anchor40","text":"friend Hist operator-(const Hist&amp; h1, double f)"},{"name":"friend Hist operator-(double f, const Hist&amp; h1)","link":"Histograms.html#anchor39","text":"friend Hist operator-(double f, const Hist&amp; h1)"},{"name":"friend Hist operator/(const Hist&amp; h1, const Hist h2)","link":"Histograms.html#anchor47","text":"friend Hist operator/(const Hist&amp; h1, const Hist h2) divide a constant by a histogram, a histogram by a constant, or two histograms by each other, bin by bin."},{"name":"friend Hist operator/(const Hist&amp; h1, double f)","link":"Histograms.html#anchor46","text":"friend Hist operator/(const Hist&amp; h1, double f)"},{"name":"friend Hist operator/(double f, const Hist&amp; h1)","link":"Histograms.html#anchor45","text":"friend Hist operator/(double f, const Hist&amp; h1)"},{"name":"friend ostream& operator&lt;&lt;(ostream&,  const RotBstMatrix& M)","link":"FourVectors.html#anchor92","text":"friend ostream& operator<<(ostream&,  const RotBstMatrix& M) writes out the values of the sixteen components of a friend ostream& operator<<(ostream&,  const RotBstMatrix& M) RotBstMatrix , on four consecutive lines and ended with a newline."},{"name":"friend ostream& operator&lt;&lt;(ostream&, const Vec4& v)","link":"FourVectors.html#anchor32","text":"friend ostream& operator<<(ostream&, const Vec4& v) writes out the values of the four components of a friend ostream& operator<<(ostream&, const Vec4& v) Vec4 and, within brackets, a fifth component being the invariant length of the four-vector, as provided by friend ostream& operator<<(ostream&, const Vec4& v) mCalc() above, and it all ended with a newline."},{"name":"friend ostream& operator&lt;&lt;(ostream&amp; os,  const Hist&amp; h)","link":"Histograms.html#anchor10","text":"friend ostream& operator<<(ostream&amp; os,  const Hist&amp; h) appends a simple histogram printout (see above for format) to the friend ostream& operator<<(ostream&amp; os,  const Hist&amp; h) ostream , while leaving the histogram object itself unchanged. At most 100 columns are allowed to be displayed. If the number of bins is larger than 100 then the contents of adjacent bins are added to give the value in each column. (Two by two up to 200 bins, three by three up to 300, and so on, with the very last column possibly summing fewer rows than the others.) friend ostream& operator<<(ostream&amp; os,  const Hist&amp; h) If the histogram has been booked with logarithmic friend ostream& operator<<(ostream&amp; os,  const Hist&amp; h) x scale then the log10 of each lower bin border will be displayed rather than the border itself, to avoid undue complication. The Pyplot interface will display correct values, however."},{"name":"friend pair&lt;Vec4,Vec4&gt; getTwoPerpendicular(const Vec4& v1,  const Vec4& v2)","link":"FourVectors.html#anchor47","text":"friend pair<Vec4,Vec4> getTwoPerpendicular(const Vec4& v1,  const Vec4& v2) create a pair of four-vectors that are perpendicular to both input vectors and to each other, and have the squared norm friend pair<Vec4,Vec4> getTwoPerpendicular(const Vec4& v1,  const Vec4& v2) -1."},{"name":"friend Vec4 operator*(const Vec4& v, double f)","link":"FourVectors.html#anchor56","text":"friend Vec4 operator*(const Vec4& v, double f) multiply a four-vector by a real number."},{"name":"friend Vec4 operator*(double f, const Vec4& v)","link":"FourVectors.html#anchor55","text":"friend Vec4 operator*(double f, const Vec4& v)"},{"name":"friend Vec4 operator+(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor53","text":"friend Vec4 operator+(const Vec4& v1, const Vec4& v2) add two four-vectors."},{"name":"friend Vec4 operator-(const Vec4& v1, const Vec4& v2)","link":"FourVectors.html#anchor54","text":"friend Vec4 operator-(const Vec4& v1, const Vec4& v2) subtract two four-vectors."},{"name":"friend Vec4 operator/(const Vec4& v, double f)","link":"FourVectors.html#anchor57","text":"friend Vec4 operator/(const Vec4& v, double f) divide a four-vector by a real number."},{"name":"friend void table(const Hist&amp; h1, const Hist&amp; h2,  ostream& os = cout, bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor17","text":"friend void table(const Hist&amp; h1, const Hist&amp; h2,  ostream& os = cout, bool printOverUnder = false, bool xMidBin = true)"},{"name":"friend void table(const Hist&amp; h1, const Hist&amp; h2,  string fileName, bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor18","text":"friend void table(const Hist&amp; h1, const Hist&amp; h2,  string fileName, bool printOverUnder = false, bool xMidBin = true) print a three-column table, where the first column gives the center of each bin and the second and third ones the corresponding bin contents of the two histograms. Only works if the two histograms have the same friend void table(const Hist&amp; h1, const Hist&amp; h2,  string fileName, bool printOverUnder = false, bool xMidBin = true) x axis (within a tiny tolerance), else nothing will be done. The optional last two arguments allows also underflow and overflow contents to be printed, and the friend void table(const Hist&amp; h1, const Hist&amp; h2,  string fileName, bool printOverUnder = false, bool xMidBin = true) x to refer to the beginning of the bin rather than the center; see above."},{"name":"HeavyIons* Pythia::getHeavyIonsPtr()","link":"ProgramFlow.html#anchor24","text":"HeavyIons* Pythia::getHeavyIonsPtr() gives access to the current HeavyIons* Pythia::getHeavyIonsPtr() Heavy Ions generator, either the default internal Angantyr one or an external one fed in by the method above this. This way a number of further event properties can be interrogated."},{"name":"Hist&amp; Hist::operator*=(const Hist&amp; h)","link":"Histograms.html#anchor30","text":"Hist&amp; Hist::operator*=(const Hist&amp; h)"},{"name":"Hist&amp; Hist::operator*=(double f)","link":"Histograms.html#anchor34","text":"Hist&amp; Hist::operator*=(double f) Hist&amp; Hist::operator*=(double f) multiplies or divides each bin content by the common factor Hist&amp; Hist::operator*=(double f) f."},{"name":"Hist&amp; Hist::operator+=(const Hist&amp; h)","link":"Histograms.html#anchor28","text":"Hist&amp; Hist::operator+=(const Hist&amp; h)"},{"name":"Hist&amp; Hist::operator+=(double f)","link":"Histograms.html#anchor32","text":"Hist&amp; Hist::operator+=(double f)"},{"name":"Hist&amp; Hist::operator-=(const Hist&amp; h)","link":"Histograms.html#anchor29","text":"Hist&amp; Hist::operator-=(const Hist&amp; h) adds or subtracts the current histogram by the contents of the histogram in the argument if Hist&amp; Hist::operator-=(const Hist&amp; h) sameSize(...) is true, else does nothing."},{"name":"Hist&amp; Hist::operator-=(double f)","link":"Histograms.html#anchor33","text":"Hist&amp; Hist::operator-=(double f) adds or subtracts each bin content by the common offset Hist&amp; Hist::operator-=(double f) f."},{"name":"Hist&amp; Hist::operator/=(const Hist&amp; h)","link":"Histograms.html#anchor31","text":"Hist&amp; Hist::operator/=(const Hist&amp; h) multiplies or divides the current histogram by the contents of the histogram in the argument if Hist&amp; Hist::operator/=(const Hist&amp; h) sameSize(...) is true, else does nothing."},{"name":"Hist&amp; Hist::operator=(const Hist&amp; h)","link":"Histograms.html#anchor5","text":"Hist&amp; Hist::operator=(const Hist&amp; h) copies all properties of the histogram in the argument, except that the original histogram title is retained."},{"name":"Hist::Hist()","link":"Histograms.html#anchor1","text":"Hist::Hist() declare a histogram, but does not define it."},{"name":"Hist::Hist(const Hist&amp; h)","link":"Histograms.html#anchor3","text":"Hist::Hist(const Hist&amp; h) creates an identical copy of the histogram in the argument, including bin contents."},{"name":"Hist::Hist(string title, const Hist&amp; h)","link":"Histograms.html#anchor4","text":"Hist::Hist(string title, const Hist&amp; h) creates an identical copy of the histogram in the argument, including bin contents, except that a new title is provided as first argument."},{"name":"Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false)","link":"Histograms.html#anchor2","text":"Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) declare and define a histogram, where Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) is a string with the title of the histogram at output, Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) is the number of bin the Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) x range will be subdivided into, limited to be at most 1000, Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) is the lower edge of the histogram, Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) is the upper edge of the histogram, Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) gives a logarithmic Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) x scale between Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) xMin and Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) xMax if set Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) true. Note that then Hist::Hist(string title, int numberOfBins, double xMin,  double xMax, bool logX = false) xMin must be above 1e-20 so as to stay with positive numbers."},{"name":"HistPlot::HistPlot(string pythonName)","link":"Histograms.html#anchor48","text":"HistPlot::HistPlot(string pythonName) create a file to which successively Python commands can be written. HistPlot::HistPlot(string pythonName) the name of the Python code file will become HistPlot::HistPlot(string pythonName) pythonName.py. When later executed with HistPlot::HistPlot(string pythonName) python pythonName.py the frames defined below will be drawn and output."},{"name":"Info Pythia::info","link":"ProgramFlow.html#anchor45","text":"Info Pythia::info further information on the event-generation process, see Info Pythia::info here for further details."},{"name":"int AlpgenPar::getParamAsInt(const string &amp;paramIn)","link":"AlpgenEventInterface.html#anchor13","text":"int AlpgenPar::getParamAsInt(const string &amp;paramIn) Return the parameter with key int AlpgenPar::getParamAsInt(const string &amp;paramIn) paramIn as a double or integer. The presence of a parameter should have already been checked using the int AlpgenPar::getParamAsInt(const string &amp;paramIn) haveParam() function above. If the parameter is not present, 0 is returned."},{"name":"int CellJet::multiplicity(int i)","link":"EventAnalysis.html#anchor36","text":"int CellJet::multiplicity(int i) gives the number of particles clustered into the int CellJet::multiplicity(int i) i 'th jet,"},{"name":"int CellJet::nError()","link":"EventAnalysis.html#anchor41","text":"int CellJet::nError() tells the number of times int CellJet::nError() analyze(...) failed to analyze events, i.e. returned int CellJet::nError() false."},{"name":"int CellJet::size()","link":"EventAnalysis.html#anchor30","text":"int CellJet::size() gives the number of jets found, with jets numbered 0 through int CellJet::size() size() - 1 ,"},{"name":"int ClusterJet::distanceSize()","link":"EventAnalysis.html#anchor25","text":"int ClusterJet::distanceSize() the number of most recent clustering scales that have been stored for readout with the next method. Normally this would be five, but less if fewer clustering steps occurred."},{"name":"int ClusterJet::jetAssignment(int i)","link":"EventAnalysis.html#anchor23","text":"int ClusterJet::jetAssignment(int i) gives the index of the jet that the particle int ClusterJet::jetAssignment(int i) i of the event record belongs to,"},{"name":"int ClusterJet::mult(int i)","link":"EventAnalysis.html#anchor22","text":"int ClusterJet::mult(int i) the number of particles that have been clustered into the int ClusterJet::mult(int i) i 'th jet."},{"name":"int ClusterJet::nError()","link":"EventAnalysis.html#anchor27","text":"int ClusterJet::nError() tells the number of times int ClusterJet::nError() analyze(...) failed to analyze events, i.e. returned int ClusterJet::nError() false."},{"name":"int ClusterJet::size()","link":"EventAnalysis.html#anchor20","text":"int ClusterJet::size() gives the number of jets found, with jets numbered 0 through int ClusterJet::size() size() - 1."},{"name":"int CoupSM::V2CKMpick(int id)","link":"StandardModelParameters.html#anchor45","text":"int CoupSM::V2CKMpick(int id) picks a random CKM partner quark or lepton (with the same sign as int CoupSM::V2CKMpick(int id) id ) according to the respective squared elements, again excluding the top quark and fourth generation from the list of possibilities. Unambiguous choice for the lepton-neutrino sector."},{"name":"int DecayChannel::meMode()","link":"ParticleDataScheme.html#anchor179","text":"int DecayChannel::meMode() set or get the mode of processing this channel, possibly with matrix elements (see the int DecayChannel::meMode() particle decays and int DecayChannel::meMode() resonance decays descriptions)."},{"name":"int DecayChannel::multiplicity()","link":"ParticleDataScheme.html#anchor181","text":"int DecayChannel::multiplicity() set or get the number of decay products in a channel, at most 8. (Is normally not to be set by hand, since it is automatically updated whenever the products list is changed.)"},{"name":"int DecayChannel::onMode()","link":"ParticleDataScheme.html#anchor174","text":"int DecayChannel::onMode() set or get the int DecayChannel::onMode() onMode of a decay channel, int DecayChannel::onMode() 0 if a channel is off, int DecayChannel::onMode() 1 if on, int DecayChannel::onMode() 2 if on for a particle but off for an antiparticle, int DecayChannel::onMode() 3 if on for an antiparticle but off for a particle. int DecayChannel::onMode() If a particle is its own antiparticle then 2 is on and 3 off but, of course, for such particles it is much simpler and safer to use only 1 and 0. int DecayChannel::onMode() The 2 and 3 options can be used e.g. to encode CP violation in B decays, or to let the int DecayChannel::onMode() W 's in a int DecayChannel::onMode() q qbar &rarr; W^+ W^- process decay in different channels."},{"name":"int DecayChannel::product(int i)","link":"ParticleDataScheme.html#anchor183","text":"int DecayChannel::product(int i) set or get a list of the decay products, 8 products 0 <= i < 8, with trailing unused ones set to 0."},{"name":"int Event::append(int id, int status, int col,  int acol, Vec4 p, double m = 0., double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor29","text":"int Event::append(int id, int status, int col,  int acol, Vec4 p, double m = 0., double scale = 0., double pol = 9.) appends a particle to the bottom of the event record and returns the index of this position, as above but with vanishing (i.e. zero) mother and daughter indices."},{"name":"int Event::append(int id, int status, int col, int acol,  double px, double py, double pz, double e, double m = 0.,  double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor28","text":"int Event::append(int id, int status, int col, int acol,  double px, double py, double pz, double e, double m = 0.,  double scale = 0., double pol = 9.)"},{"name":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  double px, double py, double pz,  double e, double m = 0.,  double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor26","text":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  double px, double py, double pz,  double e, double m = 0.,  double scale = 0., double pol = 9.) appends a particle to the bottom of the event record and returns the index of this position; int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  double px, double py, double pz,  double e, double m = 0.,  double scale = 0., double pol = 9.) see here for the meaning of the various particle properties."},{"name":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  Vec4 p, double m = 0., double scale = 0., double pol = 9.)","link":"EventRecord.html#anchor27","text":"int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  Vec4 p, double m = 0., double scale = 0., double pol = 9.) appends a particle to the bottom of the event record and returns the index of this position, as above but with four-momentum as a int Event::append(int id, int status, int mother1,  int mother2, int daughter1, int daughter2, int col, int acol,  Vec4 p, double m = 0., double scale = 0., double pol = 9.) Vec4."},{"name":"int Event::append(Particle entryIn)","link":"EventRecord.html#anchor25","text":"int Event::append(Particle entryIn) appends a particle to the bottom of the event record and returns the index of this position."},{"name":"int Event::copy(int iCopy, int newStatus = 0)","link":"EventRecord.html#anchor31","text":"int Event::copy(int iCopy, int newStatus = 0) copies the existing particle in entry int Event::copy(int iCopy, int newStatus = 0) iCopy to the bottom of the event record and returns the index of this position. By default, i.e. with int Event::copy(int iCopy, int newStatus = 0) newStatus = 0 , everything is copied precisely as it is, which means that history information has to be modified further by hand to make sense. With a positive int Event::copy(int iCopy, int newStatus = 0) newStatus , the new copy is set up to be the daughter of the old, with status code int Event::copy(int iCopy, int newStatus = 0) newStatus , while the status code of int Event::copy(int iCopy, int newStatus = 0) iCopy is negated. With a negative int Event::copy(int iCopy, int newStatus = 0) newStatus , the new copy is instead set up to be the mother of int Event::copy(int iCopy, int newStatus = 0) iCopy. An attempt to copy an out-of-range entry will return -1."},{"name":"int Event::lastColTag()","link":"EventRecord.html#anchor14","text":"int Event::lastColTag() returns the current maximum colour tag."},{"name":"int Event::nextColTag()","link":"EventRecord.html#anchor15","text":"int Event::nextColTag() increases the current maximum colour tag by one and returns this new value. This method is used whenever a new colour tag is needed."},{"name":"int Event::nFinal(bool chargedOnly = false)","link":"EventRecord.html#anchor33","text":"int Event::nFinal(bool chargedOnly = false) return the number of final-state particles in the current event record, optionally counting charged particles only."},{"name":"int Event::setEvtPtr(int iSet = -1)","link":"EventRecord.html#anchor30","text":"int Event::setEvtPtr(int iSet = -1) send in the int Event::setEvtPtr(int iSet = -1) this pointer of the current int Event::setEvtPtr(int iSet = -1) Event itself to the particle int Event::setEvtPtr(int iSet = -1) iSet , by default the most recently appended particle. Also generates a pointer to the int Event::setEvtPtr(int iSet = -1) ParticleDataEntry object of the identity code of the particle."},{"name":"int Event::size()","link":"EventRecord.html#anchor6","text":"int Event::size() The event size, i.e. the size of the int Event::size() vector<Particle>. Thus valid particles, to be accessed by the above indexing operator, are stored in the range int Event::size() 0 <= i < size(). See comment above about the (ir)relevance of entry 0."},{"name":"int Hist::getBinNumber()","link":"Histograms.html#anchor20","text":"int Hist::getBinNumber() return the number of bins in the histogram."},{"name":"int Hist::getEntries()","link":"Histograms.html#anchor23","text":"int Hist::getEntries() return the number of entries, i.e. the number of time that int Hist::getEntries() fill(...) has been called."},{"name":"int Info::code()","link":"EventInformation.html#anchor14","text":"int Info::code() the name and code of the process that occurred."},{"name":"int Info::codeMPI(int i)","link":"EventInformation.html#anchor90","text":"int Info::codeMPI(int i)"},{"name":"int Info::codeSub()","link":"EventInformation.html#anchor28","text":"int Info::codeSub()"},{"name":"int Info::getCounter(int i)","link":"EventInformation.html#anchor105","text":"int Info::getCounter(int i) the method that gives you access to the value of the various loop counters. int Info::getCounter(int i) the counter number you want to access: int Info::getCounter(int i) counters that refer to the run as a whole, i.e. are set 0 at the beginning of the run and then only can increase. int Info::getCounter(int i) the number of successful constructor calls for the int Info::getCounter(int i) Pythia class (can only be 0 or 1). int Info::getCounter(int i) the number of times a int Info::getCounter(int i) Pythia::init() call has been begun. int Info::getCounter(int i) the number of times a int Info::getCounter(int i) Pythia::init() call has been completed successfully. int Info::getCounter(int i) the number of times a int Info::getCounter(int i) Pythia::next() call has been begun. int Info::getCounter(int i) the number of times a int Info::getCounter(int i) Pythia::next() call has been completed successfully. int Info::getCounter(int i) counters that refer to each individual event, and are reset and updated in the top-level int Info::getCounter(int i) Pythia::next() method. int Info::getCounter(int i) the number of times the selection of a new hard process has been begun. Normally this should only happen once, unless a user veto is set to abort the current process and try a new one. int Info::getCounter(int i) the number of times the selection of a new hard process has been completed successfully. int Info::getCounter(int i) as 11, but additionally the process should survive any user veto and go on to the parton- and hadron-level stages. int Info::getCounter(int i) as 11, but additionally the process should survive the parton- and hadron-level stage and any user cuts. int Info::getCounter(int i) the number of times the loop over parton- and hadron-level processing has begun for a hard process. Is reset each time counter 12 above is reached. int Info::getCounter(int i) the number of times the above loop has successfully completed the parton-level step. int Info::getCounter(int i) the number of times the above loop has successfully completed the checks and user vetoes after the parton-level step. int Info::getCounter(int i) the number of times the above loop has successfully completed the hadron-level step. int Info::getCounter(int i) the number of times the above loop has successfully completed the checks and user vetoes after the hadron-level step. int Info::getCounter(int i) counters that refer to a local part of the individual event, and are reset at the beginning of this part. int Info::getCounter(int i) the current system being processed in int Info::getCounter(int i) PartonLevel::next(). Is almost always 1, but for double diffraction the two diffractive systems are 1 and 2, respectively. int Info::getCounter(int i) the number of times the processing of the current system (see above) has begun. int Info::getCounter(int i) the number of times a step has begun in the combined MPI/ISR/FSR evolution downwards in int Info::getCounter(int i) pT for the current system. int Info::getCounter(int i) the number of times MPI has been selected for the downwards step above. int Info::getCounter(int i) the number of times ISR has been selected for the downwards step above. int Info::getCounter(int i) the number of times FSR has been selected for the downwards step above. int Info::getCounter(int i) the number of times MPI has been accepted as the downwards step above, after the vetoes. int Info::getCounter(int i) the number of times ISR has been accepted as the downwards step above, after the vetoes. int Info::getCounter(int i) the number of times FSR has been accepted as the downwards step above, after the vetoes. int Info::getCounter(int i) the number of times a step has begun in the separate (optional) FSR evolution downwards in int Info::getCounter(int i) pT for the current system. int Info::getCounter(int i) the number of times FSR has been selected for the downwards step above. int Info::getCounter(int i) the number of times FSR has been accepted as the downwards step above, after the vetoes. int Info::getCounter(int i) keeps track of vetoed emission for shower reweighting. int Info::getCounter(int i) counters that are unused (currently), and that therefore are free to use, with the help of the two methods below."},{"name":"int Info::getGeneratorSize()","link":"EventInformation.html#anchor116","text":"int Info::getGeneratorSize()"},{"name":"int Info::getInitrwgtSize()","link":"EventInformation.html#anchor115","text":"int Info::getInitrwgtSize()"},{"name":"int Info::iAMPI(int i)","link":"EventInformation.html#anchor92","text":"int Info::iAMPI(int i)"},{"name":"int Info::iBMPI(int i)","link":"EventInformation.html#anchor93","text":"int Info::iBMPI(int i) are normally zero. However, if the int Info::iBMPI(int i) i 'th subprocess is a rescattering, i.e. either or both incoming partons come from the outgoing state of previous scatterings, they give the position in the event record of the outgoing-state parton that rescatters. int Info::iBMPI(int i) iAMPI and int Info::iBMPI(int i) iBMPI then denote partons coming from the first or second beam, respectively."},{"name":"int Info::id1()","link":"EventInformation.html#anchor30","text":"int Info::id1()"},{"name":"int Info::id1pdf()","link":"EventInformation.html#anchor38","text":"int Info::id1pdf()"},{"name":"int Info::id2()","link":"EventInformation.html#anchor31","text":"int Info::id2() the identities of the two partons coming in to the hard process."},{"name":"int Info::id2pdf()","link":"EventInformation.html#anchor39","text":"int Info::id2pdf() the identities of the two partons for which parton density values are defined."},{"name":"int Info::idA()","link":"EventInformation.html#anchor2","text":"int Info::idA()"},{"name":"int Info::idB()","link":"EventInformation.html#anchor3","text":"int Info::idB() the identities of the two beam particles."},{"name":"int Info::lhaStrategy()","link":"EventInformation.html#anchor75","text":"int Info::lhaStrategy() normally 0, but if Les Houches events are input then it gives the event weighting strategy, see int Info::lhaStrategy() Les Houches Accord."},{"name":"int Info::LHEFversion()","link":"EventInformation.html#anchor114","text":"int Info::LHEFversion()"},{"name":"int Info::nFinal()","link":"EventInformation.html#anchor15","text":"int Info::nFinal() the number of final-state partons in the hard process."},{"name":"int Info::nFinalSub()","link":"EventInformation.html#anchor29","text":"int Info::nFinalSub() the name, code and number of final-state partons in the subprocess that occurred when int Info::nFinalSub() hasSub() is true. For a minimum-bias event the int Info::nFinalSub() code would always be 101, while int Info::nFinalSub() codeSub() would vary depending on the actual hardest interaction, e.g. 111 for int Info::nFinalSub() g g &rarr; g g. For a Les Houches event the int Info::nFinalSub() code would always be 9999, while int Info::nFinalSub() codeSub() would be the external user-defined classification code. The methods below would also provide information for such particular subcollisions."},{"name":"int Info::nFSRinProc()","link":"EventInformation.html#anchor77","text":"int Info::nFSRinProc()"},{"name":"int Info::nFSRinRes()","link":"EventInformation.html#anchor78","text":"int Info::nFSRinRes() the number of emissions in the initial-state showering, in the final-state showering excluding resonance decays, and in the final-state showering inside resonance decays, respectively."},{"name":"int Info::nISR()","link":"EventInformation.html#anchor76","text":"int Info::nISR()"},{"name":"int Info::nMPI()","link":"EventInformation.html#anchor89","text":"int Info::nMPI() The number of hard interactions in the current event. Is 0 for elastic and diffractive events, and else at least 1, with more possible from multiparton interactions."},{"name":"int Info::nProcessesLHEF()","link":"EventInformation.html#anchor119","text":"int Info::nProcessesLHEF() return the number of processes for which the cross section is stored."},{"name":"int Info::photonMode()","link":"EventInformation.html#anchor72","text":"int Info::photonMode() Type of photon process, see int Info::photonMode() Photoproduction for details."},{"name":"int LHAup::col1(int i)","link":"LesHouchesAccord.html#anchor43","text":"int LHAup::col1(int i)"},{"name":"int LHAup::col2(int i)","link":"LesHouchesAccord.html#anchor44","text":"int LHAup::col2(int i)"},{"name":"int LHAup::id(int i)","link":"LesHouchesAccord.html#anchor39","text":"int LHAup::id(int i)"},{"name":"int LHAup::id1()","link":"LesHouchesAccord.html#anchor54","text":"int LHAup::id1()"},{"name":"int LHAup::id1pdf()","link":"LesHouchesAccord.html#anchor60","text":"int LHAup::id1pdf()"},{"name":"int LHAup::id2()","link":"LesHouchesAccord.html#anchor55","text":"int LHAup::id2()"},{"name":"int LHAup::id2pdf()","link":"LesHouchesAccord.html#anchor61","text":"int LHAup::id2pdf()"},{"name":"int LHAup::idBeamA()","link":"LesHouchesAccord.html#anchor13","text":"int LHAup::idBeamA()"},{"name":"int LHAup::idBeamB()","link":"LesHouchesAccord.html#anchor14","text":"int LHAup::idBeamB()"},{"name":"int LHAup::idProcess()","link":"LesHouchesAccord.html#anchor33","text":"int LHAup::idProcess() process number."},{"name":"int LHAup::idProcess(i)","link":"LesHouchesAccord.html#anchor23","text":"int LHAup::idProcess(i)"},{"name":"int LHAup::mother1(int i)","link":"LesHouchesAccord.html#anchor41","text":"int LHAup::mother1(int i)"},{"name":"int LHAup::mother2(int i)","link":"LesHouchesAccord.html#anchor42","text":"int LHAup::mother2(int i)"},{"name":"int LHAup::pdfGroupBeamA()","link":"LesHouchesAccord.html#anchor17","text":"int LHAup::pdfGroupBeamA()"},{"name":"int LHAup::pdfGroupBeamB()","link":"LesHouchesAccord.html#anchor18","text":"int LHAup::pdfGroupBeamB()"},{"name":"int LHAup::pdfSetBeamA()","link":"LesHouchesAccord.html#anchor19","text":"int LHAup::pdfSetBeamA()"},{"name":"int LHAup::pdfSetBeamB()","link":"LesHouchesAccord.html#anchor20","text":"int LHAup::pdfSetBeamB() for the beam properties."},{"name":"int LHAup::sizePart()","link":"LesHouchesAccord.html#anchor38","text":"int LHAup::sizePart() the size of the particle array, which is one larger than the number of particles in the event, since the zeroth entry is kept empty (see above)."},{"name":"int LHAup::sizeProc()","link":"LesHouchesAccord.html#anchor22","text":"int LHAup::sizeProc() for the number of subprocesses."},{"name":"int LHAup::status(int i)","link":"LesHouchesAccord.html#anchor40","text":"int LHAup::status(int i)"},{"name":"int LHAup::strategy()","link":"LesHouchesAccord.html#anchor21","text":"int LHAup::strategy() for the strategy choice."},{"name":"int MergingHooks::nHardInLeptons()","link":"CKKWLMerging.html#anchor23","text":"int MergingHooks::nHardInLeptons() Returns the number of incoming leptons in the hard core process."},{"name":"int MergingHooks::nHardInPartons()","link":"CKKWLMerging.html#anchor22","text":"int MergingHooks::nHardInPartons() Returns the number of incoming partons in the hard core process."},{"name":"int MergingHooks::nHardOutLeptons()","link":"CKKWLMerging.html#anchor21","text":"int MergingHooks::nHardOutLeptons() Returns the number of outgoing leptons in the hard core process."},{"name":"int MergingHooks::nHardOutPartons()","link":"CKKWLMerging.html#anchor20","text":"int MergingHooks::nHardOutPartons() Returns the number of outgoing partons in the hard core process."},{"name":"int MergingHooks::nMaxJets()","link":"CKKWLMerging.html#anchor19","text":"int MergingHooks::nMaxJets() Return the maximum number of additional jets to be merged."},{"name":"int MergingHooks::nResInCurrent()","link":"CKKWLMerging.html#anchor24","text":"int MergingHooks::nResInCurrent() The number of resonances in the hard process reconstructed from the current event. If e.g. the ME configuration was int MergingHooks::nResInCurrent() pp &rarr; (w+&rarr;e+ve)(z &rarr; mu+mu-)jj , and the ME generator put both intermediate bosons into the LHE file, this will return 2."},{"name":"int Particle::acol()","link":"ParticleProperties.html#anchor8","text":"int Particle::acol() the colour and anticolour tags, Les Houches Accord int Particle::acol() Boo01 style (starting from tag 101 by default, see below). int Particle::acol() Note: in the preliminary implementation of colour sextets (exotic BSM particles) that exists since PYTHIA 8.150, a negative anticolour tag is interpreted as an additional positive colour tag, and vice versa."},{"name":"int Particle::chargeType()","link":"ParticleProperties.html#anchor70","text":"int Particle::chargeType() charge, and three times it to make an integer."},{"name":"int Particle::col()","link":"ParticleProperties.html#anchor7","text":"int Particle::col()"},{"name":"int Particle::colType()","link":"ParticleProperties.html#anchor73","text":"int Particle::colType() 0 for colour singlets, 1 for triplets, -1 for antitriplets and 2 for octets. (A preliminary implementation of colour sextets also exists, using 3 for sextets and -3 for antisextets.)"},{"name":"int Particle::daughter1()","link":"ParticleProperties.html#anchor5","text":"int Particle::daughter1()"},{"name":"int Particle::daughter2()","link":"ParticleProperties.html#anchor6","text":"int Particle::daughter2() the indices in the event record where the first and last daughters are stored, if any. There are five allowed combinations of int Particle::daughter2() daughter1 and int Particle::daughter2() daughter2 : int Particle::daughter2() int Particle::daughter2() int Particle::daughter2() daughter1 = daughter2 = 0 : there are no daughters (so far); int Particle::daughter2() int Particle::daughter2() daughter1 = daughter2 > 0 : the particle has a 'carbon copy' as its sole daughter, but with changed momentum as a 'recoil' effect, e.g. in a shower; int Particle::daughter2() int Particle::daughter2() daughter1 > 0, daughter2 = 0 : each of the incoming beams has only (at most) one daughter, namely the initiator parton of the hardest interaction; further, in a int Particle::daughter2() 2 &rarr; 1 hard interaction, like int Particle::daughter2() q qbar &rarr; Z^0 , or in a clustering of two nearby partons, the initial partons only have this one daughter; int Particle::daughter2() int Particle::daughter2() daughter1 < daughter2 , both > 0: the particle has a range of decay products from int Particle::daughter2() daughter1 to int Particle::daughter2() daughter2 ; int Particle::daughter2() int Particle::daughter2() daughter2 < daughter1 , both > 0: the particle has two separately stored decay products (e.g. in backwards evolution of initial-state showers). int Particle::daughter2() Note 1: in backwards evolution of initial-state showers, the daughters may well appear below the mother in the event record. int Particle::daughter2() Note 2: the mother-daughter relation normally is reciprocal, but not always. An example is hadron beams (indices 1 and 2), where each beam remnant and the initiator of each multiparton interaction has the respective beam as mother, but the beam itself only has the initiator of the hardest interaction as daughter. int Particle::daughter2() Note 3: the int Particle::daughter2() daughterList() method below returns a vector of all the daughters, providing a uniform representation for all five cases. With this method, also all the daughters of the beams are caught, with the initiators of the basic process given first,  while the rest are in no guaranteed order (since they are found by a scanning of the event record for particles with the beam as mother, with no further information)."},{"name":"int Particle::iBotCopy()","link":"ParticleProperties.html#anchor95","text":"int Particle::iBotCopy() are used to trace carbon copies of the particle up to its top mother or down to its bottom daughter. If there are no such carbon copies, the index of the particle itself will be returned. A carbon copy is when the 'same' particle appears several times in the event record, but with changed momentum owing to recoil effects."},{"name":"int Particle::iBotCopyId(bool simplify = false)","link":"ParticleProperties.html#anchor97","text":"int Particle::iBotCopyId(bool simplify = false) also trace top mother and bottom daughter, but do not require carbon copies, only that one can find an unbroken chain, of mothers or daughters, with the same flavour int Particle::iBotCopyId(bool simplify = false) id code. When it encounters ambiguities, say a int Particle::iBotCopyId(bool simplify = false) g &rarr; g g branching or a int Particle::iBotCopyId(bool simplify = false) u u &rarr; u u hard scattering, it will stop the tracing and return the current position. It can be confused by nontrivial flavour changes, e.g. a hard process int Particle::iBotCopyId(bool simplify = false) u d &rarr; d u by int Particle::iBotCopyId(bool simplify = false) W^+- exchange will give the wrong answer. These methods therefore are of limited use for common particles, in particular for the gluon, but should work well for 'rare' particles. By default all mothers and daughters are studied in each step, but with int Particle::iBotCopyId(bool simplify = false) simplify = true only the first and last mother/daughter are checked, which saves time and almost always gives the same result."},{"name":"int Particle::id()","link":"ParticleProperties.html#anchor1","text":"int Particle::id() the identity of a particle, according to the PDG particle codes int Particle::id() Yao06."},{"name":"int Particle::idAbs()","link":"ParticleProperties.html#anchor32","text":"int Particle::idAbs() the absolute value of the particle identity code."},{"name":"int Particle::intPol()","link":"ParticleProperties.html#anchor35","text":"int Particle::intPol() if the polarization value is within 1e-10 of an integer 0, +-1, +-2 or 9 then this integer is returned, else -9. Is useful when the double-precision value returned by int Particle::intPol() pol() is really intended to represent an integer, e.g. a helicity eigenstate."},{"name":"int Particle::iTopCopy()","link":"ParticleProperties.html#anchor94","text":"int Particle::iTopCopy()"},{"name":"int Particle::iTopCopyId(bool simplify = false)","link":"ParticleProperties.html#anchor96","text":"int Particle::iTopCopyId(bool simplify = false)"},{"name":"int Particle::mother1()","link":"ParticleProperties.html#anchor3","text":"int Particle::mother1()"},{"name":"int Particle::mother2()","link":"ParticleProperties.html#anchor4","text":"int Particle::mother2() the indices in the event record where the first and last mothers are stored, if any. There are six allowed combinations of int Particle::mother2() mother1 and int Particle::mother2() mother2 : int Particle::mother2() int Particle::mother2() int Particle::mother2() mother1 = mother2 = 0 : for lines 0 - 2, where line 0 represents the event as a whole, and 1 and 2 the two incoming beam particles; int Particle::mother2() int Particle::mother2() mother1 = mother2 > 0 : the particle is a 'carbon copy' of its mother, but with changed momentum as a 'recoil'  effect, e.g. in a shower; int Particle::mother2() int Particle::mother2() mother1 > 0, mother2 = 0 : the 'normal' mother case, where it is meaningful to speak of one single mother to several products, in a shower or decay; int Particle::mother2() int Particle::mother2() mother1 < mother2 , both > 0, for int Particle::mother2() abs(status) = 81 - 86 : primary hadrons produced from the fragmentation of a string spanning the range from int Particle::mother2() mother1 to int Particle::mother2() mother2 , so that all partons in this range should be considered mothers; and analogously for int Particle::mother2() abs(status) = 101 - 106 , the formation of R-hadrons; int Particle::mother2() int Particle::mother2() mother1 < mother2 , both > 0, except case 4: particles with two truly different mothers, in particular the particles emerging from a hard int Particle::mother2() 2 &rarr; n interaction. int Particle::mother2() int Particle::mother2() mother2 < mother1 , both > 0: particles with two truly different mothers, notably for the special case that two nearby partons are joined together into a status 73 or 74 new parton, in the int Particle::mother2() g + q &rarr; q case the int Particle::mother2() q is made first mother to simplify flavour tracing. int Particle::mother2() Note 1: in backwards evolution of initial-state showers, the mother may well appear below the daughter in the event record. int Particle::mother2() Note 2: the int Particle::mother2() motherList() method below returns a vector of all the mothers, providing a uniform representation for all six cases."},{"name":"int Particle::spinType()","link":"ParticleProperties.html#anchor68","text":"int Particle::spinType() int Particle::spinType() 2 *spin + 1 when defined, else 0."},{"name":"int Particle::status()","link":"ParticleProperties.html#anchor2","text":"int Particle::status() status code. The status code includes information on how a particle was produced, i.e. where in the program execution it was inserted into the event record, and why. It also tells whether the particle is still present or not. It does not tell how a particle disappeared, whether by a decay, a shower branching, a hadronization process, or whatever, but this is implicit in the status code of its daughter(s). The basic scheme is: int Particle::status() int Particle::status() status = +- (10 * i + j) int Particle::status() +       : still remaining particles int Particle::status() -       : decayed/branched/fragmented/... and not remaining int Particle::status() i =  1 - 9 : stage of event generation inside PYTHIA int Particle::status() i = 10 -19 : reserved for future expansion int Particle::status() i >= 20   : free for add-on programs int Particle::status() j = 1 - 9  : further specification In detail, the list of used or foreseen status codes is: int Particle::status() int Particle::status() 11 - 19 : beam particles int Particle::status() int Particle::status() 11 : the event as a whole int Particle::status() 12 : incoming beam int Particle::status() 13 : incoming beam-inside-beam (e.g. int Particle::status() gamma inside int Particle::status() e ) int Particle::status() 14 : outgoing elastically scattered int Particle::status() 15 : outgoing diffractively scattered int Particle::status() 21 - 29 : particles of the hardest subprocess int Particle::status() int Particle::status() 21 : incoming int Particle::status() 22 : intermediate (intended to have preserved mass) int Particle::status() 23 : outgoing int Particle::status() 24 : outgoing, nonperturbatively kicked out in diffraction int Particle::status() 31 - 39 : particles of subsequent subprocesses int Particle::status() int Particle::status() 31 : incoming int Particle::status() 32 : intermediate (intended to have preserved mass) int Particle::status() 33 : outgoing int Particle::status() 34 : incoming that has already scattered int Particle::status() 41 - 49 : particles produced by initial-state-showers int Particle::status() int Particle::status() 41 : incoming on spacelike main branch int Particle::status() 42 : incoming copy of recoiler int Particle::status() 43 : outgoing produced by a branching int Particle::status() 44 : outgoing shifted by a branching int Particle::status() 45 : incoming rescattered parton, with changed kinematics        owing to ISR in the mother system (cf. status 34) int Particle::status() 46 : incoming copy of recoiler when this is a rescattered        parton (cf. status 42) int Particle::status() 47 : a int Particle::status() W or int Particle::status() Z gauge boson produced in the        shower evolution int Particle::status() 49 : a special state in the evolution, where int Particle::status() E^2 - p^2 = m^2 is not fulfilled int Particle::status() 51 - 59 : particles produced by final-state-showers int Particle::status() int Particle::status() 51 : outgoing produced by parton branching int Particle::status() 52 : outgoing copy of recoiler, with changed momentum int Particle::status() 53 : copy of recoiler when this is incoming parton,        with changed momentum int Particle::status() 54 : copy of a recoiler, when in the initial state of a        different system from the radiator int Particle::status() 55 : copy of a recoiler, when in the final state of a        different system from the radiator int Particle::status() 56 : a int Particle::status() W or int Particle::status() Z gauge boson produced in a        shower branching (special case of 51) int Particle::status() 59 : a special state in the evolution, where int Particle::status() E^2 - p^2 = m^2 is not fulfilled int Particle::status() 61 - 69 : particles produced by beam-remnant treatment int Particle::status() int Particle::status() 61 : incoming subprocess particle with primordial int Particle::status() kT included int Particle::status() 62 : outgoing subprocess particle with primordial int Particle::status() kT included int Particle::status() 63 : outgoing beam remnant int Particle::status() 64 : copied particle with new colour according to the colour        configuration of the beam remnant int Particle::status() 71 - 79 : partons in preparation of hadronization process int Particle::status() int Particle::status() 71 : copied partons to collect into contiguous colour singlet int Particle::status() 72 : copied recoiling singlet when ministring collapses to        one hadron and momentum has to be reshuffled int Particle::status() 73 : combination of very nearby partons into one int Particle::status() 74 : combination of two junction quarks (+ nearby gluons)        to a diquark (this index is not changed by recoils        or recombinations) int Particle::status() 75 : gluons split to decouple a junction-antijunction pair int Particle::status() 76 : partons with momentum shuffled or a new colour to decouple        junction-antijunction structures int Particle::status() 77 : temporary opposing parton when fragmenting first two        strings in to junction (should disappear again) int Particle::status() 78 : temporary combined diquark end when fragmenting last        string in to junction (should disappear again) int Particle::status() 79 : copy of particle with new colour indices after the        colour reconnection int Particle::status() 81 - 89 : primary hadrons produced by hadronization process int Particle::status() int Particle::status() 81 : from ministring into one hadron int Particle::status() 82 : from ministring into two hadrons int Particle::status() 83, 84 : from normal string (the difference between the two        is technical, whether fragmented off from the top of the        string system or from the bottom, useful for debug only) int Particle::status() 85, 86 : primary produced hadrons in junction fragmentation of        the first two string legs in to the junction,        in order of treatment int Particle::status() 87, 88 : primary produced baryon from a junction (similar difference           as for 83, 84) int Particle::status() 89 : primary produced baryon from a junction in the ministring        framework int Particle::status() 91 - 99 : particles produced in decay process, or by Bose-Einstein  effects int Particle::status() int Particle::status() 91 : normal decay products int Particle::status() 92 : decay products after oscillation int Particle::status() B0 &harr; B0bar or int Particle::status() B_s0 &harr; B_s0bar int Particle::status() 93, 94 : decay handled by an external program, normally        or with oscillation int Particle::status() 95, 96 : a forced decay handled by an external program, i.e. picked        from a subset of the possible channels to enhance the rate        of rare signals, normally or with oscillation int Particle::status() 99 : particles with momenta shifted by Bose-Einstein effects        (not a proper decay, but bookkept as an int Particle::status() 1 &rarr; 1 such,        happening after decays of short-lived resonances but before        decays of longer-lived particles) int Particle::status() 101 - 109 : particles in the handling of R-hadron production and  decay, i.e. long-lived (or stable) particles containing a very heavy  flavour int Particle::status() int Particle::status() 101 : when a string system contains two such long-lived particles,         the system is split up by the production of a new q-qbar         pair (bookkept as decay chains that seemingly need not conserve         flavour etc., but do when considered together) int Particle::status() 102 : partons rearranged from the long-lived particle end to prepare         for fragmentation from this end int Particle::status() 103 : intermediate 'half-R-hadron' formed when a colour octet particle         (like the gluino) has been fragmented on one side, but not yet on         the other int Particle::status() 104 : an R-hadron int Particle::status() 105 : partons or particles formed together with the R-hadron during         the fragmentation treatment int Particle::status() 106 : subdivision of an R-hadron into its flavour content, with         momentum split accordingly, in preparation of the decay of         the heavy new particle, if it is unstable int Particle::status() 107 : two temporary leftover gluons joined into one in the formation         of a gluino-gluon R-hadron int Particle::status() 111 - 119 : new hadrons or hadrons with changed momentum due to hadron  (re)scattering int Particle::status() int Particle::status() 111 : inelastic nondiffractive collisions int Particle::status() 112 : elastic scattering int Particle::status() 113 : single diffraction, first particle excited int Particle::status() 114 : single diffraction, second particle excited int Particle::status() 115 : double diffraction int Particle::status() 116 : annihilation of incoming quark-antiquark pairs int Particle::status() 117 : intermediate resonance production and decay int Particle::status() 121 - 129 : other special hadron production mechanisms int Particle::status() int Particle::status() 121 : deuteron formed by coalescence, and other particles formed  simultaneously (like a int Particle::status() gamma or int Particle::status() pi ) int Particle::status() 131 - 199 : reserved for future expansion int Particle::status() 201 - : free to be used by anybody. int Particle::status() Note: a clarification on the role of the 'hardest' vs. the 'subsequent' subprocesses, the 20'ies and 30'ies status code series, respectively. Most events contain exactly one 'hardest' int Particle::status() 2 &rarr; n interaction, and then an arbitrary number of 'subsequent' softer int Particle::status() 2 &rarr; 2 ones generated by the MPI framework. In the int Particle::status() SoftQCD:nonDiffractive event class also the 'hardest' is generated by the MPI machinery, and can be arbitrarily soft, but still with 20'ies codes. Diffractive systems span a broad mass range, where the higher masses admit a perturbative description with 'hard' and 'subsequent' subprocesses, like for nondiffractive events. A double diffractive event can contain up to two such 'hardest' interactions, one per diffractive system. A nonperturbative diffractive system does not contain any int Particle::status() 2 &rarr; n subprocesses, but there is a kicked-out quark or gluon with status 24, combined with a beam remnant of one or two partons with status 63, that together define the mass and longitudinal axis of the diffractive system, for use in the subsequent hadronization. An event may also contain two 20'ies perturbative subcollisions if you use the int Particle::status() Second Hard Process generation machinery."},{"name":"int Particle::statusAbs()","link":"ParticleProperties.html#anchor33","text":"int Particle::statusAbs() the absolute value of the status code."},{"name":"int Particle::statusHepMC()","link":"ParticleProperties.html#anchor104","text":"int Particle::statusHepMC() returns the status code according to the HepMC conventions agreed in February 2009. This convention does not preserve the full information provided by the internal PYTHIA status code, as obtained by int Particle::statusHepMC() Particle::status() , but comes reasonably close. The allowed output values are: int Particle::statusHepMC() int Particle::statusHepMC() 0 : an empty entry, with no meaningful information and therefore to be skipped unconditionally; int Particle::statusHepMC() 1 : a final-state particle, i.e. a particle that is not decayed further by the generator (may also include unstable particles that are to be decayed later, as part of the detector simulation); int Particle::statusHepMC() 2 : a decayed Standard Model hadron or tau or mu lepton, excepting virtual intermediate states thereof (i.e. the particle must undergo a normal decay, not e.g. a shower branching); int Particle::statusHepMC() 3 : a documentation entry (not used in PYTHIA); int Particle::statusHepMC() 4 : an incoming beam particle; int Particle::statusHepMC() 11 - 200 : an intermediate (decayed/branched/...) particle that does not fulfill the criteria of status code 2, with a generator-dependent classification of its nature; in PYTHIA the absolute value of the normal status code is used. int Particle::statusHepMC() Note: for a particle without a properly set pointer to its event, codes 1 and 4 can still be inferred from its status code, while everythg else is assigned code 0."},{"name":"int ParticleData::baryonNumberType(int id)","link":"ParticleDataScheme.html#anchor81","text":"int ParticleData::baryonNumberType(int id) is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a minus sign for antiparticles, and else zero."},{"name":"int ParticleData::chargeType(int id)","link":"ParticleDataScheme.html#anchor37","text":"int ParticleData::chargeType(int id) three times the charge (to make it an integer), taking into account the sign of int ParticleData::chargeType(int id) id."},{"name":"int ParticleData::colType(int id)","link":"ParticleDataScheme.html#anchor40","text":"int ParticleData::colType(int id) the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 octet, taking into account the sign of int ParticleData::colType(int id) id."},{"name":"int ParticleData::heaviestQuark(int id)","link":"ParticleDataScheme.html#anchor80","text":"int ParticleData::heaviestQuark(int id) extracts the heaviest quark or antiquark, i.e. one with largest int ParticleData::heaviestQuark(int id) id number, for a hadron."},{"name":"int ParticleData::nextId(int id)","link":"ParticleDataScheme.html#anchor28","text":"int ParticleData::nextId(int id) return the identity code of the sequentially next particle stored in table."},{"name":"int ParticleData::spinType(int id)","link":"ParticleDataScheme.html#anchor35","text":"int ParticleData::spinType(int id) the spin type, of the form int ParticleData::spinType(int id) 2 s + 1 , with special code 0 for entries of unknown or indeterminate spin."},{"name":"int ParticleDataEntry::baryonNumberType(int id)","link":"ParticleDataScheme.html#anchor153","text":"int ParticleDataEntry::baryonNumberType(int id) is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a minus sign for antiparticles, and else zero. Only the sign of the input argument is relevant."},{"name":"int ParticleDataEntry::chargeType(int id = 1)","link":"ParticleDataScheme.html#anchor109","text":"int ParticleDataEntry::chargeType(int id = 1)"},{"name":"int ParticleDataEntry::colType(int id = 1)","link":"ParticleDataScheme.html#anchor112","text":"int ParticleDataEntry::colType(int id = 1) set or get the particle colour type, 0 for singlet, 1 for triplet, -1 for antitriplet, 2 for octet. Only the sign of int ParticleDataEntry::colType(int id = 1) id is needed to distinguish particle/antiparticle."},{"name":"int ParticleDataEntry::heaviestQuark(int id)","link":"ParticleDataScheme.html#anchor152","text":"int ParticleDataEntry::heaviestQuark(int id) extracts the heaviest quark or antiquark, i.e. one with largest int ParticleDataEntry::heaviestQuark(int id) id number, for a hadron. Only the sign of the input argument is relevant."},{"name":"int ParticleDataEntry::id()","link":"ParticleDataScheme.html#anchor100","text":"int ParticleDataEntry::id() the PDG identity code."},{"name":"int ParticleDataEntry::sizeChannels()","link":"ParticleDataScheme.html#anchor156","text":"int ParticleDataEntry::sizeChannels() returns the number of decay channels for a particle."},{"name":"int ParticleDataEntry::spinType()","link":"ParticleDataScheme.html#anchor107","text":"int ParticleDataEntry::spinType() set or get the particle spin type, i.e. int ParticleDataEntry::spinType() 2 s + 1 , or 0 in some special cases."},{"name":"int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0)","link":"ProgramFlow.html#anchor31","text":"int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) perform a final-state shower evolution on partons in the int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) event event record. This could be used for externally provided simple events, or even parts of events, for which a complete generation is not foreseen. Since the mother source of the parton system is not known, one cannot expect as good accuracy as in a normal generation. When two different timelike shower instances are set up, it is the one used for showering in resonance decays that is used here. The int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) forceTimeShower method can be used in conjunction with the int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) forceHadronLevel one below. Further comments are found int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) here. int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) the first and last entry of the event record to be affected by the call. int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) the maximum int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) pT scale of emissions. Additionally, as always, the int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) scale variable of each parton sets the maximum int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) pT scale of branchings of this parton. Recall that this scale defaults to 0 if not set, so that no radiation can occur. int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) when positive, it sets the maximum number of branchings that are allowed to occur in the shower, i.e. the shower may stop evolving before reaching the lower cutoff. The argument has no effect when zero or negative, i.e. then the shower will continue to the lower cutoff. int Pythia::forceTimeShower( int iBeg, int iEnd,  double pTmax, int nBranchMax = 0) Note: The method returns the number of branchings that has been generated."},{"name":"int Pythia::mode(string key)","link":"ProgramFlow.html#anchor39","text":"int Pythia::mode(string key) read in an integer variable from the int Pythia::mode(string key) Settings database. int Pythia::mode(string key) the name of the variable to be read."},{"name":"int Rndm::pick(const vector&lt;double&gt;&amp; prob)","link":"RandomNumbers.html#anchor11","text":"int Rndm::pick(const vector<double>&amp; prob) pick one option among vector of (positive) probabilities."},{"name":"int Settings::mode(string key)","link":"SettingsScheme.html#anchor34","text":"int Settings::mode(string key)"},{"name":"int Settings::modeDefault(string key)","link":"SettingsScheme.html#anchor42","text":"int Settings::modeDefault(string key)"},{"name":"int SigmaProcess::code()","link":"SemiInternalProcesses.html#anchor13","text":"int SigmaProcess::code() returns an integer identifier of the process. This has no internal function, but is only intended as a service for the user to rapidly (and hopefully uniquely) identify which process occurred in a given event. Numbers below 10000 are reserved for internal PYTHIA use."},{"name":"int SigmaProcess::gmZmode()","link":"SemiInternalProcesses.html#anchor30","text":"int SigmaProcess::gmZmode() allows a possibility to override the global mode int SigmaProcess::gmZmode() int SigmaProcess::gmZmode() WeakZ0:gmZmode for a specific process. The global mode normally is used to switch off parts of the int SigmaProcess::gmZmode() gamma^*/Z^0 propagator for test purposes. The above local mode is useful for processes where a int SigmaProcess::gmZmode() Z^0 really is that and nothing more, such as int SigmaProcess::gmZmode() q qbar &rarr; H^0 Z^0. The default value -1 returned by int SigmaProcess::gmZmode() gmZmode() ensures that the global mode is used, while 0 gives full int SigmaProcess::gmZmode() gamma^*/Z^0 interference, 1 int SigmaProcess::gmZmode() gamma^* only and 2 int SigmaProcess::gmZmode() Z^0 only."},{"name":"int SigmaProcess::id3Mass()","link":"SemiInternalProcesses.html#anchor17","text":"int SigmaProcess::id3Mass()"},{"name":"int SigmaProcess::id4Mass()","link":"SemiInternalProcesses.html#anchor18","text":"int SigmaProcess::id4Mass()"},{"name":"int SigmaProcess::id5Mass()","link":"SemiInternalProcesses.html#anchor19","text":"int SigmaProcess::id5Mass() are the one, two or three final-state flavours, where masses are to be selected before the matrix elements are evaluated. Only the absolute value should be given. For massless particles, like gluons and photons, one need not give anything, i.e. one defaults to 0. The same goes for normal light quarks, where masses presumably are not implemented in the matrix elements. Later on, these quarks can still (automatically) obtain constituent masses, once a int SigmaProcess::id5Mass() u , int SigmaProcess::id5Mass() d or int SigmaProcess::id5Mass() s flavour has been selected."},{"name":"int SigmaProcess::idSChannel()","link":"SemiInternalProcesses.html#anchor23","text":"int SigmaProcess::idSChannel() normally no intermediate state is shown in the event record for int SigmaProcess::idSChannel() 2 &rarr; 2 and int SigmaProcess::idSChannel() 2 &rarr; 3 processes. However, in case that int SigmaProcess::idSChannel() idSChannel is overloaded to return a nonzero value, an intermediate particle with that identity code is inserted into the event record, to make it a int SigmaProcess::idSChannel() 2 &rarr; 1 &rarr; 2 or int SigmaProcess::idSChannel() 2 &rarr; 1 &rarr; 3 process. Thus if both int SigmaProcess::idSChannel() isSChannel and int SigmaProcess::idSChannel() idSChannel are overloaded, a process will behave and look like it proceeded through a resonance. The one difference is that the implementation of the matrix element is not based on the division into a production and a decay of an intermediate resonance, but is directly describing the transition from the initial to the final state."},{"name":"int SigmaProcess::idTchan1()","link":"SemiInternalProcesses.html#anchor25","text":"int SigmaProcess::idTchan1()"},{"name":"int SigmaProcess::idTchan2()","link":"SemiInternalProcesses.html#anchor26","text":"int SigmaProcess::idTchan2() the non-QCD int SigmaProcess::idTchan2() 2 &rarr; 3 phase space selection machinery is rather primitive, as already mentioned. The efficiency can be improved in processes that proceed though int SigmaProcess::idTchan2() t -channel exchanges, such as int SigmaProcess::idTchan2() q qbar' &rarr; H^0 q qbar' via int SigmaProcess::idTchan2() Z^0 Z^0 fusion, if the identity of the int SigmaProcess::idTchan2() t -channel-exchanged particles on the two side of the event are provided. Only the absolute value is of interest."},{"name":"int SigmaProcess::isQCD3body()","link":"SemiInternalProcesses.html#anchor24","text":"int SigmaProcess::isQCD3body() there are two different 3-body phase-space selection machineries, of which the non-QCD one is default. If you overload this method instead the QCD-inspired machinery will be used. The differences between these two is related to which int SigmaProcess::isQCD3body() phase space cuts can be set, and also that the QCD machinery assumes (almost) massless outgoing partons."},{"name":"int SigmaProcess::resonanceA()","link":"SemiInternalProcesses.html#anchor20","text":"int SigmaProcess::resonanceA()"},{"name":"int SigmaProcess::resonanceB()","link":"SemiInternalProcesses.html#anchor21","text":"int SigmaProcess::resonanceB() are the codes of up to two int SigmaProcess::resonanceB() s -channel resonances contributing to the matrix elements. These are used by the program to improve the phase-space selection efficiency, by partly sampling according to the relevant Breit-Wigner distributions. Massless resonances (the gluon and photon) need not be specified."},{"name":"int SlowJet::iNext()","link":"EventAnalysis.html#anchor63","text":"int SlowJet::iNext()"},{"name":"int SlowJet::jetAssignment(int i)","link":"EventAnalysis.html#anchor54","text":"int SlowJet::jetAssignment(int i) gives the index of the jet that the particle int SlowJet::jetAssignment(int i) i of the event record belongs to, or -1 if there is no jet containing particle int SlowJet::jetAssignment(int i) i ,"},{"name":"int SlowJet::jNext()","link":"EventAnalysis.html#anchor64","text":"int SlowJet::jNext()"},{"name":"int SlowJet::multiplicity(int i)","link":"EventAnalysis.html#anchor51","text":"int SlowJet::multiplicity(int i) gives the number of particles clustered into the int SlowJet::multiplicity(int i) i 'th jet,"},{"name":"int SlowJet::sizeAll()","link":"EventAnalysis.html#anchor61","text":"int SlowJet::sizeAll() gives the total current number of jets and clusters. The jets are numbered 0 through int SlowJet::sizeAll() sizeJet() - 1 , while the clusters are numbered int SlowJet::sizeAll() sizeJet() through int SlowJet::sizeAll() sizeAll() - 1. (Internally jets and clusters are represented by two separate arrays, but are here presented in one flat range.) Note that the jets are ordered in decreasing int SlowJet::sizeAll() pT , while the clusters are not ordered. When int SlowJet::sizeAll() useFJcore = true there are no intermediate steps, and thus the number of clusters is zero (after jet finding)."},{"name":"int SlowJet::sizeJet()","link":"EventAnalysis.html#anchor45","text":"int SlowJet::sizeJet() gives the number of jets found, with jets numbered 0 through int SlowJet::sizeJet() sizeJet() - 1 , and ordered in terms of decreasing transverse momentum values w.r.t. the beam axis,"},{"name":"int SlowJet::sizeOrig()","link":"EventAnalysis.html#anchor44","text":"int SlowJet::sizeOrig() gives the original number of particles (and thus clusters) that the analysis starts with."},{"name":"int SpaceShower::system()","link":"ImplementNewShowers.html#anchor38","text":"int SpaceShower::system() This method is not virtual. If a branching is constructed by the previous routine this tiny method should be able to return the number of the selected subsystem int SpaceShower::system() iSysSel where it occurred, so that the spacelike shower can be told which system to update, if necessary. Therefore int SpaceShower::system() iSysSel must be set in int SpaceShower::system() branch (or already in int SpaceShower::system() pTnext )."},{"name":"int Sphericity::nError()","link":"EventAnalysis.html#anchor8","text":"int Sphericity::nError() tells the number of times int Sphericity::nError() analyze(...) failed to analyze events, i.e. returned int Sphericity::nError() false."},{"name":"int Thrust::nError()","link":"EventAnalysis.html#anchor17","text":"int Thrust::nError() tells the number of times int Thrust::nError() analyze(...) failed to analyze events, i.e. returned int Thrust::nError() false."},{"name":"int TimeShower::system()","link":"ImplementNewShowers.html#anchor18","text":"int TimeShower::system() This method is not virtual. If a branching is constructed by the previous routine this tiny method should be able to return the number of the selected subsystem int TimeShower::system() iSysSel where it occurred, so that the spacelike shower can be told which system to update, if necessary. Therefore int TimeShower::system() iSysSel must be set in int TimeShower::system() branch (or already in int TimeShower::system() pTnext )."},{"name":"istream* LHAup::openFile(const char *fn, ifstream &ifs)","link":"LesHouchesAccord.html#anchor82","text":"istream* LHAup::openFile(const char *fn, ifstream &ifs)"},{"name":"LHAup::LHAup( int strategy = 3)","link":"LesHouchesAccord.html#anchor1","text":"LHAup::LHAup( int strategy = 3) the base class constructor takes the choice of mixing/weighting strategy as optional input argument, and calls LHAup::LHAup( int strategy = 3) setStrategy , see below. It also reserves some space for processes and particles."},{"name":"LHAupAlpgen::LHAupAlpgen(const char *baseFNin,  Info *infoPtrIn = NULL)","link":"AlpgenEventInterface.html#anchor6","text":"LHAupAlpgen::LHAupAlpgen(const char *baseFNin,  Info *infoPtrIn = NULL) The constructor for the class takes the base filename for the ALPGEN format files (without file extensions) and optionally a pointer to a PYTHIA Info class, used for warning/error message printing and for storing the ALPGEN parameter file. The event and parameter files are opened immediately, with the LHAupAlpgen::LHAupAlpgen(const char *baseFNin,  Info *infoPtrIn = NULL) AlpgenPar class, described below, used to parse the parameter file."},{"name":"LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;)","link":"HelacOniaProcesses.html#anchor1","text":"LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) creates an instance of the LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) LHAupHelaconia class. LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) pointer to the LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) Pythia instance, such that some of its facilities can be used inside the interface. LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) the name of the run directory, into which HelacOnia puts its (intermediate) results. LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) the name of the HelacOnia executable that LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) LHAupHelaconia is meant to wrap. In addition it may be necessary to prepend the full pathname of the executable: LHAupHelaconia::LHAupHelaconia(Pythia* pythia, string  dir = &quot;helaconiarun&quot;, string exe = &quot;ho_cluster&quot;) '(something)/HELAC-Onia-2.0.1/cluster/bin/ho_cluster'."},{"name":"LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;)","link":"MadGraph5Processes.html#anchor1","text":"LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) creates an instance of the LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) LHAupMadgraph class. LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) pointer to the LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) Pythia instance, such that some of its facilities can be used inside the interface. LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) should be true if jet matching is requested. For tree-level generation MLM matching is used, while FxFx matching is used for aMC\@NLO generation. This is set up in LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) LHAupMadgraph::setInit() , which could be modified to represent other matching strategies or parameter values. LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) the name of the run directory, into which MadGraph puts its (intermediate) results. LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) the name of the MadGraph5_aMC\@NLO executable that LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) LHAupMadgraph is meant to wrap. In additon it may be necessary to prepend the full pathname of the executable: LHAupMadgraph::LHAupMadgraph(Pythia* pythia,  bool match = true, string dir = &quot;madgraphrun&quot;,  string exe = &quot;mg5_aMC&quot;) '(something)/MG5_aMC_v2_3_3/bin/mg5_aMC'."},{"name":"long Info::nAccepted(int i = 0)","link":"EventInformation.html#anchor102","text":"long Info::nAccepted(int i = 0) the total number of tried phase-space points, selected hard processes and finally accepted events, summed over all allowed processes ( long Info::nAccepted(int i = 0) i = 0 ) or for the given process. The first number is only intended for a study of the phase-space selection efficiency. The last two numbers usually only disagree if the user introduces some veto during the event-generation process; then the former is the number of acceptable events found by PYTHIA and the latter the number that also were approved by the user. If you set long Info::nAccepted(int i = 0) a second hard process there may also be a mismatch."},{"name":"long Info::nSelected(int i = 0)","link":"EventInformation.html#anchor101","text":"long Info::nSelected(int i = 0)"},{"name":"long Info::nTried(int i = 0)","link":"EventInformation.html#anchor100","text":"long Info::nTried(int i = 0)"},{"name":"map&lt;string, Flag&gt; Settings::getFlagMap(string match)","link":"SettingsScheme.html#anchor49","text":"map<string, Flag> Settings::getFlagMap(string match)"},{"name":"map&lt;string, FVec&gt; Settings::getFVecMap(string match)","link":"SettingsScheme.html#anchor53","text":"map<string, FVec> Settings::getFVecMap(string match)"},{"name":"map&lt;string, Mode&gt; Settings::getModeMap(string match)","link":"SettingsScheme.html#anchor50","text":"map<string, Mode> Settings::getModeMap(string match)"},{"name":"map&lt;string, MVec&gt; Settings::getMVecMap(string match)","link":"SettingsScheme.html#anchor54","text":"map<string, MVec> Settings::getMVecMap(string match)"},{"name":"map&lt;string, Parm&gt; Settings::getParmMap(string match)","link":"SettingsScheme.html#anchor51","text":"map<string, Parm> Settings::getParmMap(string match)"},{"name":"map&lt;string, PVec&gt; Settings::getPVecMap(string match)","link":"SettingsScheme.html#anchor55","text":"map<string, PVec> Settings::getPVecMap(string match)"},{"name":"map&lt;string, Word&gt; Settings::getWordMap(string match)","link":"SettingsScheme.html#anchor52","text":"map<string, Word> Settings::getWordMap(string match)"},{"name":"map&lt;string, WVec&gt; Settings::getWVecMap(string match)","link":"SettingsScheme.html#anchor56","text":"map<string, WVec> Settings::getWVecMap(string match) return a map of all settings of the respective type that contain the string 'match' in its name."},{"name":"MergingHooks::MergingHooks()","link":"CKKWLMerging.html#anchor16","text":"MergingHooks::MergingHooks()"},{"name":"MergingHooks::setHardProcessPtr( HardProcess* myHardProcess)","link":"MatchingAndMerging.html#anchor3","text":"MergingHooks::setHardProcessPtr( HardProcess* myHardProcess)"},{"name":"MixMaxRndm::MixMaxRndm(int seed0, int seed1, int seed2,  int seed3)","link":"RandomNumbers.html#anchor1","text":"MixMaxRndm::MixMaxRndm(int seed0, int seed1, int seed2,  int seed3) construct a random number generator, and initialize it for the given four 32-bit seed numbers. The sequence of numbers produced from this set of seeds is guaranteed not to collide with another if at least one bit of the four seeds is different, and, less than MixMaxRndm::MixMaxRndm(int seed0, int seed1, int seed2,  int seed3) 10^100 random numbers are thrown."},{"name":"pair&lt;double, double&gt; Rndm::gauss2()","link":"RandomNumbers.html#anchor10","text":"pair<double, double> Rndm::gauss2() generate a pair of random numbers according to pair<double, double> Rndm::gauss2() exp( -(x^2 + y^2) / 2). Is faster than two calls to pair<double, double> Rndm::gauss2() gauss()."},{"name":"Particle& Event::at(int i)","link":"EventRecord.html#anchor4","text":"Particle& Event::at(int i)"},{"name":"Particle& Event::back()","link":"EventRecord.html#anchor5","text":"Particle& Event::back() returns a reference to the zeroth,"},{"name":"Particle& Event::front()","link":"EventRecord.html#anchor3","text":"Particle& Event::front()"},{"name":"Particle& Event::operator[](int i)","link":"EventRecord.html#anchor1","text":"Particle& Event::operator[](int i)"},{"name":"Particle& Particle::operator=(const Particle& pt)","link":"ParticleProperties.html#anchor123","text":"Particle& Particle::operator=(const Particle& pt) copies the input particle."},{"name":"Particle::Particle()","link":"ParticleProperties.html#anchor119","text":"Particle::Particle() constructs an empty particle, i.e. where all properties have been set 0 or equivalent."},{"name":"Particle::Particle(const Particle& pt)","link":"ParticleProperties.html#anchor122","text":"Particle::Particle(const Particle& pt) constructs an particle that is a copy of the input one."},{"name":"Particle::Particle(int id, int status = 0, int mother1 = 0,  int mother2 = 0, int daughter1 = 0, int daughter2 = 0, int col = 0,  int acol = 0, double px = 0., double py = 0., double pz = 0., double e = 0.,  double m = 0., double scale = 0., double pol = 9.)","link":"ParticleProperties.html#anchor120","text":"Particle::Particle(int id, int status = 0, int mother1 = 0,  int mother2 = 0, int daughter1 = 0, int daughter2 = 0, int col = 0,  int acol = 0, double px = 0., double py = 0., double pz = 0., double e = 0.,  double m = 0., double scale = 0., double pol = 9.) constructs a particle with the input properties provided, and non-provided ones set 0 (9 for Particle::Particle(int id, int status = 0, int mother1 = 0,  int mother2 = 0, int daughter1 = 0, int daughter2 = 0, int col = 0,  int acol = 0, double px = 0., double py = 0., double pz = 0., double e = 0.,  double m = 0., double scale = 0., double pol = 9.) pol )."},{"name":"Particle::Particle(int id, int status, int mother1, int mother2,  int daughter1, int daughter2, int col, int acol, Vec4 p, double m = 0.,  double scale = 0., double pol = 9.)","link":"ParticleProperties.html#anchor121","text":"Particle::Particle(int id, int status, int mother1, int mother2,  int daughter1, int daughter2, int col, int acol, Vec4 p, double m = 0.,  double scale = 0., double pol = 9.) constructs a particle with the input properties provided, and non-provided ones set 0 (9 for Particle::Particle(int id, int status, int mother1, int mother2,  int daughter1, int daughter2, int col, int acol, Vec4 p, double m = 0.,  double scale = 0., double pol = 9.) pol )."},{"name":"ParticleData Pythia::particleData","link":"ProgramFlow.html#anchor47","text":"ParticleData Pythia::particleData the particle properties and decay tables database, see ParticleData Pythia::particleData here for further details."},{"name":"ParticleData& operator=( const ParticleData& particleDataIn)","link":"ParticleDataScheme.html#anchor2","text":"ParticleData& operator=( const ParticleData& particleDataIn) copy the database from an existing ParticleData& operator=( const ParticleData& particleDataIn) ParticleData object. Can be useful when running with multiple ParticleData& operator=( const ParticleData& particleDataIn) Pythia instances. Does not include the links to the resonance decay handling set up by ParticleData& operator=( const ParticleData& particleDataIn) initWidths(...)."},{"name":"ParticleData::ParticleData()","link":"ParticleDataScheme.html#anchor1","text":"ParticleData::ParticleData() the constructor has no arguments and does not do anything. Internal."},{"name":"ParticleDataEntry& operator=( const ParticleDataEntry&  particleDataEntryIn)","link":"ParticleDataScheme.html#anchor95","text":"ParticleDataEntry& operator=( const ParticleDataEntry&  particleDataEntryIn) copy the values stored in an existing ParticleDataEntry& operator=( const ParticleDataEntry&  particleDataEntryIn) ParticleDataEntry object."},{"name":"ParticleDataEntry& particleDataEntry()","link":"ParticleProperties.html#anchor92","text":"ParticleDataEntry& particleDataEntry() a reference to the ParticleDataEntry."},{"name":"ParticleDataEntry*  ParticleData::particleDataEntryPtr(int id)","link":"ParticleDataScheme.html#anchor91","text":"ParticleDataEntry*  ParticleData::particleDataEntryPtr(int id) returns a pointer to the ParticleDataEntry*  ParticleData::particleDataEntryPtr(int id) ParticleDataEntry object. The methods in the next section can then be used to manipulate this object."},{"name":"ParticleDataEntry* ParticleData::findParticle(int id)","link":"ParticleDataScheme.html#anchor26","text":"ParticleDataEntry* ParticleData::findParticle(int id)"},{"name":"ParticleDataEntry::ParticleDataEntry(int id = 0,  string name = &quot; &quot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor93","text":"ParticleDataEntry::ParticleDataEntry(int id = 0,  string name = &quot; &quot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.)"},{"name":"ParticleDataEntry::ParticleDataEntry(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor94","text":"ParticleDataEntry::ParticleDataEntry(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.) there are two alternative constructors, that both expect the properties of a particle as input. The first assumes that there is only one particle, the latter that there is a particle-antiparticle pair (but if the antiparticle name is ParticleDataEntry::ParticleDataEntry(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0.,  double mMin = 0., double mMax = 0., double tau0 = 0.) void one reverts back to the particle-only case)."},{"name":"ParticleDataEntry::~ParticleDataEntry","link":"ParticleDataScheme.html#anchor96","text":"ParticleDataEntry::~ParticleDataEntry the destructor is needed to delete any ParticleDataEntry::~ParticleDataEntry ResonanceWidths objects that have been created and linked to the respective particle."},{"name":"PartonSystems Pythia::partonSystems","link":"ProgramFlow.html#anchor51","text":"PartonSystems Pythia::partonSystems a grouping of the partons in the event record by subsystem, see PartonSystems Pythia::partonSystems here for further details."},{"name":"PDF* getPDFPtr(int id, int sequence = 1)","link":"ProgramFlow.html#anchor42","text":"PDF* getPDFPtr(int id, int sequence = 1) get a pointer to a PDF object. Which PDF is returned depends on the PDF* getPDFPtr(int id, int sequence = 1) PDF Selection settings. PDF* getPDFPtr(int id, int sequence = 1) the identity code of the incoming particle. PDF* getPDFPtr(int id, int sequence = 1) should normally be 1, but 2 can be used for protons to let the PDF selection be determined by the special settings for hard processes ( PDF* getPDFPtr(int id, int sequence = 1) PDF:useHard etc.)."},{"name":"Pythia8ToHepMC::Pythia8ToHepMC()","link":"HepMCInterface.html#anchor1","text":"Pythia8ToHepMC::Pythia8ToHepMC()"},{"name":"Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true)","link":"ProgramFlow.html#anchor3","text":"Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true) creates an instance of the Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true) Pythia event generators, and sets initial default values, notably for all settings and particle data. This option is intended for runs with multiple Pythia instances, where input streams can avoid file read congestion. Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true) can be set Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true) false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia::Pythia( istream& settingsStrings,  istream& particleDataStrings, bool printBanner = true) Pythia instances, where output needs to be restricted."},{"name":"Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true)","link":"ProgramFlow.html#anchor2","text":"Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) creates an instance of the Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) Pythia event generators, and sets initial default values, notably for all settings and particle data. This option is intended for runs with multiple Pythia instances, where only the first one needs to read the Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) xmldoc files, while subsequent ones can 'inherit' this information. Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) can be set Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia::Pythia(Settings& settingsIn,  ParticleData& particleDataIn, bool printBanner = true) Pythia instances, where output needs to be restricted."},{"name":"Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true)","link":"ProgramFlow.html#anchor1","text":"Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) creates an instance of the Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) Pythia event generators, and sets initial default values, notably for all settings and particle data. You may use several Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) Pythia instances in the same run; only when you want to access external static libraries could this cause problems. (This includes in particular Fortran libraries such as Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) LHAPDF5 .) Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) allows you to choose from which directory the default settings and particle data values are read in. If the Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) PYTHIA8DATA environment variable has been set it takes precedence. Else this optional argument allows you to choose another directory location than the default one. Note that it is only the directory location you can change, its contents must be the ones of the Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) xmldoc directory in the standard distribution. Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) can be set Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) false to stop the program from printing a banner. The banner contains useful information, so this option is only intended for runs with multiple Pythia::Pythia(string xmlDir  = &quot;../share/Pythia8/xmldoc&quot;, bool printBanner = true) Pythia instances, where output needs to be restricted."},{"name":"Pythia::setMergingHooksPtr( MergingHooks* myMergingHooks)","link":"MatchingAndMerging.html#anchor2","text":"Pythia::setMergingHooksPtr( MergingHooks* myMergingHooks)"},{"name":"Pythia::setMergingPtr( Merging* myMerging)","link":"MatchingAndMerging.html#anchor1","text":"Pythia::setMergingPtr( Merging* myMerging)"},{"name":"Pythia::~Pythia","link":"ProgramFlow.html#anchor4","text":"Pythia::~Pythia the destructor deletes the objects created by the constructor."},{"name":"ResonanceWidths* ParticleDataEntry::getResonancePtr()","link":"ParticleDataScheme.html#anchor163","text":"ResonanceWidths* ParticleDataEntry::getResonancePtr() set or get a pointer to an object that can be used for dynamic calculation of partial and total resonance widths. Here a resonance is a particle such as top, ResonanceWidths* ParticleDataEntry::getResonancePtr() Z^0 , ResonanceWidths* ParticleDataEntry::getResonancePtr() W^+- , Higgs, and new unstable states beyond the Standard Model."},{"name":"Rndm Pythia::rndm","link":"ProgramFlow.html#anchor48","text":"Rndm Pythia::rndm the random number generator, see Rndm Pythia::rndm here and Rndm Pythia::rndm here for further details."},{"name":"Rndm::Rndm()","link":"RandomNumbers.html#anchor2","text":"Rndm::Rndm() construct a random number generator, but does not initialize it."},{"name":"Rndm::Rndm(int seed)","link":"RandomNumbers.html#anchor3","text":"Rndm::Rndm(int seed) construct a random number generator, and initialize it for the given seed number."},{"name":"RotBstMatrix fromCMframe(const Vec4& p)","link":"FourVectors.html#anchor94","text":"RotBstMatrix fromCMframe(const Vec4& p) Return a RotBstMatrix fromCMframe(const Vec4& p) RotBstMatrix corresponding to a boost from the rest frame of RotBstMatrix fromCMframe(const Vec4& p) p."},{"name":"RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2)","link":"FourVectors.html#anchor96","text":"RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) Return a RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) RotBstMatrix corresponding to a boost and rotation from the rest frame of RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) p_1 and RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) p_2 , with RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) p_1 along the RotBstMatrix fromCMframe(const Vec4& p1, const Vec4& p2) +z axis."},{"name":"RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz)","link":"FourVectors.html#anchor98","text":"RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) Return a RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) RotBstMatrix corresponding to a boost and rotation from the rest frame of RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_{tot} , where additionally the RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_z vector is along the RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) +z axis and the RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_{xz} is in the RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) xz plane with positive RotBstMatrix fromCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) x when in the rest frame."},{"name":"RotBstMatrix RotBstMatrix::inverse()","link":"FourVectors.html#anchor88","text":"RotBstMatrix RotBstMatrix::inverse() return the inverse matrix, which corresponds to an opposite sequence and sign of rotations and boosts, without overwriting the original matrix."},{"name":"RotBstMatrix toCMframe(const Vec4& p)","link":"FourVectors.html#anchor93","text":"RotBstMatrix toCMframe(const Vec4& p) Return a RotBstMatrix toCMframe(const Vec4& p) RotBstMatrix corresponding to a boost to the rest frame of RotBstMatrix toCMframe(const Vec4& p) p."},{"name":"RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2)","link":"FourVectors.html#anchor95","text":"RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) Return a RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) RotBstMatrix corresponding to a boost and rotation to the rest frame of RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) p_1 and RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) p_2 , with RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) p_1 along the RotBstMatrix toCMframe(const Vec4& p1, const Vec4& p2) +z axis."},{"name":"RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz)","link":"FourVectors.html#anchor97","text":"RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) Return a RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) RotBstMatrix corresponding to a boost and rotation to the rest frame of RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_{tot} , where additionally the RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_z vector is put along the RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) +z axis and the RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) p_{xz} on put in the RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) xz plane with positive RotBstMatrix toCMframe(const Vec4& ptot, const Vec4& pz,  const Vec4& pxz) x."},{"name":"RotBstMatrix& RotBstMatrix::operator*(const RotBstMatrix& Min)","link":"FourVectors.html#anchor85","text":"RotBstMatrix& RotBstMatrix::operator*(const RotBstMatrix& Min) return the combination of this and another matrix (corresponding to first making the transformation RotBstMatrix& RotBstMatrix::operator*(const RotBstMatrix& Min) M_{in} and then this transformation."},{"name":"RotBstMatrix& RotBstMatrix::operator=(const RotBstMatrix4& Min)","link":"FourVectors.html#anchor75","text":"RotBstMatrix& RotBstMatrix::operator=(const RotBstMatrix4& Min) copies the input matrix."},{"name":"RotBstMatrix::RotBstMatrix()","link":"FourVectors.html#anchor73","text":"RotBstMatrix::RotBstMatrix() creates a diagonal unit matrix, i.e. one that leaves a four-vector unchanged."},{"name":"RotBstMatrix::RotBstMatrix(const RotBstMatrix& Min)","link":"FourVectors.html#anchor74","text":"RotBstMatrix::RotBstMatrix(const RotBstMatrix& Min) creates a copy of the input matrix."},{"name":"Settings Pythia::settings","link":"ProgramFlow.html#anchor46","text":"Settings Pythia::settings the settings database, see Settings Pythia::settings here for further details."},{"name":"Settings::Settings()","link":"SettingsScheme.html#anchor1","text":"Settings::Settings() the constructor, which takes no arguments. Internal."},{"name":"SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true)","link":"EventAnalysis.html#anchor42","text":"SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) create a SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) SlowJet instance, where SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) tells (half) the power of the transverse-momentum dependence of the distance measure, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the anti- SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) kT algorithm, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the Cambridge/Aachen algorithm, and SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) kT algorithm. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) R size parameter, which is crudely related to the radius of the jet cone in SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) (y, phi) space around the center of the jet. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the minimum transverse momentum required for a cluster to become a jet. By default all clusters become jets, and therefore all analyzed particles are assigned to a jet. For comparisons with perturbative QCD, however, it is only meaningful to consider jets with a significant SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) pT. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) the maximum +-pseudorapidity that the detector is assumed to cover. If you pick a value above 20 there is assumed to be full coverage (obviously only meaningful for theoretical studies). SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) tells which particles are analyzed, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) all final-state particles, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) isVisible() particle method), and SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) only charged final-state particles. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) masses assumed for the particles used in the analysis SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) all massless, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) photons are massless while all others are assigned the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) pi+- mass, and SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) all given their correct masses. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) gives the possibility to send in your own selection routine for which particles should be part of the analysis; see further below on the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) SlowJetHook class. If this pointer is sent in nonzero, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) etaMax and SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) massSet are disregarded, and SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) select only gives the basic selection, to which the user can add further requirements. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) choice of code used for finding the jets. Does not affect the outcome of the analysis, but only the speed, and some more specialized options. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) use the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) fjcore package of SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) FastJet 3.0.5. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) use the native SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) SlowJet implementation, which gives a slower jet finding, but allows some extra options of step-by-step jet joining. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) definition of SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) R distance between two jets. This switch is only meaningful for SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) useFJcore = false ; within the SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) fjcore package the standard option below is always used. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) standard, as described above, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) DeltaR_ij^2 = (y_i - y_j)^2 + (phi_i - phi_j)^2. SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) alternative, SlowJet::SlowJet(int power, double R, double pTjetMin = 0.,  double etaMax = 25., int select = 2, int massSet = 2,  SlowJetHook* sjHookPtr = 0, bool useFJcore = true, bool useStandardR = true) DeltaR_ij^2 = 2 (cosh(y_i - y_j) - cos(phi_i - phi_j)) , which corresponds to the rim of the 'deformed cone' giving a constant invariant mass between the two partons considered (for fixed masses and transverse momenta)."},{"name":"SlowJetHook::SlowJetHook()","link":"EventAnalysis.html#anchor66","text":"SlowJetHook::SlowJetHook()"},{"name":"SpaceShower::SpaceShower()","link":"ImplementNewShowers.html#anchor28","text":"SpaceShower::SpaceShower() The constructor does not need to do anything."},{"name":"Sphericity::Sphericity(double power = 2., int select = 2)","link":"EventAnalysis.html#anchor1","text":"Sphericity::Sphericity(double power = 2., int select = 2) create a sphericity analysis object, where Sphericity::Sphericity(double power = 2., int select = 2) is the power Sphericity::Sphericity(double power = 2., int select = 2) r defined above, i.e. Sphericity::Sphericity(double power = 2., int select = 2) gives Sphericity, and Sphericity::Sphericity(double power = 2., int select = 2) gives the linear form. Sphericity::Sphericity(double power = 2., int select = 2) tells which particles are analyzed, Sphericity::Sphericity(double power = 2., int select = 2) all final-state particles, Sphericity::Sphericity(double power = 2., int select = 2) all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the Sphericity::Sphericity(double power = 2., int select = 2) isVisible() particle method), and Sphericity::Sphericity(double power = 2., int select = 2) only charged final-state particles."},{"name":"string Hist::getTitle()","link":"Histograms.html#anchor19","text":"string Hist::getTitle() return the title of the histogram."},{"name":"string Info::getEventAttribute(string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor129","text":"string Info::getEventAttribute(string key, bool doRemoveWhitespace = false) return the value of the event attribute named string Info::getEventAttribute(string key, bool doRemoveWhitespace = false) key. Setting string Info::getEventAttribute(string key, bool doRemoveWhitespace = false) doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named string Info::getEventAttribute(string key, bool doRemoveWhitespace = false) key does not exist."},{"name":"string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor118","text":"string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false) Return the value of the generator attribute named string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false) key for the n'th generator in the vector. Setting string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false) doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named string Info::getGeneratorAttribute(unsigned int n, string key, bool doRemoveWhitespace = false) key does not exist."},{"name":"string Info::getGeneratorValue(unsigned int n = 0)","link":"EventInformation.html#anchor117","text":"string Info::getGeneratorValue(unsigned int n = 0) Return the contents of the n'th string Info::getGeneratorValue(unsigned int n = 0) <generator> tag in the vector of tags."},{"name":"string Info::getScalesValue()","link":"EventInformation.html#anchor127","text":"string Info::getScalesValue()"},{"name":"string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor126","text":"string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false) Return the value of the string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false) <weights> tag's attribute named string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false) key. Setting string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false) doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named string Info::getWeightsCompressedAttribute(string key, bool doRemoveWhitespace = false) key does not exist."},{"name":"string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false)","link":"EventInformation.html#anchor123","text":"string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false) Return the value of the wgt attribute named string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false) key for the n'th wgt in the vector. Setting string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false) doRemoveWhitespace to true will return the value, stripped of any whitespace. An empty string is returned if the attribute named string Info::getWeightsDetailedAttribute(string n, string key, bool doRemoveWhitespace = false) key does not exist."},{"name":"string Info::header(string key)","link":"EventInformation.html#anchor130","text":"string Info::header(string key) return the header named string Info::header(string key) key"},{"name":"string Info::name()","link":"EventInformation.html#anchor13","text":"string Info::name()"},{"name":"string Info::nameProc(int i = 0)","link":"EventInformation.html#anchor99","text":"string Info::nameProc(int i = 0) returns the process name for process code string Info::nameProc(int i = 0) i."},{"name":"string Info::nameSub()","link":"EventInformation.html#anchor27","text":"string Info::nameSub()"},{"name":"string LHAup::getFileName()","link":"LesHouchesAccord.html#anchor89","text":"string LHAup::getFileName() Return the name of the LHE file above."},{"name":"string Particle::name()","link":"ParticleProperties.html#anchor66","text":"string Particle::name() the name of the particle."},{"name":"string Particle::nameWithStatus()","link":"ParticleProperties.html#anchor67","text":"string Particle::nameWithStatus() as above, but for negative-status particles the name is given in brackets to emphasize that they are intermediaries."},{"name":"string ParticleData::name(int id)","link":"ParticleDataScheme.html#anchor33","text":"string ParticleData::name(int id) particle and antiparticle names are stored separately, the sign of string ParticleData::name(int id) id determines which of the two is returned, with string ParticleData::name(int id) void used to indicate the absence of an antiparticle."},{"name":"string ParticleDataEntry::name(int id = 1)","link":"ParticleDataScheme.html#anchor105","text":"string ParticleDataEntry::name(int id = 1) set or get the particle or antiparticle name. Only the sign of string ParticleDataEntry::name(int id = 1) id is needed to distinguish particle/antiparticle."},{"name":"string Pythia::word(string key)","link":"ProgramFlow.html#anchor41","text":"string Pythia::word(string key) read in a string variable from the string Pythia::word(string key) Settings database. string Pythia::word(string key) the name of the variable to be read."},{"name":"string Settings::output(string key, bool fullLine = true)","link":"SettingsScheme.html#anchor13","text":"string Settings::output(string key, bool fullLine = true) provide the value of a variable as a character string, whatever the type. If the variable does not exist then string Settings::output(string key, bool fullLine = true) unknown is returned. string Settings::output(string key, bool fullLine = true) the name of the settings variable. string Settings::output(string key, bool fullLine = true) If true then a whole 'line' is returned, ' string Settings::output(string key, bool fullLine = true) key = value\n ', while if false only the string Settings::output(string key, bool fullLine = true) value string."},{"name":"string Settings::word(string key)","link":"SettingsScheme.html#anchor36","text":"string Settings::word(string key)"},{"name":"string Settings::wordDefault(string key)","link":"SettingsScheme.html#anchor44","text":"string Settings::wordDefault(string key)"},{"name":"string SigmaProcess::inFlux()","link":"SemiInternalProcesses.html#anchor14","text":"string SigmaProcess::inFlux() this string specifies the combinations of incoming partons that are allowed for the process under consideration, and thereby which incoming flavours string SigmaProcess::inFlux() id1 and string SigmaProcess::inFlux() id2 the string SigmaProcess::inFlux() sigmaHat() calls will be looped over. It is always possible to pick a wider flavour selection than strictly required and then put to zero cross sections in the superfluous channels, but of course this may cost some extra execution time. Currently allowed options are: string SigmaProcess::inFlux() * string SigmaProcess::inFlux() gg : two gluons. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() qg : one (anti)quark and one gluon. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() qq : any combination of two quarks, two antiquarks or a quark and an antiquark. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() qqbar : any combination of a quark and an antiquark; a subset of the string SigmaProcess::inFlux() qq option. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() qqbarSame : a quark and its antiquark; a subset of the string SigmaProcess::inFlux() qqbar option. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() ff : any combination of two fermions, two antifermions or a fermion and an antifermion; is the same as string SigmaProcess::inFlux() qq for hadron beams but also allows processes to work with lepton beams. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() ffbar : any combination of a fermion and an antifermion; is the same as string SigmaProcess::inFlux() qqbar for hadron beams but also allows processes to work with lepton beams. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() ffbarSame : a fermion and its antifermion; is the same as string SigmaProcess::inFlux() qqbarSame for hadron beams but also allows processes to work with lepton beams. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() ffbarChg : a fermion and an antifermion that combine to give charge +-1. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() fgm : a fermion and a photon (gamma). string SigmaProcess::inFlux() * string SigmaProcess::inFlux() ggm : a gluon and a photon. string SigmaProcess::inFlux() * string SigmaProcess::inFlux() gmgm : two photons."},{"name":"string SigmaProcess::name()","link":"SemiInternalProcesses.html#anchor12","text":"string SigmaProcess::name() returns the name of the process, as you want it to be shown in listings."},{"name":"SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true)","link":"UserHooks.html#anchor32","text":"SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) The optional arguments of the constructor provides further variability. SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) corresponds to the additional factor SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) k in the above formula. It is by default equal to 1 but can be used to explore deviations from the expected value. SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) if this number SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) n is bigger than the default 0, the corresponding number of SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) alpha_strong factors is also reweighted from the normal renormalization scale to a modified one, i.e. a further suppression factor SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) ( alpha_s((k*pT0)^2 + Q^2_ren) / alpha_s(Q^2_ren) )^n is introduced. SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) regulates which kind of new SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) alpha_strong value is evaluated for the numerator in the above expression. It is by default the same as set for multiparton interactions (i.e. same starting value at SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) M_Z and same order of running), but if SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) false instead the one for hard subprocesses. The denominator SuppressSmallPT::SuppressSmallPT( double pT0timesMPI = 1.,  int numberAlphaS = 0, bool useSameAlphaSasMPI = true) alpha_s(Q^2_ren) is always the value used for the 'original', unweighted cross section."},{"name":"SusyLesHouches Pythia::slha","link":"ProgramFlow.html#anchor50","text":"SusyLesHouches Pythia::slha parameters and particle data in the context of supersymmetric models, see SusyLesHouches Pythia::slha here for further details."},{"name":"Thrust::Thrust(int select = 2)","link":"EventAnalysis.html#anchor9","text":"Thrust::Thrust(int select = 2) create a thrust analysis object, where Thrust::Thrust(int select = 2) tells which particles are analyzed, Thrust::Thrust(int select = 2) all final-state particles, Thrust::Thrust(int select = 2) all observable final-state particles, i.e. excluding neutrinos and other particles without strong or electromagnetic interactions (the Thrust::Thrust(int select = 2) isVisible() particle method), and Thrust::Thrust(int select = 2) only charged final-state particles."},{"name":"TimeShower::TimeShower()","link":"ImplementNewShowers.html#anchor1","text":"TimeShower::TimeShower() The constructor does not need to do anything."},{"name":"unsigned int Info::getWeightsCompressedSize()","link":"EventInformation.html#anchor124","text":"unsigned int Info::getWeightsCompressedSize()"},{"name":"unsigned int Info::getWeightsDetailedSize()","link":"EventInformation.html#anchor121","text":"unsigned int Info::getWeightsDetailedSize()"},{"name":"UserHooks::UserHooks()","link":"UserHooks.html#anchor1","text":"UserHooks::UserHooks()"},{"name":"Vec4 BeamShape::deltaPA()","link":"BeamShape.html#anchor5","text":"Vec4 BeamShape::deltaPA()"},{"name":"Vec4 BeamShape::deltaPB()","link":"BeamShape.html#anchor6","text":"Vec4 BeamShape::deltaPB() read out the three-momentum shifts for beams A and B that were set by Vec4 BeamShape::deltaPB() pick(). The energy components are put to zero at this stage, since they are most conveniently calculated after the original and the shift three-momenta have been added."},{"name":"Vec4 BeamShape::vertex()","link":"BeamShape.html#anchor7","text":"Vec4 BeamShape::vertex() read out the production-vertex position and time that were set by Vec4 BeamShape::vertex() pick()."},{"name":"Vec4 CellJet::pMassive(int i)","link":"EventAnalysis.html#anchor38","text":"Vec4 CellJet::pMassive(int i) gives a Vec4 CellJet::pMassive(int i) Vec4 corresponding to the four-momentum defined by the sum of all the contributing cells to the Vec4 CellJet::pMassive(int i) i 'th jet, where each cell contributes a four-momentum as if all the Vec4 CellJet::pMassive(int i) eT is deposited in the center of the cell,"},{"name":"Vec4 CellJet::pMassless(int i)","link":"EventAnalysis.html#anchor37","text":"Vec4 CellJet::pMassless(int i) gives a Vec4 CellJet::pMassless(int i) Vec4 corresponding to the four-momentum defined by the Vec4 CellJet::pMassless(int i) eT and the weighted center of the Vec4 CellJet::pMassless(int i) i 'th jet,"},{"name":"Vec4 ClusterJet::p(int i)","link":"EventAnalysis.html#anchor21","text":"Vec4 ClusterJet::p(int i) gives a Vec4 ClusterJet::p(int i) Vec4 corresponding to the four-momentum defined by the sum of all the contributing particles to the Vec4 ClusterJet::p(int i) i 'th jet."},{"name":"Vec4 Particle::p()","link":"ParticleProperties.html#anchor13","text":"Vec4 Particle::p() the particle four-momentum vector, with components as above."},{"name":"Vec4 Particle::vDec()","link":"ParticleProperties.html#anchor63","text":"Vec4 Particle::vDec() the decay vertex coordinates, in mm or mm/c. This decay vertex is calculated from the production vertex, the proper lifetime and the four-momentum assuming no magnetic field or other detector interference. It can be used to decide whether a decay should be performed or not, and thus is defined also for particles which PYTHIA did not let decay."},{"name":"Vec4 Particle::vProd()","link":"ParticleProperties.html#anchor21","text":"Vec4 Particle::vProd() The production vertex four-vector. Note that the components of a Vec4 Particle::vProd() Vec4 are named Vec4 Particle::vProd() px(), py(), pz() and e() which of course then should be reinterpreted as above."},{"name":"Vec4 RotBstMatrix::operator*(Vec4 p)","link":"FourVectors.html#anchor86","text":"Vec4 RotBstMatrix::operator*(Vec4 p) return a rotated and boosted version of Vec4 RotBstMatrix::operator*(Vec4 p) p."},{"name":"Vec4 SlowJet::p(int i)","link":"EventAnalysis.html#anchor49","text":"Vec4 SlowJet::p(int i)"},{"name":"Vec4 Sphericity::eventAxis(i)","link":"EventAnalysis.html#anchor6","text":"Vec4 Sphericity::eventAxis(i) gives the matching normalized eigenvector, as a Vec4 Sphericity::eventAxis(i) Vec4 with vanishing time/energy component."},{"name":"Vec4 Thrust::eventAxis(int i)","link":"EventAnalysis.html#anchor15","text":"Vec4 Thrust::eventAxis(int i) gives the matching normalized event-axis vectors, for Vec4 Thrust::eventAxis(int i) i = 1, 2 or 3 corresponding to thrust, major or minor, as a Vec4 Thrust::eventAxis(int i) Vec4 with vanishing time/energy component."},{"name":"Vec4 Vec4::operator-()","link":"FourVectors.html#anchor48","text":"Vec4 Vec4::operator-() return a vector with flipped sign for all components, while leaving the original vector unchanged."},{"name":"Vec4& Vec4::operator*=(double f)","link":"FourVectors.html#anchor51","text":"Vec4& Vec4::operator*=(double f) multiply all four-vector components by a real number."},{"name":"Vec4& Vec4::operator+=(const Vec4& v)","link":"FourVectors.html#anchor49","text":"Vec4& Vec4::operator+=(const Vec4& v) add a four-vector to an existing one."},{"name":"Vec4& Vec4::operator-=(const Vec4& v)","link":"FourVectors.html#anchor50","text":"Vec4& Vec4::operator-=(const Vec4& v) subtract a four-vector from an existing one."},{"name":"Vec4& Vec4::operator/=(double f)","link":"FourVectors.html#anchor52","text":"Vec4& Vec4::operator/=(double f) divide all four-vector components by a real number."},{"name":"Vec4& Vec4::operator=(const Vec4& v)","link":"FourVectors.html#anchor3","text":"Vec4& Vec4::operator=(const Vec4& v) copies the input four-vector."},{"name":"Vec4& Vec4::operator=(double value)","link":"FourVectors.html#anchor4","text":"Vec4& Vec4::operator=(double value) gives a  four-vector with all components set to Vec4& Vec4::operator=(double value) value."},{"name":"Vec4::Vec4(const Vec4& v)","link":"FourVectors.html#anchor2","text":"Vec4::Vec4(const Vec4& v) creates a four-vector copy of the input four-vector."},{"name":"Vec4::Vec4(double x = 0., double y = 0., double z = 0.,  double t = 0.)","link":"FourVectors.html#anchor1","text":"Vec4::Vec4(double x = 0., double y = 0., double z = 0.,  double t = 0.) creates a four-vector, by default with all components set to 0."},{"name":"vector &lt;double&gt; JetMatchingMadgraph::getDJR()","link":"JetMatching.html#anchor33","text":"vector <double> JetMatchingMadgraph::getDJR() Return a vector of jet clustering scales produced by running the jet algorithm used for jet matching on the event record without resonance decay products and particles that should not be included in the matching. In this vector, clustering scales for combining few jets appear before scales from combining many jets. This function is useful for the kT-MLM scheme, or to have quick access to this information for histogramming and sanity checks."},{"name":"vector &lt;string&gt; Info::headerKeys()","link":"EventInformation.html#anchor131","text":"vector <string> Info::headerKeys() return a vector of all header key names"},{"name":"vector&lt;bool&gt; Settings::fvec(string key)","link":"SettingsScheme.html#anchor37","text":"vector<bool> Settings::fvec(string key)"},{"name":"vector&lt;bool&gt; Settings::fvecDefault(string key)","link":"SettingsScheme.html#anchor45","text":"vector<bool> Settings::fvecDefault(string key)"},{"name":"vector&lt;double&gt; Settings::pvec(string key)","link":"SettingsScheme.html#anchor39","text":"vector<double> Settings::pvec(string key)"},{"name":"vector&lt;double&gt; Settings::pvecDefault(string key)","link":"SettingsScheme.html#anchor47","text":"vector<double> Settings::pvecDefault(string key)"},{"name":"vector&lt;int&gt; Info::codesHard()","link":"EventInformation.html#anchor98","text":"vector<int> Info::codesHard() returns a vector with all the process codes set up for the current run, i.e. the valid nonzero arguments for the five methods below."},{"name":"vector&lt;int&gt; Particle::daughterList()","link":"ParticleProperties.html#anchor99","text":"vector<int> Particle::daughterList() returns a vector of all the daughter indices of the particle. This is derived from the vector<int> Particle::daughterList() daughter1 , vector<int> Particle::daughterList() daughter2 and vector<int> Particle::daughterList() status information as explained above. This list is empty for a particle that did not decay (or, if the evolution is stopped early enough, a parton that did not branch), while otherwise it can contain a list of varying length, from one to many. For the two incoming beam particles, all shower initiators and beam remnants are counted as daughters, with the one in slot 0 being the one leading up to the hardest interaction. The 'system' in line 0 does not have any daughters, i.e. is not counted as part of the history. Many partons may have the same vector<int> Particle::daughterList() daughterList. Daughters are listed in ascending order."},{"name":"vector&lt;int&gt; Particle::daughterListRecursive()","link":"ParticleProperties.html#anchor100","text":"vector<int> Particle::daughterListRecursive() returns a vector of all the daughter indices of the particle, recursively including all subsequent decay generations. It is based on the vector<int> Particle::daughterListRecursive() daughterList() method, so obeys the rules given there, except that the listing does not necessarily have to be in ascending order. Its primary application is for the decay of a hadron, or of a resonance in the vector<int> Particle::daughterListRecursive() process record. It is less convenient e.g. for the full parton-shower evolution, and should there only be used with caution."},{"name":"vector&lt;int&gt; Particle::motherList()","link":"ParticleProperties.html#anchor98","text":"vector<int> Particle::motherList() returns a vector of all the mother indices of the particle. This is derived from the vector<int> Particle::motherList() mother1 , vector<int> Particle::motherList() mother2 and vector<int> Particle::motherList() status information as explained above. This list is empty for entries 0, 1 and 2, i.e. the 'system' in line 0 is not counted as part of the history. Normally the list contains one or two mothers, but it can also be more, e.g. in string fragmentation the whole fragmenting system is counted as mothers to the primary hadrons. Many particles may have the same vector<int> Particle::motherList() motherList. Mothers are listed in ascending order."},{"name":"vector&lt;int&gt; Particle::sisterList(bool traceTopBot  = false)","link":"ParticleProperties.html#anchor101","text":"vector<int> Particle::sisterList(bool traceTopBot  = false) returns a vector of all the sister indices of the particle, i.e. all the daughters of the first mother, except the particle itself. If the argument vector<int> Particle::sisterList(bool traceTopBot  = false) traceTopBot = true the particle is first traced up with vector<int> Particle::sisterList(bool traceTopBot  = false) iTopCopy() before its mother is found, and then all the particles in the vector<int> Particle::sisterList(bool traceTopBot  = false) daughterList() of this mother are traced down with vector<int> Particle::sisterList(bool traceTopBot  = false) iBotCopy() , omitting the original particle itself. The method is not meaningful for the 0 entry, with status code -11, and there returns an empty list."},{"name":"vector&lt;int&gt; Settings::mvec(string key)","link":"SettingsScheme.html#anchor38","text":"vector<int> Settings::mvec(string key)"},{"name":"vector&lt;int&gt; Settings::mvecDefault(string key)","link":"SettingsScheme.html#anchor46","text":"vector<int> Settings::mvecDefault(string key)"},{"name":"vector&lt;int&gt; SlowJet::clusConstituents(int i)","link":"EventAnalysis.html#anchor53","text":"vector<int> SlowJet::clusConstituents(int i) gives a list of the indices of the particles that have been clustered into the vector<int> SlowJet::clusConstituents(int i) i 'th cluster, at the current stage of the clustering process,"},{"name":"vector&lt;int&gt; SlowJet::constituents(int i)","link":"EventAnalysis.html#anchor52","text":"vector<int> SlowJet::constituents(int i) gives a list of the indices of the particles that have been clustered into the vector<int> SlowJet::constituents(int i) i 'th jet,"},{"name":"vector&lt;string&gt; ParticleData::getReadHistory()","link":"ParticleDataScheme.html#anchor19","text":"vector<string> ParticleData::getReadHistory() Method to retrieve the history of vector<string> ParticleData::getReadHistory() readString commands that have been processed by the vector<string> ParticleData::getReadHistory() ParticleData instance, e.g. for inspection. Note that vector<string> ParticleData::getReadHistory() ParticleData commands read by vector<string> ParticleData::getReadHistory() Pythia::readString and vector<string> ParticleData::getReadHistory() Pythia::readFile are interpreted by vector<string> ParticleData::getReadHistory() readString and thus also are listed."},{"name":"vector&lt;string&gt; ParticleData::getReadHistory(int subrun)","link":"ParticleDataScheme.html#anchor20","text":"vector<string> ParticleData::getReadHistory(int subrun) Method to retrieve the history of vector<string> ParticleData::getReadHistory(int subrun) readString commands that have been processed by the vector<string> ParticleData::getReadHistory(int subrun) ParticleData instance, for a specific subrun (see the section on vector<string> ParticleData::getReadHistory(int subrun) Main-Program Settings ). For vector<string> ParticleData::getReadHistory(int subrun) subrun = -1 , returns the vector<string> ParticleData::getReadHistory(int subrun) readString history common to all subruns. For vector<string> ParticleData::getReadHistory(int subrun) subrun >= 0 , returns the history of vector<string> ParticleData::getReadHistory(int subrun) readString commands for that specific subrun (omitting the common part)."},{"name":"vector&lt;string&gt; Settings::getReadHistory()","link":"SettingsScheme.html#anchor14","text":"vector<string> Settings::getReadHistory() Method to retrieve the history of vector<string> Settings::getReadHistory() readString commands that have been processed by the vector<string> Settings::getReadHistory() Settings instance, e.g. for inspection. Note that vector<string> Settings::getReadHistory() readFile command lines are interpreted by vector<string> Settings::getReadHistory() readString and thus also are listed, as are the vector<string> Settings::getReadHistory() Settings commands read by vector<string> Settings::getReadHistory() Pythia::readString and vector<string> Settings::getReadHistory() Pythia::readFile."},{"name":"vector&lt;string&gt; Settings::getReadHistory(int subrun)","link":"SettingsScheme.html#anchor15","text":"vector<string> Settings::getReadHistory(int subrun) Method to retrieve the history of vector<string> Settings::getReadHistory(int subrun) readString commands that have been processed by vector<string> Settings::getReadHistory(int subrun) Settings , for a specific subrun (see the section on vector<string> Settings::getReadHistory(int subrun) Main-Program Settings ). For vector<string> Settings::getReadHistory(int subrun) subrun = -1 , returns the vector<string> Settings::getReadHistory(int subrun) readString history common to all subruns. For vector<string> Settings::getReadHistory(int subrun) subrun >= 0 , returns the history of vector<string> Settings::getReadHistory(int subrun) readString commands for that specific subrun (omitting the common part)."},{"name":"vector&lt;string&gt; Settings::wvec(string key)","link":"SettingsScheme.html#anchor40","text":"vector<string> Settings::wvec(string key) return the current value(s) of the respective setting. If the name does not exist in the database, a value vector<string> Settings::wvec(string key) false , vector<string> Settings::wvec(string key) 0 , vector<string> Settings::wvec(string key) 0. , vector<string> Settings::wvec(string key) &quot; &quot; , or a vector of length 1 and value vector<string> Settings::wvec(string key) false , vector<string> Settings::wvec(string key) 0 , vector<string> Settings::wvec(string key) 0. or vector<string> Settings::wvec(string key) &quot; &quot; , respectively, is returned."},{"name":"vector&lt;string&gt; Settings::wvecDefault(string key)","link":"SettingsScheme.html#anchor48","text":"vector<string> Settings::wvecDefault(string key) return the default value(s) of the respective setting. If the name does not exist in the database, a value vector<string> Settings::wvecDefault(string key) false , vector<string> Settings::wvecDefault(string key) 0 , vector<string> Settings::wvecDefault(string key) 0. , vector<string> Settings::wvecDefault(string key) &quot; &quot; , or a vector of length 1 and value vector<string> Settings::wvecDefault(string key) false , vector<string> Settings::wvecDefault(string key) 0 , vector<string> Settings::wvecDefault(string key) 0. or vector<string> Settings::wvecDefault(string key) &quot; &quot; , respectively, is returned."},{"name":"virtual BeamShape::~BeamShape()","link":"BeamShape.html#anchor2","text":"virtual BeamShape::~BeamShape() the constructor and destructor do not need to do anything."},{"name":"virtual bool canChangeFragPar()","link":"UserHooks.html#anchor47","text":"virtual bool canChangeFragPar() In the base class this method returns false. If you redefine it to return true, it will enable the methods virtual bool canChangeFragPar() doChangeFragPar(...) , virtual bool canChangeFragPar() doVetoFragmentation(...) and virtual bool canChangeFragPar() setStringEnds(...)."},{"name":"virtual bool canCutOnRecState()","link":"MatchingAndMerging.html#anchor16","text":"virtual bool canCutOnRecState()"},{"name":"virtual bool canSetImpactParameter()","link":"UserHooks.html#anchor51","text":"virtual bool canSetImpactParameter() In the base class this method returns false. If you redefine it to return true, it will enable the method virtual bool canSetImpactParameter() doSetImpactParameter()."},{"name":"virtual bool canVetoTrialEmission()","link":"MatchingAndMerging.html#anchor18","text":"virtual bool canVetoTrialEmission()"},{"name":"virtual bool DecayHandler::chainDecay(  vector&lt;int&gt;&amp; idProd, vector&lt;int&gt;&amp; motherProd,  vector&lt;double&gt;&amp; mProd, vector&lt;Vec4&gt;&amp; pProd,  int iDec, const Event&amp; event)","link":"ExternalDecays.html#anchor2","text":"virtual bool DecayHandler::chainDecay(  vector<int>&amp; idProd, vector<int>&amp; motherProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd,  int iDec, const Event&amp; event) where virtual bool DecayHandler::chainDecay(  vector<int>&amp; idProd, vector<int>&amp; motherProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd,  int iDec, const Event&amp; event) is a list of the indices of the mother, virtual bool DecayHandler::chainDecay(  vector<int>&amp; idProd, vector<int>&amp; motherProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd,  int iDec, const Event&amp; event) and the other arguments are as above."},{"name":"virtual bool DecayHandler::decay(vector&lt;int&gt;&amp; idProd,  vector&lt;double&gt;&amp; mProd, vector&lt;Vec4&gt;&amp; pProd, int iDec,  const Event&amp; event)","link":"ExternalDecays.html#anchor1","text":"virtual bool DecayHandler::decay(vector<int>&amp; idProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd, int iDec,  const Event&amp; event) where virtual bool DecayHandler::decay(vector<int>&amp; idProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd, int iDec,  const Event&amp; event) is a list of particle PDG identity codes, virtual bool DecayHandler::decay(vector<int>&amp; idProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd, int iDec,  const Event&amp; event) is a list of their respective masses (in GeV), and virtual bool DecayHandler::decay(vector<int>&amp; idProd,  vector<double>&amp; mProd, vector<Vec4>&amp; pProd, int iDec,  const Event&amp; event) is a list of their respective four-momenta."},{"name":"virtual bool doChainDecay(int idMother)","link":"ExternalDecays.html#anchor3","text":"virtual bool doChainDecay(int idMother) if true then virtual bool doChainDecay(int idMother) chainDecay is called, else virtual bool doChainDecay(int idMother) decay. This method is called for each particle that is to be decayed externally. virtual bool doChainDecay(int idMother) is the PDG identity code of the decaying mother."},{"name":"virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector&lt;int&gt; iParton,  const StringEnd * sEnd)","link":"UserHooks.html#anchor48","text":"virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) This is the method for changing fragmentation parameters. If all parameters are changed as they should, the method should return true. In case of errors the method returns false and a warning is printed. The method takes as argument pointers to three objects that hold the fragmentation parameters, and three arguments that give information about the string currently being hadronized. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) is a pointer to a virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) StringFlav object, which selects quark and diquark flavours and hadron species formed in the string breaks. The parameters can be changed by setting new parameters in a virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) Settings object and reinitializing with virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) flavPtr->init(settings,randomPtr) , where virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) settings is the settings object and virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) randomPtr is a pointer to the desired random number generator. Note that the virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) UserHooks base class already holds pointers to the virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) Settings and virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) Random objects. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) is a pointer to a virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) StringZ object, which selects the hadron momentum fraction virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) z using the Lund fragmentation function. Parameters are changed by virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) zPtr->init(settings,particleData,randomPtr) in the same way as above. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) is a pointer to a virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) StringPT object which selects the hadron virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) pT from a Gaussian distribution. Parameters are changed by virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) pTPtr->init(settings,particleData,randomPtr) in the same way as above. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) gives the code of the parton (quark, diquark or gluon) in the string end that we are currently hadronizing from. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) gives the invariant mass squared of all hadrons produced from the current end of the string up to this point. Used to keep track of where we are on the string. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) contains the indices in the standard event record for all the partons in the string currently being hadronized. virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) is a pointer to a virtual bool doChangeFragPar(StringFlav* flavPtr, StringZ* zPtr,  StringPT* pTPtr, int idEnd, double m2Had, vector<int> iParton,  const StringEnd * sEnd) StringEnd object  containing additional information about the string break."},{"name":"virtual bool doCutOnRecState( const Event& event )","link":"MatchingAndMerging.html#anchor17","text":"virtual bool doCutOnRecState( const Event& event )"},{"name":"virtual bool doSetImpactParameter()","link":"UserHooks.html#anchor52","text":"virtual bool doSetImpactParameter() This method allows the user to select a particular impact parameter in the MPI machinery in the generation of minimum-bias events. The function takes no arguments and is intended for situations where the impact parameter is generated from the outside, as is the case in the Angantyr model for Heavy Ion collisions. Note that it does not modify the virtual bool doSetImpactParameter() virtual bool doSetImpactParameter() MultipartonInteractions:bProfile used in the MPI machinery, and that currently it will only affect the virtual bool doSetImpactParameter() virtual bool doSetImpactParameter() SoftQCD processes."},{"name":"virtual bool doVetoFragmentation(Particle had,  const StringEnd * sEnd)","link":"UserHooks.html#anchor49","text":"virtual bool doVetoFragmentation(Particle had,  const StringEnd * sEnd) This method can veto the production of a hadron, whereby the current string break is redone. virtual bool doVetoFragmentation(Particle had,  const StringEnd * sEnd) is a (copy of) the hadron being produced, just before it is added to the event record. virtual bool doVetoFragmentation(Particle had,  const StringEnd * sEnd) is a pointer to a virtual bool doVetoFragmentation(Particle had,  const StringEnd * sEnd) StringEnd object containing additional information about the string break."},{"name":"virtual bool doVetoFragmentation(Particle had1, Particle had2,  const StringEnd * sEnd1, const StringEnd * sEnd1)","link":"UserHooks.html#anchor50","text":"virtual bool doVetoFragmentation(Particle had1, Particle had2,  const StringEnd * sEnd1, const StringEnd * sEnd1) This method can veto the production of the final hadrons produced in the fragmentation of a string. virtual bool doVetoFragmentation(Particle had1, Particle had2,  const StringEnd * sEnd1, const StringEnd * sEnd1) are (copies of) the two final hadrons being produced, just before they are added to the event record. virtual bool doVetoFragmentation(Particle had1, Particle had2,  const StringEnd * sEnd1, const StringEnd * sEnd1) are pointers to virtual bool doVetoFragmentation(Particle had1, Particle had2,  const StringEnd * sEnd1, const StringEnd * sEnd1) StringEnd objects containing additional information about the string break."},{"name":"virtual bool doVetoTrialEmission( const Event&, const  Event& )","link":"MatchingAndMerging.html#anchor19","text":"virtual bool doVetoTrialEmission( const Event&, const  Event& )"},{"name":"virtual bool LHAup::setEvent(int idProcess = 0)","link":"LesHouchesAccord.html#anchor30","text":"virtual bool LHAup::setEvent(int idProcess = 0) this pure virtual method has to be implemented in the derived class, to set relevant information when called. For strategy options +-1 and +-2 the input virtual bool LHAup::setEvent(int idProcess = 0) idProcess value specifies which process that should be generated, while virtual bool LHAup::setEvent(int idProcess = 0) idProcess is irrelevant for strategies +-3 and +-4. The method should return false if it fails to set the info, i.e. normally that the supply of events in a file is exhausted. If so, no event is generated, and virtual bool LHAup::setEvent(int idProcess = 0) Pythia::next() returns false. You can then interrogate virtual bool LHAup::setEvent(int idProcess = 0) virtual bool LHAup::setEvent(int idProcess = 0) Info::atEndOfFile() to confirm that indeed the failure is caused in this method, and decide to break out of the event generation loop."},{"name":"virtual bool LHAup::setInit()","link":"LesHouchesAccord.html#anchor4","text":"virtual bool LHAup::setInit() this pure virtual method has to be implemented in the derived class, to set relevant information when called. It should return false if it fails to set the info. In the no-beams extension this method need not do anything, since by default strategy 3 is chosen and the rest is set vanishing, but the method must exist."},{"name":"virtual bool LHAup::skipEvent(int nSkip)","link":"LesHouchesAccord.html#anchor68","text":"virtual bool LHAup::skipEvent(int nSkip) skip ahead virtual bool LHAup::skipEvent(int nSkip) nSkip events in the Les Houches generation sequence, without doing anything further with them. Mainly intended for debug purposes, e.g. when an event at a known location in a Les Houches Event File is causing problems. Will return false if operation fails, specifically if the end of an LHEF has been reached. The implementation in the base class simply executes virtual bool LHAup::skipEvent(int nSkip) setEvent() the requested number of times. The derived virtual bool LHAup::skipEvent(int nSkip) LHAupLHEF class (see below) only uses the virtual bool LHAup::skipEvent(int nSkip) setNewEventLHEF(...) part of its virtual bool LHAup::skipEvent(int nSkip) setEvent() method, and other derived classes could choose other shortcuts."},{"name":"virtual bool MergingHooks::canCutOnRecState()","link":"CKKWLMerging.html#anchor27","text":"virtual bool MergingHooks::canCutOnRecState() In the base class this method returns false. If you redefine it to return true then the method virtual bool MergingHooks::canCutOnRecState() doCutOnRecState(...) will be called for each reclustered state encountered in the generation of all possible histories of the matrix element state."},{"name":"virtual bool MergingHooks::doCutOnRecState(const Event&  event)","link":"CKKWLMerging.html#anchor28","text":"virtual bool MergingHooks::doCutOnRecState(const Event&  event) This routine will be supplied internally with every possible reclustered event that can be reached by reclustering any number of partons in the matrix element input state. The new, reclustered, states can then be analysed. If the method returns false, the history to which the state belongs will be treated as if it were unordered, i.e. this path will only be chosen if no other histories are available. In this way, the number of histories not fulfilling the user criterion will be minimised."},{"name":"virtual bool MyHardProcess::allowCandidates(int iPos,  vector&lt;int&gt; Pos1, vector&lt;int&gt; Pos2, const Event& event)","link":"MatchingAndMerging.html#anchor28","text":"virtual bool MyHardProcess::allowCandidates(int iPos,  vector<int> Pos1, vector<int> Pos2, const Event& event) This function uses the input vectors of positions of particles in the input event to decide if the particle with virtual bool MyHardProcess::allowCandidates(int iPos,  vector<int> Pos1, vector<int> Pos2, const Event& event) iPos could be member of the core scattering. If the particle with position virtual bool MyHardProcess::allowCandidates(int iPos,  vector<int> Pos1, vector<int> Pos2, const Event& event) iPos cannot be part of the core scattering (e.g. because it is a final state parton, while the core scattering contains final state leptons only), then the function should return false. Else, return true to allow this candidate. Note that it might be possible to find multiple equally good core scattering candidates. In this case, all candidates should be found (with the virtual bool MyHardProcess::allowCandidates(int iPos,  vector<int> Pos1, vector<int> Pos2, const Event& event) findOtherCandidates function), and can be potentially be replaced (with virtual bool MyHardProcess::allowCandidates(int iPos,  vector<int> Pos1, vector<int> Pos2, const Event& event) exchangeCandidates )."},{"name":"virtual bool MyHardProcess::exchangeCandidates(  vector&lt;int&gt; candidates1, vector&lt;int&gt; candidates2, map&lt;int,  int&gt; further1, map&lt;int, int&gt; further2)","link":"MatchingAndMerging.html#anchor31","text":"virtual bool MyHardProcess::exchangeCandidates(  vector<int> candidates1, vector<int> candidates2, map<int,  int> further1, map<int, int> further2) This function implements the replacement of a list of core scattering candidates by another list of candidates."},{"name":"virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace)","link":"MatchingAndMerging.html#anchor30","text":"virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace) The argument virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace) iPos specifies the position of a particle in the input event which is tagged as part of the core scattering. This function may be used to check the role of virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace) iPos as  core scattering member may be filled by another particle in the event record. If so, and if virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace) doReplace=true , then virtual bool MyHardProcess::findOtherCandidates(int iPos, const  Event& event, bool doReplace) iPos will no longer be book-kept as part of the core scattering. An example where this functionality is helpful is if the input event is g g -> b b~ b  b~, and the core scattering is g g -> b b~. Not swapping the hard process candidates could in this case mean that not all parton shower histories can be found. The function should return false if no replacements can be found, and true otherwise."},{"name":"virtual bool MyHardProcess::matchesAnyOutgoing(int iPos, const  Event& event)","link":"MatchingAndMerging.html#anchor29","text":"virtual bool MyHardProcess::matchesAnyOutgoing(int iPos, const  Event& event) This function may be used to check if the particle with position virtual bool MyHardProcess::matchesAnyOutgoing(int iPos, const  Event& event) iPos in the input event should be considered an outgoing particle of the core scattering."},{"name":"virtual bool MyMergingHooks::canVetoEmission()","link":"MatchingAndMerging.html#anchor12","text":"virtual bool MyMergingHooks::canVetoEmission() This function will be used to tell Pythia if a veto of emissions should potentially be applied."},{"name":"virtual bool MyMergingHooks::canVetoStep()","link":"MatchingAndMerging.html#anchor10","text":"virtual bool MyMergingHooks::canVetoStep() This function will be used to tell Pythia if a CKKW-L-style event veto after the first parton shower emission should be checked. If so, the function should return true, and false otherwise."},{"name":"virtual bool MyMergingHooks::doVetoStep( const Event& event)","link":"MatchingAndMerging.html#anchor13","text":"virtual bool MyMergingHooks::doVetoStep( const Event& event) This function will be used to implement the check if shower emissions should be discarded, as e.g. necessary in UMEPS or UNLOPS merging. You can study the input event virtual bool MyMergingHooks::doVetoStep( const Event& event) event after emission, and return true if the emission is valid, and false if you want to reject the emission. Note that this veto does not lead to event rejections, only in potentially removing certain emissions during shower evolution."},{"name":"virtual bool MyMergingHooks::doVetoStep( const Event& process,  const Event& event, bool doResonance = false )","link":"MatchingAndMerging.html#anchor11","text":"virtual bool MyMergingHooks::doVetoStep( const Event& process,  const Event& event, bool doResonance = false ) This function will be used to implement the check of a CKKW-L-style event veto after the first parton shower emission, i.e. to check if the first parton shower emission is above the merging scale. If the input event virtual bool MyMergingHooks::doVetoStep( const Event& process,  const Event& event, bool doResonance = false ) event after emission should be kept, then false should be returned. If you want instead to veto the event and continue with a completely now hard scattering event, true should be returned."},{"name":"virtual bool MyMergingHooks::setShowerStartingScales( bool      isTrial, bool doMergeFirstEmm,      double& pTscaleIn, const Event& event,      double& pTmaxFSRIn, bool& limitPTmaxFSRin,      double& pTmaxISRIn, bool& limitPTmaxISRin,      double& pTmaxMPIIn, bool& limitPTmaxMPIin )","link":"MatchingAndMerging.html#anchor14","text":"virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) This function allows to set the starting scales for timelike and spacelike showering as well as multiparton interactions. It is thus necessary to properly start trial showers (that generate necessary no-emission probabilities), and for setting the correct starting conditions for parton showering of accepted (non-zero weight) events. The input virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) event gives the hard process before showers and MPI are attempted. If virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) isTrial=true , this means that the function is currently called from within a trial shower object (to produce no-emission probabilities). If virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) doMergeFirstEmm=true , then the function is called to set starting conditions for the shower evolution of an (accepted) event. The double arguments virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) pTscaleIn , virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) pTmaxFSRIn , virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) pTmaxISRIn and virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) pTmaxMPIIn are tentative values for the starting scales of FSR, ISR and MPI. The function may overwrite these with the desired values. Similarly, virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) limitPTmaxFSRin , virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) limitPTmaxFSRin and virtual bool MyMergingHooks::setShowerStartingScales( bool    isTrial, bool doMergeFirstEmm,    double& pTscaleIn, const Event& event,    double& pTmaxFSRIn, bool& limitPTmaxFSRin,    double& pTmaxISRIn, bool& limitPTmaxISRin,    double& pTmaxMPIIn, bool& limitPTmaxMPIin ) limitPTmaxMPIin inform Pythia if the phase space for FSR/ISR/MPI is restricted (true) or unrestricted (false). Again, the tentative values can be overwritten."},{"name":"virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel)","link":"EventAnalysis.html#anchor68","text":"virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) is the main method that you will need to write. It will be called once for each final-state particle in an event, subject to the value of the virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) select switch in the virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) SlowJet constructor. The value virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) select = 2 may be convenient since then you do not need to remove e.g. neutrinos yourself, but use virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) select = 1 for full control. The method should then return virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) true if you want to see particle included in the jet clustering, and virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) false if not. virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) is the index in the event record of the currently studied particle. virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) is an object of the virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) Event class, most likely the virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) pythia.event one, where the currently studied particle is found. virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) is at input the four-momentum of the currently studied particle. You can change the values, e.g. to take into account energy smearing in the detector, to define the initial cluster value, without corrupting the event record itself. virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) is at input the mass of the currently studied particle. You can change the value, e.g. to take into account particle misidentification, to define the initial cluster value, without corrupting the event record itself. Note that the changes of virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) pSel and virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) mSel must be coordinated such that virtual bool SlowJetHook::include(int iSel,  const Event& event, Vec4& pSel, double& mSel) E^2 - p^2 = m^2 holds."},{"name":"virtual bool SpaceShower::allowedSplitting( const Event& event,  int iRad, int iEmt)","link":"ImplementNewShowers.html#anchor47","text":"virtual bool SpaceShower::allowedSplitting( const Event& event,  int iRad, int iEmt) This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the spacelike shower if a particular combination of radiator and emission could have resulted from a splitting. The function arguments are the virtual bool SpaceShower::allowedSplitting( const Event& event,  int iRad, int iEmt) event which contains the radiator and emission, and the position of the radiator ( virtual bool SpaceShower::allowedSplitting( const Event& event,  int iRad, int iEmt) iRad ) and emission ( virtual bool SpaceShower::allowedSplitting( const Event& event,  int iRad, int iEmt) iEmt ) in said event. The function should return true if the combination was possible, and false otherwise."},{"name":"virtual bool SpaceShower::branch( Event& event)","link":"ImplementNewShowers.html#anchor37","text":"virtual bool SpaceShower::branch( Event& event) This method will be called once ISR has won the competition with MPI and FSR to do the next branching. The candidate branching found in the previous step should here be carried out in full. The pre-branching partons should get a negative status code and new replacement ones added to the end of the event record. Also the subsystem information should be updated, and possibly also the beams. virtual bool SpaceShower::branch( Event& event) Should some problem be encountered in this procedure, e.g. if some not-previously-considered kinematics requirement fails, it is allowed to return virtual bool SpaceShower::branch( Event& event) false to indicate that no branching could be carried out. Also a complete restart of the parton-level description may be necessary, see virtual bool SpaceShower::branch( Event& event) doRestart() below."},{"name":"virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor42","text":"virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name) This function should return true if the splitting that produced the particles virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iRad] , virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iRec] and virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iEmt] should be classified as spacelike splittings (i.e. is handled by initial state showers). The identifier virtual bool SpaceShower::isSpacelike( const Event& event,  int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.)","link":"ImplementNewShowers.html#anchor32","text":"virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) The question is whether the ISR should be allowed to occur at larger scales than the hard process it surrounds. This is process-dependent. For instance, if the hard process is virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) Z^0 production we know that ISR should be allowed to go right up to the kinematical limit. If it is a virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) 2 &rarr; 2 QCD process the ISR should not exceed the scale of the hard process, since if so one would double-count. The virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) SpaceShower:pTmaxMatch switch allows you to force the behaviour, or else to program your own logic. The current default implementation limits virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) pT whenever the final state contains a quark (except top), gluon or photon, since then the danger of double-counting is there. You may replace by your own logic, or leave as is. virtual bool SpaceShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) The internal PYTHIA implementation also allows intermediate options, where emissions can go up to the kinematical limit but be dampened above the factorization or renormalization scale. Therefore the (square of the) latter two are provided as optional input parameters."},{"name":"virtual bool TimeShower::allowedSplitting( const Event& event,  int iRad, int iEmt)","link":"ImplementNewShowers.html#anchor26","text":"virtual bool TimeShower::allowedSplitting( const Event& event,  int iRad, int iEmt) This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the timelike shower if a particular combination of radiator and emission could have resulted from a splitting. The function arguments are the virtual bool TimeShower::allowedSplitting( const Event& event,  int iRad, int iEmt) event which contains the radiator and emission, and the position of the radiator ( virtual bool TimeShower::allowedSplitting( const Event& event,  int iRad, int iEmt) iRad ) and emission ( virtual bool TimeShower::allowedSplitting( const Event& event,  int iRad, int iEmt) iEmt ) in said event. The function should return true if the combination was possible, and false otherwise."},{"name":"virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false)","link":"ImplementNewShowers.html#anchor16","text":"virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) This method will be called once FSR has won the competition with MPI and ISR to do the next branching. The candidate branching found in the previous step should here be carried out in full. The pre-branching partons should get a negative status code and new replacement ones added to the end of the event record. Also the subsystem information should be updated, and possibly also the beams. virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) Should some problem be encountered in this procedure, e.g. if some not-previously-considered kinematics requirement fails, it is allowed to return virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) false to indicate that no branching could be carried out. virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) Normally the optional virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) isInterleaved argument would not be of interest. It can be used to separate resonance decays, false, from the interleaved evolution together with MPI and ISR, true. More precisely, it separates calls to the virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) timesDecPtr and the virtual bool TimeShower::branch( Event& event,  bool isInterleaved = false) timesPtr instances."},{"name":"virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor21","text":"virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name) This function should return true if the splitting that produced the particles virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iRad] , virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iRec] and virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name) event[iEmt] should be classified as timelike splittings (i.e. is handled by final state showers). The identifier virtual bool TimeShower::isTimelike( const Event& event,  int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"virtual bool TimeShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.)","link":"ImplementNewShowers.html#anchor5","text":"virtual bool TimeShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) The question is whether the FSR should be allowed to occur at larger scales than the hard process it surrounds. This is process-dependent, as illustrated below for the the analogous virtual bool TimeShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) SpaeShower::limitPTmax(...) method, although the two kinds of radiation need not have to be modeled identically. The virtual bool TimeShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) TimeShower:pTmaxMatch switch allows you to force the behaviour among three options, but you may replace by your own logic. virtual bool TimeShower::limitPTmax( Event& event,  double Q2Fac = 0.,  double Q2Ren = 0.) The internal PYTHIA implementation also allows intermediate options, where emissions can go up to the kinematical limit but be dampened above the factorization or renormalization scale. Therefore the (square of the) latter two are provided as optional input parameters."},{"name":"virtual bool TimeShower::rescatterPropogateRecoil(  Event& event, Vec4& pNew)","link":"ImplementNewShowers.html#anchor17","text":"virtual bool TimeShower::rescatterPropogateRecoil(  Event& event, Vec4& pNew) This method is only called if rescattering is switched on in the description of multiparton interactions. It then propagates a recoil from a timelike branching to internal lines that connect systems. As for virtual bool TimeShower::rescatterPropogateRecoil(  Event& event, Vec4& pNew) rescatterUpdate above, this is not likely to be of interest to most implementors of new showers."},{"name":"virtual bool UserHooks::canBiasSelection()","link":"UserHooks.html#anchor33","text":"virtual bool UserHooks::canBiasSelection() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canBiasSelection() biasSelectionBy(...) will allow you to modify the phase space sampling, with a compensating event weight, such that the cross section is unchanged. You cannot combine this kind of reweighting with the selection of virtual bool UserHooks::canBiasSelection() a second hard process."},{"name":"virtual bool UserHooks::canEnhanceEmission()","link":"UserHooks.html#anchor42","text":"virtual bool UserHooks::canEnhanceEmission() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canEnhanceEmission() enhanceFactor(...) will be used to rescale an initial-state splitting probability. Both virtual bool UserHooks::canEnhanceEmission() enhanceFactor(...) and virtual bool UserHooks::canEnhanceEmission() vetoProbability(...) will have to be derived to allow for a branching enhancement."},{"name":"virtual bool UserHooks::canEnhanceTrial()","link":"UserHooks.html#anchor46","text":"virtual bool UserHooks::canEnhanceTrial() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canEnhanceTrial() enhanceFactor(...) (see above) will be used to rescale an initial-state trial splitting probability."},{"name":"virtual bool UserHooks::canModifySigma()","link":"UserHooks.html#anchor29","text":"virtual bool UserHooks::canModifySigma() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canModifySigma() multiplySigmaBy(...) will allow you to modify the cross section weight assigned to the current event."},{"name":"virtual bool UserHooks::canReconnectResonanceSystems()","link":"UserHooks.html#anchor40","text":"virtual bool UserHooks::canReconnectResonanceSystems() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canReconnectResonanceSystems() doReconnectResonanceSystems(...) will be called immediately after the resonance decays and their associated final-state showers have been added to the event record."},{"name":"virtual bool UserHooks::canSetResonanceScale()","link":"UserHooks.html#anchor38","text":"virtual bool UserHooks::canSetResonanceScale() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canSetResonanceScale() scaleResonance(...) will set the initial scale of downwards shower evolution."},{"name":"virtual bool UserHooks::canVetoFSREmission()","link":"UserHooks.html#anchor25","text":"virtual bool UserHooks::canVetoFSREmission() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoFSREmission() doVetoFSREmission(...) will interrupt the final-state shower immediately after each emission and allow that emission to be vetoed."},{"name":"virtual bool UserHooks::canVetoISREmission()","link":"UserHooks.html#anchor23","text":"virtual bool UserHooks::canVetoISREmission() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoISREmission() doVetoISREmission(...) will interrupt the initial-state shower immediately after each emission and allow that emission to be vetoed."},{"name":"virtual bool UserHooks::canVetoMPIEmission()","link":"UserHooks.html#anchor27","text":"virtual bool UserHooks::canVetoMPIEmission() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoMPIEmission() doVetoMPIEmission(...) will interrupt the MPI machinery immediately after each multiparton interaction and allow it to be vetoed."},{"name":"virtual bool UserHooks::canVetoMPIStep()","link":"UserHooks.html#anchor20","text":"virtual bool UserHooks::canVetoMPIStep() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoMPIStep() doVetoMPIStep(...) will interrupt the downward MPI evolution the first virtual bool UserHooks::canVetoMPIStep() numberVetoMPIStep() times."},{"name":"virtual bool UserHooks::canVetoPartonLevel()","link":"UserHooks.html#anchor10","text":"virtual bool UserHooks::canVetoPartonLevel() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoPartonLevel() doVetoPartonLevel(...) will be called immediately after the parton level has been generated and stored in the virtual bool UserHooks::canVetoPartonLevel() virtual bool UserHooks::canVetoPartonLevel() event event record. Thus showers, multiparton interactions and beam remnants have been set up, but hadronization and decays have not yet been performed. This is already a fairly complete event, possibly with quite a complex parton-level history. Therefore it is usually only meaningful to study the hardest interaction, e.g. using virtual bool UserHooks::canVetoPartonLevel() subEvent(...) introduced above, or fairly generic properties, such as the parton-level jet structure."},{"name":"virtual bool UserHooks::canVetoPartonLevelEarly()","link":"UserHooks.html#anchor12","text":"virtual bool UserHooks::canVetoPartonLevelEarly() is very similar to virtual bool UserHooks::canVetoPartonLevelEarly() canVetoPartonLevel() above, except that the chance to veto appears somewhat earlier in the generation chain, after showers and multiparton interactions, but before the beam remnants and resonance decays have been added. It is therefore somewhat more convenient for many matrix element strategies, where the primordial virtual bool UserHooks::canVetoPartonLevelEarly() kT added along with the beam remnants should not be included."},{"name":"virtual bool UserHooks::canVetoProcessLevel()","link":"UserHooks.html#anchor8","text":"virtual bool UserHooks::canVetoProcessLevel() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoProcessLevel() doVetoProcessLevel(...) will be called immediately after a hard process (and associated resonance decays) has been selected and stored in the virtual bool UserHooks::canVetoProcessLevel() virtual bool UserHooks::canVetoProcessLevel() process event record. virtual bool UserHooks::canVetoProcessLevel() At this stage, the virtual bool UserHooks::canVetoProcessLevel() process record typically contains the two beams in slots 1 and 2, the two incoming partons to the hard process in slots 3 and 4, the N (usually 1, 2 or 3) primary produced particles in slots 5 through 4 + N, and thereafter recursively the resonance decay chains, if any. Use the method virtual bool UserHooks::canVetoProcessLevel() omitResonanceDecays(...) if you want to skip these decay chains. There are exceptions to this structure, for virtual bool UserHooks::canVetoProcessLevel() soft QCD processes (where the partonic process may not yet have been selected at this stage), and when virtual bool UserHooks::canVetoProcessLevel() a second hard process has been requested (where two hard processes are bookkept). In general it is useful to begin the development work by listing a few virtual bool UserHooks::canVetoProcessLevel() process records, to clarify what the structure is for the cases of interest."},{"name":"virtual bool UserHooks::canVetoPT()","link":"UserHooks.html#anchor14","text":"virtual bool UserHooks::canVetoPT() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoPT() doVetoPT(...) will interrupt the downward evolution at virtual bool UserHooks::canVetoPT() scaleVetoPT()."},{"name":"virtual bool UserHooks::canVetoResonanceDecays()","link":"UserHooks.html#anchor36","text":"virtual bool UserHooks::canVetoResonanceDecays() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoResonanceDecays() doVetoResonanceDecays(...) will be called immediately after the resonance decays have been selected and stored in the virtual bool UserHooks::canVetoResonanceDecays() process event record, as described above for virtual bool UserHooks::canVetoResonanceDecays() canVetoProcessLevel()."},{"name":"virtual bool UserHooks::canVetoStep()","link":"UserHooks.html#anchor17","text":"virtual bool UserHooks::canVetoStep() In the base class this method returns false. If you redefine it to return true then the method virtual bool UserHooks::canVetoStep() doVetoStep(...) will interrupt the downward ISR and FSR evolution the first virtual bool UserHooks::canVetoStep() numberVetoStep() times."},{"name":"virtual bool UserHooks::doReconnectResonanceSystems(  int oldSizeEvent, Event& event)","link":"UserHooks.html#anchor41","text":"virtual bool UserHooks::doReconnectResonanceSystems(  int oldSizeEvent, Event& event) can optionally be called, as described above, to reconnect colours in the event. The method should normally return true, but false if the colour-reconnected event is unphysical and to be rejected. (If this is likely to happen, having a safety copy to restore to is a good idea, so that false can be avoided to the largest extent possible.) virtual bool UserHooks::doReconnectResonanceSystems(  int oldSizeEvent, Event& event) the size of the event record before resonance decay products and their associated final-state showers have been added to the event. Can thus be used to easily separate the resonance-decay partons from those in the rest of the event. virtual bool UserHooks::doReconnectResonanceSystems(  int oldSizeEvent, Event& event) the event record contains a list of all particles generated so far. You are allowed to freely modify this record, but with freedom comes responsibility. Firstly, it is only meaningful to modify the colour indices of final-state (at the time) partons; all other event properties had better be left undisturbed. Secondly, it is up to you to ensure that the new colour topology is meaningful, e.g. that no gluon has obtained the same colour as anticolour index and thereby forms a singlet on its own."},{"name":"virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false)","link":"UserHooks.html#anchor26","text":"virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) event event record of the partonic process. Based on that you can decide whether to veto the emission, true, or not, false. If you veto, then the latest emission is removed from the event record. In either case the evolution of the shower will continue from the point where it was left off. virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) is the size of the event record before the latest emission was added to it. It will also become the new size if the emission is vetoed. virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent emission, which are stored in entries from virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) sizeOld through virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) event.size() - 1 inclusive. If you veto the emission these entries will be removed, and the history info in the remaining partons will be restored to a state as if the emission had never occurred. virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) the system where the radiation occurs, according to Parton Systems. virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) virtual bool UserHooks::doVetoFSREmission(  int sizeOld, const Event& event, int iSys, bool inResonance = false) true if the emission takes place in a resonance decay, subsequent to the hard process."},{"name":"virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys)","link":"UserHooks.html#anchor24","text":"virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) event event record of the partonic process. Based on that you can decide whether to veto the emission, true, or not, false. If you veto, then the latest emission is removed from the event record. In either case the evolution of the shower will continue from the point where it was left off. virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) is the size of the event record before the latest emission was added to it. It will also become the new size if the emission is vetoed. virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent emission, which are stored in entries from virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) sizeOld through virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) event.size() - 1 inclusive. If you veto the emission these entries will be removed, and the history info in the remaining partons will be restored to a state as if the emission had never occurred. virtual bool UserHooks::doVetoISREmission(  int sizeOld, const Event& event, int iSys) the system where the radiation occurs, according to Parton Systems."},{"name":"virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event)","link":"UserHooks.html#anchor28","text":"virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) event event record of the partonic process. Based on that you can decide whether to veto the MPI, true, or not, false. If you veto, then the latest MPI is removed from the event record. In either case the interleaved evolution will continue from the point where it was left off. virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) is the size of the event record before the latest MPI was added to it. It will also become the new size if the MPI is vetoed. virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) the event record contains a list of all partons generated so far. Of special interest are the ones associated with the most recent MPI, which are stored in entries from virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) sizeOld through virtual bool UserHooks::doVetoMPIEmission(  int sizeOld, const Event& event) event.size() - 1 inclusive. If you veto the MPI these entries will be removed."},{"name":"virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event)","link":"UserHooks.html#anchor22","text":"virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) Pythia::next(). virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) is the number of MPI subprocesses has occurred so far. virtual bool UserHooks::doVetoMPIStep(int nMPI,  const Event& event) the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', e.g. leftovers from the ISR and FSR evolution of previously generated systems. The most recently added one has not had time to radiate, of course."},{"name":"virtual bool UserHooks::doVetoPartonLevel(const Event& event)","link":"UserHooks.html#anchor11","text":"virtual bool UserHooks::doVetoPartonLevel(const Event& event) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoPartonLevel(const Event& event) event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The virtual bool UserHooks::doVetoPartonLevel(const Event& event) Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of virtual bool UserHooks::doVetoPartonLevel(const Event& event) Pythia::next(). virtual bool UserHooks::doVetoPartonLevel(const Event& event) Note: the above veto is different from setting the flag virtual bool UserHooks::doVetoPartonLevel(const Event& event) virtual bool UserHooks::doVetoPartonLevel(const Event& event) HadronLevel:all = off. Also in the latter case the event generation will stop after the parton level, but an event generated up to this point is considered perfectly acceptable. It can be studied and it contributes to the cross section. That is, virtual bool UserHooks::doVetoPartonLevel(const Event& event) HadronLevel:all = off is intended for simple studies of complete partonic states, where one can save time by not generating the complete hadronic final state. By contrast, the virtual bool UserHooks::doVetoPartonLevel(const Event& event) doVetoPartonLevel() method allows you to throw away uninteresting events to save time that way, but those events that do survive the veto are allowed to develop into complete final states (unless flags have been set otherwise)."},{"name":"virtual bool UserHooks::doVetoPartonLevelEarly(const  Event& event)","link":"UserHooks.html#anchor13","text":"virtual bool UserHooks::doVetoPartonLevelEarly(const  Event& event) is very similar to virtual bool UserHooks::doVetoPartonLevelEarly(const  Event& event) doVetoPartonLevel(...) above, but the veto can be done earlier, as described for virtual bool UserHooks::doVetoPartonLevelEarly(const  Event& event) canVetoPartonLevelEarly()."},{"name":"virtual bool UserHooks::doVetoProcessLevel(Event& process)","link":"UserHooks.html#anchor9","text":"virtual bool UserHooks::doVetoProcessLevel(Event& process) can optionally be called, as described above. You can study the virtual bool UserHooks::doVetoProcessLevel(Event& process) process event record of the hard process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The virtual bool UserHooks::doVetoProcessLevel(Event& process) Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of virtual bool UserHooks::doVetoProcessLevel(Event& process) Pythia::next(). virtual bool UserHooks::doVetoProcessLevel(Event& process) Warning: Normally you should not modify the virtual bool UserHooks::doVetoProcessLevel(Event& process) process event record. However, for some matrix-element-matching procedures it may become unavoidable. If so, be very careful, since there are many pitfalls. Only to give one example: if you modify the incoming partons then also the information stored in the beam particles may need to be modified. virtual bool UserHooks::doVetoProcessLevel(Event& process) Note: the above veto is different from setting the flag virtual bool UserHooks::doVetoProcessLevel(Event& process) virtual bool UserHooks::doVetoProcessLevel(Event& process) PartonLevel:all = off. Also in the latter case the event generation will stop after the process level, but an event generated up to this point is considered perfectly acceptable. It can be studied and it contributes to the cross section. That is, virtual bool UserHooks::doVetoProcessLevel(Event& process) PartonLevel:all = off is intended for simple studies of hard processes, where one can save a lot of time by not generating the rest of the story. By contrast, the virtual bool UserHooks::doVetoProcessLevel(Event& process) doVetoProcessLevel() method allows you to throw away uninteresting events at an early stage to save time, but those events that do survive the veto are allowed to develop into complete final states (unless flags have been set otherwise)."},{"name":"virtual bool UserHooks::doVetoPT(int iPos, const Event& event)","link":"UserHooks.html#anchor16","text":"virtual bool UserHooks::doVetoPT(int iPos, const Event& event) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoPT(int iPos, const Event& event) event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The virtual bool UserHooks::doVetoPT(int iPos, const Event& event) Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of virtual bool UserHooks::doVetoPT(int iPos, const Event& event) Pythia::next(). virtual bool UserHooks::doVetoPT(int iPos, const Event& event) is the position/status when the routine is called, information that can help you decide your course of action: virtual bool UserHooks::doVetoPT(int iPos, const Event& event) when no MPI, ISR or FSR occurred above the veto scale; virtual bool UserHooks::doVetoPT(int iPos, const Event& event) when inside the interleaved MPI + ISR + FSR evolution, after an MPI process; virtual bool UserHooks::doVetoPT(int iPos, const Event& event) when inside the interleaved MPI + ISR + FSR evolution, after an ISR emission; virtual bool UserHooks::doVetoPT(int iPos, const Event& event) when inside the interleaved MPI + ISR + FSR evolution, after an FSR emission; virtual bool UserHooks::doVetoPT(int iPos, const Event& event) for the optional case where FSR is deferred from the interleaved evolution and only considered separately afterward (then alternative 3 would never occur); virtual bool UserHooks::doVetoPT(int iPos, const Event& event) is for subsequent resonance decays, and is called once for each decaying resonance in a chain such as virtual bool UserHooks::doVetoPT(int iPos, const Event& event) t &rarr; b W, W &rarr; u dbar. virtual bool UserHooks::doVetoPT(int iPos, const Event& event) the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', and also those from further multiparton interactions. This may not be desirable for comparisons with matrix-element calculations. You may want to make use of the virtual bool UserHooks::doVetoPT(int iPos, const Event& event) subEvent(...) method below to obtain a simplified event record virtual bool UserHooks::doVetoPT(int iPos, const Event& event) workEvent."},{"name":"virtual bool UserHooks::doVetoResonanceDecays(Event& process)","link":"UserHooks.html#anchor37","text":"virtual bool UserHooks::doVetoResonanceDecays(Event& process) can optionally be called, as described above. You can study the virtual bool UserHooks::doVetoResonanceDecays(Event& process) process event record of the hard process. Based on that you can decide whether to reject the sequence of resonance decays that was not already fixed by the production step of the hard process (which can vary depending on how a process has been set up, see above). If you veto, then a new resonance decay sequence is selected, but the production step remains unchanged. The cross section remains unaffected by this veto, for better or worse. virtual bool UserHooks::doVetoResonanceDecays(Event& process) Warning: Normally you should not modify the virtual bool UserHooks::doVetoResonanceDecays(Event& process) process event record. However, as an extreme measure, parts or the complete decay chain could be overwritten. If so, be very careful."},{"name":"virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event)","link":"UserHooks.html#anchor19","text":"virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) can optionally be called, as described above. You can study, but not modify, the virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) event event record of the partonic process. Based on that you can decide whether to veto the event, true, or let it continue to evolve, false. If you veto, then this event is not counted among the accepted ones, and does not contribute to the estimated cross section. The virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) Pytha::next() method will begin a completely new event, so the vetoed event will not appear in the output of virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) Pythia::next(). virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) is the position/status when the routine is called, information that can help you decide your course of action. Agrees with options 2 - 5 of the virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) doVetoPT(...) routine above, while options 0 and 1 are not relevant here. virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) is the number of ISR emissions in the hardest process so far. For resonance decays, virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) iPos = 5 , it is 0. virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) is the number of FSR emissions in the hardest process so far. For resonance decays, virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) iPos = 5 , it is the number of emissions in the currently studied system. virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) the event record contains a list of all partons generated so far, also including intermediate ones not part of the 'current final state', and also those from further multiparton interactions. This may not be desirable for comparisons with matrix-element calculations. You may want to make use of the virtual bool UserHooks::doVetoStep(int iPos,  int nISR, int nFSR, const Event& event) subEvent(...) method above to obtain a simplified event record."},{"name":"virtual bool UserHooks::initAfterBeams()","link":"UserHooks.html#anchor7","text":"virtual bool UserHooks::initAfterBeams() This routine is called by Pythia::init(), after the beams have been set up, but before any other initialisation. Therefore, at this stage, it is still possible to modify settings (apart from virtual bool UserHooks::initAfterBeams() Beams:* ) and particle data. This is mainly intended to be used in conjunction with Les Houches Event files, where headers are read in during beam initialisation, see the header functions in the virtual bool UserHooks::initAfterBeams() Info class. In the base class this method returns true. By returning false, PYTHIA initialisation will be aborted."},{"name":"virtual bool useShowerPlugin()","link":"MatchingAndMerging.html#anchor23","text":"virtual bool useShowerPlugin()"},{"name":"virtual double dampenIfFailCuts( const Event& inEvent )","link":"MatchingAndMerging.html#anchor15","text":"virtual double dampenIfFailCuts( const Event& inEvent )"},{"name":"virtual double hardProcessME( const Event& inEvent )","link":"MatchingAndMerging.html#anchor20","text":"virtual double hardProcessME( const Event& inEvent )"},{"name":"virtual double MergingHooks::dampenIfFailCuts(const Event&  event)","link":"CKKWLMerging.html#anchor26","text":"virtual double MergingHooks::dampenIfFailCuts(const Event&  event) This routine will be supplied internally with the lowest multiplicity  reclustered state as an input Event. From this input event, the user can then check if matrix element cuts are fulfilled. The return value will be internally multiplied to the CKKW-L weight of the current event. Thus, if the user wishes  to suppress contributions not passing particular cuts, a number smaller than  unity can be returned."},{"name":"virtual double MergingHooks::hardProcessME(const Event&  inEvent)","link":"CKKWLMerging.html#anchor29","text":"virtual double MergingHooks::hardProcessME(const Event&  inEvent) This routine will be supplied internally with the reconstructed lowest-multiplicity event. From this, it is possible to calculate the squared matrix element of the hard process, by using the information stored in the event record. The function should return a virtual double MergingHooks::hardProcessME(const Event&  inEvent) double value that corresponds to the matrix element at the phase space point given by the input event record. This number will then be multiplied to the product of splitting functions that define the probability of the current path of the parton shower history. In this way, the hard process configuration can be taken into account when choosing the parton shower history, which is, internally, used to generate the 'merging weight'."},{"name":"virtual double MergingHooks::tmsDefinition(const Event& event)","link":"CKKWLMerging.html#anchor18","text":"virtual double MergingHooks::tmsDefinition(const Event& event) This method will have to calculate the value of the merging scale defined in  some variable from the input event record. An example of such a function is  given in virtual double MergingHooks::tmsDefinition(const Event& event) main82.cc."},{"name":"virtual double RndmEngine::flat()","link":"RandomNumbers.html#anchor14","text":"virtual double RndmEngine::flat() if you want to construct an external random number generator (or generator interface) then you must implement this method in your class derived from the virtual double RndmEngine::flat() RndmEningen base class, to give a random number between 0 and 1."},{"name":"virtual double SpaceShower::enhancePTmax()","link":"ImplementNewShowers.html#anchor33","text":"virtual double SpaceShower::enhancePTmax() When the above method limits virtual double SpaceShower::enhancePTmax() pT_max to the scale of the process, it may still be convenient to vary the matching slightly for the hardest interaction in an event, to probe the sensitivity to such details. The base-class implementation returns the value of the virtual double SpaceShower::enhancePTmax() SpaceShower:pTmaxFudge parameter."},{"name":"virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor46","text":"virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) This function should return the probability of an emission of the particle with index virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iEmt from the particle with index virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iRad and virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iRec. All indices are relative to the input virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) event. The identifier virtual double SpaceShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility."},{"name":"virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1)","link":"ImplementNewShowers.html#anchor36","text":"virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) This is the main driver routine for the downwards evolution. A new virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) pT is to be selected based on the current information set up by the routines above, and along with that a branching parton or dipole. The virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) pTbegAll scale is the maximum scale allowed, from which the downwards evolution should be begun (usually respecting the maximum scale of each individual parton). If no emission is found above virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) pTendAll (and above the respective shower cutoff scales) then virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) 0. should be returned and no emissions will be allowed. Both scales can vary from one event to the next: if a scale has already been selected for MPI or ISR it makes no sense to look for a scale smaller than that from FSR, since it would not be able to compete, so virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) pTendAll is set correspondingly. As it happens, FSR is tried before ISR and MPI in the interleaved evolution, but this is an implementation detail that could well change. virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) Typically the implementation of this routine would be to set up a loop over all possible radiating objects (dipoles, dipole ends, ...), for each pick its possible branching scale and then pick the one with largest scale as possible winner. At this stage no branching should actually be carried out, since MPI, ISR and FSR still have to be compared to assign the winner. virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) The input virtual double SpaceShower::pTnext( Event& event,  double pTbegAll, double pTendAll, int nRadIn = -1) nRadIn provides the total number of ISR and FSR emissions already generated in the event, and so allows a special treatment for the very first emission, if desired."},{"name":"virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor25","text":"virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) This function should return the probability of an emission of the particle with index virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iEmt from the particles with index virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iRad and virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) iRec All indices are relative to the input virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) event. The identifier virtual double TimeShower::getSplittingProb( const  Event& event, int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility."},{"name":"virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false)","link":"ImplementNewShowers.html#anchor15","text":"virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) This is the main driver routine for the downwards evolution. A new virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) pT is to be selected based on the current information set up by the routines above, and along with that a branching parton or dipole. The virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) pTbegAll scale is the maximum scale allowed, from which the downwards evolution should be begun (usually respecting the maximum scale of each individual parton). If no emission is found above virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) pTendAll (and above the respective shower cutoff scales) then virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) 0. should be returned and no emissions will be allowed. Both scales can vary from one event to the next: if a scale has already been selected for MPI or ISR it makes no sense to look for a scale smaller than that from FSR, since it would not be able to compete, so virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) pTendAll is set correspondingly. As it happens, FSR is tried before ISR and MPI in the interleaved evolution, but this is an implementation detail that could well change. virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) Typically the implementation of this routine would be to set up a loop over all possible radiating objects (dipoles, dipole ends, ...), for each pick its possible branching scale and then pick the one with largest scale as possible winner. At this stage no branching should actually be carried out, since MPI, ISR and FSR still have to be compared to assign the winner. virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) The virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) isFirstTrial is virtual double TimeShower::pTnext( Event& event,  double pTbegAll, double pTendAll, bool isFirstTrial = false) true only for the very first emission, and is currently used in the global recoil option."},{"name":"virtual double tmsDefinition( const Event&  event)","link":"MatchingAndMerging.html#anchor21","text":"virtual double tmsDefinition( const Event&  event)"},{"name":"virtual double UserHooks::biasedSelectionWeight()","link":"UserHooks.html#anchor35","text":"virtual double UserHooks::biasedSelectionWeight() Returns the weight you should assign to the event, to use e.g. when you histogram results. It is the exact inverse of the weight you used to modify the phase-space sampling, a weight that must be stored in the virtual double UserHooks::biasedSelectionWeight() selBias member variable, such that this routine can return virtual double UserHooks::biasedSelectionWeight() 1/selBias. The weight is also returned by the virtual double UserHooks::biasedSelectionWeight() Info::weight() method, which may be more convenient to use."},{"name":"virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent)","link":"UserHooks.html#anchor34","text":"virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) when called this method should provide the factor by which you want to see the phase space sampling of the current event modified. Events are assigned a weight being the inverse of this, such that the integrated cross section of a process is unchanged. Note that the selection is only modifiable for normal hard processes. It does not affect the selection in further multiparton interactions, nor in elastic/diffractive/minimum-bias events. virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) : what makes this routine somewhat tricky to write is that the hard-process event has not yet been constructed, so one is restricted to use the information available in the phase-space and cross-section objects currently being accessed. Which of their  methods are applicable depends on the process, in particular the number of final-state particles. The virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) biasSelectionBy code in virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) UserHooks.cc contains explicit instructions about which methods provide meaningful information, and so offers a convenient starting point. virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) : this flag is true when the method is called from within the event-generation machinery and false when it is called at the initialization stage of the run, when the cross section is explored to find a maximum for later Monte Carlo usage. Cross-section modifications should be independent of this flag, for consistency, but if virtual double UserHooks::biasSelectionBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) biasSelectionBy(...) is used to collect statistics on the original kinematics distributions before cuts, then it is important to be able to exclude the initialization stage from comparisons."},{"name":"virtual double UserHooks::enhanceFactor( string name)","link":"UserHooks.html#anchor43","text":"virtual double UserHooks::enhanceFactor( string name) This function should return the enhancement factor for the splitting probability with identifier virtual double UserHooks::enhanceFactor( string name) name. It should return 1. by default, i.e. for all input strings it does not propose to handle. virtual double UserHooks::enhanceFactor( string name) the name of the splitting that can enhanced. Currently, the following input names are recognized by the PYTHIA showers, and can thus be used to enhance the respective splittings. virtual double UserHooks::enhanceFactor( string name) ISR QCD branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:G2GG for virtual double UserHooks::enhanceFactor( string name) g &rarr; g + g , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:G2QQ for virtual double UserHooks::enhanceFactor( string name) g &rarr; q + qbar with virtual double UserHooks::enhanceFactor( string name) q a light quark, virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:G2QQ:cc for virtual double UserHooks::enhanceFactor( string name) g &rarr; c + cbar virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:G2QQ:bb for virtual double UserHooks::enhanceFactor( string name) g &rarr; b + bbar virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:Q2QG for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + g , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:Q2GQ for virtual double UserHooks::enhanceFactor( string name) q &rarr; g + q ; virtual double UserHooks::enhanceFactor( string name) ISR QED branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:Q2QA for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + photon , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:Q2AQ for virtual double UserHooks::enhanceFactor( string name) q &rarr; photon + q ; virtual double UserHooks::enhanceFactor( string name) ISR weak shower branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) isr:Q2QW for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + W or virtual double UserHooks::enhanceFactor( string name) q &rarr; q + Z ; virtual double UserHooks::enhanceFactor( string name) FSR QCD branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:G2GG for virtual double UserHooks::enhanceFactor( string name) g &rarr; g + g , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:G2QQ for virtual double UserHooks::enhanceFactor( string name) g &rarr; q + qbar with virtual double UserHooks::enhanceFactor( string name) q a light quark, virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:G2QQ:cc for virtual double UserHooks::enhanceFactor( string name) g &rarr; c + cbar virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:G2QQ:bb for virtual double UserHooks::enhanceFactor( string name) g &rarr; b + bbar virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:Q2QG for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + g ; virtual double UserHooks::enhanceFactor( string name) FSR QED branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:Q2QA for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + photon , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:A2QQ for virtual double UserHooks::enhanceFactor( string name) photon &rarr; q + qbar , virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:A2LL for virtual double UserHooks::enhanceFactor( string name) photon &rarr; lepton + antilepton , virtual double UserHooks::enhanceFactor( string name) FSR weak shower branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:Q2QW for virtual double UserHooks::enhanceFactor( string name) q &rarr; q + W or virtual double UserHooks::enhanceFactor( string name) q &rarr; q + Z ; virtual double UserHooks::enhanceFactor( string name) FSR hidden valley branchings: virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) fsr:Q2QHV for all hidden valley branchings. virtual double UserHooks::enhanceFactor( string name) virtual double UserHooks::enhanceFactor( string name) Charge-conjugated branchings are included whenever relevant. Note that the order of the daughters matters: in the backwards evolution machinery the step is from the first daughter to the mother by the emission of the second daughter. virtual double UserHooks::enhanceFactor( string name) Let's consider some examples. The evolution step changing the partonic state from virtual double UserHooks::enhanceFactor( string name) q qbar &rarr; e+ e- to virtual double UserHooks::enhanceFactor( string name) g qbar &rarr; e+ e- qbar through an initial state splitting can be enhanced by allowing a non-unity return value for the splitting with virtual double UserHooks::enhanceFactor( string name) name equalling virtual double UserHooks::enhanceFactor( string name) isr:G2QQ. Another evolution step changing virtual double UserHooks::enhanceFactor( string name) g qbar &rarr; e+ e- qbar to virtual double UserHooks::enhanceFactor( string name) g qbar &rarr; e+ e- qbar gluon through FSR (ISR) can be enhanced by allowing a non-unity return value for the splitting with virtual double UserHooks::enhanceFactor( string name) name equalling virtual double UserHooks::enhanceFactor( string name) fsr:Q2QG ( virtual double UserHooks::enhanceFactor( string name) isr:Q2QG ). Yet another ISR branching converting virtual double UserHooks::enhanceFactor( string name) g qbar &rarr; e+ e- qbar to virtual double UserHooks::enhanceFactor( string name) q qbar &rarr; e+ e- qbar q can be enhanced by non-unity return value for the splitting with virtual double UserHooks::enhanceFactor( string name) name equalling virtual double UserHooks::enhanceFactor( string name) isr:Q2GQ (note the ordering in the branching name)."},{"name":"virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent)","link":"UserHooks.html#anchor30","text":"virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) when called this method should provide the factor by which you want to see the cross section weight of the current event modified. If you return unity then the normal cross section is obtained. Note that, unlike the methods above, these modifications do not lead to a difference between the number of 'selected' events and the number of 'accepted' ones, since the modifications occur already before the 'selected' level. The integrated cross section of a process is modified, of course. Note that the cross section is only modifiable for normal hard processes. It does not affect the cross section in further multiparton interactions, nor in elastic/diffractive/minimum-bias events. virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) : what makes this routine somewhat tricky to write is that the hard-process event has not yet been constructed, so one is restricted to use the information available in the phase-space and cross-section objects currently being accessed. Which of their  methods are applicable depends on the process, in particular the number of final-state particles. The virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) multiplySigmaBy code in virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) UserHooks.cc contains explicit instructions about which methods provide meaningful information, and so offers a convenient starting point. virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) : this flag is true when the method is called from within the event-generation machinery and false when it is called at the initialization stage of the run, when the cross section is explored to find a maximum for later Monte Carlo usage. Cross-section modifications should be independent of this flag, for consistency, but if virtual double UserHooks::multiplySigmaBy(  const SigmaProcess* sigmaProcessPtr, const PhaseSpace* phaseSpacePtr,  bool inEvent) multiplySigmaBy(...) is used to collect statistics on the original kinematics distributions before cuts, then it is important to be able to exclude the initialization stage from comparisons."},{"name":"virtual double UserHooks::scaleResonance( int iRes,  const Event& event)","link":"UserHooks.html#anchor39","text":"virtual double UserHooks::scaleResonance( int iRes,  const Event& event) can optionally be called, as described above. You should return the maximum scale, in GeV, from which the shower evolution will begin. The base class method returns 0, i.e. gives no shower evolution at all. You can study, but not modify, the virtual double UserHooks::scaleResonance( int iRes,  const Event& event) event event record of the partonic process to check which resonance is decaying, and into what. virtual double UserHooks::scaleResonance( int iRes,  const Event& event) is the location in the event record of the resonance that decayed to the particles that now will shower. virtual double UserHooks::scaleResonance( int iRes,  const Event& event) the event record contains a list of all partons generated so far, specifically the decaying resonance and its immediate decay products."},{"name":"virtual double UserHooks::scaleVetoPT()","link":"UserHooks.html#anchor15","text":"virtual double UserHooks::scaleVetoPT() In the base class this method returns 0. You should redefine it to return the virtual double UserHooks::scaleVetoPT() pT scale at which you want to study the event."},{"name":"virtual double UserHooks::vetoProbability( string name)","link":"UserHooks.html#anchor44","text":"virtual double UserHooks::vetoProbability( string name) This function should return the probability of an emission that has been enhanced with the help of virtual double UserHooks::vetoProbability( string name) enhanceFactor(...) , for the same virtual double UserHooks::vetoProbability( string name) name arguments as above. An optimal choice depends on your personal needs. Using 0.5 as a baseline is perfectly acceptable. It should return 0. by default, i.e. for all input strings it does not propose to handle."},{"name":"virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor43","text":"virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) This function should return a PYTHIA event record in which the emission of the particle with index virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) iEmt in the input virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) event (also changing the particles with index virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) iRad and virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) iRec ) is undone. virtual Event SpaceShower::clustered( const Event& event,  int iRad, int iEmt, int iRec, string name) name is a string identifier for the splitting. Such reclustered events are crucial in setting up consistent parton shower histories."},{"name":"virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor22","text":"virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) This function should return a PYTHIA event record in which the emission of the particle with index virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) iEmt in the input virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) event (also changing the particles with index virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) iRad and virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) iRec ) is undone. The identifier virtual Event TimeShower::clustered( const Event& event, int  iRad, int iEmt, int iRec, string name) name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist. Reclustered events are crucial in setting up consistent parton shower histories."},{"name":"virtual int getNumberOfClusteringSteps(const  Event& event, bool resetNjetMax = false)","link":"MatchingAndMerging.html#anchor22","text":"virtual int getNumberOfClusteringSteps(const  Event& event, bool resetNjetMax = false)"},{"name":"virtual int MyMerging::mergeProcess( Event& process)","link":"MatchingAndMerging.html#anchor7","text":"virtual int MyMerging::mergeProcess( Event& process) This function should be the main interface of Pythia to the MM plugin. Pythia will execute this function once the partonic (fixed-order) scattering has been constructed (or read from LHEF). The partonic scattering is transferred via the virtual int MyMerging::mergeProcess( Event& process) process argument. The external MM plugin should then, based on the virtual int MyMerging::mergeProcess( Event& process) process , implement the matching/merging strategy. It is permissible that this function changes virtual int MyMerging::mergeProcess( Event& process) process. In this case, Pythia will continue the event generation with the changed virtual int MyMerging::mergeProcess( Event& process) process as starting point. The return value of the function steers how Pythia should proceed after the function execution. The following return values are supported: virtual int MyMerging::mergeProcess( Event& process) -1 : Reject the event and exit the generation/processing of the current event virtual int MyMerging::mergeProcess( Event& process) 0: Reject the event but continue with the generation/processing of the current event. virtual int MyMerging::mergeProcess( Event& process) 1: Keep the event but continue with the generation/processing of the current event. virtual int MyMerging::mergeProcess( Event& process) 2: Reject the event but continue with the generation/processing of the   current event. However, re-evaluate resonance decays before any other   event generation step. This option can be necessary if the merging code   removes or changes resonant particles from virtual int MyMerging::mergeProcess( Event& process) process. Note that because this function is the main interface between the MM plugin and Pythia, it is necessary to use this function to set up all the information that you might later need (merging weights, particle counters, etc) in this call already."},{"name":"virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0)","link":"ImplementNewShowers.html#anchor7","text":"virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) This is an all-in-one call for shower evolution, and as such cannot be used for the normal interleaved evolution, where only the routines below are used. It also cannot be used in resonance decays that form part of the hard process, since there the virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) user hooks insert a potential veto step. Currently this routine is therefore only used in the hadron-level decays, e.g. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) Upsilon &rarr; g g g. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) iBeg and virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) iEnd is the position of the first and last parton of a separate system, typically produced by a resonance decay. Such a system only evolves in isolation, and in particular does not relate to the beams. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) The virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) pTmax value sets the maximum scale for evolution, but normally you would restrict that further for each individual parton based on its respective scale value. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) The virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) nBranchMax value, if positive, gives the maximum number of allowed branchings in the call, as useful for matching studies. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) The routine is expected to return the number of FSR branchings that were generated, but only for non-critical statistics purposes. virtual int TimeShower::shower( int iBeg, int iEnd,  Event& event, double pTmax, int nBranchMax = 0) Since the real action typically is delegated to the routines below, it may well be that the existing code need not be replaced."},{"name":"virtual int TimeShower::showerQED( int iBeg, int iEnd,  Event& event, double pTmax)","link":"ImplementNewShowers.html#anchor8","text":"virtual int TimeShower::showerQED( int iBeg, int iEnd,  Event& event, double pTmax) This is a further simplified version of the virtual int TimeShower::showerQED( int iBeg, int iEnd,  Event& event, double pTmax) shower method above. Currently it only handles the emission of photons in the decay of a hadron into a pair of leptons, either a charged lepton-antilepton or a lepton-neutrino pair. It is properly matched to the matrix element in the decay via a virtual photon or virtual int TimeShower::showerQED( int iBeg, int iEnd,  Event& event, double pTmax) W^+- , respectively. It is called as part of such decays if virtual int TimeShower::showerQED( int iBeg, int iEnd,  Event& event, double pTmax) ParticleDecays:allowPhotonRadiation = on , which is not the default value."},{"name":"virtual int TimeShower::showerQEDafterRemnants( Event& event)","link":"ImplementNewShowers.html#anchor9","text":"virtual int TimeShower::showerQEDafterRemnants( Event& event) Optional method to add QED showers after beam remnants have been added  but before hadronisation.  It is called from the very end of virtual int TimeShower::showerQEDafterRemnants( Event& event) PartonLevel::next() ,  after the main perturbative evolution has finished and all beam  remnants have been added."},{"name":"virtual int UserHooks::numberVetoMPIStep()","link":"UserHooks.html#anchor21","text":"virtual int UserHooks::numberVetoMPIStep() Returns the number of steps in the MPI evolution that you want to be able to study, right after each new step has been taken and the subcollision has been added to the event record. The number of steps defaults to the first one only, but you are free to pick another value. Note that the hardest interaction of an events counts as the first multiparton interaction. For most hard processes it thus at the first step offers nothing not available with the virtual int UserHooks::numberVetoMPIStep() VetoProcessLevel functionality above. For the minimum-bias and diffractive systems the hardest interaction is not selected at the process level, however, so there a check after the first multiparton interaction offers new functionality. Note that double diffraction is handled as two separate Pomeron-proton collisions, and thus has two sequences of interactions. Also, if you have set up a second hard process then a check is made after these first two, and the first interaction coming from the MPI machinery would have sequence number 3."},{"name":"virtual int UserHooks::numberVetoStep()","link":"UserHooks.html#anchor18","text":"virtual int UserHooks::numberVetoStep() Returns the number of steps virtual int UserHooks::numberVetoStep() n each of ISR and FSR, for the hardest interaction, that you want to be able to study. That is, the method will be called after the first virtual int UserHooks::numberVetoStep() n ISR emissions, irrespective of the number of FSR ones at the time, and after the first virtual int UserHooks::numberVetoStep() n FSR emissions, irrespective of the number of ISR ones. The number of steps defaults to the first one only, but you are free to pick another value. Note that double diffraction is handled as two separate Pomeron-proton collisions, and thus has two sequences of emissions."},{"name":"virtual LHAup::~LHAup()","link":"LesHouchesAccord.html#anchor2","text":"virtual LHAup::~LHAup() the destructor does not need to do anything."},{"name":"virtual map &lt;string,double&gt; SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor44","text":"virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) This function should return a map of variables related to the splitting that produced the particles virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iRad] , virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iRec] and virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iEmt]. Four entries are compulsory, virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) t gives the evolution variable associated with the splitting, virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) tRS gives the evolution variable at which the shower should be restarted after a branching, virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) scaleAS gives the argument of virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) &alpha; virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) s used for the branching, and virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) scalePDF gives the argument of PDF factors used for the branching. virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) All other entries are optional and may be auxiliary variables related to the splitting (e.g. an energy sharing variable, an azimuthal angle, kinematical invariants etc.). virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) The identifier virtual map <string,double> SpaceShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"virtual map &lt;string,double&gt; TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name)","link":"ImplementNewShowers.html#anchor23","text":"virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) This function should return a map of variables related to the splitting that produced the particles virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iRad] , virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iRec] and virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) event[iEmt]. Four entries are compulsory, virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) t gives the evolution variable associated with the splitting, virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) tRS gives the evolution variable at which the shower should be restarted after a branching, virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) scaleAS gives the argument of virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) &alpha; virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) s used for the branching, and virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) - the key virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) scalePDF gives the argument of PDF factors used for the branching. virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) All other entries are optional and may be auxiliary variables related to the splitting (e.g. an energy sharing variable, an azimuthal angle, kinematical invariants etc.). virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) The identifier virtual map <string,double> TimeShower::getStateVariables(  const Event& event, int iRad, int iEmt, int iRec, string name) name can be used for additional flexibility, e.g. if multiple kernels with identical post-branching states exist."},{"name":"virtual MergingHooks::~MergingHooks()","link":"CKKWLMerging.html#anchor17","text":"virtual MergingHooks::~MergingHooks() The constructor and destructor do not need to do anything."},{"name":"virtual Pythia8ToHepMC::~Pythia8ToHepMC()","link":"HepMCInterface.html#anchor2","text":"virtual Pythia8ToHepMC::~Pythia8ToHepMC() the constructor and destructor take no arguments."},{"name":"virtual SlowJetHook::~SlowJetHook()","link":"EventAnalysis.html#anchor67","text":"virtual SlowJetHook::~SlowJetHook() the constructor and destructor need not do anything, and if so you need not write your own destructor."},{"name":"virtual SpaceShower::~SpaceShower()","link":"ImplementNewShowers.html#anchor29","text":"virtual SpaceShower::~SpaceShower() Also the destructor does not need to do anything."},{"name":"virtual TimeShower::~TimeShower()","link":"ImplementNewShowers.html#anchor2","text":"virtual TimeShower::~TimeShower() The destructor does not need to do anything."},{"name":"virtual UserHooks::~UserHooks()","link":"UserHooks.html#anchor2","text":"virtual UserHooks::~UserHooks() The constructor and destructor do not need to do anything."},{"name":"virtual Vec4 vertexFSR( int iNow, Event& event)","link":"VertexInformation.html#anchor8","text":"virtual Vec4 vertexFSR( int iNow, Event& event) Method to assign production vertex to a particle produced in the FSR ( virtual Vec4 vertexFSR( int iNow, Event& event) TimeShower ). Should set the vertex virtual Vec4 vertexFSR( int iNow, Event& event) vProd of the particle concerned. virtual Vec4 vertexFSR( int iNow, Event& event) is the index of the parton concerned. In a branching the daughters automatically inherit the vertex of the mother, if it has one, and similarly for the recoiler. This method is called specifically for what is considered the emitted parton of the process, i.e. the gluon in a virtual Vec4 vertexFSR( int iNow, Event& event) q &rarr; q g branching, and allows the vertex of this parton to be modified. virtual Vec4 vertexFSR( int iNow, Event& event) reference to the whole event, to read information from and set the relevant virtual Vec4 vertexFSR( int iNow, Event& event) vProd values into."},{"name":"virtual Vec4 vertexISR( int iNow, Event& event)","link":"VertexInformation.html#anchor9","text":"virtual Vec4 vertexISR( int iNow, Event& event) Method to assign production vertex to a particle produced in the ISR ( virtual Vec4 vertexISR( int iNow, Event& event) SpaceShower ). Should set the vertices virtual Vec4 vertexISR( int iNow, Event& event) vProd of the particle concerned. virtual Vec4 vertexISR( int iNow, Event& event) is the index of the parton concerned. This method is called three times for each ISR branching, for the daughter, the new recoiler and the sister. virtual Vec4 vertexISR( int iNow, Event& event) reference to the whole event, to read information from and set the relevant virtual Vec4 vertexISR( int iNow, Event& event) vProd values into."},{"name":"virtual vector&lt;int&gt; SpaceShower::getRecoilers(  const Event& event, int iRad, int iEmt, string name)","link":"ImplementNewShowers.html#anchor48","text":"virtual vector<int> SpaceShower::getRecoilers(  const Event& event, int iRad, int iEmt, string name) This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the spacelike shower for all possible recoilers for a particular combination of radiator and emission. The function arguments are the virtual vector<int> SpaceShower::getRecoilers(  const Event& event, int iRad, int iEmt, string name) event which contains the radiator and emission, and the position of the radiator ( virtual vector<int> SpaceShower::getRecoilers(  const Event& event, int iRad, int iEmt, string name) iRad ) and emission ( virtual vector<int> SpaceShower::getRecoilers(  const Event& event, int iRad, int iEmt, string name) iEmt ) in said event. Since this information might not be enough to uniquely determine the list of recoilers, a further string argument that encodes e.g. the splitting name is supplied. The function should return a vector of the positions of all possible allowed recoilers in the input event."},{"name":"virtual vector&lt;int&gt;TimeShower::getRecoilers(  const Event&  event, int iRad, int iEmt, string name)","link":"ImplementNewShowers.html#anchor27","text":"virtual vector<int>TimeShower::getRecoilers(  const Event&  event, int iRad, int iEmt, string name) This function is not used in the Pythia core code, and can thus be omitted. The purpose of this function is to allow ME+PS plugins for Pythia to ask the timelike shower for all possible recoilers for a particular combination of radiator and emission. The function arguments are the virtual vector<int>TimeShower::getRecoilers(  const Event&  event, int iRad, int iEmt, string name) event which contains the radiator and emission, and the position of the radiator ( virtual vector<int>TimeShower::getRecoilers(  const Event&  event, int iRad, int iEmt, string name) iRad ) and emission ( virtual vector<int>TimeShower::getRecoilers(  const Event&  event, int iRad, int iEmt, string name) iEmt ) in said event. Since this information might not be enough to uniquely determine the list of recoilers, a further string argument that encodes e.g. the splitting name is supplied. The function should return a vector of the positions of all possible allowed recoilers in the input event."},{"name":"virtual vector&lt;string&gt; SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec)","link":"ImplementNewShowers.html#anchor45","text":"virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) This function should return a string identifier of the splitting producing the particles with indices virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) iRad , virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) iEmt and virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) iRec in the input virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) event. If e.g. virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) iRad is the index of an intial state quark and virtual vector<string> SpaceShower::getSplittingName(  const Event& event, int iRad, int iEmt, int iRec) iEmt the index of a final state gluon, we could imagine returning the string 'isr:Q2QG' (which is the name of such a branching in PYTHIA's UserHooks facilities). The return value is a vector to allow for multiple string identifiers, e.g. if multiple splittings lead to identical final states."},{"name":"virtual vector&lt;string&gt; TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec)","link":"ImplementNewShowers.html#anchor24","text":"virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) This function should return a vector of string identifiers of the splitting producing the particles with indices virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) iRad , virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) iEmt and virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) iRec in the input virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) event. If e.g. virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) iRad is the index of a final state quark and virtual vector<string> TimeShower::getSplittingName( const  Event& event, int iRad, int iEmt, int iRec) iEmt the index of a final state antiquark, we could imagine returning the string 'fsr:G2QQ' (which is the name of such a branching in PYTHIA's UserHooks facilities). The return value is a vector to allow for multiple string identifiers, e.g. if multiple splittings lead to identical final states."},{"name":"virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn)","link":"BeamShape.html#anchor3","text":"virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn) the base-class method simply reads in the relevant values stored in the virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn) Settings data base, and saves a pointer to the random-number generator. You are free to write your own derived initialization routine, or use the existing one. In the latter case you can then give your own modified interpretation to the beam spread parameters defined there. virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn) The two flags virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn) Beams:allowMomentumSpread and virtual void BeamShape::init( Settings& settings,  Rndm* rndmPtrIn) Beams:allowVertexSpread should not be tampered with, however. These are checked elsewhere to determine whether the beam shape should be set or not, whereas the other momentum-spread and vertex-spread parameters are local to this class."},{"name":"virtual void BeamShape::pick()","link":"BeamShape.html#anchor4","text":"virtual void BeamShape::pick() this method is the key one to supply in the derived class. Here you are free to pick whatever parametrization you desire for beam momenta and vertex position, including correlations between the two. At the end of the day, you should set a few protected virtual void BeamShape::pick() double numbers: virtual void BeamShape::pick() virtual void BeamShape::pick() deltaPxA, deltaPyA, deltaPzA for the three-momentum shift of the first incoming beam, relative to the nominal values; virtual void BeamShape::pick() virtual void BeamShape::pick() deltaPxB, deltaPyB, deltaPzB for the three-momentum shift of the second incoming beam, relative to the nominal values; virtual void BeamShape::pick() virtual void BeamShape::pick() vertexX, vertexY, vertexZ, vertexT for the production-vertex position and time. virtual void BeamShape::pick() As usual, momentum is given in GeV, and space and time in mm, with virtual void BeamShape::pick() c = 1."},{"name":"virtual void init()","link":"VertexInformation.html#anchor6","text":"virtual void init() can be used to initialize various parameters of the model or precalculate common numbers. Note that a separate non-virtual method will already have provided pointers to the virtual void init() Info , virtual void init() Settings and virtual void init() Rndm classes, so that these are available in all derived classes."},{"name":"virtual void MyHardProcess::initOnProcess( string process,  ParticleData* particleData)","link":"MatchingAndMerging.html#anchor25","text":"virtual void MyHardProcess::initOnProcess( string process,  ParticleData* particleData) This function can be used to initialize the instance of your HardProcess class. In the internal Pythia implementation, this acts as a wrapper around the next function."},{"name":"virtual void MyHardProcess::storeCandidates( const Event& event,  string process)","link":"MatchingAndMerging.html#anchor27","text":"virtual void MyHardProcess::storeCandidates( const Event& event,  string process) This function studies the input event and book-keeps the particles that may be considered as part of the core scattering process. For this, it may use the four next functions."},{"name":"virtual void MyHardProcess::translateProcessString( string  process)","link":"MatchingAndMerging.html#anchor26","text":"virtual void MyHardProcess::translateProcessString( string  process) This function will use the string argument to set up the hard process bookkeeping, e.g. how many incoming/outgoing particles of which flavour are contained in the core (lowest multiplicity) scattering process."},{"name":"virtual void MyMerging::init()","link":"MatchingAndMerging.html#anchor5","text":"virtual void MyMerging::init() A method that is used to initialize your merging class. Pythia will call this function during its initialization and after all pointers to internal classes (e.g. to instances of the virtual void MyMerging::init() Info and virtual void MyMerging::init() ParticleData classes) have been set up."},{"name":"virtual void MyMerging::statistics()","link":"MatchingAndMerging.html#anchor6","text":"virtual void MyMerging::statistics() This function can be used to collect and print merging information at the end of the event generation. Pythia will call this function in the execution of a virtual void MyMerging::statistics() Pythia::stat() call."},{"name":"virtual void MyMergingHooks::init()","link":"MatchingAndMerging.html#anchor9","text":"virtual void MyMergingHooks::init() A method that is used to initialize your virtual void MyMergingHooks::init() MyMergingHooks class. Pythia will call this function during its initialization and after all pointers to internal classes (e.g. to instances of the virtual void MyMergingHooks::init() Info and virtual void MyMergingHooks::init() ParticleData classes) have been set up."},{"name":"virtual void SpaceShower::init(BeamParticle* beamAPtrIn,  BeamParticle* beamBPtrIn)","link":"ImplementNewShowers.html#anchor31","text":"virtual void SpaceShower::init(BeamParticle* beamAPtrIn,  BeamParticle* beamBPtrIn) You have to store your local copy of the pointers to these objects, since they have to be used during the generation, as explained above. This is also the place to do initialization of whatever parameters you plan to use, e.g. by reading in them from a user-accessible database like the virtual void SpaceShower::init(BeamParticle* beamAPtrIn,  BeamParticle* beamBPtrIn) Settings one."},{"name":"virtual void SpaceShower::list()","link":"ImplementNewShowers.html#anchor41","text":"virtual void SpaceShower::list() This method is not at all required. In the current implementation it outputs a list of all the dipole ends, with information on the respective dipole. The routine is not called anywhere in the public code, but has been inserted at various places during the development/debug phase."},{"name":"virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true)","link":"ImplementNewShowers.html#anchor34","text":"virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true) This method is called immediately after a new interaction has been added, and should then be used to prepare the subsystem of partons for subsequent evolution. In the current code this involves identifying the colour and charge dipole ends: the position of radiating and recoiling partons, maximum virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true) pT scales, and possible higher-order matrix elements matchings to apply. Depending on what you have in mind you may choose to store slightly different quantities. You have to use the subsystem information described above to find the positions of the two incoming partons (and the outgoing ones) of the system, and from there the scales at which they were produced. virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true) The virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true) limitPTmax input agrees with the output of the previous method for the hardest process, and is always true for subsequent MPI, since there an unlimited virtual void SpaceShower::prepare( int iSys,  Event& event, bool limitPTmaxIn = true) pT for sure would lead to double-counting."},{"name":"virtual void SpaceShower::update( int iSys, Event& event,  bool hasWeakRad = false)","link":"ImplementNewShowers.html#anchor35","text":"virtual void SpaceShower::update( int iSys, Event& event,  bool hasWeakRad = false) This method is called immediately after a timelike branching in the virtual void SpaceShower::update( int iSys, Event& event,  bool hasWeakRad = false) iSys 'th subsystem. Thus the information for that system may be out-of-date, and to be updated. For the standard PYTHIA showers this routine does not need to do anything, but that may be different in another implementation. The optional final argument is used to signal if a weak radiation has occured in the timelike evolution, which might be used to switch off the spacelike weak emissions."},{"name":"virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0)","link":"ImplementNewShowers.html#anchor4","text":"virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0) You have to store your local copy of the pointers to these objects, since they have to be used during the generation, as explained above. The pointers could be zero; e.g. a local copy of virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0) TimeShower is created to handle showers in decays such as virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0) Upsilon &rarr; q qbar from inside the virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0) ParticleDecays class. This is also the place to do initialization of whatever parameters you plan to use, e.g. by reading in them from a user-accessible database like the virtual void TimeShower::init( BeamParticle* beamAPtrIn = 0,  BeamParticle* beamBPtrIn = 0) Settings one."},{"name":"virtual void TimeShower::list()","link":"ImplementNewShowers.html#anchor20","text":"virtual void TimeShower::list() This method is not at all required. In the current implementation it outputs a list of all the dipole ends, with information on the respective dipole. The routine is not called anywhere in the public code, but has been inserted at various places during the development/debug phase."},{"name":"virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true)","link":"ImplementNewShowers.html#anchor12","text":"virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) This method is called immediately after a new interaction (or the products of a resonance decay) has been added, and should then be used to prepare the subsystem of partons for subsequent evolution. In the current code this involves identifying all colour and charge dipole ends: the position of radiating and recoiling partons, maximum virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) pT scales, possible higher-order matrix elements matchings to apply, and so on. virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) The virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) iSys parameter specifies which parton system is to be prepared. It is used to extract the set of partons to be treated, with rules as described in the above section on subsystems. Specifically, the first two partons represent the incoming state, or are 0 for resonance decays unrelated to the beams, while the rest are not required to be in any particular order. virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) The virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) limitPTmaxIn switch conveys the choice made on maximum scale for the dipole-ends evolution associated with the hard interaction of the event (while scales for subsequent MPIs by default are set to respect virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) pT ordering). If virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) true then this scale is set by the user choice options, see the virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) TimeShower::limitPTmax method above, while if virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) false emissions are allowed to go up to the kinematical limit. For the two-hard-interactions scenario, the two class variables virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) dopTlimit1 and virtual void TimeShower::prepare( int iSys, Event& event,  bool limitPTmaxIn = true) dopTlimit2 instead convey the choice made."},{"name":"virtual void TimeShower::prepareGlobal( Event& event)","link":"ImplementNewShowers.html#anchor11","text":"virtual void TimeShower::prepareGlobal( Event& event) This method resets some counters and extracts the locations of outgoing partons, in preparation of using the optional global recoil scheme. Unlike virtual void TimeShower::prepareGlobal( Event& event) prepare(...) below it is only called once during the parton-level evolution, since it only relates to the hardest interaction. Is probably of no use to most people."},{"name":"virtual void TimeShower::rescatterUpdate( int iSys,  Event& event)","link":"ImplementNewShowers.html#anchor13","text":"virtual void TimeShower::rescatterUpdate( int iSys,  Event& event) This method is called immediately after rescattering in the description of multiparton interactions. Thus the information on one or several systems is out-of-date, while that of the others is unchanged. We do not provide the details here, since we presume few implementors of new showers will want to touch the technicalities involved in obtaining a description of rescattering."},{"name":"virtual void TimeShower::update( int iSys, Event& event,  bool hasWeakRad = false)","link":"ImplementNewShowers.html#anchor14","text":"virtual void TimeShower::update( int iSys, Event& event,  bool hasWeakRad = false) This method is called immediately after a spacelike branching in the virtual void TimeShower::update( int iSys, Event& event,  bool hasWeakRad = false) iSys 'th subsystem. Thus the information for that system is out-of-date, while that of the others is unchanged. If you want, you are free to throw away all information for the affected subsystem and call virtual void TimeShower::update( int iSys, Event& event,  bool hasWeakRad = false) prepare( iSys, event) to create new one. Alternatively you may choose only to update the information that has changed. The optional final argument is used to signal if a weak radiation has occured in the spacelike evolution, which might be used to switch off the timelike weak emissions."},{"name":"virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event)","link":"VertexInformation.html#anchor7","text":"virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) Method to assign a production vertex to a particle produced in the MPI framework. Should set the vertices virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) vProd of the particles concerned. virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) is the index of the first parton of a MPI. virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) is the number of partons involved in the MPI, currently always four: two in and two out. virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) is the impact parameter of the event. It is not expressed in physical units (like fm), but rescaled such that the average is unity for MPI events. See the section on virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) Multiparton Interactions for a description of choices for the virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) b dependence. virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) reference to the whole event, to read information from and set the relevant virtual void vertexMPI( int iBeg, int nAdd, double bNow,  Event& event) vProd values into."},{"name":"virtual ~MyHardProcess()","link":"MatchingAndMerging.html#anchor24","text":"virtual ~MyHardProcess() A destructor for your HardProcess class. If not defined, the base class's empty destructor will be used."},{"name":"virtual ~MyMerging()","link":"MatchingAndMerging.html#anchor4","text":"virtual ~MyMerging() A destructor for your ME+PS class. If not defined, the base class's empty destructor will be used."},{"name":"virtual ~MyMergingHooks()","link":"MatchingAndMerging.html#anchor8","text":"virtual ~MyMergingHooks() A destructor for your MergingHooks class. If not defined, the base class's empty destructor will be used."},{"name":"void AlpgenPar::void printParams()","link":"AlpgenEventInterface.html#anchor14","text":"void AlpgenPar::void printParams() Method to print a list of stored parameters."},{"name":"void CellJet::list()","link":"EventAnalysis.html#anchor40","text":"void CellJet::list() provides a listing of the above information (except void CellJet::list() pMassless , for reasons of space)."},{"name":"void ClusterJet::list()","link":"EventAnalysis.html#anchor24","text":"void ClusterJet::list() provides a listing of the reconstructed jets."},{"name":"void CoupSM::init(Settings& settings, Rndm* rndmPtr)","link":"StandardModelParameters.html#anchor17","text":"void CoupSM::init(Settings& settings, Rndm* rndmPtr) this is where the void CoupSM::init(Settings& settings, Rndm* rndmPtr) AlphaStrong and void CoupSM::init(Settings& settings, Rndm* rndmPtr) AlphaEM instances are initialized, and weak couplings and the quark mixing matrix are read in and set. This is based on the values stored on this page and among the void CoupSM::init(Settings& settings, Rndm* rndmPtr) Couplings and Scales. Internal."},{"name":"void DecayChannel::bRatio(double bRatio,  bool countAsChanged = true)","link":"ParticleDataScheme.html#anchor175","text":"void DecayChannel::bRatio(double bRatio,  bool countAsChanged = true)"},{"name":"void DecayChannel::currentBR(double currentBR)","link":"ParticleDataScheme.html#anchor189","text":"void DecayChannel::currentBR(double currentBR)"},{"name":"void DecayChannel::meMode(int meMode)","link":"ParticleDataScheme.html#anchor178","text":"void DecayChannel::meMode(int meMode)"},{"name":"void DecayChannel::multiplicity(int multiplicity)","link":"ParticleDataScheme.html#anchor180","text":"void DecayChannel::multiplicity(int multiplicity)"},{"name":"void DecayChannel::onMode(int onMode)","link":"ParticleDataScheme.html#anchor173","text":"void DecayChannel::onMode(int onMode)"},{"name":"void DecayChannel::onShellWidth(double onShellWidth)","link":"ParticleDataScheme.html#anchor191","text":"void DecayChannel::onShellWidth(double onShellWidth)"},{"name":"void DecayChannel::onShellWidthFactor(double factor)","link":"ParticleDataScheme.html#anchor193","text":"void DecayChannel::onShellWidthFactor(double factor) multiply the current partial width by void DecayChannel::onShellWidthFactor(double factor) factor."},{"name":"void DecayChannel::openSec(int idSgn, double openSecIn)","link":"ParticleDataScheme.html#anchor194","text":"void DecayChannel::openSec(int idSgn, double openSecIn)"},{"name":"void DecayChannel::product(int i, int product)","link":"ParticleDataScheme.html#anchor182","text":"void DecayChannel::product(int i, int product)"},{"name":"void DecayChannel::rescaleBR(double fac)","link":"ParticleDataScheme.html#anchor177","text":"void DecayChannel::rescaleBR(double fac) multiply the current branching ratio by void DecayChannel::rescaleBR(double fac) fac."},{"name":"void DecayChannel::setHasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor184","text":"void DecayChannel::setHasChanged(bool hasChanged)"},{"name":"void Event::bst(const Vec4& vec)","link":"EventRecord.html#anchor42","text":"void Event::bst(const Vec4& vec) boost all particles in the event by this three-vector. Optionally you may provide the void Event::bst(const Vec4& vec) gamma value as a fourth argument, which may help avoid roundoff errors for big boosts. You may alternatively supply a void Event::bst(const Vec4& vec) Vec4 four-vector, in which case the boost vector becomes void Event::bst(const Vec4& vec) beta = p/E."},{"name":"void Event::bst(double betaX, double betaY,  double betaZ, double gamma)","link":"EventRecord.html#anchor41","text":"void Event::bst(double betaX, double betaY,  double betaZ, double gamma)"},{"name":"void Event::bst(double betaX, double betaY, double betaZ)","link":"EventRecord.html#anchor40","text":"void Event::bst(double betaX, double betaY, double betaZ)"},{"name":"void Event::clear()","link":"EventRecord.html#anchor20","text":"void Event::clear() empties event record. Specifically the void Event::clear() Particle vector size is reset to zero."},{"name":"void Event::free()","link":"EventRecord.html#anchor21","text":"void Event::free() empties event record, like void Event::free() clear() above, but also frees up the memory of the void Event::free() Particle vector."},{"name":"void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100)","link":"EventRecord.html#anchor19","text":"void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) initializes colour, the pointer to the particle database, and the header specification used for the event listing. We remind that a void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) Pythia object contains two event records void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) process and void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) event. Thus one may e.g. call either void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) pythia.process.list() or void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) pythia.event.list(). To distinguish those two rapidly at visual inspection, the void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) 'Pythia Event Listing' header is printed out differently, in one case adding void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) '(hard process)' and in the other void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) '(complete event)'. When void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) += is used to append an event, the modified event is printed with void Event::init(string headerIn = &quot;&quot;,  ParticleData* particleDataPtrIn = 0, int startColTagIn = 100) '(combination of several events)' as a reminder."},{"name":"void Event::initColTag(int colTag = 0)","link":"EventRecord.html#anchor13","text":"void Event::initColTag(int colTag = 0) forces the current colour tag value to be the larger of the input void Event::initColTag(int colTag = 0) colTag and the above void Event::initColTag(int colTag = 0) Event:startColTag values."},{"name":"void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3)","link":"EventRecord.html#anchor7","text":"void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) Provide a listing of the whole event, i.e. of the void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) vector<Particle>. The basic identity code, status, mother, daughter, colour, four-momentum and mass data are always given, but the methods can also be called with a few optional arguments for further information: void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) optionally give a second line for each particle, with the production scale (in GeV), the particle polarization (dimensionless), the production vertex (in mm or mm/c) and the invariant lifetime (also in mm/c). void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) gives a list of all daughters and mothers of a particle, as defined by the void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) motherList(i) and void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) daughterList(i) methods described below. It is mainly intended for debug purposes. void Event::list(bool showScaleAndVertex = false,  bool showMothersAndDaughters = false, int precision = 3) the number of digits to the right of the decimal point shown for momenta, energies andf masses. Can be set above 3, but reducing it below 3 will have no effect. This option is intended for expert users, e.g. for debugging purposes, and so no effort has been made to stretch header and footer to match."},{"name":"void Event::popBack(int n = 1)","link":"EventRecord.html#anchor23","text":"void Event::popBack(int n = 1) removes the last void Event::popBack(int n = 1) n particle entries; must be a positive number. History (and other) information of remaning entries is untouched, and so may be internally inconsistent."},{"name":"void Event::remove(int iFirst, int iLast,  bool shiftHistory = true)","link":"EventRecord.html#anchor24","text":"void Event::remove(int iFirst, int iLast,  bool shiftHistory = true) removes particles in the range between indices void Event::remove(int iFirst, int iLast,  bool shiftHistory = true) iFirst and void Event::remove(int iFirst, int iLast,  bool shiftHistory = true) iLast , including the endpoints. By default all mother and daughter indices above the removed range are shifted down by the number of removed entries, while indices in the removed range are put zero. Optionally these shifts can be omitted. Other information remains unchanged, which may lead to inconsistencies. If the decay products of a particle are removed, e.g., the mother particle status should be set positive, cf. void Event::remove(int iFirst, int iLast,  bool shiftHistory = true) Particle::undoDecay()."},{"name":"void Event::reset()","link":"EventRecord.html#anchor22","text":"void Event::reset() empties the event record, as void Event::reset() clear() above, but then fills the zero entry of the void Event::reset() Particle vector with the pseudoparticle used to represent the event as a whole. At this point the pseudoparticle is not assigned any momentum or mass."},{"name":"void Event::restorePtrs()","link":"EventRecord.html#anchor32","text":"void Event::restorePtrs() each particle in the event record has a pointer to the event itself and another to the particle species it belongs to. The latter pointer is automatically set/changed whenever the particle identity is set/changed by one of the normal methods. Of course the pointer values are specific to the memory locations of the current run, and so it has no sense to save them if events are written to file. Should you use some persistency scheme that bypasses the normal methods when the event is read back in, you can use void Event::restorePtrs() restorePtrs() afterwards to set these pointers appropriately."},{"name":"void Event::rot(double theta, double phi)","link":"EventRecord.html#anchor39","text":"void Event::rot(double theta, double phi) rotate all particles in the event by this polar and azimuthal angle (expressed in radians)."},{"name":"void Event::rotbst(const RotBstMatrix& M,  bool boostVertices = true)","link":"EventRecord.html#anchor43","text":"void Event::rotbst(const RotBstMatrix& M,  bool boostVertices = true) rotate and boost by the combined action encoded in the void Event::rotbst(const RotBstMatrix& M,  bool boostVertices = true) void Event::rotbst(const RotBstMatrix& M,  bool boostVertices = true) RotBstMatrix M. If the optional second argument is false only the four-momenta are boosted, and not the production vertices."},{"name":"void Event::scale( double scaleIn)","link":"EventRecord.html#anchor8","text":"void Event::scale( double scaleIn)"},{"name":"void Event::scaleSecond( double scaleSecondIn)","link":"EventRecord.html#anchor10","text":"void Event::scaleSecond( double scaleSecondIn)"},{"name":"void Hist::book(string title, int numberOfBins,  double xMin, double xMax, bool logXIn = false)","link":"Histograms.html#anchor6","text":"void Hist::book(string title, int numberOfBins,  double xMin, double xMax, bool logXIn = false) define a histogram that previously was only declared; see above for the meaning of the arguments."},{"name":"void Hist::fill(double xValue, double weight)","link":"Histograms.html#anchor9","text":"void Hist::fill(double xValue, double weight) fill the histogram, where void Hist::fill(double xValue, double weight) is the void Hist::fill(double xValue, double weight) x position where the filling should occur, and void Hist::fill(double xValue, double weight) is the amount of weight to be added at this void Hist::fill(double xValue, double weight) x value."},{"name":"void Hist::null()","link":"Histograms.html#anchor8","text":"void Hist::null() reset bin contents, but keep other histogram properties unchanged."},{"name":"void Hist::pyplotTable(ostream&amp; os = cout,  bool isHist = true)","link":"Histograms.html#anchor15","text":"void Hist::pyplotTable(ostream&amp; os = cout,  bool isHist = true)"},{"name":"void Hist::rivetTable(ostream&amp; os = cout,  bool printError = false)","link":"Histograms.html#anchor13","text":"void Hist::rivetTable(ostream&amp; os = cout,  bool printError = false)"},{"name":"void Hist::rivetTable(string fileName,  bool printError = false)","link":"Histograms.html#anchor14","text":"void Hist::rivetTable(string fileName,  bool printError = false) print a five-column table, where the first two columns give the lower and upper borders of each bin, the third one the bin contents, and the fourth and fifth the error (up and down) associated with the contents. This format matches the one that Rivet uses for its histograms. The choice between the two methods is the same as above for the void Hist::rivetTable(string fileName,  bool printError = false) table methods. void Hist::rivetTable(string fileName,  bool printError = false) The error bins are put to zero by default, since the PYTHIA histogramming is not sophisticated enough to compensate for rescalings or other operations, or for weighted events. With the optional void Hist::rivetTable(string fileName,  bool printError = false) printError = true the error will be taken as the square root of the bin content, as is relevant if this content has the same unit weight for each entry to it."},{"name":"void Hist::table(ostream&amp; os = cout,  bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor11","text":"void Hist::table(ostream&amp; os = cout,  bool printOverUnder = false, bool xMidBin = true)"},{"name":"void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true)","link":"Histograms.html#anchor12","text":"void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) print a two-column table, where the first column gives the center of each bin and the second one the corresponding bin contents. The table may be useful for plotting e.g. with Gnuplot. void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) The desired output stream or file name can be provided as argument. The former is more flexible (e.g., it allows easy append to an existing file), whereas the latter is simpler for the case that each histogram should be a file of its own. void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) An optional void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) printOverUnder = true argument allows also underflow and overflow contents to be printed. (The arbitrary void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) x coordinates for these are placed as if corresponding to same-size bins just below or above the regular histogram bins.) void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) An optional void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) xMidBin = false argument will have the void Hist::table(string fileName,  bool printOverUnder = false, bool xMidBin = true) x value at the beginning of each bin printed, rather than the default midpoint value."},{"name":"void Hist::takeLog(bool tenLog = true)","link":"Histograms.html#anchor25","text":"void Hist::takeLog(bool tenLog = true) by default take 10-logarithm of current contents bin by bin. With optional argument void Hist::takeLog(bool tenLog = true) false instead take void Hist::takeLog(bool tenLog = true) e -logarithm of contents bin by bin. If to be used, then right before the histogram is output."},{"name":"void Hist::takeSqrt()","link":"Histograms.html#anchor26","text":"void Hist::takeSqrt() take square root of current contents bin by bin, with negative contents set to zero."},{"name":"void Hist::title(string title)","link":"Histograms.html#anchor7","text":"void Hist::title(string title) change the title of a histogram, but keep other properties unchanged."},{"name":"void Hist:pyplotTable(string fileName,  bool isHist = true)","link":"Histograms.html#anchor16","text":"void Hist:pyplotTable(string fileName,  bool isHist = true) prints either a two- or a three-column table, depending on whether the contents are to be plotted as a curve or as a histogram, the latter being default. In either case the first column gives the center of each bin and the second one the corresponding bin contents. For a histogram the third column gives the lower border of each bin. Then also a final line is provided, that gives no further histogram contents but provides the upper border of the last bin. This format is used for plotting with Pyplot, see below. The choice between the two methods is the same as above for the void Hist:pyplotTable(string fileName,  bool isHist = true) table methods."},{"name":"void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;)","link":"Histograms.html#anchor50","text":"void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;) add a histogram to the current plot frame, where void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;) is the name of the histogram to be plotted, void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;) tells how the histogram data will be represented in the figure, where default 'h' is histogram style, '-' full lines, '--' dashed ones, '-.' dash-dotted ones, '.' points, 'o' circles, '+' and 'x' crosses, '*' stars, and so on as described in the Pyplot manual; additionally a colour may also be specified as described earlier, separated by a comma from the symbol; either of both can be used, e.g. 'h,r', ',magenta', '+,', '--' or just ''; and void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;) is the text written in association with the plotting symbol, where the default void HistPlot::add(const Hist& hist,  string style = &quot;h&quot;, string legend = &quot;void&quot;) void is replaced by the title provided when the histogram was booked, and LaTex input may be used as described in the note above."},{"name":"void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;)","link":"Histograms.html#anchor49","text":"void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) command to open a frame where successive histograms can be added and plotted, where void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) is the frame that will become a PFD file void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) frameName.pdf when the Python program is run; if left blank the frame will be appended to the most recent previous  PDF file, so clearly it cannot be left blank for the first call, void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) is an optional title of the histogram, plotted on top of the frame, void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) is an optional label plotted below the void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) x axis, and void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) is an optional label plotted to the right of the void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) y axis. void HistPlot::frame( string frameName, string title =  &quot;&quot;, string xLabel = &quot;&quot;, string yLabel = &quot;&quot;) Note: the title and labels may contain special LaTeX symbols, e.g. simple math formulae enclosed by dollar signs $...$, that are interpreted by the Pyplot package. A backslash \ needs to be doubled to \\, however, since else it will be intepreted as an escape sequence."},{"name":"void HistPlot::plot( bool logY = false)","link":"Histograms.html#anchor51","text":"void HistPlot::plot( bool logY = false) write the Pyplot commands for the current frame, as defined by the input from the two methods above, and additionally write the data files needed when the Python code is to be run. void HistPlot::plot( bool logY = false) By default a linear void HistPlot::plot( bool logY = false) y scale is used, but when true the void HistPlot::plot( bool logY = false) y scale is instead logarithmic, except that a linear scale is used the very last step to zero bin content. void HistPlot::plot( bool logY = false) Note: whether the void HistPlot::plot( bool logY = false) x scale is linear or logarithmic depends on what choice was made when the histogram was booked, and cannot be changed later."},{"name":"void HistPlot::plotFrame( string frameName, const Hist& hist,  string title = &quot;&quot;, string xLabel = &quot;&quot;, string yLabel =  &quot;&quot;, string style = &quot;h&quot;, string legend = &quot;void&quot;,  bool logY = false)","link":"Histograms.html#anchor52","text":"void HistPlot::plotFrame( string frameName, const Hist& hist,  string title = &quot;&quot;, string xLabel = &quot;&quot;, string yLabel =  &quot;&quot;, string style = &quot;h&quot;, string legend = &quot;void&quot;,  bool logY = false) is an omnibus version combining the three above methods when only a single histogram is to be plotted in a frame. The arguments and their meaning is the same as already explained for them, and the order in which they appear is almost the same, the exception being that the two compulsory arguments void HistPlot::plotFrame( string frameName, const Hist& hist,  string title = &quot;&quot;, string xLabel = &quot;&quot;, string yLabel =  &quot;&quot;, string style = &quot;h&quot;, string legend = &quot;void&quot;,  bool logY = false) frameName and void HistPlot::plotFrame( string frameName, const Hist& hist,  string title = &quot;&quot;, string xLabel = &quot;&quot;, string yLabel =  &quot;&quot;, string style = &quot;h&quot;, string legend = &quot;void&quot;,  bool logY = false) hist have been put at the beginning."},{"name":"void Info::addCounter(int i, int value = 0)","link":"EventInformation.html#anchor107","text":"void Info::addCounter(int i, int value = 0) increase the above counters by a given amount. Only to be used by you for the unassigned counters 40 - 49. void Info::addCounter(int i, int value = 0) the counter number, see above. void Info::addCounter(int i, int value = 0) increase the counter by this amount; normally the default value is what you want."},{"name":"void Info::hasHistory(bool hasHistoryIn)","link":"EventInformation.html#anchor108","text":"void Info::hasHistory(bool hasHistoryIn)"},{"name":"void Info::list()","link":"EventInformation.html#anchor1","text":"void Info::list() a listing of most of the information set for the current event."},{"name":"void Info::pT2NowISR(bool pT2NowIn)","link":"EventInformation.html#anchor112","text":"void Info::pT2NowISR(bool pT2NowIn)"},{"name":"void Info::setCounter(int i, int value = 0)","link":"EventInformation.html#anchor106","text":"void Info::setCounter(int i, int value = 0) set the above counters to a given value. Only to be used by you for the unassigned counters 40 - 49. void Info::setCounter(int i, int value = 0) the counter number, see above. void Info::setCounter(int i, int value = 0) set the counter to this number; normally the default value is what you want."},{"name":"void Info::setHeader(string key, string val)","link":"EventInformation.html#anchor132","text":"void Info::setHeader(string key, string val) set the header named void Info::setHeader(string key, string val) key with the contents of void Info::setHeader(string key, string val) val"},{"name":"void Info::zNowISR(bool zNowIn)","link":"EventInformation.html#anchor110","text":"void Info::zNowISR(bool zNowIn)"},{"name":"void LHAup::addParticle( int id, int status, int mother1,  int mother2, int colourTag1, int colourTag2, double p_x, double p_y,  double p_z, double e, double m, double tau, double spin, double scale)","link":"LesHouchesAccord.html#anchor32","text":"void LHAup::addParticle( int id, int status, int mother1,  int mother2, int colourTag1, int colourTag2, double p_x, double p_y,  double p_z, double e, double m, double tau, double spin, double scale) gives the properties of the next particle handed in (cf. void LHAup::addParticle( int id, int status, int mother1,  int mother2, int colourTag1, int colourTag2, double p_x, double p_y,  double p_z, double e, double m, double tau, double spin, double scale) IDUP, ISTUP, MOTHUP(1,..), MOTHUP(2,..), ICOLUP(1,..), ICOLUP(2,..),  PUP(J,..), VTIMUP, SPINUP ; while void LHAup::addParticle( int id, int status, int mother1,  int mother2, int colourTag1, int colourTag2, double p_x, double p_y,  double p_z, double e, double m, double tau, double spin, double scale) scale is a new optional property, see further below)."},{"name":"void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax)","link":"LesHouchesAccord.html#anchor8","text":"void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax) sets info on an allowed process (cf. void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax) LPRUP, XSECUP, XERRUP, XMAXUP ). Each new call will append one more entry to the list of processes. The choice of strategy determines which quantities are mandatory: void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax) xSec for strategies +-2 and +-3, void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax) xErr never, and void LHAup::addProcess( int idProcess, double xSec,  double xErr, double xMax) xMax for strategies +-1 and +-2."},{"name":"void LHAup::closeFile(istream *&is, ifstream &ifs)","link":"LesHouchesAccord.html#anchor83","text":"void LHAup::closeFile(istream *&is, ifstream &ifs) open and close a file, also gzip files, where an intermediate decompression layer is needed."},{"name":"void LHAup::listEvent()","link":"LesHouchesAccord.html#anchor67","text":"void LHAup::listEvent() prints the above information for the current event.  In cases where the void LHAup::listEvent() LHAup object is not available to the user, the void LHAup::listEvent() Pythia::LHAeventList() method can be used, which is a wrapper for the above."},{"name":"void LHAup::listInit()","link":"LesHouchesAccord.html#anchor29","text":"void LHAup::listInit() prints the above initialization information. This method is automatically called from void LHAup::listInit() Pythia::init() , so would normally not need to be called directly by the user."},{"name":"void LHAup::setBeamA( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0)","link":"LesHouchesAccord.html#anchor5","text":"void LHAup::setBeamA( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0)"},{"name":"void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0)","link":"LesHouchesAccord.html#anchor6","text":"void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0) sets the properties of the first and second incoming beam, respectively (cf. the Fortran void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0) IDBMUP(1), EBMUP(i), PDFGUP(i), PDFSUP(i) , with void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0) i 1 or 2). These numbers can be used to tell which PDF sets were used when the hard process was generated, while the normal void LHAup::setBeamB( int identity, double energy,  int pdfGroup = 0, int pdfSet = 0) PDF Selection is used for the further event generation in PYTHIA."},{"name":"void LHAup::setIdX(int id1, int id2, double x1, double x2)","link":"LesHouchesAccord.html#anchor53","text":"void LHAup::setIdX(int id1, int id2, double x1, double x2)"},{"name":"void LHAup::setInfoHeader(const string &key,  const string &val)","link":"LesHouchesAccord.html#anchor80","text":"void LHAup::setInfoHeader(const string &key,  const string &val) is used to send header information on to the void LHAup::setInfoHeader(const string &key,  const string &val) Info class."},{"name":"void LHAup::setInfoHeader(string &key, string &val)","link":"LesHouchesAccord.html#anchor12","text":"void LHAup::setInfoHeader(string &key, string &val) set the header void LHAup::setInfoHeader(string &key, string &val) key to have value void LHAup::setInfoHeader(string &key, string &val) val. This is a wrapper function to the void LHAup::setInfoHeader(string &key, string &val) Info::setHeader function that should be used in any classes derived from LHAup."},{"name":"void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet)","link":"LesHouchesAccord.html#anchor58","text":"void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet) which gives the flavours , the void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet) x and the void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet) Q scale (in GeV) at which the parton densities void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet) x*f_i(x, Q) have been evaluated. The last argument is normally void LHAup::setPdf( int id1pdf, int id2pdf, double x1pdf,  double x2pdf, double scalePDF, double pdf1, double pdf2, bool pdfIsSet) true."},{"name":"void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD)","link":"LesHouchesAccord.html#anchor31","text":"void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD) tells which kind of process occurred, with what weight, at what scale, and which void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD) alpha_EM and void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD) alpha_strong were used (cf. void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD) IDPRUP, XWTGUP, SCALUP, AQEDUP, AQCDUP ). This method also resets the size of the particle list, and adds the empty zeroth line, so it has to be called before the void LHAup::setProcess( int idProcess, double weight,  double scale, double alphaQED, double alphaQCD) addParticle method below."},{"name":"void LHAup::setPtr(Info* infoPtr)","link":"LesHouchesAccord.html#anchor3","text":"void LHAup::setPtr(Info* infoPtr) this method only sets the pointer that allows some information to be accessed, and is automatically called by void LHAup::setPtr(Info* infoPtr) Pythia::init()."},{"name":"void LHAup::setStrategy( int strategy)","link":"LesHouchesAccord.html#anchor7","text":"void LHAup::setStrategy( int strategy) sets the event weighting and cross section strategy. The default, provided in the class constructor, is 3, which is the natural value e.g. for an LHEF. void LHAup::setStrategy( int strategy) chosen strategy (cf. void LHAup::setStrategy( int strategy) IDWTUP ; see void LHAup::setStrategy( int strategy) Sjo06 section 9.9.1 for extensive comments). void LHAup::setStrategy( int strategy) events come with non-negative weight, given in units of pb, with an average that converges towards the cross section of the process. PYTHIA is in charge of the event mixing, i.e. for each new try decides which process should be generated, and then decides whether is should be kept, based on a comparison with void LHAup::setStrategy( int strategy) xMax. Accepted events therefore have unit weight. void LHAup::setStrategy( int strategy) as option 1, except that cross sections can now be negative and events after unweighting have weight +-1. You can use void LHAup::setStrategy( int strategy) void LHAup::setStrategy( int strategy) Info::weight() to find the weight of the current event. A correct event mixing requires that a process that can take both signs should be split in two, one limited to positive or zero and the other to negative or zero values, with void LHAup::setStrategy( int strategy) xMax chosen appropriately for the two. void LHAup::setStrategy( int strategy) events come with non-negative weight, in unspecified units, but such that void LHAup::setStrategy( int strategy) xMax can be used to unweight the events to unit weight. Again PYTHIA is in charge of the event mixing. The total cross section of a process is stored in void LHAup::setStrategy( int strategy) xSec. void LHAup::setStrategy( int strategy) as option 2, except that cross sections can now be negative and events after unweighting have weight +-1. As for option -1 processes with indeterminate sign should be split in two. void LHAup::setStrategy( int strategy) events come with unit weight, and are thus accepted as is. The total cross section of the process is stored in void LHAup::setStrategy( int strategy) xSec. void LHAup::setStrategy( int strategy) as option 3, except that events now come with weight +-1. Unlike options -1 and -2 processes with indeterminate sign need not be split in two, unless you intend to mix with internal PYTHIA processes (see below). void LHAup::setStrategy( int strategy) events come with non-negative weight, given in units of pb, with an average that converges towards the cross section of the process, like for option 1. No attempt is made to unweight the events, however, but all are generated in full, and retain their original weight. For consistency with normal PYTHIA units, the weight stored in void LHAup::setStrategy( int strategy) Info::weight() has been converted to mb, however. void LHAup::setStrategy( int strategy) as option 4, except that events now can come either with positive or negative weights. void LHAup::setStrategy( int strategy) Note 1 : if several processes have already been mixed and stored in a common event file, either LHEF or some private format, it would be problematical to read back events in a different order. Since it is then not feasible to let PYTHIA pick the next process type, strategies +-1 and +-2 would not work. Instead strategy 3 would be the recommended choice, or -3 if negative-weight events are required. void LHAup::setStrategy( int strategy) Note 2 : it is possible to switch on internally implemented processes and have PYTHIA mix these with LHA ones according to their relative cross sections for strategies +-1, +-2 and 3. It does not work for strategy -3 unless the positive and negative sectors of the cross sections are in separate subprocesses (as must always be the case for -1 and -2), since otherwise the overall mixture of PYTHIA and LHA processes will be off. Mixing is not possible for strategies +-4, since the weighting procedure is not specified by the standard. (For instance, the intention may be to have events biased towards larger void LHAup::setStrategy( int strategy) pT values in some particular functional form.)"},{"name":"void LHAup::setXErr( int i, double xErr)","link":"LesHouchesAccord.html#anchor10","text":"void LHAup::setXErr( int i, double xErr) update the void LHAup::setXErr( int i, double xErr) xErr value of the void LHAup::setXErr( int i, double xErr) i 'th process added with void LHAup::setXErr( int i, double xErr) addProcess method."},{"name":"void LHAup::setXMax( int i, double xMax)","link":"LesHouchesAccord.html#anchor11","text":"void LHAup::setXMax( int i, double xMax) update the void LHAup::setXMax( int i, double xMax) xMax value of the void LHAup::setXMax( int i, double xMax) i 'th process added with void LHAup::setXMax( int i, double xMax) addProcess method."},{"name":"void LHAup::setXSec( int i, double xSec)","link":"LesHouchesAccord.html#anchor9","text":"void LHAup::setXSec( int i, double xSec) update the void LHAup::setXSec( int i, double xSec) xSec value of the void LHAup::setXSec( int i, double xSec) i 'th process added with void LHAup::setXSec( int i, double xSec) addProcess method (i.e. void LHAup::setXSec( int i, double xSec) i runs from 0 through void LHAup::setXSec( int i, double xSec) sizeProc() - 1 , see below)."},{"name":"void LHAupHelaconia::setEvents(int events)","link":"HelacOniaProcesses.html#anchor3","text":"void LHAupHelaconia::setEvents(int events) the number of events to generate per HelacOnia run. Normally does not need to be set, but defaults to 10000."},{"name":"void LHAupHelaconia::setSeed(int seed, int runs = 30081)","link":"HelacOniaProcesses.html#anchor4","text":"void LHAupHelaconia::setSeed(int seed, int runs = 30081) the random seed (sequence), normally not needed to be set explicitly. If the random seed is negative (default of -1), then the HelacOnia seed is taken as the Pythia parameter void LHAupHelaconia::setSeed(int seed, int runs = 30081) 'Random:seed' , which must be greater than 0. If the maximum number of allowed runs is exceeded (default of 30081) an error is thrown. The seed for a HelacOnia run is set as: void LHAupHelaconia::setSeed(int seed, int runs = 30081) (random seed - 1) * (maximum runs) + (number of runs) + 1. void LHAupHelaconia::setSeed(int seed, int runs = 30081) HelacOnia can only handle random seeds up to 30081 * 30081. So, with this strategy, one can generate Pythia jobs with seeds from 1 to 30081, with each job running HelacOnia less than 30081 times, and ensure a fully statistically independent sample. If more than 30081 jobs are needed, then the maximum allowed runs can be lowered accordingly, and if need be, setEvents can be used to increase the number of events generated per run."},{"name":"void LHAupLHEF::closeAllFiles()","link":"LesHouchesAccord.html#anchor84","text":"void LHAupLHEF::closeAllFiles() close main event file (LHEF) and, if present, separate header file."},{"name":"void LHAupMadgraph::setEvents(int events)","link":"MadGraph5Processes.html#anchor3","text":"void LHAupMadgraph::setEvents(int events) the number of events to generate per MadGraph run. Normally does not need to be set, but defaults to 10000."},{"name":"void LHAupMadgraph::setJets(int jets)","link":"MadGraph5Processes.html#anchor5","text":"void LHAupMadgraph::setJets(int jets) Set the number maximum number of jets generated by MadGraph. If negative (default of -1) then the number of jets is determined automatically, to be the maximum number of jets produced at leading order."},{"name":"void LHAupMadgraph::setSeed(int seed, int runs = 30081)","link":"MadGraph5Processes.html#anchor4","text":"void LHAupMadgraph::setSeed(int seed, int runs = 30081) the random seed (sequence), normally not needed to be set explicitly. If the random seed is negative (default of -1), then the MadGraph seed is taken as the Pythia parameter void LHAupMadgraph::setSeed(int seed, int runs = 30081) 'Random:seed' , which must be greater than 0. If the maximum number of allowed runs is exceeded (default of 30081) an error is thrown. The seed for a MadGraph run is set as: void LHAupMadgraph::setSeed(int seed, int runs = 30081) (random seed - 1) * (maximum runs) + (number of runs) + 1. void LHAupMadgraph::setSeed(int seed, int runs = 30081) MadGraph can only handle random seeds up to 30081 * 30081. So, with this strategy, one can generate Pythia jobs with seeds from 1 to 30081, with each job running MadGraph less than 30081 times, and ensure a fully statistically independent sample. If more than 30081 jobs are needed, then the maximum allowed runs can be lowered accordingly, and if need be, setEvents can be used to increase the number of events generated per run."},{"name":"void Particle::bst(const Vec4& pBst)","link":"ParticleProperties.html#anchor112","text":"void Particle::bst(const Vec4& pBst) boost four-momentum and production vertex by void Particle::bst(const Vec4& pBst) beta = (px/e, py/e, pz/e)."},{"name":"void Particle::bst(const Vec4& pBst, double mBst)","link":"ParticleProperties.html#anchor113","text":"void Particle::bst(const Vec4& pBst, double mBst) as above, but also use void Particle::bst(const Vec4& pBst, double mBst) gamma> = e/m to reduce roundoff errors."},{"name":"void Particle::bst(double betaX, double betaY, double betaZ)","link":"ParticleProperties.html#anchor110","text":"void Particle::bst(double betaX, double betaY, double betaZ) boost four-momentum and production vertex by this three-vector."},{"name":"void Particle::bst(double betaX, double betaY, double betaZ,  double gamma)","link":"ParticleProperties.html#anchor111","text":"void Particle::bst(double betaX, double betaY, double betaZ,  double gamma) as above, but also input the void Particle::bst(double betaX, double betaY, double betaZ,  double gamma) gamma value, to reduce roundoff errors."},{"name":"void Particle::bstback(const Vec4& pBst)","link":"ParticleProperties.html#anchor114","text":"void Particle::bstback(const Vec4& pBst)"},{"name":"void Particle::bstback(const Vec4& pBst, double mBst)","link":"ParticleProperties.html#anchor115","text":"void Particle::bstback(const Vec4& pBst, double mBst) as above, but with sign of boost flipped."},{"name":"void Particle::cols(int col, int acol)","link":"ParticleProperties.html#anchor28","text":"void Particle::cols(int col, int acol) sets both colour and anticolour in one go."},{"name":"void Particle::daughters(int daughter1, int daughter2)","link":"ParticleProperties.html#anchor27","text":"void Particle::daughters(int daughter1, int daughter2) sets both daughters in one go."},{"name":"void Particle::index()","link":"ParticleProperties.html#anchor93","text":"void Particle::index() the index of the particle itself in the event record."},{"name":"void Particle::mothers(int mother1, int mother2)","link":"ParticleProperties.html#anchor26","text":"void Particle::mothers(int mother1, int mother2) sets both mothers in one go."},{"name":"void Particle::offsetCol( int addCol)","link":"ParticleProperties.html#anchor118","text":"void Particle::offsetCol( int addCol) add a positive offset to colour indices, i.e. if void Particle::offsetCol( int addCol) col is positive then void Particle::offsetCol( int addCol) addCol is added to it, same with void Particle::offsetCol( int addCol) acol."},{"name":"void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter))","link":"ParticleProperties.html#anchor117","text":"void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) add a positive offset to the mother and daughter indices, i.e. if void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) mother1 is above void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) minMother then void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) addMother is added to it, same with void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) mother2 , if void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) daughter1 is above void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) minDaughter then void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) addDaughter is added to it, same with void Particle::offsetHistory( int minMother, int addMother,  int minDaughter, int addDaughter)) daughter2."},{"name":"void Particle::p(double px, double py, double pz, double e)","link":"ParticleProperties.html#anchor29","text":"void Particle::p(double px, double py, double pz, double e) sets the four-momentum components in one go."},{"name":"void Particle::rescale3(double fac)","link":"ParticleProperties.html#anchor106","text":"void Particle::rescale3(double fac) multiply the three-momentum components by void Particle::rescale3(double fac) fac."},{"name":"void Particle::rescale4(double fac)","link":"ParticleProperties.html#anchor107","text":"void Particle::rescale4(double fac) multiply the four-momentum components by void Particle::rescale4(double fac) fac."},{"name":"void Particle::rescale5(double fac)","link":"ParticleProperties.html#anchor108","text":"void Particle::rescale5(double fac) multiply the four-momentum components and the mass by void Particle::rescale5(double fac) fac."},{"name":"void Particle::rot(double theta, double phi)","link":"ParticleProperties.html#anchor109","text":"void Particle::rot(double theta, double phi) rotate three-momentum and production vertex by these polar and azimuthal angles."},{"name":"void Particle::rotbst(const RotBstMatrix& M,  bool boostVertex = true)","link":"ParticleProperties.html#anchor116","text":"void Particle::rotbst(const RotBstMatrix& M,  bool boostVertex = true) combined rotation and boost of the four-momentum and production vertex. If the optional second argument is false only the four-momentum is boosted, and not the production vertex."},{"name":"void Particle::setEvtPtr(Event* evtPtr)","link":"ParticleProperties.html#anchor124","text":"void Particle::setEvtPtr(Event* evtPtr) sets the pointer to the void Particle::setEvtPtr(Event* evtPtr) Event object the particle belongs to. This method is automatically called when a particle is appended to an event record. Also calls void Particle::setEvtPtr(Event* evtPtr) setPDEPtr below."},{"name":"void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0)","link":"ParticleProperties.html#anchor125","text":"void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0) sets the pointer to the void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0) ParticleDataEntry object of the particle, based on its current void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0) id code. If the particle belongs to an event there is no need to provide the input argument. As explained above, a valid void Particle::setPDEPtr(ParticleDataEntry* pdePtr = 0) ParticleDataEntry pointer is needed for the methods that provide information generic to the particle species."},{"name":"void Particle::statusCode(int code)","link":"ParticleProperties.html#anchor25","text":"void Particle::statusCode(int code) changes the absolute value but retains the original sign."},{"name":"void Particle::statusNeg()","link":"ParticleProperties.html#anchor24","text":"void Particle::statusNeg() sets the status sign positive or negative, without changing the absolute value."},{"name":"void Particle::statusPos()","link":"ParticleProperties.html#anchor23","text":"void Particle::statusPos()"},{"name":"void Particle::vProd(double xProd, double yProd,  double zProd, double tProd)","link":"ParticleProperties.html#anchor30","text":"void Particle::vProd(double xProd, double yProd,  double zProd, double tProd) sets the production vertex components in one go."},{"name":"void Particle::vProdAdd(Vec4 vProdIn)","link":"ParticleProperties.html#anchor31","text":"void Particle::vProdAdd(Vec4 vProdIn) shifts the production vertex four-vector by the input four-vector amount."},{"name":"void ParticleData::addParticle(int id,  string name = &quot; &quot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor22","text":"void ParticleData::addParticle(int id,  string name = &quot; &quot;, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.)"},{"name":"void ParticleData::addParticle(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.)","link":"ParticleDataScheme.html#anchor23","text":"void ParticleData::addParticle(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0., double tau0 = 0.) add a particle to the decay table; in the first form a particle which is its own antiparticle, in the second where a separate antiparticle exists."},{"name":"void ParticleData::antiName(int id, string antiName)","link":"ParticleDataScheme.html#anchor31","text":"void ParticleData::antiName(int id, string antiName)"},{"name":"void ParticleData::chargeType(int id, int chargeType)","link":"ParticleDataScheme.html#anchor36","text":"void ParticleData::chargeType(int id, int chargeType)"},{"name":"void ParticleData::checkTable(int verbosity)","link":"ParticleDataScheme.html#anchor21","text":"void ParticleData::checkTable(int verbosity) check that the particle decay table makes sense, especially for decays. void ParticleData::checkTable(int verbosity) level of checks. 0 is only minimal, e.g. if a particle has no open decay channels. 1, which is the level of the first method, provides warning if any individual channel is closed, except for resonances. 2 also prints the branching-ratio-averaged threshold mass. 11 and 12 are like 1 and 2, but also include resonances in the detailed checks."},{"name":"void ParticleData::colType(int id, int colType)","link":"ParticleDataScheme.html#anchor39","text":"void ParticleData::colType(int id, int colType)"},{"name":"void ParticleData::doExternalDecays(int id,  bool doExternalDecays)","link":"ParticleDataScheme.html#anchor57","text":"void ParticleData::doExternalDecays(int id,  bool doExternalDecays)"},{"name":"void ParticleData::doForceWidth(int id, bool doForceWidth)","link":"ParticleDataScheme.html#anchor61","text":"void ParticleData::doForceWidth(int id, bool doForceWidth)"},{"name":"void ParticleData::hasChanged(int id, bool hasChanged)","link":"ParticleDataScheme.html#anchor63","text":"void ParticleData::hasChanged(int id, bool hasChanged)"},{"name":"void ParticleData::initPtr(Info* infoPtr,  Settings* settingsPtrIn, Rndm* rndmPtrIn, CoupSM* coupSMPtrIn)","link":"ParticleDataScheme.html#anchor3","text":"void ParticleData::initPtr(Info* infoPtr,  Settings* settingsPtrIn, Rndm* rndmPtrIn, CoupSM* coupSMPtrIn) initialize pointers to a few other classes. Internal."},{"name":"void ParticleData::initWidths(  vector&lt;ResonanceWidths*&gt; resonancePtrs)","link":"ParticleDataScheme.html#anchor8","text":"void ParticleData::initWidths(  vector<ResonanceWidths*> resonancePtrs) initialize Breit-Wigner shape parameters for all particles, and the detailed handling of resonances, i.e. particles with perturbatively calculable partial widths, which can be used to obtain a mass-dependent Breit-Wigner and a dynamic choice of decay channels. Called from void ParticleData::initWidths(  vector<ResonanceWidths*> resonancePtrs) Pythia::init()."},{"name":"void ParticleData::isResonance(int id, bool isResonance)","link":"ParticleDataScheme.html#anchor53","text":"void ParticleData::isResonance(int id, bool isResonance)"},{"name":"void ParticleData::isVisible(int id, bool isVisible)","link":"ParticleDataScheme.html#anchor59","text":"void ParticleData::isVisible(int id, bool isVisible)"},{"name":"void ParticleData::list(bool changedOnly = false,  bool changedRes = true)","link":"ParticleDataScheme.html#anchor16","text":"void ParticleData::list(bool changedOnly = false,  bool changedRes = true) methods intended to present a listing of particle data in a readable format. The first two are special cases of the third. The first lists all particle data, the second only data for those particles that were changed after the original creation of the particle data table. Resonances are a special case since they can get their data changed by being linked to an object that does the calculation of branching ratios. By default the second method does not count such resonances as changed, whereas the third does and thus lists all resonances."},{"name":"void ParticleData::list(int idList)","link":"ParticleDataScheme.html#anchor17","text":"void ParticleData::list(int idList)"},{"name":"void ParticleData::list(vector&lt;int&gt; idList)","link":"ParticleDataScheme.html#anchor18","text":"void ParticleData::list(vector<int> idList) list particle data for one single particle, with the identity code as input, or for a set of particles, with an input vector of identity codes."},{"name":"void ParticleData::listAll()","link":"ParticleDataScheme.html#anchor14","text":"void ParticleData::listAll()"},{"name":"void ParticleData::listChanged(bool changedRes = false)","link":"ParticleDataScheme.html#anchor15","text":"void ParticleData::listChanged(bool changedRes = false)"},{"name":"void ParticleData::listFF(string outFile)","link":"ParticleDataScheme.html#anchor12","text":"void ParticleData::listFF(string outFile) read in free-format-style data from a file or write it out to a file. For the former one can also decide whether to reset all particles to scratch, or only overwrite those particles in the file. The former method is used by void ParticleData::listFF(string outFile) reInit above."},{"name":"void ParticleData::listXML(string outFile)","link":"ParticleDataScheme.html#anchor10","text":"void ParticleData::listXML(string outFile) read in XML-style data from a file or write it out to a file. For the former one can also decide whether to reset all particles to scratch, or only overwrite those particles in the file. The former method is used by void ParticleData::listXML(string outFile) init and void ParticleData::listXML(string outFile) reInit above."},{"name":"void ParticleData::m0(int id, double m0)","link":"ParticleDataScheme.html#anchor41","text":"void ParticleData::m0(int id, double m0)"},{"name":"void ParticleData::mayDecay(int id, bool mayDecay)","link":"ParticleDataScheme.html#anchor55","text":"void ParticleData::mayDecay(int id, bool mayDecay)"},{"name":"void ParticleData::mMax(int id, double mMax)","link":"ParticleDataScheme.html#anchor47","text":"void ParticleData::mMax(int id, double mMax)"},{"name":"void ParticleData::mMin(int id, double mMin)","link":"ParticleDataScheme.html#anchor45","text":"void ParticleData::mMin(int id, double mMin)"},{"name":"void ParticleData::mWidth(int id, double mWidth)","link":"ParticleDataScheme.html#anchor43","text":"void ParticleData::mWidth(int id, double mWidth)"},{"name":"void ParticleData::name(int id, string name)","link":"ParticleDataScheme.html#anchor30","text":"void ParticleData::name(int id, string name)"},{"name":"void ParticleData::names(int id,  string name, string antiName)","link":"ParticleDataScheme.html#anchor32","text":"void ParticleData::names(int id,  string name, string antiName)"},{"name":"void ParticleData::rescaleBR(int id, double newSumBR = 1.)","link":"ParticleDataScheme.html#anchor82","text":"void ParticleData::rescaleBR(int id, double newSumBR = 1.) rescales all partial branching ratios by a common factor, such that the sum afterward becomes void ParticleData::rescaleBR(int id, double newSumBR = 1.) newSumBR."},{"name":"void ParticleData::resInit(int id)","link":"ParticleDataScheme.html#anchor84","text":"void ParticleData::resInit(int id) initialize the treatment of a resonance."},{"name":"void ParticleData::setAll(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.)","link":"ParticleDataScheme.html#anchor24","text":"void ParticleData::setAll(int id,  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.) change all the properties of the particle associated with a given identity code."},{"name":"void ParticleData::spinType(int id, int spinType)","link":"ParticleDataScheme.html#anchor34","text":"void ParticleData::spinType(int id, int spinType)"},{"name":"void ParticleData::tau0(int id, double tau0)","link":"ParticleDataScheme.html#anchor51","text":"void ParticleData::tau0(int id, double tau0)"},{"name":"void ParticleDataEntry::addChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0,  int prod7 = 0,)","link":"ParticleDataScheme.html#anchor155","text":"void ParticleDataEntry::addChannel(int onMode = 0,  double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0,  int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0,  int prod6 = 0,  int prod7 = 0,) adds a decay channel with up to 8 products."},{"name":"void ParticleDataEntry::clearChannels()","link":"ParticleDataScheme.html#anchor154","text":"void ParticleDataEntry::clearChannels() resets to an empty decay table."},{"name":"void ParticleDataEntry::hasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor136","text":"void ParticleDataEntry::hasChanged(bool hasChanged) keep track of whether the data for a particle has been changed in any respect between initialization and the current status. Is used e.g. by the void ParticleDataEntry::hasChanged(bool hasChanged) ParticleData::listChanged method to determine which particles to list."},{"name":"void ParticleDataEntry::initBWmass()","link":"ParticleDataScheme.html#anchor137","text":"void ParticleDataEntry::initBWmass() Prepare the Breit-Wigner mass selection by precalculating frequently-used expressions."},{"name":"void ParticleDataEntry::initPtr(ParticleData*  particleDataPtrIn)","link":"ParticleDataScheme.html#anchor98","text":"void ParticleDataEntry::initPtr(ParticleData*  particleDataPtrIn) initialize pointer back to the whole database (so that masses of decay products can be accessed, e.g.)."},{"name":"void ParticleDataEntry::rescaleBR(double newSumBR = 1.)","link":"ParticleDataScheme.html#anchor159","text":"void ParticleDataEntry::rescaleBR(double newSumBR = 1.) rescales all partial branching ratios by a common factor, such that the sum afterward becomes void ParticleDataEntry::rescaleBR(double newSumBR = 1.) newSumBR."},{"name":"void ParticleDataEntry::resInit(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  CoupSM* coupSMPtrIn)","link":"ParticleDataScheme.html#anchor164","text":"void ParticleDataEntry::resInit(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  CoupSM* coupSMPtrIn) initialize the treatment of a resonance."},{"name":"void ParticleDataEntry::setAll(  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.)","link":"ParticleDataScheme.html#anchor99","text":"void ParticleDataEntry::setAll(  string name, string antiName, int spinType = 0, int chargeType = 0,  int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0.,  double mMax = 0.,double tau0 = 0.) change all the properties of the particle associated with a given identity code."},{"name":"void ParticleDataEntry::setAntiName(string antiName)","link":"ParticleDataScheme.html#anchor103","text":"void ParticleDataEntry::setAntiName(string antiName)"},{"name":"void ParticleDataEntry::setChargeType(int chargeType)","link":"ParticleDataScheme.html#anchor108","text":"void ParticleDataEntry::setChargeType(int chargeType)"},{"name":"void ParticleDataEntry::setColType(int colType)","link":"ParticleDataScheme.html#anchor111","text":"void ParticleDataEntry::setColType(int colType)"},{"name":"void ParticleDataEntry::setDefaults()","link":"ParticleDataScheme.html#anchor97","text":"void ParticleDataEntry::setDefaults() initialize some particle flags with default values, e.g. whether a particle is a resonance, may decay, or is visible. Is called from the constructors and from void ParticleDataEntry::setDefaults() setAll."},{"name":"void ParticleDataEntry::setDoExternalDecays(bool  doExternalDecays)","link":"ParticleDataScheme.html#anchor129","text":"void ParticleDataEntry::setDoExternalDecays(bool  doExternalDecays)"},{"name":"void ParticleDataEntry::setDoForceWidth(bool  doForceWidth)","link":"ParticleDataScheme.html#anchor133","text":"void ParticleDataEntry::setDoForceWidth(bool  doForceWidth)"},{"name":"void ParticleDataEntry::setHasChanged(bool hasChanged)","link":"ParticleDataScheme.html#anchor135","text":"void ParticleDataEntry::setHasChanged(bool hasChanged)"},{"name":"void ParticleDataEntry::setIsResonance(bool isResonance)","link":"ParticleDataScheme.html#anchor125","text":"void ParticleDataEntry::setIsResonance(bool isResonance)"},{"name":"void ParticleDataEntry::setIsVisible(bool isVisible)","link":"ParticleDataScheme.html#anchor131","text":"void ParticleDataEntry::setIsVisible(bool isVisible)"},{"name":"void ParticleDataEntry::setM0(double m0)","link":"ParticleDataScheme.html#anchor113","text":"void ParticleDataEntry::setM0(double m0)"},{"name":"void ParticleDataEntry::setMayDecay(bool mayDecay)","link":"ParticleDataScheme.html#anchor127","text":"void ParticleDataEntry::setMayDecay(bool mayDecay)"},{"name":"void ParticleDataEntry::setMMax(double mMax)","link":"ParticleDataScheme.html#anchor119","text":"void ParticleDataEntry::setMMax(double mMax)"},{"name":"void ParticleDataEntry::setMMin(double mMin)","link":"ParticleDataScheme.html#anchor117","text":"void ParticleDataEntry::setMMin(double mMin)"},{"name":"void ParticleDataEntry::setMWidth(double mWidth)","link":"ParticleDataScheme.html#anchor115","text":"void ParticleDataEntry::setMWidth(double mWidth)"},{"name":"void ParticleDataEntry::setName(string name)","link":"ParticleDataScheme.html#anchor102","text":"void ParticleDataEntry::setName(string name)"},{"name":"void ParticleDataEntry::setNames(string name,  string antiName)","link":"ParticleDataScheme.html#anchor104","text":"void ParticleDataEntry::setNames(string name,  string antiName)"},{"name":"void ParticleDataEntry::setResonancePtr(ResonanceWidths*  resonancePtr)","link":"ParticleDataScheme.html#anchor162","text":"void ParticleDataEntry::setResonancePtr(ResonanceWidths*  resonancePtr)"},{"name":"void ParticleDataEntry::setSpinType(int spinType)","link":"ParticleDataScheme.html#anchor106","text":"void ParticleDataEntry::setSpinType(int spinType)"},{"name":"void ParticleDataEntry::setTau0(double tau0,  bool countAsChanged = true)","link":"ParticleDataScheme.html#anchor123","text":"void ParticleDataEntry::setTau0(double tau0,  bool countAsChanged = true)"},{"name":"void Pythia8ToHepMC::set_convert_gluon_to_0(bool b = false)","link":"HepMCInterface.html#anchor9","text":"void Pythia8ToHepMC::set_convert_gluon_to_0(bool b = false)"},{"name":"void Pythia8ToHepMC::set_free_parton_exception(bool b = true)","link":"HepMCInterface.html#anchor7","text":"void Pythia8ToHepMC::set_free_parton_exception(bool b = true)"},{"name":"void Pythia8ToHepMC::set_print_inconsistency(bool b = true)","link":"HepMCInterface.html#anchor5","text":"void Pythia8ToHepMC::set_print_inconsistency(bool b = true)"},{"name":"void Pythia8ToHepMC::set_store_pdf(bool b = true)","link":"HepMCInterface.html#anchor11","text":"void Pythia8ToHepMC::set_store_pdf(bool b = true)"},{"name":"void Pythia8ToHepMC::set_store_proc(bool b = true)","link":"HepMCInterface.html#anchor13","text":"void Pythia8ToHepMC::set_store_proc(bool b = true)"},{"name":"void Pythia8ToHepMC::set_store_xsec(bool b = true)","link":"HepMCInterface.html#anchor15","text":"void Pythia8ToHepMC::set_store_xsec(bool b = true)"},{"name":"void Pythia::initPtrs()","link":"ProgramFlow.html#anchor5","text":"void Pythia::initPtrs()"},{"name":"void Pythia::LHAeventList()","link":"ProgramFlow.html#anchor35","text":"void Pythia::LHAeventList() list the Les Houches Accord information on the current event, see void Pythia::LHAeventList() void Pythia::LHAeventList() LHAup::listEvent(...). (Other listings are available via the class members below, so this listing is a special case that would not fit elsewhere.)"},{"name":"void Pythia::stat()","link":"ProgramFlow.html#anchor37","text":"void Pythia::stat() list statistics on the event generation, specifically total and partial cross sections and the number of different errors. For more details see void Pythia::stat() here and for available options void Pythia::stat() here."},{"name":"void ResonanceWidths::calcPreFac(bool calledFromInit = false)","link":"SemiInternalResonances.html#anchor2","text":"void ResonanceWidths::calcPreFac(bool calledFromInit = false) is called once a mass has been chosen for the resonance, but before a specific final state is considered. This routine can therefore be used to perform calculations that otherwise might have to be repeated over and over again in void ResonanceWidths::calcPreFac(bool calledFromInit = false) calcWidth below. It is optional whether you want to use this method, however, or put everything in void ResonanceWidths::calcPreFac(bool calledFromInit = false) calcWidth(). void ResonanceWidths::calcPreFac(bool calledFromInit = false) The optional argument will have the value void ResonanceWidths::calcPreFac(bool calledFromInit = false) true when the resonance is initialized, and then be void ResonanceWidths::calcPreFac(bool calledFromInit = false) false throughout the event generation, should you wish to make a distinction. In PYTHIA such a distinction is made for void ResonanceWidths::calcPreFac(bool calledFromInit = false) gamma^*/Z^0 and void ResonanceWidths::calcPreFac(bool calledFromInit = false) gamma^*/Z^0/Z'^0 , owing to the necessity of a special description of interference effects, but not for other resonances. void ResonanceWidths::calcPreFac(bool calledFromInit = false) In addition to the base-class member variables already described above, void ResonanceWidths::calcPreFac(bool calledFromInit = false) mHat contains the current mass of the resonance. At initialization this agrees with the nominal mass void ResonanceWidths::calcPreFac(bool calledFromInit = false) mRes , but during the run it will not (in general)."},{"name":"void ResonanceWidths::calcWidth(bool calledFromInit = false)","link":"SemiInternalResonances.html#anchor3","text":"void ResonanceWidths::calcWidth(bool calledFromInit = false) is the key method for width calculations and returns a partial width value, as further described below. It is called for a specific final state, typically in a loop over all allowed final states, subsequent to the void ResonanceWidths::calcWidth(bool calledFromInit = false) calcPreFac(...) call above. Information on the final state is stored in a number of base-class variables, for you to use in your calculations: void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) iChannel : the channel number in the list of possible decay channels; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) mult : the number of decay products; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) id1, id2, id3 : the identity code of up to the first three decay products, arranged in descending order of the absolute value of the identity code; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) id1Abs, id2Abs, id3Abs : the absolute value of the above three identity codes; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) mHat : the current resonance mass, which is the same as in the latest void ResonanceWidths::calcWidth(bool calledFromInit = false) calcPreFac(...) call; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) mf1, mf2, mf3 : masses of the above decay products; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) mr1, mr2, mr3 : squared ratio of the product masses to the resonance mass; void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) ps : is only meaningful for two-body decays, where it gives the phase-space factor void ResonanceWidths::calcWidth(bool calledFromInit = false) ps = sqrt( (1. - mr1 - mr2)^2 - 4. * mr1 * mr2 ) ; void ResonanceWidths::calcWidth(bool calledFromInit = false) In two-body decays the third slot is zero for the above properties. Should there be more than three particles in the decay, you would have to take care of the subsequent products yourself, e.g. using void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) particlePtr->decay[iChannel].product(j); void ResonanceWidths::calcWidth(bool calledFromInit = false) to extract the void ResonanceWidths::calcWidth(bool calledFromInit = false) j 'th decay products (with void ResonanceWidths::calcWidth(bool calledFromInit = false) j = 0 for the first, etc.). Currently we are not aware of any such examples. void ResonanceWidths::calcWidth(bool calledFromInit = false) The base class also contains methods for void ResonanceWidths::calcWidth(bool calledFromInit = false) alpha_em and void ResonanceWidths::calcWidth(bool calledFromInit = false) alpha_strong evaluation, and can access many standard-model couplings; see the existing code for examples. void ResonanceWidths::calcWidth(bool calledFromInit = false) The result of your calculation should be stored in void ResonanceWidths::calcWidth(bool calledFromInit = false) void ResonanceWidths::calcWidth(bool calledFromInit = false) widNow : the partial width of the current channel, expressed in GeV."},{"name":"void ResonanceWidths::initConstants()","link":"SemiInternalResonances.html#anchor1","text":"void ResonanceWidths::initConstants() is called once during initialization, and can then be used to set up further parameters specific to this particle species, such as couplings, and perform calculations that need not be repeated for each new event, thereby saving time. This method needs not be implemented."},{"name":"void Rndm::init(int seed = 0)","link":"RandomNumbers.html#anchor5","text":"void Rndm::init(int seed = 0) initialize, or reinitialize, the random number generator for the given seed number. Not necessary if the seed was already set in the constructor."},{"name":"void RotBstMatrix::bst(const Vec4& p1, const Vec4& p2)","link":"FourVectors.html#anchor81","text":"void RotBstMatrix::bst(const Vec4& p1, const Vec4& p2) boost so that void RotBstMatrix::bst(const Vec4& p1, const Vec4& p2) p_1 is transformed to void RotBstMatrix::bst(const Vec4& p1, const Vec4& p2) p_2. It is assumed that the two vectors obey void RotBstMatrix::bst(const Vec4& p1, const Vec4& p2) p_1^2 = p_2^2."},{"name":"void RotBstMatrix::bst(const Vec4&)","link":"FourVectors.html#anchor79","text":"void RotBstMatrix::bst(const Vec4&)"},{"name":"void RotBstMatrix::bst(double betaX = 0., double betaY = 0.,  double betaZ = 0.)","link":"FourVectors.html#anchor78","text":"void RotBstMatrix::bst(double betaX = 0., double betaY = 0.,  double betaZ = 0.) boost by this void RotBstMatrix::bst(double betaX = 0., double betaY = 0.,  double betaZ = 0.) beta vector."},{"name":"void RotBstMatrix::bstback(const Vec4&)","link":"FourVectors.html#anchor80","text":"void RotBstMatrix::bstback(const Vec4&) boost with a void RotBstMatrix::bstback(const Vec4&) beta = p/E or void RotBstMatrix::bstback(const Vec4&) beta = -p/E , respectively."},{"name":"void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2)","link":"FourVectors.html#anchor83","text":"void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) rotate and boost from the rest frame of void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) p_1 and void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) p_2 , with void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) p_1 along the void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) +z axis, to the actual frame of void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) p_1 and void RotBstMatrix::fromCMframe(const Vec4& p1, const Vec4& p2) p_2 , i.e. the inverse of the above."},{"name":"void RotBstMatrix::invert()","link":"FourVectors.html#anchor87","text":"void RotBstMatrix::invert() invert the matrix, which corresponds to an opposite sequence and sign of rotations and boosts."},{"name":"void RotBstMatrix::reset()","link":"FourVectors.html#anchor89","text":"void RotBstMatrix::reset() reset to no rotation/boost; i.e. the default at creation."},{"name":"void RotBstMatrix::rot(const Vec4& p)","link":"FourVectors.html#anchor77","text":"void RotBstMatrix::rot(const Vec4& p) rotate so that a vector originally along the void RotBstMatrix::rot(const Vec4& p) +z axis becomes parallel with void RotBstMatrix::rot(const Vec4& p) p. More specifically, rotate by void RotBstMatrix::rot(const Vec4& p) -phi , void RotBstMatrix::rot(const Vec4& p) theta and void RotBstMatrix::rot(const Vec4& p) phi , with angles defined by void RotBstMatrix::rot(const Vec4& p) p."},{"name":"void RotBstMatrix::rot(double theta = 0., double phi = 0.)","link":"FourVectors.html#anchor76","text":"void RotBstMatrix::rot(double theta = 0., double phi = 0.) rotate by this polar and azimuthal angle."},{"name":"void RotBstMatrix::rotbst(const RotBstMatrix& Min);","link":"FourVectors.html#anchor84","text":"void RotBstMatrix::rotbst(const RotBstMatrix& Min); combine the current matrix with another one."},{"name":"void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2)","link":"FourVectors.html#anchor82","text":"void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2) boost and rotate to the rest frame of void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2) p_1 and void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2) p_2 , with void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2) p_1 along the void RotBstMatrix::toCMframe(const Vec4& p1, const Vec4& p2) +z axis."},{"name":"void setResonancePtr(int id, ResonanceWidths* resonancePtr)","link":"ParticleDataScheme.html#anchor83","text":"void setResonancePtr(int id, ResonanceWidths* resonancePtr) set a pointer for a particle kind to a void setResonancePtr(int id, ResonanceWidths* resonancePtr) ResonanceWidths object. This is done, from inside void setResonancePtr(int id, ResonanceWidths* resonancePtr) ParticleData::initWidths , only for resonances, i.e. for particles such as void setResonancePtr(int id, ResonanceWidths* resonancePtr) Z^0 , void setResonancePtr(int id, ResonanceWidths* resonancePtr) W^+- , top, Higgs, and new unstable states beyond the Standard Model. The presence of such an object will allow a more dynamic calculation of partial and total widths, as illustrated by the following methods."},{"name":"void Settings::addFlag(string key, bool default)","link":"SettingsScheme.html#anchor25","text":"void Settings::addFlag(string key, bool default)"},{"name":"void Settings::addFVec(string key,  vector&lt;bool&gt; default)","link":"SettingsScheme.html#anchor29","text":"void Settings::addFVec(string key,  vector<bool> default)"},{"name":"void Settings::addMode(string key,  int default, bool hasMin, bool hasMax, int min, int max)","link":"SettingsScheme.html#anchor26","text":"void Settings::addMode(string key,  int default, bool hasMin, bool hasMax, int min, int max)"},{"name":"void Settings::addMVec(string key,  vector&lt;int&gt; default, bool hasMin, bool hasMax,  int min, int max)","link":"SettingsScheme.html#anchor30","text":"void Settings::addMVec(string key,  vector<int> default, bool hasMin, bool hasMax,  int min, int max)"},{"name":"void Settings::addParm(string key,  double default, bool hasMin, bool hasMax, double min, double max)","link":"SettingsScheme.html#anchor27","text":"void Settings::addParm(string key,  double default, bool hasMin, bool hasMax, double min, double max)"},{"name":"void Settings::addPVec(string key,  vector&lt;double&gt; default, bool hasMin, bool hasMax,  double min, double max)","link":"SettingsScheme.html#anchor31","text":"void Settings::addPVec(string key,  vector<double> default, bool hasMin, bool hasMax,  double min, double max)"},{"name":"void Settings::addWord(string key,  string default)","link":"SettingsScheme.html#anchor28","text":"void Settings::addWord(string key,  string default)"},{"name":"void Settings::addWVec(string key,  vector&lt;string&gt; default)","link":"SettingsScheme.html#anchor32","text":"void Settings::addWVec(string key,  vector<string> default) add an entry of the respective kind to the database. The name and default value(s) always has to be supplied, for void Settings::addWVec(string key,  vector<string> default) Mode , void Settings::addWVec(string key,  vector<string> default) Parm , void Settings::addWVec(string key,  vector<string> default) MVec and void Settings::addWVec(string key,  vector<string> default) PVec additionally if lower and/or upper limits are to be imposed and, if so, what those limit are."},{"name":"void Settings::flag(string key, bool now, bool force = false)","link":"SettingsScheme.html#anchor57","text":"void Settings::flag(string key, bool now, bool force = false)"},{"name":"void Settings::forceMode(string key, int now)","link":"SettingsScheme.html#anchor65","text":"void Settings::forceMode(string key, int now)"},{"name":"void Settings::forceMVec(string key,  vector&lt;int&gt; now)","link":"SettingsScheme.html#anchor67","text":"void Settings::forceMVec(string key,  vector<int> now)"},{"name":"void Settings::forceParm(string key, double now)","link":"SettingsScheme.html#anchor66","text":"void Settings::forceParm(string key, double now)"},{"name":"void Settings::forcePVec(string key,  vector&lt;double&gt; now)","link":"SettingsScheme.html#anchor68","text":"void Settings::forcePVec(string key,  vector<double> now) as above, but do not check lower and upper limits, so that the current value(s) can be put outside the intended borders. void Settings::forcePVec(string key,  vector<double> now) Note: these methods have been superseded by the void Settings::forcePVec(string key,  vector<double> now) force = true option in the standard methods above. They are kept for backwards compatibility with version 8.223 and earlier but will be removed in a future major release."},{"name":"void Settings::fvec(string key, vector&lt;bool&gt; now,  bool force = false)","link":"SettingsScheme.html#anchor61","text":"void Settings::fvec(string key, vector<bool> now,  bool force = false)"},{"name":"void Settings::list(string match)","link":"SettingsScheme.html#anchor12","text":"void Settings::list(string match) list all or changed settings, or a group of them. void Settings::list(string match) list all those settings where the name contains the void Settings::list(string match) match (sub)string (case-insensitive)."},{"name":"void Settings::listAll()","link":"SettingsScheme.html#anchor10","text":"void Settings::listAll()"},{"name":"void Settings::listChanged()","link":"SettingsScheme.html#anchor11","text":"void Settings::listChanged()"},{"name":"void Settings::mode(string key, int now,  bool force = false)","link":"SettingsScheme.html#anchor58","text":"void Settings::mode(string key, int now,  bool force = false)"},{"name":"void Settings::mvec(string key, vector&lt;int&gt; now,  bool force = false)","link":"SettingsScheme.html#anchor62","text":"void Settings::mvec(string key, vector<int> now,  bool force = false)"},{"name":"void Settings::parm(string key, double now,  bool force = false)","link":"SettingsScheme.html#anchor59","text":"void Settings::parm(string key, double now,  bool force = false)"},{"name":"void Settings::pvec(string key, vector&lt;double&gt; now,  bool force = false)","link":"SettingsScheme.html#anchor63","text":"void Settings::pvec(string key, vector<double> now,  bool force = false)"},{"name":"void Settings::resetAll()","link":"SettingsScheme.html#anchor16","text":"void Settings::resetAll() reset all current values to their defaults."},{"name":"void Settings::resetFlag(string key)","link":"SettingsScheme.html#anchor69","text":"void Settings::resetFlag(string key)"},{"name":"void Settings::resetFVec(string key)","link":"SettingsScheme.html#anchor73","text":"void Settings::resetFVec(string key)"},{"name":"void Settings::resetMode(string key)","link":"SettingsScheme.html#anchor70","text":"void Settings::resetMode(string key)"},{"name":"void Settings::resetMVec(string key)","link":"SettingsScheme.html#anchor74","text":"void Settings::resetMVec(string key)"},{"name":"void Settings::resetParm(string key)","link":"SettingsScheme.html#anchor71","text":"void Settings::resetParm(string key)"},{"name":"void Settings::resetPVec(string key)","link":"SettingsScheme.html#anchor75","text":"void Settings::resetPVec(string key)"},{"name":"void Settings::resetWord(string key)","link":"SettingsScheme.html#anchor72","text":"void Settings::resetWord(string key)"},{"name":"void Settings::resetWVec(string key)","link":"SettingsScheme.html#anchor76","text":"void Settings::resetWVec(string key) reset the current value to the default one."},{"name":"void Settings::word(string key, string now,  bool force = false)","link":"SettingsScheme.html#anchor60","text":"void Settings::word(string key, string now,  bool force = false)"},{"name":"void Settings::wvec(string key, vector&lt;string&gt; now,  bool force = false)","link":"SettingsScheme.html#anchor64","text":"void Settings::wvec(string key, vector<string> now,  bool force = false) change the current value(s) of the respective setting to the provided new value(s). If lower or upper limits have been set and void Settings::wvec(string key, vector<string> now,  bool force = false) force=false , input values outside the allowed range are reinterpreted as being at the nearest limit. If void Settings::wvec(string key, vector<string> now,  bool force = false) force = true , upper and lower limits will be ignored, allowing to force values outside the allowed range (to be used with caution and at own responsibility!). Any key not found in the settings database will be ignored, unless void Settings::wvec(string key, vector<string> now,  bool force = false) force = true , in which case the missing key will be added to the database with the given value."},{"name":"void SigmaProcess::initProc()","link":"SemiInternalProcesses.html#anchor5","text":"void SigmaProcess::initProc() is called once during initialization, and can then be used to set up parameters, such as masses and couplings, and perform calculations that need not be repeated for each new event, thereby saving time. This method needs not be implemented, since in principle all calculations can be done in void SigmaProcess::initProc() sigmaHat below."},{"name":"void SigmaProcess::setIdColAcol()","link":"SemiInternalProcesses.html#anchor9","text":"void SigmaProcess::setIdColAcol() is called only once an initial state and a kinematical configuration has been picked. This routine must set the complete flavour information and the colour flow of the process. This may involve further random choices, between different possible final-state flavours or between possible competing colour flows. Private data members of the class may be used to retain some information from the previous steps above. void SigmaProcess::setIdColAcol() When this routine is called the two incoming flavours have already been selected and are available in void SigmaProcess::setIdColAcol() id1 and void SigmaProcess::setIdColAcol() id2 , whereas the one, two or three outgoing ones either are fixed for a given process or can be determined from the instate (e.g. whether a void SigmaProcess::setIdColAcol() W^+ or void SigmaProcess::setIdColAcol() W^- was produced).  There is also a standard method in void SigmaProcess::setIdColAcol() VCKM to pick a final flavour from an initial one with CKM mixing. Once you have figured out the value of void SigmaProcess::setIdColAcol() id3 and, the case being, void SigmaProcess::setIdColAcol() id4 and void SigmaProcess::setIdColAcol() id5 , you store these values permanently by a call void SigmaProcess::setIdColAcol() setId( id1, id2, id3, id4, id5) , where the last two may be omitted if irrelevant. void SigmaProcess::setIdColAcol() Correspondingly, the colours are stored with void SigmaProcess::setIdColAcol() setColAcol( col1, acol1, col2, acol2, col3, acol3, col4, acol4, col5, acol5) , where the final ones may be omitted if irrelevant. Les Houches style colour tags are used, but starting with number 1 (and later shifted by the currently requested offset). The input is grouped particle by particle, with the colour index before the anticolour one. You may need to select colour flow dynamically, depending on the kinematics, when several distinct possibilities exist. Trivial operations, like swapping colours and anticolours, can be done with existing methods. void SigmaProcess::setIdColAcol() When the void SigmaProcess::setIdColAcol() id3Mass() and void SigmaProcess::setIdColAcol() id4Mass() methods have been used, the order of the outgoing particles may be inconsistent with the way the void SigmaProcess::setIdColAcol() tHat and void SigmaProcess::setIdColAcol() uHat variables have been defined. A typical example would be a process like void SigmaProcess::setIdColAcol() q g &rarr; q' W with void SigmaProcess::setIdColAcol() tHat defined between incoming and outgoing quark, but where void SigmaProcess::setIdColAcol() id3Mass() = 24 and so the process is to be stored as void SigmaProcess::setIdColAcol() q g &rarr; W q'. One should then put the variable void SigmaProcess::setIdColAcol() swapTU = true in void SigmaProcess::setIdColAcol() setIdColAcol() for each event where the void SigmaProcess::setIdColAcol() tHat and void SigmaProcess::setIdColAcol() uHat variables should be swapped before the event kinematics is reconstructed. This variable is automatically restored to void SigmaProcess::setIdColAcol() false for each new event."},{"name":"void SigmaProcess::sigmaKin()","link":"SemiInternalProcesses.html#anchor6","text":"void SigmaProcess::sigmaKin() is called once a kinematical configuration has been determined, but before the two incoming flavours are known. This routine can therefore be used to perform calculations that otherwise might have to be repeated over and over again in void SigmaProcess::sigmaKin() sigmaHat below. For instance a flavour-independent cross section calculation for a void SigmaProcess::sigmaKin() q g initial state would be repeated 20 times in void SigmaProcess::sigmaKin() sigmaHat , five times for the five quark flavours allowed in the incoming beams, times twice to include antiquarks, times twice since the (anti)quark could be in either of the two beams. You could therefore calculate the result once only and store it as a private data member of the class. It is optional whether you want to use this method, however, or put everything in void SigmaProcess::sigmaKin() sigmaHat."},{"name":"void SlowJet::list()","link":"EventAnalysis.html#anchor56","text":"void SlowJet::list() provides a listing of the basic jet information from above."},{"name":"void SlowJet::list(bool listAll = false)","link":"EventAnalysis.html#anchor62","text":"void SlowJet::list(bool listAll = false) provides a listing of the above information. void SlowJet::list(bool listAll = false) lists both jets and clusters if void SlowJet::list(bool listAll = false) true , else only jets."},{"name":"void SlowJet::removeJet(int i)","link":"EventAnalysis.html#anchor55","text":"void SlowJet::removeJet(int i) removes the void SlowJet::removeJet(int i) i 'th jet,"},{"name":"void SpaceShower::initPtr(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  Rndm* rndmPtrIn, CoupSM* coupSMPtrIn, PartonSystems* partonSystemsPtrIn,  UserHooks* userHooksPtrIn, MergingHooks* mergingHooksPtrIn = 0)","link":"ImplementNewShowers.html#anchor30","text":"void SpaceShower::initPtr(Info* infoPtrIn,  Settings* settingsPtrIn, ParticleData* particleDataPtrIn,  Rndm* rndmPtrIn, CoupSM* coupSMPtrIn, PartonSystems* partonSystemsPtrIn,  UserHooks* userHooksPtrIn, MergingHooks* mergingHooksPtrIn = 0) This method only imports pointers to standard facilities, and is not virtual."},{"name":"void Sphericity::list()","link":"EventAnalysis.html#anchor7","text":"void Sphericity::list() provides a listing of the above information."},{"name":"void Thrust::list()","link":"EventAnalysis.html#anchor16","text":"void Thrust::list() provides a listing of the above information."},{"name":"void TimeShower::initPtr(Info* infoPtr, Settings* settingsPtr,  ParticleData* particleDataPtr, Rndm* rndmPtr, CoupSM* coupSMPtr,  PartonSystems* partonSystemsPtr, UserHooks* userHooksPtr)","link":"ImplementNewShowers.html#anchor3","text":"void TimeShower::initPtr(Info* infoPtr, Settings* settingsPtr,  ParticleData* particleDataPtr, Rndm* rndmPtr, CoupSM* coupSMPtr,  PartonSystems* partonSystemsPtr, UserHooks* userHooksPtr) This method only imports pointers to standard facilities, and is not virtual."},{"name":"void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr)","link":"UserHooks.html#anchor3","text":"void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) this (non-virtual) method is automatically called during the initialization stage to set several useful pointers, and to set up the void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) workEvent below. The corresponding objects can later be used to extract some useful information. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) Info : general event and run information, including some loop counters. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) Settings : the settings used to determine the character of the run. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) ParticleData : the particle data used in the event record (including void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) workEvent below). void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) Rndm : the random number generator, that you could also use in your code. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) BeamParticle : the void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) beamAPtr and void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) beamBPtr beam particles contain info on partons extracted from the two incoming beams, on the PDFs used, and more. In cases when diffraction is simulated, also special Pomeron beams void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) beamPomAPtr and void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) beamPomBPtr are introduced, for the Pomerons residing inside the respective proton. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) CoupSM : Standard Model couplings. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) PartonSystems : the list of partons that belong to each individual subcollision system. void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) void UserHooks::initPtr( Info* infoPtr,  Settings* settingsPtr, ParticleData* particleDataPtr,  Rndm* rndmPtr, BeamParticle* beamAPtr, BeamParticle* beamBPtr,  BeamParticle* beamPomAPtr, BeamParticle* beamPomBPtr,  CoupSM* coupSMPtr, PartonSystems* partonSystemsPtr,  SigmaTotal* sigmaTotPtr) SigmaTotal : total/elastic/diffractive cross section parametrizations."},{"name":"void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false)","link":"UserHooks.html#anchor4","text":"void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) is a protected method that you can make use of in your own methods to extract a simplified list of the hard process, where all resonance decay chains are omitted. Intended for the void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) can/doVetoProcessLevel routines. Note that the normal process-level generation does include resonance decays. That is, if a top quark is produced in the hard process, then also decays such as void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) t &rarr; b W+, W+ &rarr; u dbar will be generated and stored in void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) process. The void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) omitResonanceDecays routine will take the input void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) process and copy it to void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) workEvent (see below), minus the resonance decay chains. All particles produced in the hard process, such as the top, will be considered final-state ones, with positive status and no daughters, just as it is before resonances are allowed to decay. void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) (In the void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) PartonLevel routines, these decay chains will initially not be copied from void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) process to void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) event. Instead the combined MPI, ISR and FSR evolution is done with the top above as final particle. Only afterwards will the resonance decay chains be copied over, with kinematics changes reflecting those of the top, and showers in the decays carried out.) void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) For the default void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) finalOnly = false the beam particles and incoming partons are retained, so the event looks like a normal event record up to the point of resonance decays, with a normal history setup. void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) With void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) finalOnly = true only the final-state partons are retained in the list. It therefore becomes similar in functionality to the void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) subEvent method below, with the difference that void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) subEvent counts the decay products of the resonances as the final state, whereas here the resonances themselves are the final state. Since the history has been removed in this option, void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) mother1() and void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) mother2() return 0, while void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) daughter1() and void UserHooks::omitResonanceDecays(const Event& process,  bool finalOnly = false) daughter2() both return the index of the same parton in the original event record."},{"name":"void UserHooks::subEvent(const Event& event,  bool isHardest = true)","link":"UserHooks.html#anchor5","text":"void UserHooks::subEvent(const Event& event,  bool isHardest = true) is a protected method that you can make use of in your own methods to extract a brief list of the current partons of interest, with all irrelevant ones omitted. It is primarily intended to track the evolution at the parton level, notably the shower evolution of the hardest (i.e. first) interaction. void UserHooks::subEvent(const Event& event,  bool isHardest = true) For the default void UserHooks::subEvent(const Event& event,  bool isHardest = true) isHardest = true only the outgoing partons from the hardest interaction (including the partons added to it by ISR and FSR) are extracted, as relevant e.g. for void UserHooks::subEvent(const Event& event,  bool isHardest = true) doVetoPT( iPos, event) with void UserHooks::subEvent(const Event& event,  bool isHardest = true) iPos = 0 - 4. With void UserHooks::subEvent(const Event& event,  bool isHardest = true) isHardest = false instead the outgoing partons of the latest 'subprocess' are extracted, as relevant when void UserHooks::subEvent(const Event& event,  bool isHardest = true) iPos = 5 , where it corresponds to the outgoing partons in the currently considered decay. void UserHooks::subEvent(const Event& event,  bool isHardest = true) The method also works at the process level, but there simply extracts all final-state partons in the event, and thus offers no extra functionality. void UserHooks::subEvent(const Event& event,  bool isHardest = true) The result is stored in void UserHooks::subEvent(const Event& event,  bool isHardest = true) workEvent below. Since the history has been removed, void UserHooks::subEvent(const Event& event,  bool isHardest = true) mother1() and void UserHooks::subEvent(const Event& event,  bool isHardest = true) mother2() return 0, while void UserHooks::subEvent(const Event& event,  bool isHardest = true) daughter1() and void UserHooks::subEvent(const Event& event,  bool isHardest = true) daughter2() both return the index of the same parton in the original event record ( void UserHooks::subEvent(const Event& event,  bool isHardest = true) event ; possibly void UserHooks::subEvent(const Event& event,  bool isHardest = true) process ), so that you can trace the full history, if of interest."},{"name":"void Vec4::bst(const Vec4& p)","link":"FourVectors.html#anchor68","text":"void Vec4::bst(const Vec4& p) boost the four-momentum by void Vec4::bst(const Vec4& p) beta = (p_x/E, p_y/E, p_z/E)."},{"name":"void Vec4::bst(const Vec4& p, double m)","link":"FourVectors.html#anchor69","text":"void Vec4::bst(const Vec4& p, double m) boost the four-momentum by void Vec4::bst(const Vec4& p, double m) beta = (p_x/E, p_y/E, p_z/E) , where the void Vec4::bst(const Vec4& p, double m) gamma = E/m is also calculated from input to allow better precision when void Vec4::bst(const Vec4& p, double m) beta is close to unity."},{"name":"void Vec4::bst(double betaX, double betaY, double betaZ)","link":"FourVectors.html#anchor66","text":"void Vec4::bst(double betaX, double betaY, double betaZ) boost the four-momentum by void Vec4::bst(double betaX, double betaY, double betaZ) beta = (beta_x, beta_y, beta_z)."},{"name":"void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma)","link":"FourVectors.html#anchor67","text":"void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma) boost the four-momentum by void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma) beta = (beta_x, beta_y, beta_z) , where the void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma) gamma = 1/sqrt(1 - beta^2) is also input to allow better precision when void Vec4::bst(double betaX, double betaY, double betaZ,  double gamma) beta is close to unity."},{"name":"void Vec4::bstback(const Vec4& p)","link":"FourVectors.html#anchor70","text":"void Vec4::bstback(const Vec4& p) boost the four-momentum by void Vec4::bstback(const Vec4& p) beta = (-p_x/E, -p_y/E, -p_z/E)."},{"name":"void Vec4::bstback(const Vec4& p, double m)","link":"FourVectors.html#anchor71","text":"void Vec4::bstback(const Vec4& p, double m) boost the four-momentum by void Vec4::bstback(const Vec4& p, double m) beta = (-p_x/E, -p_y/E, -p_z/E) , where the void Vec4::bstback(const Vec4& p, double m) gamma = E/m is also calculated from input to allow better precision when void Vec4::bstback(const Vec4& p, double m) beta is close to unity."},{"name":"void Vec4::e(double eIn)","link":"FourVectors.html#anchor11","text":"void Vec4::e(double eIn) sets the respective component to the input value."},{"name":"void Vec4::flip3()","link":"FourVectors.html#anchor61","text":"void Vec4::flip3() flip the sign of the three-vector components, but keep the fourth component unchanged."},{"name":"void Vec4::flip4()","link":"FourVectors.html#anchor62","text":"void Vec4::flip4() flip the sign of all four-vector components."},{"name":"void Vec4::p(double pxIn, double pyIn, double pzIn,  double eIn)","link":"FourVectors.html#anchor6","text":"void Vec4::p(double pxIn, double pyIn, double pzIn,  double eIn) sets all components to their input values."},{"name":"void Vec4::p(Vec4 pIn)","link":"FourVectors.html#anchor7","text":"void Vec4::p(Vec4 pIn) sets all components equal to those of the input four-vector."},{"name":"void Vec4::px(double pxIn)","link":"FourVectors.html#anchor8","text":"void Vec4::px(double pxIn)"},{"name":"void Vec4::py(double pyIn)","link":"FourVectors.html#anchor9","text":"void Vec4::py(double pyIn)"},{"name":"void Vec4::pz(double pzIn)","link":"FourVectors.html#anchor10","text":"void Vec4::pz(double pzIn)"},{"name":"void Vec4::rescale3(double f)","link":"FourVectors.html#anchor59","text":"void Vec4::rescale3(double f) multiply the three-vector components by void Vec4::rescale3(double f) f , but keep the fourth component unchanged."},{"name":"void Vec4::rescale4(double f)","link":"FourVectors.html#anchor60","text":"void Vec4::rescale4(double f) multiply all four-vector components by void Vec4::rescale4(double f) f."},{"name":"void Vec4::reset()","link":"FourVectors.html#anchor5","text":"void Vec4::reset() sets all components to 0."},{"name":"void Vec4::rot(double theta, double phi)","link":"FourVectors.html#anchor63","text":"void Vec4::rot(double theta, double phi) rotate the three-momentum with the polar angle void Vec4::rot(double theta, double phi) theta and the azimuthal angle void Vec4::rot(double theta, double phi) phi."},{"name":"void Vec4::rotaxis(double phi, double nx, double ny,  double nz)","link":"FourVectors.html#anchor64","text":"void Vec4::rotaxis(double phi, double nx, double ny,  double nz) rotate the three-momentum with the azimuthal angle void Vec4::rotaxis(double phi, double nx, double ny,  double nz) phi around the direction defined by the void Vec4::rotaxis(double phi, double nx, double ny,  double nz) (n_x, n_y, n_z) three-vector."},{"name":"void Vec4::rotaxis(double phi, Vec4& n)","link":"FourVectors.html#anchor65","text":"void Vec4::rotaxis(double phi, Vec4& n) rotate the three-momentum with the azimuthal angle void Vec4::rotaxis(double phi, Vec4& n) phi around the direction defined by the three-vector part of void Vec4::rotaxis(double phi, Vec4& n) n."},{"name":"void Vec4::rotbst(const RotBstMatrix& M)","link":"FourVectors.html#anchor72","text":"void Vec4::rotbst(const RotBstMatrix& M) perform a combined rotation and boost; see below for a description of the void Vec4::rotbst(const RotBstMatrix& M) RotBstMatrix."}];