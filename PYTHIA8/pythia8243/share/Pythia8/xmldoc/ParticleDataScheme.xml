<chapter name="The Particle Data Scheme"> 
 
<h2>The Particle Data Scheme</h2> 
 
The particle data scheme may take somewhat longer to understand than 
the settings one. In particular the set of methods to access information 
is rather more varied, to allow better functionality for advanced usage. 
However, PYTHIA does come with a sensible default set of particle 
properties and decay tables. Thus there is no need to learn any of the 
methods on this page to get going. Only when you perceive a specific need 
does it make sense to learn the basics. 
 
<p/> 
The central section on this page is the Operation one. The preceding 
sections are there mainly to introduce the basic structure and the set 
of properties that can be accessed. The subsequent sections provide a 
complete listing of the existing public methods, which most users 
probably will have little interaction with. 
 
<h3>Databases</h3> 
 
The management of particle data is based on three classes: 
<ul> 
<li><code>ParticleData</code>, which is the top-level class, with 
methods that can be used to interrogate all particle data. It contains 
a map of PDG particle identity numbers <ref>Yao06</ref> onto the relevant 
<code>ParticleDataEntry</code> objects,</li> 
<li><code>ParticleDataEntry</code>, which stores the relevant information 
on an individual particle species, and</li> 
<li><code>DecayChannel</code>, which stores info on one particular decay 
mode of a particle.</li> 
 
</ul> 
The objects of these classes together form a database that is 
continuously being used as the program has to assign particle masses, 
select decay modes, etc. 
 
<p/> 
Each <code>Pythia</code> object has a public member 
<code>particleData</code> of the <code>ParticleData</code> class. 
Therefore you access the particle data methods as 
<code>pythia.particleData.command(argument)</code>, 
assuming that <code>pythia</code> is an instance of the 
<code>Pythia</code> class. Further, for some of the most frequent user 
tasks, <code>Pythia</code> methods have been defined, so that 
<code>pythia.command(argument)</code> 
would work, see further below. 
 
<p/> 
A fundamental difference between the particle data classes and the 
settings ones is that the former are accessed regularly during the 
event generation process, as a new particle is produced and its mass 
need to be set, e.g., while the latter are mainly/only used 
at the initialization stage. Nevertheless, it is not a good idea to 
change data in either of them in mid-run, since this may lead to 
inconsistencies. 
 
<h3>Stored properties for particles</h3> 
 
The main properties stored for each particle are as follows. 
Different ways to set and get these properties will be described 
further down. 
 
<ul> 
 
<li><code>name</code>: a character string with the name of the 
particle. Particle and antiparticle names are stored separately, 
with <code>void</code> returned when no antiparticle exists.</li> 
 
<li><code>spinType</code>: the spin type, of the form <ei>2 s + 1</ei>, 
with special code 0 for entries of unknown or indeterminate spin.</li> 
 
<li><code>chargeType</code>: three times the charge (to make it an 
integer).</li> 
 
<li><code>colType</code>: the colour type, with 0 uncoloured, 1 triplet, 
-1 antitriplet and 2 octet. (A preliminary implementation of colour 
  sextets, available since version 8.150, further uses 3 for a sextet 
  and -3 for an antisextet.) </li> 
 
<li><code>m0</code>: the nominal mass <ei>m_0</ei> (in GeV).</li> 
 
<li><code>mWidth</code>: the width <ei>Gamma</ei> of the Breit-Wigner 
distribution (in GeV).</li> 
 
<li><code>mMin</code>: the lower limit of the allowed mass range 
generated by the Breit-Wigner (in GeV). Has no meaning for particles 
without width, and would typically be 0 there.</li> 
 
<li><code>mMax</code>: the upper limit of the allowed mass range 
generated by the Breit-Wigner (in GeV). If <ei>mMax &lt; mMin</ei> then 
no upper limit is imposed. Has no meaning for particles without width, 
and would typically be 0 there.</li> 
 
<li><code>tau0</code>: the nominal proper lifetime <ei>tau_0</ei> 
(in mm/c).</li> 
 
<li><code>isResonance</code>: a flag telling whether a particle species 
is considered as a resonance or not. Here 
<aloc href="ResonanceDecays">"resonance"</aloc> is used as shorthand 
for any massive particle where the decay process should be counted as part 
of the hard process itself, and thus be performed before showers and other 
event aspects are added. Restrictions on allowed decay channels is also 
directly reflected in the cross section of simulated processes, while 
those of normal hadrons and other light particles are not. 
In practice, it is reserved for states above the <ei>b bbar</ei> 
bound systems in mass, i.e. for <ei>W, Z, t</ei>, Higgs states, 
supersymmetric states and (most?) other states in any new theory. 
All particles with <code>m0</code> above 20 GeV are by default 
initialized to be considered as resonances.</li> 
 
<li><code>mayDecay</code>: a flag telling whether a particle species 
may decay or not, offering the main user switch. Whether a given particle 
of this kind then actually will decay also depends on it having allowed 
decay channels, and on other flags for 
<aloc href="ParticleDecays">particle decays</aloc> 
(or <aloc href="ResonanceDecays">resonance decays</aloc>). 
All particles with <code>tau0</code> below 1000 mm are 
by default initialized to allow decays.</li> 
 
<li><code>doExternalDecays</code>: a flag telling whether a particle 
should be handled by an external decay package or not, with the latter 
default. Can be manipulated as described on this page, but should 
normally not be. Instead the 
<code><aloc href="ExternalDecays">Pythia::decayPtr(...)</aloc></code> 
method should be provided with the list of relevant particles.</li> 
 
<li><code>isVisible</code>: a flag telling whether a particle species 
is to be considered as visible in a detector or not, as used e.g. in 
analysis routines. By default the invisibles include neutrinos, 
Dark Matter particles (codes 51 - 60) and a few BSM particles (gravitino, 
sneutrinos, neutralinos) that have neither strong nor electromagnetic 
charge, and are not made up of constituents that have it. The value of 
this flag is only relevant if a particle is long-lived enough actually 
to make it to a detector.</li> 
 
<li><code>doForceWidth</code>: a flag applicable only for resonances 
(see <code>isResonance</code> above), whereby it is possible to force 
resonances to retain their assigned width, whatever that is, see 
<aloc href="ResonanceDecays">Resonance Decays</aloc> for details.</li> 
 
</ul> 
 
<h3>Stored properties for decays</h3> 
 
An unstable particle has a decay table consisting of one or more 
decay channel. The following properties are stored for each such channel. 
Again different ways to set and get these properties will be described 
further down. 
<ul> 
 
<li><code>onMode</code>: integer code for use or not of channel,<br/> 
0 if a channel is off,<br/> 
1 if on,<br/> 
2 if on for a particle but off for an antiparticle,<br/> 
3 if on for an antiparticle but off for a particle.<br/> 
If a particle is its own antiparticle then 2 is on and 3 off 
but, of course, for such particles it is much simpler and safer 
to use only 1 and 0.<br/> 
The 2 and 3 options can be used e.g. to encode CP violation in 
B decays, or to let the <ei>W</ei>'s in a <ei>q qbar &rarr; W^+ W^-</ei> 
process decay in different channels. </li> 
 
<li><code>bRatio</code>: the branching ratio of the channel 
(with some reservations for resonances, see <code>meMode</code> 
below).</li> 
 
<li><code>meMode</code>: the mode of processing this channel, possibly 
with matrix elements; see the 
<aloc href="ParticleDecays">particle decays</aloc> and 
<aloc href="ResonanceDecays">resonance decays</aloc> 
descriptions for the list of possibilities. 
Notably the default code 0 for a particle means pure phase space 
decays according to the given branching ratios, while for a resonance 
it means that code exists for the dynamic calculations of partial 
widths and thereby branching ratios as a function of the resonance mass 
(which is done e.g. at initialization based on the mass set by the user). 
Then codes 1 - 99 are reserved for various matrix-element-improved 
ordinary particle decays, and 100 - 103 for resonances where the 
partial width of a given channel is calculated from the total width 
and the stored branching ratio. Thus, to enforce a new branching ratio 
for a resonance channel (with its own partial-width calculation code) 
it is not sufficient only to change the <code>bRatio</code> but also 
to set e.g. <code>meMode = 100</code>. </li> 
 
<li><code>multiplicity</code>: the number of decay products of the 
channel. Can be at most 8.</li> 
 
<li><code>product(i)</code>: the identity code of the decay products, 
where <code>i</code> runs between <code>0</code> and 
<code>multiplicity - 1</code>. Trailing positions are filled with 0. 
</li> 
 
</ul> 
 
<h3>Operation</h3> 
 
The normal flow of the particle data operations is: 
 
<ol> 
 
<li> 
When a <code>Pythia</code> object <code>pythia</code> is created, the 
<code>pythia.particleData</code> member is asked to scan the 
<code>ParticleData.xml</code> file. 
 
<p/> 
All lines beginning with <code>&lt;particle</code> are scanned for 
information on a particle species, and all lines beginning with 
<code>&lt;channel</code> are assumed to contain a decay channel of the 
enclosing particle. In both cases XML syntax is used, with attributes 
used to identify the stored properties, and with omitted properties 
defaulting back to 0 where meaningful. The particle and channel 
information may be split over several lines, up to the &gt; endtoken. 
The format of a <code>&lt;particle</code> tag is: 
<pre> 
    &lt;particle id="..." name="..." antiName="..." spinType="..." chargeType="..." colType="..." 
       m0="..." mWidth="..." mMin="..." mMax="..." tau0="..."&gt; 
    &lt;/particle&gt; 
</pre> 
where the fields are the properties already introduced above. 
Note that <code>isResonance</code>, <code>mayDecay</code>, 
<code>doExternalDecay</code>, <code>isVisible</code> and 
<code>doForceWidth</code> are not set here, but are provided with 
default values by the rules described above. Once initialized, also 
these latter properties can be changed, see below.<br/> 
 
The format of  a <code>&lt;channel></code> tag is: 
<pre> 
    &lt;channel onMode="..." bRatio="..." meMode="..." products="..." /&gt; 
</pre> 
again see properties above. The products are given as a blank-separated 
list of <code>id</code> codes. 
<note>Important</note>: the values in the <code>.xml</code> file should not 
be changed, except by the PYTHIA authors. Any changes should be done 
with the help of the methods described below. 
</li> 
 
<li> <p/> 
Between the creation of the <code>Pythia</code> object and the 
<code>init</code> call for it, you may use the methods of the 
<code>ParticleData</code> class to modify some of the default values. 
Several different approaches can be chosen for this. 
 
<p/> 
a) Inside your main program you can directly set values with 
<pre> 
    pythia.readString(string); 
</pre> 
where both the variable name and the value are contained inside 
the character string, separated by blanks and/or a =, e.g. 
<pre> 
    pythia.readString("111:mayDecay = off"); 
</pre> 
switches off the decays of the <ei>pi^0</ei>.<br/> 
 
The particle id (> 0) and the property to be changed must be given, 
separated by a colon.<br/> 
 
The allowed properties are: <code>name</code>, <code>antiName</code>, 
<code>spinType</code>, <code>chargeType</code>, <code>colType</code>, 
<code>m0</code>, <code>mWidth</code>, <code>mMin</code>, 
<code>mMax</code>, <code>tau0</code>, <code>isResonance</code>, 
<code>mayDecay</code>, <code>doExternalDecay</code>, 
<code>isVisible</code> and <code>doForceWidth</code>. All of these 
names are case-insensitive. Names that do not match an existing 
variable are ignored.<br/> 
 
Strings beginning with a non-alphanumeric character, like # or !, 
are assumed to be comments and are not processed at all. For 
<code>bool</code> values, the following notation may be used 
interchangeably: <code>true = on = yes = ok = 1</code>, while everything 
else gives <code>false</code> (including but not limited to 
<code>false</code>, <code>off</code>, <code>no</code> and 
<code>0</code>). 
 
<p/> 
Particle data often comes in sets of closely related information. 
Therefore some properties expect the value to consist of several 
numbers. These can then be separated by blanks (or by commas). 
A simple example is <code>names</code>, which expects both the 
name and antiname to be given. A more interesting one is the 
<code>all</code> property, 
<pre> 
    id:all = name antiName spinType chargeType colType m0 mWidth mMin mMax tau0 
</pre> 
where all the current information on the particle itself is replaced, 
but any decay channels are kept unchanged. Using <code>new</code> instead 
of <code>all</code> also removes any previous decay channels. 
If the string contains fewer fields than expected the trailing 
properties are set to vanish ("void", 0 or 0.). Note that such a 
truncated string should not be followed by a comment, since this 
comment would then be read in as if it contained the missing properties. 
The truncation can be done anywhere, specifically a string with only 
<code>id:new</code> defines a new "empty" particle. 
As before, <code>isResonance</code>, <code>mayDecay</code>, 
<code>doExternalDecay</code>, <code>isVisible</code> and 
<code>doForceWidth</code> are (re)set to their default values, and 
would have to be changed separately if required. 
 
<p/> 
A further command is <code>rescaleBR</code>, which rescales each of the 
existing branching ratios with a common factor, such that their new 
sum is the provided value. This may be a first step towards adding 
new decay channels, see further below. 
 
<p/> 
Alternatively the <code>id</code> code may be followed by another integer, 
which then gives the decay channel number. This then has to be 
followed by the property specific to this channel, either 
<code>onMode</code>, <code>bRatio</code>, <code>meMode</code> or 
<code>products</code>. In the latter case all the products of 
the channel should be given: 
<pre> 
    id:channel:products =  product1 product2 .... 
</pre> 
The line will be scanned until the end of the line, or until a 
non-number word is encountered, or until the maximum allowed number 
of eight products is encountered, whichever happens first. (Thus the 
multiplicity of a decay channel need not be input; it is automatically 
calculated from the products list.) It is also possible to replace all 
the properties of a channel in a similar way: 
<pre> 
    id:channel:all = onMode bRatio meMode product1 product2 .... 
</pre> 
To add a new channel at the end, use 
<pre> 
    id:addChannel = onMode bRatio meMode product1 product2 .... 
</pre> 
 
<p/> 
It is currently not possible to remove a channel selectively, but 
setting its branching ratio vanishing is as effective. If you want to 
remove all existing channels and force decays into one new channel 
you can use 
<pre> 
    id:oneChannel = onMode bRatio meMode product1 product2 .... 
</pre> 
 A first <code>oneChannel</code> command could be followed by 
several subsequent <code>addChannel</code> ones, to build 
up a completely new decay table for an existing particle. 
 
<p/> 
When adding new channels or changing branching ratios in general, 
note that, once a particle is to be decayed, the sum of branching 
ratios is always rescaled to unity. Beforehand, <code>rescaleBR</code> 
may be used to rescale an existing branching ratio by the given factor. 
 
<p/> 
There are a few commands that will study all the decay channels of the 
given particle, to switch them on or off as desired. The 
<pre> 
    id:onMode = onMode 
</pre> 
will set the <code>onMode</code> property of all channels to the 
desired value. The 
<pre> 
    id:offIfAny   = product1 product2 .... 
    id:onIfAny    = product1 product2 .... 
    id:onPosIfAny = product1 product2 .... 
    id:onNegIfAny = product1 product2 .... 
</pre> 
will set the <code>onMode</code> 0, 1, 2 or 3, respectively, for all 
channels which contain any of the enumerated products, where the matching 
to these products is done without distinction of particles and 
antiparticles. Note that "<code>Pos</code>" and "<code>Neg</code>" 
are slightly misleading since it refers to the particle and antiparticle 
of the <code>id</code> species rather than charge, but should still be 
simpler to remember and understand than alternative notations. 
Correspondingly 
<pre> 
    id:offIfAll   = product1 product2 .... 
    id:onIfAll    = product1 product2 .... 
    id:onPosIfAll = product1 product2 .... 
    id:onNegIfAll = product1 product2 .... 
</pre> 
will set the <code>onMode</code> 0, 1, 2 or 3, respectively, for all 
channels which contain all of the enumerated products, again without 
distinction of particles and antiparticles. If the same product appears 
twice in the list it must also appear twice in the decay channel, and 
so on. The decay channel is allowed to contain further particles, 
beyond the product list. By contrast, 
<pre> 
    id:offIfMatch   = product1 product2 .... 
    id:onIfMatch    = product1 product2 .... 
    id:onPosIfMatch = product1 product2 .... 
    id:onNegIfMatch = product1 product2 .... 
</pre> 
requires the decay-channel multiplicity to agree with that of the product 
list, but otherwise works as the <code>onIfAll/offIfAll</code> methods. 
 
<p/> 
Note that the action of several of the commands depends on the order 
in which they are executed, as one would logically expect. For instance, 
<code>id:oneChannel</code> removes all decay channels of <code>id</code> 
and thus all previous changes in this decay table, while subsequent 
additions or changes would still take effect. Another example would be that 
<code>23:onMode = off</code> followed by <code>23:onIfAny = 1 2 3 4 5</code> 
would let the <ei>Z^0</ei> decay to quarks, while no decays would be 
allowed if the order were to be reversed. 
 
<p/> 
b) The <code>Pythia</code> <code>readString(string)</code> method actually 
does not do changes itself, but sends on the string either to the 
<code>ParticleData</code> class or to the <code>Settings</code> one, 
depending on whether the string begins with a digit or a letter. 
If desired, it is possible to communicate directly with the corresponding 
<code>ParticleData</code> method: 
<pre> 
    pythia.particleData.readString("111:mayDecay = off"); 
    pythia.particleData.readString("15:2:products = 16 -211"); 
</pre> 
In this case, changes intended for <code>Settings</code> would not be 
understood. 
 
<p/> 
c) Underlying this are commands for all the individual properties in 
the <code>ParticleData</code> class, one for each. These are 
further described below. Thus, an example now reads 
<pre> 
    pythia.particleData.mayDecay(111, false); 
</pre> 
Boolean values should here be given as <code>true</code> or 
<code>false</code>. 
 
<p/> 
d) A simpler and more useful way is to collect all your changes 
in a separate file, with one line per change, e.g. 
<pre> 
    111:mayDecay = off 
</pre> 
The file can be read by the 
<pre> 
    pythia.readFile(fileName); 
</pre> 
method, where <code>fileName</code> is a string, e.g. 
<code>pythia.readFile("main.cmnd")</code> (or an <code>istream</code> 
instead of a <code>fileName</code>). Each line is processed as 
described for the string in 2a). This file can freely mix commands to 
the <code>Settings</code> and <code>ParticleData</code> classes. 
</li> 
 
<li> <p/> 
A routine <code>reInit(fileName)</code> is provided, and can be used to 
zero the particle data table and reinitialize it from scratch. 
Such a call might be useful if several subruns are to be made with 
widely different particle data - normally the maps are only built 
from scratch once, namely when the <code>Pythia()</code> object is 
created. Also, there is no other possibility to restore the default 
values, unlike for the settings. 
</li> 
 
<li> <p/> 
You may at any time obtain a listing of all the particle data by calling 
<pre> 
    pythia.particleData.listAll(); 
</pre> 
The listing is by increasing <code>id</code> number. It shows the basic 
quantities introduced above. Some are abbreviated in the header to fit on 
the lines: <code>spn = spinType</code>, <code>chg = chargeType</code>, 
<code>col = colType</code>, <code>res = isResonance</code>, 
<code>dec = mayDecay && canDecay</code> (the latter checks that decay 
channels have been defined), <code>ext = doExternalDecay</code>, 
<code>vis = isVisible</code> and <code>wid = doForceWidth</code>.<br/> 
 
To list only those particles that were changed (one way or another, the 
listing will not tell what property or decay channel was changed), instead use 
<pre> 
    pythia.particleData.listChanged(); 
</pre> 
(This info is based on a further <code>hasChanged</code> flag of a particle 
or a channel, set <code>true</code> whenever any of the changing methods are 
used. It is possible to manipulate this value, but this is not recommended.) 
By default the internal initialization of the widths of resonances such as 
<ei>gamma^*/Z^0, W^+-, t/tbar, H^0</ei> do not count as changes; if you want 
to list also those changes instead call <code>listChanged(true)</code>. 
<br/> 
 
To list only one particle, give its <code>id</code> code as argument to 
the <code>list(...)</code> function.. To list a restricted set of particles, 
give in their <code>id</code> codes to <code>list(...)</code> as a 
<code>vector&lt;int></code>. 
</li> 
 
<li> <p/> 
For wholesale changes of particle properties all available data can be 
written out, edited, and then read back in again. These methods are 
mainly intended for expert users. You can choose between two alternative 
syntaxes. 
 
<p/> 
a) XML syntax, using the <code>&lt;particle</code> and 
<code>&lt;channel</code> lines already described. You use the method 
<code>particleData.listXML(fileName)</code> to produce such an XML 
file and <code>particleData.readXML(fileName)</code> to read it back 
in after editing. 
 
<p/> 
b) Fixed/free format, using exactly the same information as illustrated 
for the <code>&lt;particle</code> and <code>&lt;channel</code> lines 
above, but now without any tags. This means that all information fields 
must be provided (if there is no antiparticle then write 
<code>void</code>), in the correct order (while the order is irrelevant 
with XML syntax), and all on one line. Information is written out in 
properly lined-up columns, but the reading is done using free format, 
so fields need only be separated by at least one blank. Each new particle 
is supposed to be separated by (at least) one blank line, whereas no 
blank lines are allowed between the particle line and the subsequent 
decay channel lines, if any.  You use the method 
<code>particleData.listFF(fileName)</code> to produce such a fixed/free 
file and <code>particleData.readFF(fileName)</code> to read it back 
in after editing. 
 
<p/> 
As an alternative to the <code>readXML</code> and <code>readFF</code> 
methods you can also use the 
<code>particleData.reInit(fileName, xmlFormat)</code> method, where 
<code>xmlFormat = true</code> (default) corresponds to reading an XML 
file and <code>xmlFormat = false</code> to a fixed/free format one. 
 
<p/> 
To check that the new particle and decay tables makes sense, you can use 
the <code>particleData.checkTable()</code> method, either directly or by 
switching it on among the standard 
<aloc href="ErrorChecks">error checks</aloc>. 
</li> 
 
</ol> 
 
<br/><hr/> 
<h3>The public methods</h3> 
 
In the following we present briefly the public methods in the three 
classes used to build up the particle database. The order 
is top-down, i.e from the full table of all particles to a single 
particle to a single channel. 
Note that these methods usually are less elegant and safe than the 
input methods outlined above. If you use any of these methods, it is 
likely to be the ones in the full database, i.e. the first ones to be 
covered in the following. 
 
<p/> 
For convenience, we have grouped related input and output methods 
together. It should be obvious from the context which is which: 
the input is of type <code>void</code> and has an extra last argument, 
namely is the input value, while the output method returns a 
quantity of the expected type. 
 
<h4>The ParticleData methods</h4> 
 
<method name="ParticleData::ParticleData()"> 
the constructor has no arguments and does not do anything. Internal. 
</method> 
 
<method name="ParticleData& operator=( const ParticleData& particleDataIn)"> 
copy the database from an existing <code>ParticleData</code> object. 
Can be useful when running with multiple <code>Pythia</code> instances. 
Does not include the links to the resonance decay handling set up by 
<code>initWidths(...)</code>. 
</method> 
 
<method name="void ParticleData::initPtr(Info* infoPtr, 
Settings* settingsPtrIn, Rndm* rndmPtrIn, CoupSM* coupSMPtrIn)"> 
initialize pointers to a few other classes. Internal. 
</method> 
 
<method name="bool ParticleData::init(string 
startFile = &quot;../share/Pythia8/xmldoc/ParticleData.xml&quot;)"> 
read in an XML-style file with particle data and initialize the 
particle data tables accordingly. This command is executed 
in the <code>Pythia</code> constructor, i.e. is mainly for 
internal use. 
<argument name="startFile" default ="../share/Pythia8/xmldoc/ParticleData.xml"> 
the name of the data file to be read. When called from the 
<code>Pythia</code> constructor the directory is provided by the 
<code><aloc href="ProgramFlow">PYTHIA8DATA</aloc></code> 
environment variable, if set, else by the argument of this constructor, 
which has the default value &quot;../share/Pythia8/xmldoc&quot;. 
</argument> 
</method> 
 
<method name="bool ParticleData::init(const ParticleData& particleDataIn"> 
copy particle data from information stored in an existing 
<code>ParticleData</code> instance. 
</method> 
 
<method name="bool ParticleData::init(istream& is"> 
copy particle data from a stream (rather than from a file). 
</method> 
 
<method name="bool ParticleData::reInit(string startFile, 
bool xmlFormat = true)"> 
overwrite the existing database by reading from the specified file. 
Unlike <code>init</code> above this method is not called by the 
<code>Pythia</code> constructor, but is entirely intended for users 
who want to replace the existing particle data with their own. 
<argument name="startFile">the path and name of file to be read. 
</argument> 
<argument name="xmlFormat">if true read the same kind of XML-style file 
as used by <code>init</code>, if not use an alternative "free format" 
file (i.e. without any XML tags, but with well-defined rules 
specifying in which order properties are stored). 
</argument> 
</method> 
 
<method name="void ParticleData::initWidths( 
vector&lt;ResonanceWidths*&gt; resonancePtrs)"> 
initialize Breit-Wigner shape parameters for all particles, 
and the detailed handling of resonances, i.e. particles with 
perturbatively calculable partial widths, which can be used to 
obtain a mass-dependent Breit-Wigner and a dynamic choice of 
decay channels. Called from <code>Pythia::init()</code>. 
</method> 
 
<method name="bool ParticleData::readXML(string inFile, 
bool reset = true)"> 
</method> 
<methodmore name="void ParticleData::listXML(string outFile)"> 
read in XML-style data from a file or write it out to a file. For the 
former one can also decide whether to reset all particles to scratch, 
or only overwrite those particles in the file. The former method is 
used by <code>init</code> and <code>reInit</code> above. 
</methodmore> 
 
<method name="bool ParticleData::readFF(string inFile, 
bool reset = true)"> 
</method> 
<methodmore name="void ParticleData::listFF(string outFile)"> 
read in free-format-style data from a file or write it out to a file. 
For the former one can also decide whether to reset all particles to 
scratch, or only overwrite those particles in the file. The former 
method is used by <code>reInit</code> above. 
</methodmore> 
 
<method name="bool ParticleData::readString(string line, 
bool warn = true)"> 
read in a string and interpret is as a new or changed particle data. 
The possibilities are extensively described above. It is normally 
used indirectly, via <code>Pythia::readString(...)</code> and 
<code>Pythia::readFile(...)</code>. 
<argument name="line"> 
the string to be interpreted as an instruction. 
</argument> 
<argument name="warn" default="on"> 
write a warning message or not whenever the instruction does not make 
sense, e.g. if the particle does not exist in the database. 
</argument> 
<note>Note:</note> the method returns false if it fails to 
make sense out of the input string. 
</method> 
 
<method name="void ParticleData::listAll()"> 
</method> 
<methodmore name="void ParticleData::listChanged(bool changedRes = false)"> 
</methodmore> 
<methodmore name="void ParticleData::list(bool changedOnly = false, 
bool changedRes = true)"> 
methods intended to present a listing of particle data in a readable 
format. The first two are special cases of the third. The first 
lists all particle data, the second only data for those particles that 
were changed after the original creation of the particle data table. 
Resonances are a special case since they can get their data changed 
by being linked to an object that does the calculation of branching 
ratios. By default the second method does not count such resonances 
as changed, whereas the third does and thus lists all resonances. 
</methodmore> 
 
<method name="void ParticleData::list(int idList)"> 
</method> 
<methodmore name="void ParticleData::list(vector&lt;int&gt; idList)"> 
list particle data for one single particle, with the identity code as 
input, or for a set of particles, with an input vector of identity codes. 
</methodmore> 
 
<method name="vector&lt;string&gt; ParticleData::getReadHistory()"> 
Method to retrieve the history of <code>readString</code> commands that 
have been processed by the <code>ParticleData</code> instance, e.g. for 
inspection. Note that <code>ParticleData</code> commands read by 
<code>Pythia::readString</code> and <code>Pythia::readFile</code> 
are interpreted by <code>readString</code> and thus also are listed. 
</method> 
 
<method name="vector&lt;string&gt; ParticleData::getReadHistory(int subrun)"> 
Method to retrieve the history of <code>readString</code> commands that 
have been processed by the <code>ParticleData</code> instance, for a 
specific subrun (see the section on <aidx href="MainProgramSettings"> 
Main-Program Settings</aidx>). For <code>subrun = -1</code>, returns the 
<code>readString</code> history common to all subruns. For 
<code>subrun >= 0</code>, returns the history of <code>readString</code> 
commands for that specific subrun (omitting the common part). 
</method> 
 
<method name="void ParticleData::checkTable(int verbosity)"> 
check that the particle decay table makes sense, especially for decays. 
<argument name="verbosity"> level of checks. 0 is only minimal, 
e.g. if a particle has no open decay channels. 1, which is the level 
of the first method, provides warning if any individual channel is 
closed, except for resonances. 2 also prints the 
branching-ratio-averaged threshold mass. 11 and 12 are like 1 and 2, 
but also include resonances in the detailed checks. 
</argument> 
</method> 
 
<method name="void ParticleData::addParticle(int id, 
string name = &quot; &quot;, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0., 
double mMax = 0., double tau0 = 0.)"> 
</method> 
<methodmore name="void ParticleData::addParticle(int id, 
string name, string antiName, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0., 
double mMax = 0., double tau0 = 0.)"> 
add a particle to the decay table; in the first form a particle which is 
its own antiparticle, in the second where a separate antiparticle exists. 
</methodmore> 
 
<method name="void ParticleData::setAll(int id, 
string name, string antiName, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0., 
double mMax = 0.,double tau0 = 0.)"> 
change all the properties of the particle associated with a given 
identity code. 
</method> 
 
<method name="bool ParticleData::isParticle(int id)"> 
query whether the particle data table contains the particle of the 
identity code. 
</method> 
 
<method name="ParticleDataEntry* ParticleData::findParticle(int id)"> 
</method> 
<methodmore name="const ParticleDataEntry* ParticleData::findParticle(int id)"> 
query whether the particle data table contains the particle of the 
identity code, and if so return a (const) iterator to it. 
</methodmore> 
 
<method name="int ParticleData::nextId(int id)"> 
return the identity code of the sequentially next particle stored in table. 
</method> 
 
<method name="bool ParticleData::hasAnti(int id)"> 
bool whether a distinct antiparticle exists or not. Is true if an 
antiparticle name has been set (and is different from 
<code>void</code>). 
</method> 
 
<method name="void ParticleData::name(int id, string name)"> 
</method> 
<methodmore name="void ParticleData::antiName(int id, string antiName)"> 
</methodmore> 
<methodmore name="void ParticleData::names(int id, 
string name, string antiName)"> 
</methodmore> 
<methodmore name="string ParticleData::name(int id)"> 
particle and antiparticle names are stored separately, the sign of 
<code>id</code> determines which of the two is returned, with 
<code>void</code> used to indicate the absence of an antiparticle. 
</methodmore> 
 
<method name="void ParticleData::spinType(int id, int spinType)"> 
</method> 
<methodmore name="int ParticleData::spinType(int id)"> 
the spin type, of the form <ei>2 s + 1</ei>, with special code 0 
for entries of unknown or indeterminate spin. 
</methodmore> 
 
<method name="void ParticleData::chargeType(int id, int chargeType)"> 
</method> 
<methodmore name="int ParticleData::chargeType(int id)"> 
three times the charge (to make it an integer), taking into account 
the sign of <code>id</code>. 
</methodmore> 
 
<method name="double ParticleData::charge(int id)"> 
the electrical charge of a particle, equal to 
<code>chargeType(id)/3</code>. 
</method> 
 
<method name="void ParticleData::colType(int id, int colType)"> 
</method> 
<methodmore name="int ParticleData::colType(int id)"> 
the colour type, with 0 uncoloured, 1 triplet, -1 antitriplet and 2 
octet, taking into account the sign of <code>id</code>. 
</methodmore> 
 
<method name="void ParticleData::m0(int id, double m0)"> 
</method> 
<methodmore name="double ParticleData::m0(int id)"> 
the nominal mass <ei>m_0</ei> (in GeV). 
</methodmore> 
 
<method name="void ParticleData::mWidth(int id, double mWidth)"> 
</method> 
<methodmore name="double ParticleData::mWidth(int id)"> 
the width <ei>Gamma</ei> of the Breit-Wigner distribution (in GeV). 
</methodmore> 
 
<method name="void ParticleData::mMin(int id, double mMin)"> 
</method> 
<methodmore name="double ParticleData::mMin(int id)"> 
the lower limit of the allowed mass range generated by the Breit-Wigner 
(in GeV). Has no meaning for particles without width, and would 
typically be 0 there. 
</methodmore> 
 
<method name="void ParticleData::mMax(int id, double mMax)"> 
</method> 
<methodmore name="double ParticleData::mMax(int id)"> 
the upper limit of the allowed mass range generated by the Breit-Wigner 
(in GeV). If <ei>mMax &lt; mMin</ei> then no upper limit is imposed. 
Has no meaning for particles without width, and would typically 
be 0 there. 
</methodmore> 
 
<method name="double ParticleData::m0Min(int id)"> 
similar to <code>mMin()</code> above, except that for particles with 
no width the <code>m0(id)</code> value is returned. 
</method> 
 
<method name="double ParticleData::m0Max(int id)"> 
similar to <code>mMax()</code> above, except that for particles with 
no width the <code>m0(id)</code> value is returned. 
</method> 
 
<method name="void ParticleData::tau0(int id, double tau0)"> 
</method> 
<methodmore name="double ParticleData::tau0(int id)"> 
the nominal proper lifetime <ei>tau_0</ei> (in mm/c). 
</methodmore> 
 
<method name="void ParticleData::isResonance(int id, bool isResonance)"> 
</method> 
<methodmore name="bool ParticleData::isResonance(int id)"> 
a flag telling whether a particle species are considered as a resonance 
or not. Here <aloc href="ResonanceDecays">"resonance"</aloc> 
is used as shorthand for any massive particle 
where the decay process should be counted as part of the hard process 
itself, and thus be performed before showers and other event aspects 
are added. Restrictions on allowed decay channels is also directly 
reflected in the cross section of simulated processes, while those of 
normal hadrons and other light particles are not. 
In practice, it is reserved for states above the <ei>b bbar</ei> 
bound systems in mass, i.e. for <ei>W, Z, t</ei>, Higgs states, 
supersymmetric states and (most?) other states in any new theory. 
All particles with <code>m0</code> above 20 GeV are by default 
initialized to be considered as resonances. 
</methodmore> 
 
<method name="void ParticleData::mayDecay(int id, bool mayDecay)"> 
</method> 
<methodmore name="bool ParticleData::mayDecay(int id)"> 
a flag telling whether a particle species may decay or not, offering 
the main user switch. Whether a given particle of this kind then actually 
will decay also depends on it having allowed decay channels, and on 
other flags for <aloc href="ParticleDecays">particle decays</aloc> 
(or <aloc href="ResonanceDecays">resonance decays</aloc>). 
All particles with <code>tau0</code> below 1000 mm are 
by default initialized to allow decays. 
</methodmore> 
 
<method name="void ParticleData::doExternalDecays(int id, 
bool doExternalDecays)"> 
</method> 
<methodmore name="bool ParticleData::doExternalDecay(int id)"> 
a flag telling whether a particle should be handled by an external 
decay package or not, with the latter default. Can be manipulated as 
described on this page, but should normally not be. Instead the 
<code><aloc href="ExternalDecays">pythia.decayPtr</aloc></code> 
method should be provided with the list of relevant particles. 
</methodmore> 
 
<method name="void ParticleData::isVisible(int id, bool isVisible)"> 
</method> 
<methodmore name="bool ParticleData::isVisible(int id)"> 
a flag telling whether a particle species is to be considered as 
visible in a detector or not, as used e.g. in analysis routines. 
By default the invisibles include neutrinos, Dark Matter particles 
(codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, 
neutralinos) that have neither strong nor electromagnetic charge, 
and are not made up of constituents that have it. The value of this 
flag is only relevant if a particle is long-lived enough actually 
to make it to a detector. 
</methodmore> 
 
<method name="void ParticleData::doForceWidth(int id, bool doForceWidth)"> 
</method> 
<methodmore name="bool ParticleData::doForceWidth(int id)"> 
a flag applicable only for resonances (see <code>isResonance</code> above), 
whereby it is possible to force resonances to retain their assigned widths, 
whatever that is, see <aloc href="ResonanceDecays">Resonance Decays</aloc> 
for details. The normal behaviour is <code>false</code>, i.e. the width 
is based on hardcoded calculations whenever available. 
</methodmore> 
 
<method name="void ParticleData::hasChanged(int id, bool hasChanged)"> 
</method> 
<methodmore name="bool ParticleData::hasChanged(int id)"> 
keep track of whether the data for a particle has been changed 
in any respect between initialization and the current status. 
Is used e.g. by the <code>listChanged</code> method to determine 
which particles to list. 
</methodmore> 
 
<method name="bool ParticleData::useBreitWigner(int id)"> 
tells whether a particle will have a Breit-Wigner mass distribution or 
not. Is determined by an internal logic based on the particle width and 
on the value of the 
<code><aloc href="ParticleData">ParticleData:modeBreitWigner</aloc></code> 
switch. 
</method> 
 
<method name="double ParticleData::constituentMass(int id)"> 
is the constituent mass for a quark, hardcoded as 
<ei>m_u = m_d = 0.325</ei>, <ei>m_s = 0.50</ei>, <ei>m_c = 1.60</ei> 
and <ei>m_b = 5.0</ei> GeV, for a diquark the sum of quark constituent 
masses, and for everything else the same as the ordinary mass. 
</method> 
 
<method name="double ParticleData::mSel(int id)"> 
returns a mass distributed according to a truncated Breit-Wigner, 
with parameters as described here. Is equal to <code>m0(id)</code> for 
particles without width. 
</method> 
 
<method name="double ParticleData::mRun(int id, double mH)"> 
calculate the running mass of species <code>id</code> when probed at a 
hard mass scale of <code>mH</code>. Only applied to obtain the 
running quark masses; for all other particle the normal fixed mass 
is used. 
</method> 
 
<method name="bool ParticleData::canDecay(int id)"> 
true for a particle with at least one decay channel defined. 
</method> 
 
<method name="bool ParticleData::isLepton(int id)"> 
true for a lepton or an antilepton (including neutrinos). 
</method> 
 
<method name="bool ParticleData::isQuark(int id)"> 
true for a quark or an antiquark. 
</method> 
 
<method name="bool ParticleData::isGluon(int id)"> 
true for a gluon. 
</method> 
 
<method name="bool ParticleData::isDiquark(int id)"> 
true for a diquark or antidiquark. 
</method> 
 
<method name="bool ParticleData::isParton()"> 
true for a gluon, a quark or antiquark up to the b (but excluding top), 
and a diquark or antidiquark consisting of quarks up to the b. 
</method> 
 
<method name="bool ParticleData::isHadron(int id)"> 
true for a hadron (made up out of normal quarks and gluons, 
i.e. not for R-hadrons and other exotic states). 
</method> 
 
<method name="bool ParticleData::isMeson(int id)"> 
true for a meson. 
</method> 
 
<method name="bool ParticleData::isBaryon(int id)"> 
true for a baryon or antibaryon. 
</method> 
 
<method name="bool ParticleData::isOnium(int id)"> 
true for a charmonium, bottomonium or (hypothetical) toponium state, 
i.e any state composed of <ei>c cbar</ei>, <ei>b bbar</ei> or 
<ei>t tbar</ei> irrespective of colour (singlet or octet) and 
spin, angular momentum or radial excitation. 
</method> 
 
<method name="bool ParticleData::isOctetHadron(int id)"> 
true for an intermediate hadron-like state with a colour octet charge 
as used in the colour octet model for 
<aloc href="OniaProcesses">onia</aloc> production. 
</method> 
 
<method name="int ParticleData::heaviestQuark(int id)"> 
extracts the heaviest quark or antiquark, i.e. one with largest 
<code>id</code> number, for a hadron. 
</method> 
 
<method name="int ParticleData::baryonNumberType(int id)"> 
is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a 
minus sign for antiparticles, and else zero. 
</method> 
 
<method name="void ParticleData::rescaleBR(int id, double newSumBR = 1.)"> 
rescales all partial branching ratios by a common factor, such that 
the sum afterward becomes <code>newSumBR</code>. 
</method> 
 
<method name="void setResonancePtr(int id, ResonanceWidths* resonancePtr)"> 
set a pointer for a particle kind to a <code>ResonanceWidths</code> object. 
This is done, from inside <code>ParticleData::initWidths</code>, only for 
resonances, i.e. for particles such as <ei>Z^0</ei>, <ei>W^+-</ei>, top, 
Higgs, and new unstable states beyond the Standard Model. The presence 
of such an object will allow a more dynamic calculation of partial and 
total widths, as illustrated by the following methods. 
</method> 
 
<method name="void ParticleData::resInit(int id)"> 
initialize the treatment of a resonance. 
</method> 
 
<method name="double ParticleData::resWidth(int id, double mHat, 
int idInFlav = 0, bool openOnly = false, bool setBR = false)"> 
calculate the total with for a resonance of a given current mass, 
optionally including coupling to incoming flavour state (consider 
the <ei>gamma*/Z^0</ei> combination), optionally excluding decay 
channels that have been closed by the user, and optionally storing 
the results in the normal decay table. 
</method> 
 
<method name="double ParticleData::resWidthOpen(int id, double mHat, 
int idInFlav = 0)"> 
special case of <code>resWidth</code>, where only open channels are 
included, but results are not stored in the normal decay table. 
</method> 
 
<method name="double ParticleData::resWidthStore(int id, double mHat, 
int idInFlav = 0)"> 
special case of <code>resWidth</code>, where only open channels are 
included, and results are stored in the normal decay table. 
</method> 
 
<method name="double ParticleData::resOpenFrac(int id1, int id2 = 0, 
int id3 = 0)"> 
calculate the fraction of the full branching ratio that is left 
open by the user choice of allowed decay channels. Can be applied 
to a final state with up to three resonances. Since the procedure 
is multiplicative, it would be easy to generalize also to more. 
</method> 
 
<method name="double ParticleData::resWidthRescaleFactor(int id)"> 
the factor used to rescale all partial widths in case the total 
width is being forced to a specific value by the user. 
</method> 
 
<method name="double ParticleData::resWidthChan(int id, 
double mHat, int idAbs1 = 0, int idAbs2 = 0)"> 
special case to calculate one final-state width; currently only used 
for Higgs decay to <ei>q qbar</ei>, <ei>g g</ei> or 
<ei>gamma gamma</ei>. 
</method> 
 
<method name="ParticleDataEntry* 
ParticleData::particleDataEntryPtr(int id)"> 
returns a pointer to the <code>ParticleDataEntry</code> object. 
The methods in the next section can then be used to manipulate 
this object. 
</method> 
 
<method name="bool ParticleData::getIsInit()"> 
return true if the database has been initialized, else false. 
</method> 
 
<h4>The ParticleDataEntry methods</h4> 
 
Most of the methods that can be applied to a single 
<code>ParticleDataEntry</code> object are almost identical with 
those used above for the <code>ParticleData</code>, except 
that the <code>id</code> argument is no longer needed to find 
the right entry in the table. By and large, this makes direct 
access to the <code>ParticleDataEntry</code> methods superfluous. 
There are a few methods that are unique to each class, however. 
Furthermore, to avoid some naming ambiguities, many methods that 
set values begin with <code>set</code>. 
 
<method name="ParticleDataEntry::ParticleDataEntry(int id = 0, 
string name = &quot; &quot;, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., 
double mMin = 0., double mMax = 0., double tau0 = 0.)"> 
</method> 
<methodmore name="ParticleDataEntry::ParticleDataEntry(int id, 
string name, string antiName, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., 
double mMin = 0., double mMax = 0., double tau0 = 0.)"> 
there are two alternative constructors, that both expect the 
properties of a particle as input. The first assumes that there 
is only one particle, the latter that there is a 
particle-antiparticle pair (but if the antiparticle name is 
<code>void</code> one reverts back to the particle-only case). 
</methodmore> 
 
<method name="ParticleDataEntry& operator=( const ParticleDataEntry& 
particleDataEntryIn)"> 
copy the values stored in an existing <code>ParticleDataEntry</code> 
object. 
</method> 
 
<method name="ParticleDataEntry::~ParticleDataEntry"> 
the destructor is needed to delete any <code>ResonanceWidths</code> 
objects that have been created and linked to the respective particle. 
</method> 
 
<method name="void ParticleDataEntry::setDefaults()"> 
initialize some particle flags with default values, e.g. whether 
a particle is a resonance, may decay, or is visible. Is called from the 
constructors and from <code>setAll</code>. 
</method> 
 
<method name="void ParticleDataEntry::initPtr(ParticleData* 
particleDataPtrIn)"> 
initialize pointer back to the whole database (so that masses of 
decay products can be accessed, e.g.). 
</method> 
 
<method name="void ParticleDataEntry::setAll( 
string name, string antiName, int spinType = 0, int chargeType = 0, 
int colType = 0, double m0 = 0., double mWidth = 0., double mMin = 0., 
double mMax = 0.,double tau0 = 0.)"> 
change all the properties of the particle associated with a given 
identity code. 
</method> 
 
<method name="int ParticleDataEntry::id()"> 
the PDG identity code. 
</method> 
 
<method name="bool ParticleDataEntry::hasAnti()"> 
tell whether a separate antiparticle exists. 
</method> 
 
<method name="void ParticleDataEntry::setName(string name)"> 
</method> 
<methodmore name="void ParticleDataEntry::setAntiName(string antiName)"> 
</methodmore> 
<methodmore name="void ParticleDataEntry::setNames(string name, 
string antiName)"> 
</methodmore> 
<methodmore name="string ParticleDataEntry::name(int id = 1)"> 
set or get the particle or antiparticle name. Only the sign of 
<code>id</code> is needed to distinguish particle/antiparticle. 
</methodmore> 
 
<method name="void ParticleDataEntry::setSpinType(int spinType)"> 
</method> 
<methodmore name="int ParticleDataEntry::spinType()"> 
set or get the particle spin type, i.e. <ei>2 s + 1</ei>, or 0 in some 
special cases. 
</methodmore> 
 
<method name="void ParticleDataEntry::setChargeType(int chargeType)"> 
</method> 
<methodmore name="int ParticleDataEntry::chargeType(int id = 1)"> 
</methodmore> 
<methodmore name="double ParticleDataEntry::charge(int id = 1)"> 
set or get the particle charge type, i.e. three times the charge, 
or the charge itself. Only the sign of <code>id</code> is needed 
to distinguish particle/antiparticle. 
</methodmore> 
 
<method name="void ParticleDataEntry::setColType(int colType)"> 
</method> 
<methodmore name="int ParticleDataEntry::colType(int id = 1)"> 
set or get the particle colour type, 0 for singlet, 1 for triplet, 
-1 for antitriplet, 2 for octet. Only the sign of <code>id</code> 
is needed to distinguish particle/antiparticle. 
</methodmore> 
 
<method name="void ParticleDataEntry::setM0(double m0)"> 
</method> 
<methodmore name="double ParticleDataEntry::m0()"> 
the nominal mass <ei>m_0</ei> (in GeV). 
</methodmore> 
 
<method name="void ParticleDataEntry::setMWidth(double mWidth)"> 
</method> 
<methodmore name="double ParticleDataEntry::mWidth()"> 
the width <ei>Gamma</ei> of the Breit-Wigner distribution (in GeV). 
</methodmore> 
 
<method name="void ParticleDataEntry::setMMin(double mMin)"> 
</method> 
<methodmore name="double ParticleDataEntry::mMin()"> 
the lower limit of the allowed mass range generated by the Breit-Wigner 
(in GeV). Has no meaning for particles without width, and would 
typically be 0 there. 
</methodmore> 
 
<method name="void ParticleDataEntry::setMMax(double mMax)"> 
</method> 
<methodmore name="double ParticleDataEntry::mMax()"> 
the upper limit of the allowed mass range generated by the Breit-Wigner 
(in GeV). If <ei>mMax &lt; mMin</ei> then no upper limit is imposed. 
Has no meaning for particles without width, and would typically 
be 0 there. 
</methodmore> 
 
<method name="double ParticleDataEntry::m0Min()"> 
similar to <code>mMin()</code> above, except that for particles with 
no width the <code>m0(id)</code> value is returned. 
</method> 
 
<method name="double ParticleDataEntry::m0Max()"> 
similar to <code>mMax()</code> above, except that for particles with 
no width the <code>m0(id)</code> value is returned. 
</method> 
 
<method name="void ParticleDataEntry::setTau0(double tau0, 
bool countAsChanged = true)"> 
</method> 
<methodmore name="double ParticleDataEntry::tau0()"> 
the nominal proper lifetime <ei>tau_0</ei> (in mm/c). Second argument of 
input method for internal use only. 
</methodmore> 
 
<method name="void ParticleDataEntry::setIsResonance(bool isResonance)"> 
</method> 
<methodmore name="bool ParticleDataEntry::isResonance()"> 
a flag telling whether a particle species are considered as a resonance 
or not. Here <aloc href="ResonanceDecays">"resonance"</aloc> 
is used as shorthand for any massive particle 
where the decay process should be counted as part of the hard process 
itself, and thus be performed before showers and other event aspects 
are added. Restrictions on allowed decay channels is also directly 
reflected in the cross section of simulated processes, while those of 
normal hadrons and other light particles are not. 
In practice, it is reserved for states above the <ei>b bbar</ei> 
bound systems in mass, i.e. for <ei>W, Z, t</ei>, Higgs states, 
supersymmetric states and (most?) other states in any new theory. 
All particles with <code>m0</code> above 20 GeV are by default 
initialized to be considered as resonances. 
</methodmore> 
 
<method name="void ParticleDataEntry::setMayDecay(bool mayDecay)"> 
</method> 
<methodmore name="bool ParticleDataEntry::mayDecay()"> 
a flag telling whether a particle species may decay or not, offering 
the main user switch. Whether a given particle of this kind then actually 
will decay also depends on it having allowed decay channels, and on 
other flags for <aloc href="ParticleDecays">particle decays</aloc> 
(or <aloc href="ResonanceDecays">resonance decays</aloc>). 
All particles with <code>tau0</code> below 1000 mm are 
by default initialized to allow decays. 
</methodmore> 
 
<method name="void ParticleDataEntry::setDoExternalDecays(bool 
doExternalDecays)"> 
</method> 
<methodmore name="bool ParticleDataEntry::doExternalDecay()"> 
a flag telling whether a particle should be handled by an external 
decay package or not, with the latter default. Can be manipulated as 
described on this page, but should normally not be. Instead the 
<code><aloc href="ExternalDecays">pythia.decayPtr</aloc></code> 
method should be provided with the list of relevant particles. 
</methodmore> 
 
<method name="void ParticleDataEntry::setIsVisible(bool isVisible)"> 
</method> 
<methodmore name="bool ParticleDataEntry::isVisible()"> 
a flag telling whether a particle species is to be considered as 
visible in a detector or not, as used e.g. in analysis routines. 
By default the invisibles include neutrinos, Dark Matter particles 
(codes 51 - 60) and a few BSM particles (gravitino, sneutrinos, 
neutralinos) that have neither strong nor electromagnetic charge, 
and are not made up of constituents that have it. The value of this 
flag is only relevant if a particle is long-lived enough actually 
to make it to a detector. 
</methodmore> 
 
<method name="void ParticleDataEntry::setDoForceWidth(bool 
doForceWidth)"> 
</method> 
<methodmore name="bool ParticleDataEntry::doForceWidth()"> 
a flag applicable only for resonances (see <code>isResonance</code> above), 
whereby it is possible to force resonances to retain their assigned widths, 
whatever that is, see <aloc href="ResonanceDecays">Resonance Decays</aloc> 
for details. The normal behaviour is <code>false</code>, i.e. the width 
is based on hardcoded calculations whenever available. 
</methodmore> 
 
<method name="void ParticleDataEntry::setHasChanged(bool hasChanged)"> 
</method> 
<method name="void ParticleDataEntry::hasChanged(bool hasChanged)"> 
keep track of whether the data for a particle has been changed 
in any respect between initialization and the current status. 
Is used e.g. by the <code>ParticleData::listChanged</code> method 
to determine which particles to list. 
</method> 
 
<method name="void ParticleDataEntry::initBWmass()"> 
Prepare the Breit-Wigner mass selection by precalculating 
frequently-used expressions. 
</method> 
 
<method name="double ParticleDataEntry::constituentMass()"> 
is the constituent mass for a quark, hardcoded as 
<ei>m_u = m_d = 0.325</ei>, <ei>m_s = 0.50</ei>, <ei>m_c = 1.60</ei> 
and <ei>m_b = 5.0</ei> GeV, for a diquark the sum of quark constituent 
masses, and for everything else the same as the ordinary mass. 
</method> 
 
<method name="double ParticleDataEntry::mSel()"> 
give the mass of a particle, either at the nominal value 
or picked according to a (linear or quadratic) Breit-Wigner. 
</method> 
 
<method name="double ParticleDataEntry::mRun(double mH)"> 
calculate the running quark mass at a hard scale <code>mH</code>. 
For other particles the on-shell mass is given. 
</method> 
 
<method name="bool ParticleDataEntry::useBreitWigner()"> 
tells whether a particle will have a Breit-Wigner mass distribution or 
not. Is determined by an internal logic based on the particle width and 
on the value of the <code><aloc href="ParticleData"> 
ParticleData:modeBreitWigner</aloc></code> switch. 
</method> 
 
<method name="bool ParticleDataEntry::canDecay(int id)"> 
true for a particle with at least one decay channel defined. 
</method> 
 
<method name="bool ParticleDataEntry::isLepton()"> 
true for a lepton or an antilepton (including neutrinos). 
</method> 
 
<method name="bool ParticleDataEntry::isQuark()"> 
true for a quark or an antiquark. 
</method> 
 
<method name="bool ParticleDataEntry::isGluon()"> 
true for a gluon. 
</method> 
 
<method name="bool ParticleDataEntry::isDiquark()"> 
true for a diquark or antidiquark. 
</method> 
 
<method name="bool ParticleDataEntry::isParton()"> 
true for a gluon, a quark or antiquark up to the b (but excluding top), 
and a diquark or antidiquark consisting of quarks up to the b. 
</method> 
 
<method name="bool ParticleDataEntry::isHadron()"> 
true for a hadron (made up out of normal quarks and gluons, 
i.e. not for R-hadrons and other exotic states). 
</method> 
 
<method name="bool ParticleDataEntry::isMeson()"> 
true for a meson. 
</method> 
 
<method name="bool ParticleDataEntry::isBaryon()"> 
true for a baryon or antibaryon. 
</method> 
 
<method name="bool ParticleDataEntry::isOctetHadron()"> 
true for an intermediate hadron-like state with a colour octet charge 
as used in the colour octet model for 
<aloc href="OniaProcesses">onia</aloc> production. 
</method> 
 
<method name="int ParticleDataEntry::heaviestQuark(int id)"> 
extracts the heaviest quark or antiquark, i.e. one with largest 
<code>id</code> number, for a hadron. Only the sign of the input 
argument is relevant. 
</method> 
 
<method name="int ParticleDataEntry::baryonNumberType(int id)"> 
is 1 for a quark, 2 for a diquark, 3 for a baryon, the same with a 
minus sign for antiparticles, and else zero. Only the sign of the 
input argument is relevant. 
</method> 
 
<method name="void ParticleDataEntry::clearChannels()"> 
resets to an empty decay table. 
</method> 
 
<method name="void ParticleDataEntry::addChannel(int onMode = 0, 
double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0, 
int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0, 
int prod6 = 0,  int prod7 = 0,)"> 
adds a decay channel with up to 8 products. 
</method> 
 
<method name="int ParticleDataEntry::sizeChannels()"> 
returns the number of decay channels for a particle. 
</method> 
 
<method name="DecayChannel& ParticleDataEntry::channel(int i)"> 
</method> 
<methodmore name="const DecayChannel& ParticleDataEntry::channel(int i)"> 
gain access to a specified channel in the decay table. 
</methodmore> 
 
<method name="void ParticleDataEntry::rescaleBR(double newSumBR = 1.)"> 
rescales all partial branching ratios by a common factor, such that 
the sum afterward becomes <code>newSumBR</code>. 
</method> 
 
<method name="bool ParticleDataEntry::preparePick(int idSgn, 
double mHat = 0., int idInFlav = 0)"> 
prepare to pick a decay channel. 
</method> 
 
<method name="DecayChannel& ParticleDataEntry::pickChannel()"> 
pick a decay channel according to branching ratios from 
<code>preparePick</code>. 
</method> 
 
<method name="void ParticleDataEntry::setResonancePtr(ResonanceWidths* 
resonancePtr)"> 
</method> 
<methodmore name="ResonanceWidths* ParticleDataEntry::getResonancePtr()"> 
set or get a pointer to an object that can be used for dynamic calculation 
of partial and total resonance widths. Here a resonance is a particle 
such as top, <ei>Z^0</ei>, <ei>W^+-</ei>, Higgs, and new unstable states 
beyond the Standard Model. 
</methodmore> 
 
<method name="void ParticleDataEntry::resInit(Info* infoPtrIn, 
Settings* settingsPtrIn, ParticleData* particleDataPtrIn, 
CoupSM* coupSMPtrIn)"> 
initialize the treatment of a resonance. 
</method> 
 
<method name="double ParticleDataEntry::resWidth(int idSgn, 
double mHat, int idInFlav = 0, bool openOnly = false, 
bool setBR = false)"> 
calculate the total with for a resonance of a given current mass, 
optionally including coupling to incoming flavour state (consider 
the <ei>gamma*/Z^0</ei> combination), optionally excluding decay 
channels that have been closed by the user, and optionally storing 
the results in the normal decay table. For the first argument only 
the sign is relevant. 
</method> 
 
<method name="double ParticleDataEntry::resWidthOpen(int idSgn, 
double mHat, int idInFlav = 0)"> 
special case of <code>resWidth</code>, where only open channels are 
included, but results are not stored in the normal decay table. 
</method> 
 
<method name="double ParticleDataEntry::resWidthStore(int idSgn, 
double mHat, int idInFlav = 0)"> 
special case of <code>resWidth</code>, where only open channels are 
included, and results are stored in the normal decay table. 
</method> 
 
<method name="double ParticleDataEntry::resOpenFrac(int idSgn)"> 
calculate the fraction of the full branching ratio that is left 
open by the user choice of allowed decay channels. 
</method> 
 
<method name="double ParticleDataEntry::resWidthRescaleFactor()"> 
the factor used to rescale all partial widths in case the total 
width is being forced to a specific value by the user. 
</method> 
 
<method name="double ParticleDataEntry::resWidthChan(double mHat, 
int idAbs1 = 0, int idAbs2 = 0)"> 
special case to calculate one final-state width; currently only used 
for Higgs decay to <ei>q qbar</ei>, <ei>g g</ei> or 
<ei>gamma gamma</ei>. 
</method> 
 
<h4>The DecayChannel methods</h4> 
 
The properties stored in an individual decay channel can be set or get 
by the methods in this section. 
 
<method name="DecayChannel::DecayChannel(int onMode = 0, 
double bRatio = 0., int meMode = 0, int prod0 = 0, int prod1 = 0, 
int prod2 = 0, int prod3 = 0, int prod4 = 0, int prod5 = 0, 
int prod6 = 0, int prod7 = 0)"> 
the constructor for a decay channel. Internal. 
</method> 
 
<method name="DecayChannel& operator=( const DecayChannel& decayChannelIn)"> 
copy the values stored in an existing <code>DecayChannel</code> object. 
</method> 
 
<method name="void DecayChannel::onMode(int onMode)"> 
</method> 
<methodmore name="int DecayChannel::onMode()"> 
set or get the <code>onMode</code> of a decay channel,<br/> 
0 if a channel is off,<br/> 
1 if on,<br/> 
2 if on for a particle but off for an antiparticle,<br/> 
3 if on for an antiparticle but off for a particle.<br/> 
If a particle is its own antiparticle then 2 is on and 3 off 
but, of course, for such particles it is much simpler and safer 
to use only 1 and 0.<br/> 
The 2 and 3 options can be used e.g. to encode CP violation in 
B decays, or to let the <ei>W</ei>'s in a <ei>q qbar &rarr; W^+ W^-</ei> 
process decay in different channels. 
</methodmore> 
 
<method name="void DecayChannel::bRatio(double bRatio, 
bool countAsChanged = true)"> 
</method> 
<methodmore name="double DecayChannel::bRatio()"> 
set or get the branching ratio of the channel. Second argument only 
for internal use. 
</methodmore> 
 
<method name="void DecayChannel::rescaleBR(double fac)"> 
multiply the current branching ratio by <code>fac</code>. 
</method> 
 
<method name="void DecayChannel::meMode(int meMode)"> 
</method> 
<methodmore name="int DecayChannel::meMode()"> 
set or get the mode of processing this channel, possibly with matrix 
elements (see the <aloc href="ParticleDecays">particle decays</aloc> 
and <aloc href="ResonanceDecays">resonance decays</aloc> descriptions). 
</methodmore> 
 
<method name="void DecayChannel::multiplicity(int multiplicity)"> 
</method> 
<methodmore name="int DecayChannel::multiplicity()"> 
set or get the number of decay products in a channel, at most 8. 
(Is normally not to be set by hand, since it is automatically 
updated whenever the products list is changed.) 
</methodmore> 
 
<method name="void DecayChannel::product(int i, int product)"> 
</method> 
<methodmore name="int DecayChannel::product(int i)"> 
set or get a list of the decay products, 8 products 0 &lt;= i &lt; 8, 
with trailing unused ones set to 0. 
</methodmore> 
 
<method name="void DecayChannel::setHasChanged(bool hasChanged)"> 
</method> 
<methodmore name="bool DecayChannel::hasChanged()"> 
used for internal purposes, to know which decay modes have been changed. 
</methodmore> 
 
<method name="bool DecayChannel::contains(int id1)"> 
</method> 
<methodmore name="bool DecayChannel::contains(int id1, int id2)"> 
</methodmore> 
<methodmore name="bool DecayChannel::contains(int id1, int id2, int id3)"> 
find if the decay product list contains the one, two or three particle 
identities provided. If the same code is repeated then so must it be in 
the products list. Matching also requires correct sign. 
</methodmore> 
 
<method name="void DecayChannel::currentBR(double currentBR)"> 
</method> 
<methodmore name="double DecayChannel::currentBR()"> 
set or get the current branching ratio, taking into account on/off 
switches and dynamic width for resonances. For internal use. 
</methodmore> 
 
<method name="void DecayChannel::onShellWidth(double onShellWidth)"> 
</method> 
<methodmore name="double DecayChannel::onShellWidth()"> 
set or get the current partial width of the channel; intended for 
resonances where the widths are recalculated based on the current 
resonance mass. For internal use. 
</methodmore> 
 
<method name="void DecayChannel::onShellWidthFactor(double factor)"> 
multiply the current partial width by <code>factor</code>. 
</method> 
 
<method name="void DecayChannel::openSec(int idSgn, double openSecIn)"> 
</method> 
<methodmore name="double DecayChannel::openSec(nt idSgn)"> 
set or get the fraction of secondary open widths, separately for 
positive and negative particles. For internal use. 
</methodmore> 
 
</chapter> 
 
<!-- Copyright (C) 2019 Torbjorn Sjostrand --> 
