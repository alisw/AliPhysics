#!/bin/sh

# $Id$

#############################################################################
# alibtool - a shell script to help makeing modules for AliRoot Makefile
#############################################################################
#
# modification history
# $Log$
# Revision 1.11  2006/05/24 10:10:20  hristov
# Correct dependences for files from subdirecties (Matevz)
#
# Revision 1.10.4.1  2006/05/24 10:09:05  hristov
# Correct dependences for files from subdirecties (Matevz)
#
# Revision 1.10  2005/06/14 11:11:19  alibrary
# Always output at least one line
#
# Revision 1.9  2004/06/18 10:30:54  rdm
# fix typo in comment.
#
# Revision 1.8  2004/06/03 23:41:51  rdm
# wrap some insanely long lines into mulitple lines.
#
# Revision 1.7  2003/11/10 15:02:38  rdm
# re-direct warnings of rmkdepend about not found system include files
# to /dev/null. Only generate dependencies on ROOT and AliRoot, not on
# system or compiler specific files.
#
# Revision 1.6  2003/07/13 09:26:14  hristov
# Transition to NewIO
#
# Revision 1.5  2003/05/02 15:11:52  hristov
# Changes to avoid warnings (I.Hrivnacova)
#
# Revision 1.4  2002/10/14 14:57:45  hristov
# Merging the VirtualMC branch to the main development branch (HEAD)
#
# Revision 1.3.6.1  2002/07/09 12:24:49  alibrary
# Corrections for new MC
#
# Revision 1.3  2002/02/22 07:57:35  alibrary
# Reduce verbose output
#
# Revision 1.2  2001/11/14 17:52:48  hristov
# Updated version of the flat makefiles (J.-E.Revsbech)
#
# Revision 1.1  2001/10/09 13:45:57  hristov
# alibtool is added
#
#
# SYNOPSIS
# alibtool <command> <commandparameters>
#
# command must be one of the following:
#
#         mkmodule
#         depend
#         dependF
#
#
# DESCRIPTION
#
# This scipts is called with a primary command and a command parameter.
# It generates output on stdout, so normally it is called with a redirection,
# like:
#
#   alibtool mkmodule STEER > STEER/module.mk
#
# The command is one of the following:
#
# depend
#     Makes the dependencies for the file specified as second argument
#     (for c and cxx files)
#
# dependF
#     Makes the dependencies for the file specified as second argument
#     (for fortran files)
#
# mkmodule
#     Creates the module.mk for the the given directory specified as
#     the second argument
#
# MKMODULE
#
# When alibtool is called with the mkmodule command it searches the directory
# given as the second argument for files called *.pkg. If a file (possibly
# several) is found, it will create a file called module.mk based on these
# files. For example if running alibtool mkmodule STEER, it will search the
# STEER directory and create STEER/module.mk based on all .pkg files is
# STEER directory. If a file called libSTEER.pkg is found, then module.mk
# will have a section devoted to makeing library libSTEER.so with alle the
# sourcefiles specified in libSTEER.pkg. If a file called binSTEER.pkg is
# found the module.mk file will create an executable called STEER. Several
# *.pkg files can be placed in the same directory. The module.mk files is
# created on background of build/header.tpl and build/module.mk by variable
# substituion of variables @MODULE@ @PACKAGE@ and @TYPE@.
#
# PKG FILES
#
#
# The syntax for the pkg file is very simple. You specify the sources, headers
# and possibly extra include or link options. The *.pkg files is just
# inserted "as is" in the module.mk file, so normal Makefile syntax can
# be used. These variables can be specified: SRCS, FSRCS, CSRCS, HDRS, CHDRS,
# DHDR, EINCLUDE, ELIBS, ELIBSDIR, PACKFFLAGS, PACKCFLAGS, PACKCXXFLAGS.
# The first five is just the C++ sources, fortran sources, C sources,
# C++ headers and C headers. DHDR is the dictionary header and is the
# LinkDef file. EINCLUDE, ELIBS and ELIBSDIR is extra includedirs,
# libraries and library search paths. If for example a binary is to be
# linked against the variable ELIBSDIR would be set to lib/tgt_$ALICE_TARGET.
# Notice that -L and -l is not needed. If the PACKFFLAGS, PACKCFLAGS or
# PACKCXXFLAGS is not set it will be set to the default options (set in
# config/Makefile.$ALICE_TARGET. For example on Linux GEANT321 has to be
# compiled without -O options, so a line like
# PACKFFLAGS := $(filter-out -O%,$(FFLAGS))
# is needed.
#
#
# DEPEND
# 
# If alibtool is called with the depend command it will generate a dependecy
# file for the sourcefile given as second argument. This only goes for C++
# and C files. If dependencies for fortran-fiels is needed, call alibtool
# with command dependF. The dependencies are made with rmkdepend.
#
#
# DEPENDF
#
# The same as depend, but for fortran files.
#
#C<
###########################################################################
 

MkDepend()
{
echo "#"
rmkdepend -f- -Y -w 3000 -- $* 2>/dev/null | sed -e "s@^\([^/]*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
# rmkdepend -f- -Y -w 3000 -- $* 2>/dev/null | sed -e "s@^\(.*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
}
MkDependF()
{
echo "#"
rmkdepend -f- -Y -w 3000 -- $* 2>/dev/null | sed -e "s@^\([^/]*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
# rmkdepend -f- -Y -w 3000 -- $* 2>/dev/null | sed -e "s@^\(.*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
}

MkModule()
{
module=$1
#This one gets all the library pkg files
tempo=`find ${module} -maxdepth 1 -name "lib*.pkg"  | sed -e "sQ${module}/libQQ" -e "sQ\.pkgQQ"`

echo "#**************************************************************************";
echo "#**** This file is automatically generated from the mkmodules script  *****";
echo "#****          DO NOT EDIT!!                                          *****";
echo "#**************************************************************************";

for i in $tempo; do
    package=$i;
    type=lib;
    MkModuleLib $package
done;

#This one gets all the binary(executable) pkg files
tempo=`find ${module} -name "bin*.pkg"  | sed -e "sQ${module}/binQQ" -e "sQ\.pkgQQ"`

for i in $tempo; do
    package=$i;
    type=bin;
    MkModuleLib $package 
done;

#Now make general bottom for every module (Clean and so on)
    cat build/clean.tpl | sed -e "sQ\@MODULE@Q${module}Qg"
}

MkModuleLib()
{
    file=$module/$type$i.pkg
    cat build/header.tpl | sed -e "sQ\@MODULE@Q${module}Qg"  -e "sQ@PACKAGE@Q${package}Qg" -e "sQ\@TYPE@Q${type}Qg"
    echo;
    cat $file;
    echo;
    cat build/module.tpl | sed -e "sQ\@MODULE@Q${module}Qg"  -e "sQ@PACKAGE@Q${package}Qg" -e "sQ\@TYPE@Q${type}Qg"

}

case $1 in
depend)
    MkDepend $2
    ;;
dependF)
    MkDependF $2
    ;;
mkmodule)
    MkModule $2
    ;;
esac;
