/**
 * @file   ToyModel.C
 * @author Christian Holm Christensen <cholm@nbi.dk>
 * @date   Thu Sep  1 10:42:55 2016
 * 
 * @brief  A toy model of trackleting in the SPD 
 * 
 * @ingroup pwglf_forward_tracklets_toy
 */
#ifndef __CINT__
# include <TGraphErrors.h>
# include <TList.h>
# include <TCanvas.h>
# include <TH1.h>
# include <TH2.h>
# include <TLine.h>
# include <TMath.h>
# include <TRandom.h>
# include <TLegend.h>
# include <TLegendEntry.h>
# include <TF1.h>
# include <TLatex.h>
# include <TSystem.h>
# include <TNtuple.h>
# include <TFile.h>
# include <TParameter.h>
# include <iostream>
# include <iomanip>
# include <THStack.h>
# include <TStopwatch.h>
#else
class TGraphErrors;
class TGraph;
class TList;
class TCanvas;
class TH1;
class TLine;
class TH2;
class TNtuple;
class TFile;
#endif
#include <list>

/**
 * @defgroup pwglf_forward_tracklets_toy Toy model of trackleting
 *
 * A model of SPD tracklets.  
 *
 * @image html spd_tracklet_toymodel_event229.png "Example event with 229 generated tracks" 
 *
 * The problem is reduced to 1 dimension.  We have two layers, one
 * placed at Y=1, and one placed at some configurable Y.  The two
 * layers extend from -1 to +1 in X.
 *
 * The interaction point is set to (0,0).  
 *
 * N number of tracks are generated by drawing a random number from
 * pi/4 to 3pi/4 (por 45 to 135 degrees).  
 *
 * On each of the two layers, clusters are generated for every track,
 * by finding the X value where each track crosses the Y of the layer.
 *
 * The clusters are smeared with some Gaussian noise with a
 * configurable spread.  The chosen spread is also set as the cluster
 * uncertainty along X.
 *
 * A track contains references to it's two clusters, and a cluster
 * contains references to its generating track.
 *
 * Trackleting can then be performed in one of 3 ways:
 *
 * - For all clusters on the outer layer (Y=1), we form tracklets by
 *   combining with all possible clusters on the first layer.  The
 *   tracklet with the least distance along X to the interaction point
 *   (0,0) is then accepted as a final tracklet. Note, a cluster can
 *   be used more than one time.
 *
 * - For all clusters on the outer layer (Y=1), we form tracklets by
 *   combining with all unused clusters on the first layer.  The
 *   tracklet with the least distance along X to the interaction point
 *   (0,0) is then accepted as a final tracklet.
 *
 * - For all clusters on the outer layer (Y=1), we form tracklets by
 *   combining with all possible clusters on the first layer.  After
 *   processing all clusters on the outer layer, select those
 *   tracklets which come closes to the interaction point (0,0) but
 *   does not used clusters used by other previously selected (and
 *   therefore closer to the IP) tracklets.
 *
 * Tracklets have references to it's to clusters, and clusters have
 * references to all tracklets that use the cluster.  In this way, we
 * can distinguish fake from good tracklets by inspecting the track
 * references of each of the constituent clusters.
 *
 * For each event, we accumulate statistics on the number of good and
 * fake tracklets, as well as the total number of tracklets, the
 * number of generated tracks, and the number of unused clusters (on
 * each layer, and in total). The statistics is saved in a Ntuple. 
 * 
 * @ingroup pwglf_forward_tracklets
 */
/**
 * A toy model of SPD trackleting 
 * 
 * @see pwglf_forward_tracklets_toy
 *
 * @ingroup pwglf_forward_tracklets_toy
 */
struct ToyModel
{
  // Forward declaration
  struct Track;
  // Forward declaration 
  struct Tracklet;

  /**
   * Suppress output from ROOT 
   */
  struct SuppressGuard
  {
    /** The previous message level */
    Int_t save;
    /** 
     * Constructor 
     * 
     * @param lvl Level to suppress to 
     */
    SuppressGuard(Int_t lvl=2000)
      : save(0)
    {
      save = gErrorIgnoreLevel;
      gErrorIgnoreLevel = lvl;
    }
    /** 
     * Destructor 
     */
    ~SuppressGuard()
    {
      gErrorIgnoreLevel = save;
    }
  };

 
  /** 
   * A cluster 
   */
  struct Cluster
  {
    /** A list of references to tracklets */
    typedef std::list<Tracklet*> TrackletList;
    /** Position */
    Double_t     fX;
    /** Size of cluster */
    Double_t     fE;
    /** Reference to generating track */
    Track*       fTrack;
    /** Whether the cluster has been used */
    Bool_t       fUsed;
    /** List of tracklets */
    TrackletList fTracklets;
    /** 
     * Constructor 
     * 
     * @param t   Generating track 
     * @param x   Position along @f$ x@f$ 
     * @param ex  Error on position along @f$ x@f$, the cluster size
     */
    Cluster(Track* t, Double_t x, Double_t ex)
      : fX(x),
	fE(ex),
	fTrack(t),
	fUsed(false),
	fTracklets()
    {}
    /** 
     * Add a tracklet reference to a cluster 
     * 
     * @param t tracklet 
     */
    void AddTracklet(Tracklet* t)
    {
      if (!t) return;
      fTracklets.push_back(t);
    }
  };
  //__________________________________________________________________
  /** 
   * Structure to compare clusters
   */
  struct CompareClusters
  {
    /** 
     * Perform the comparison 
     * 
     * @return true of @a t1 is better than @a t2 
     */
    bool operator()(Cluster* t1, Cluster* t2)
    {
      return t1->fX < t2->fX;
    }
  };

  //__________________________________________________________________
  /** 
   * A layer 
   */
  struct Layer
  {
    /** A list of clusters */
    typedef std::list<Cluster*> ClusterList;
    /** List of clusters */
    ClusterList    fClusters;
    /** Location in plane */
    const Double_t fY;
    /** Line to draw */
    TGraph         fLine;
    /** Graph of used clusters for drawing */
    TGraphErrors   fUsed;
    /** Graph of used clusters for drawing */
    TGraphErrors   fFree;

    /** 
     * A Layer
     *
     * Clusters are stored in a TGraphErrors.  
     */
    Layer(const Double_t y)
      : fY(y),
	fClusters(),
	fLine(2),
	fUsed(0),
	fFree(0)
    {      
      fUsed.SetMarkerStyle(20);
      fUsed.SetMarkerColor(kBlue+2);
      fUsed.SetMarkerSize(1.2);
      fUsed.SetFillStyle(0);
      fUsed.SetLineColor(kBlue+2);
      fUsed.SetLineWidth(2);
      fFree.SetMarkerStyle(24);
      fFree.SetMarkerColor(kRed+2);
      fFree.SetMarkerSize(1.3);
      fFree.SetFillStyle(0);
      fFree.SetLineColor(kRed+2);
      fFree.SetLineWidth(2);
      fLine.SetTitle(Form("Layer at %f", y));
      fLine.SetName(Form("layer%03d", Int_t(y*100)));
      fLine.SetPoint(0,-1,y);
      fLine.SetPoint(1,+1,y);
      fLine.SetLineWidth(2);
      fLine.SetLineColor(kGray);
    }
    /** 
     * Remove all clusters
     * 
     */    
    void Clear()
    {
      fUsed.Set(0);
      fFree.Set(0);
      for (ClusterList::iterator i = fClusters.begin();
	   i != fClusters.end(); i++)
	delete *i;
      fClusters.clear();
    }
    /** 
     * Count number of free clusters 
     * 
     * @return Number of free clusters 
     */
    Int_t CountFree() const
    {
      Int_t nFree = 0;
      for (ClusterList::const_iterator j=fClusters.begin();
	   j!=fClusters.end(); j++) 
	if (!(*j)->fUsed) nFree++;
      return nFree;
    }      
    /** 
     * Merge clusters that are close to each other 
     * 
     */
    void Merge()
    {
      CompareClusters c;
      fClusters.sort(c); // ascending 

      for (ClusterList::iterator i = fClusters.begin();
	   i != fClusters.end();) {
	ClusterList::iterator j = i;
	++j;
	if (j == fClusters.end()) break;
	Double_t xi  = (*i)->fX;
	Double_t ei  = (*i)->fE;
	Double_t xj  = (*j)->fX;
	Double_t ej  = (*j)->fE;	
	bool     rem = ((xj-xi) / (ei+ej)) < .5;
	if (rem) {
	  (*j)->fX = (xi+xj)/2;
	  (*j)->fE = TMath::Sqrt(ei*ei+ej*ej);
	  i        = fClusters.erase(i);
	}
	else
	  ++i;
      }
    }
    
    /** 
     * Create and add a cluster based on track information.  The X
     * coordinate along the layer is set the intersect of the track
     * with the layer, smeared with a Guassian of with @a sigma.  The
     * cluster uncertainty is also set to @a sigma.
     * 
     * @param t     Generating track 
     * @param sigma Smear of X and cluster uncertainty
     */
    void AddCluster(Track& t, Double_t sigma)
    {
      Double_t ang = t.fAngle;
      Double_t off = t.fOffset;
      Double_t x0  = fY / TMath::Tan(ang) + off;      
      Double_t x   =  x0 + gRandom->Gaus(0,sigma);
      if (x < -1 || x > +1) return;
      Cluster* c   = new Cluster(&t, x, sigma);
      fClusters.push_back(c);
    }
    /** 
     * Add a noise cluster.  We check if there is not already a
     * cluster at the given postion before adding.  If there is a
     * cluster at the position, do not add a new one, and return false
     * 
     * @param x     Position
     * @param sigma Width of the clusters 
     * 
     * @return true if the noise cluster was added
     */
    Bool_t AddNoise(Double_t x, Double_t sigma)
    {
      for (ClusterList::iterator i = fClusters.begin();
	   i != fClusters.end(); ++i) 
	if (TMath::Abs((*i)->fX-x) < ((*i)->fE+sigma)) return false;
      Cluster* c   = new Cluster(0, x, sigma);
      fClusters.push_back(c);
    }	
    /** 
     * Add point to graphical representation 
     * 
     * @param g  Graph object 
     * @param x  X value 
     * @param xe Error on cluster 
     */
    void AddPoint(TGraphErrors& g, Double_t x, Double_t xe)
    {
      Int_t n = g.GetN();
      g.SetPoint     (n, x,  fY);
      g.SetPointError(n, xe, xe);
    }
    /** 
     * Draw the layer 
     * 
     */
    void Draw()
    {
      for (ClusterList::iterator i = fClusters.begin();
	   i != fClusters.end(); i++) {
	if ((*i)->fUsed) AddPoint(fUsed, (*i)->fX, (*i)->fE);
	else             AddPoint(fFree, (*i)->fX, (*i)->fE);
      }
	   
      fLine.DrawClone("l");
      fUsed.Draw("2");
      fFree.Draw("2");
    }
  };
  //__________________________________________________________________
  /** 
   * A track
   * 
   */
  struct Track
  {
    /** 
     * Constructor 
     * 
     * @param angle  Angle 
     * @param offset Offset along X 
     */
    Track(Double_t angle, Double_t offset=0)
      : fAngle(angle),
	fOffset(offset),
	fLine(offset,0,offset,1)
    {}
    /** 
     * @return Marker/Line Color to use 
     */
    virtual Color_t Color() const { return kMagenta+2; }
    /** 
     * @return Marker Style to use 
     */
    virtual Style_t Style() const { return 3; }
    /** 
     * @return Line width to use 
     */
    virtual Double_t Width() const { return 1; }
    /** 
     * Draw this track 
     */
    void Draw()
    {
      Double_t x2= 1/TMath::Tan(fAngle) + fOffset;
      fLine.SetLineColor(Color());
      fLine.SetLineStyle(Style());
      fLine.SetLineWidth(Width());
      fLine.SetX2(x2);
      fLine.Draw();
    }
    /** Angle of track */
    Double_t fAngle;
    /** Offset along X relative to IP (at x=0) */
    Double_t fOffset;
    /** Butter of drawn object */
    TLine    fLine;
  };
  //__________________________________________________________________
  /** 
   * A tracklets
   *
   * A measusred track 
   */      
  struct Tracklet : public Track
  {
    /** 
     * Constructor 
     * 
     * @param c1   Cluster in layer 1 
     * @param c2   Cluster in layer 2 
     * @param ang  Tracklet angle 
     * @param off  Tracklet offset along X
     */
    Tracklet(Cluster& c1, Cluster& c2, Double_t ang, Double_t off)
      : Track(ang, off),
	fCluster1(c1),
	fCluster2(c2),
	fAccepted(false)
    {
      
      fCluster1.AddTracklet(this);
      fCluster2.AddTracklet(this);
    }
    /** 
     * @return Marker Style to use 
     */
    Style_t Style()      const { return fAccepted ? 1      : 2; }
    /** 
     * @return Marker/Line Color to use 
     */
    Color_t Color()      const { return IsFake()  ? kRed+2 : kGreen+2; }
    /** 
     * @return Line width to use 
     */
    Double_t Width()      const { return 2; }
    /** 
     * Check if this is a fake tracklet.  A fake tracklet is either a
     * tracklet for which the two consituent clusters from from
     * different tracks, or if both clusters are from noise.
     *
     * @return true if fake.  
     */
    Bool_t IsFake()     const
    {
      return (fCluster1.fTrack) != (fCluster2.fTrack) || fCluster1.fTrack == 0;
    }
    /** 
     * @return true of accepted 
     */
    Bool_t IsAccepted() const { return fAccepted; }
    /** 
     * Mark this as accepted
     * 
     * @param acc If true, mark as accepted, otherwise not accepted
     */
    void Accept(Bool_t acc=true)
    {
      fAccepted = acc;
      fCluster1.fUsed = true;
      fCluster2.fUsed = true;
    }
    /** 
     * Return the quality @f$ q@f$ of the tracklet calculated as 
     * @f[ 
     q = \sigma_1^2 + \sigma_2^2 + \delta^2
     @f]      
     * where @f$\sigma_{1,2}@f$ are the size of the clusters on the
     * first and second layer, respectively, and @f$\delta@f$ is the
     * distance from the tracklet to the origin.
     * 
     * A smaller @f$ q@f$ indicates a better determined tracklet. 
     * 
     * @return @f$ q@f$ 
     */
    Double_t Quality() const
    {
      return (TMath::Power(fCluster1.fE, 2) +
	      TMath::Power(fCluster2.fE, 2) +
	      TMath::Power(fOffset,      2));
    }
    /** Cluster on layer 1 identifier - point number*/
    Cluster& fCluster1;
    /** Cluster on layer 2 identifier - point number */
    Cluster& fCluster2;
    /** Acceptance flag */
    Bool_t fAccepted;
  };
  //__________________________________________________________________
  /** 
   * Structure to compare tracklets
   */
  struct CompareTracklets
  {
    /** 
     * Perform the comparison 
     * 
     * @return true of @a t1 is better than @a t2 
     */
    bool operator()(Tracklet* t1, Tracklet* t2)
    {
      Double_t q1 = t1->Quality();
      Double_t q2 = t2->Quality();
      if (TMath::Abs(q1-q2) < 1e-12) {
	// Warning("CompareTracklets", \
	//         "tracklets have the same quality: %g %g",o1,o2);
	// Priorities good tracks 
	if (!t1->IsFake() && t2->IsFake()) return true;
      }
      return q1 < q2;
    }
  };
  
  /** Type of a list of tracks */
  typedef std::list<Track*>    TrackList;
  /** Type of a list of tracklets */
  typedef std::list<Tracklet*> TrackletList;
  /** 
   * @{ 
   * @name Containers 
   */
  /** List of tracks */
  TrackList    fTracks;
  /** List of tracklets */
  TrackletList fTracklets;
  /** Layer 1 */
  Layer        fLayer1;
  /** Layer 1 */
  Layer        fLayer2;
  /* @} */
  /**
   * @{ 
   * @name Visualisation 
   */
  /** Draw frame */
  TH2*         fFrame;
  /** Draw area */
  TCanvas*     fCanvas;
  /* @} */
  /** 
   * @{ 
   * @name Event data and output data  
   */
  /** Statistics */
  TNtuple      fStat;
  /** Event record */
  TNtuple      fRecord;
  /** Input tracks */
  TNtuple      fGenerated;
  /** Event variables */
  Int_t        fNGood;
  /** Event variable */
  Int_t        fNFake;
  /** Event variable */
  Int_t        fNFree;
  /* @} */

  struct Params {
    /** 
     * @{ 
     * @name Options 
     */
    /** Location of inner layer */
    Double_t fY1;
    /** Should we track from out to in, or vice versa */
    Bool_t fOut2In;
    /** Should we do global tracklet selection */
    Bool_t fGlobal;
    /** Should we ignore already used clusters */
    Bool_t fNoReuse;
    /** Smear of clusters */
    Double_t fSigma;
    /** Cut on vertex */
    Double_t fOffsetCut;
    /** Should we add Noise clusters (randomly disitrbuted) */
    Bool_t fNoise;
    /** Should we have random sigmas */
    Bool_t fVary;
    /** Should we merge overlapping clusters */
    Bool_t fMerge;
    /** Should we make "secondary" tracks */
    Bool_t fSecondary;
    /* @} */

    Params()
      : fY1(.75),
	fOut2In(true),
	fGlobal(true),
	fNoReuse(true),
	fSigma(0.0008),
	fOffsetCut(0.5),
	fNoise(false),
	fVary(false),
	fMerge(false),
	fSecondary(false)
    {}
    Params(const Params& o)
      : fY1(o.fY1),
	fOut2In(o.fOut2In),
	fGlobal(o.fGlobal),
	fNoReuse(o.fNoReuse),
	fSigma(o.fSigma),
	fOffsetCut(o.fOffsetCut),
	fNoise(o.fNoise),
	fVary(o.fVary),
	fMerge(o.fMerge),
	fSecondary(o.fSecondary)
    {}
    Params& operator=(const Params& o)
    {
      if (&o == this) return *this;
      fY1        = o.fY1;
      fOut2In    = o.fOut2In;
      fGlobal    = o.fGlobal;
      fNoReuse   = o.fNoReuse;
      fSigma     = o.fSigma;
      fOffsetCut = o.fOffsetCut;
      fNoise     = o.fNoise;
      fVary      = o.fVary;
      fMerge     = o.fMerge;
      fSecondary = o.fSecondary;
      return *this;
    }
    void Store() const
    {
      (new TParameter<double>("y1",       fY1))       ->Write();
      (new TParameter<bool>  ("out2in",   fOut2In))   ->Write();
      (new TParameter<bool>  ("global",   fGlobal))   ->Write();
      (new TParameter<bool>  ("noReuse",  fNoReuse))  ->Write();
      (new TParameter<double>("sigma",    fSigma))    ->Write();
      (new TParameter<double>("offsetCut",fOffsetCut))->Write();
      (new TParameter<bool>  ("vary",     fVary))     ->Write();
      (new TParameter<bool>  ("merge",    fMerge))    ->Write();
      (new TParameter<bool>  ("secondary",fSecondary))->Write();
    }
  };
  /** Our parameters */
  Params fParams;
    
  /**
   * Copy constructor 
   * 
   * @param m Object to copy from 
   */
  ToyModel(const ToyModel& m)
    : fTracks(),
      fLayer1(m.fLayer1.fY),
      fLayer2(m.fLayer2.fY),
      fFrame(0),
      fCanvas(0),
      fStat("stat","Stats","nTrack:nTotal:nGood:nFake:nFree:nFree1:nFree2"),
      fRecord("record","Record","nTrack:angle:off:qual:fake"),
      fGenerated("generated","Tracks","angle:off"),
      fNGood(0),
      fNFake(0),
      fNFree(0),
      fParams(m.fParams)
  {}
  /** 
   * Constructor 
   * 
   * @param y1 Virtical distance of layer one (between 0 and 1)
   */
  ToyModel(const Params& p)
    : fTracks(),
      fLayer1(p.fY1),
      fLayer2(1),
      fFrame(0),
      fCanvas(0),
      fStat("stat","Stats","nTrack:nTotal:nGood:nFake:nFree:nFree1:nFree2"),
      fRecord("record","Record","nTrack:angle:off:qual:fake"),
      fGenerated("generated","Tracks","angle:off"),
      fNGood(0),
      fNFake(0),
      fNFree(0),
      fParams(p)
  {}
    
  /** 
   * Constructor 
   * 
   * @param y1 Virtical distance of layer one (between 0 and 1)
   */
  ToyModel(Double_t y1=.5)
    : fTracks(),
      fLayer1(y1),
      fLayer2(1),
      fFrame(0),
      fCanvas(0),
      fStat("stat","Stats","nTrack:nTotal:nGood:nFake:nFree:nFree1:nFree2"),
      fRecord("record","Record","nTrack:angle:off:qual:fake"),
      fGenerated("generated","Tracks","angle:off"),
      fNGood(0),
      fNFake(0),
      fNFree(0),
      fParams()
  {
  }
  /** 
   * @{ 
   * @name Set parameters 
   */
  /** 
   * Set all parameters 
   * 
   * @param p Parameters object
   */
  void SetParams(const Params& p) { fParams = p; }
  /** Should we track from out to in, or vice versa */
  void SetOut2In(Bool_t x) { fParams.fOut2In = x; }
  /** Should we do global tracklet selection */
  void SetGlobal(Bool_t x) { fParams.fGlobal = x; }
  /** Should we ignore already used clusters */
  void SetNoReuse(Bool_t x) { fParams.fNoReuse = x; }
  /** Smear of clusters */
  void SetSigma(Double_t x) { fParams.fSigma = x; }
  /** Smear of clusters */
  void SetOffsetCut(Double_t x) { fParams.fOffsetCut = x; }
  /** Should we add Noise clusters (randomly disitrbuted) */
  void SetNoise(Bool_t x) { fParams.fNoise = x; }
  /** Should we have random sigmas */
  void SetVary(Bool_t x) { fParams.fVary = x; }
  /** Should we merge overlapping clusters */
  void SetMerge(Bool_t x) { fParams.fMerge = x; }
  /** Should we make "secondary" tracks */
  void SetSecondary(Bool_t x) { fParams.fSecondary = x; }
  /* @} */

  /** 
   * @{ 
   * @name Clear internal stuff 
   */
  /** 
   * Clear a track list 
   * 
   * @param tracks List
   */
  void Clear(TrackList& tracks)
  {
    for (TrackList::iterator i = tracks.begin(); i != tracks.end(); ++i)
      delete (*i);
    tracks.erase(tracks.begin(), tracks.end());
  }
  /** 
   * Clear a tracklet list 
   * 
   * @param tracklets List
   */
  void Clear(TrackletList& tracklets)
  {
    for (TrackletList::iterator i = tracklets.begin();
	 i != tracklets.end(); ++i)
      delete (*i);
    tracklets.erase(tracklets.begin(), tracklets.end());
  }
  /** 
   * Clear internal structures for event calculations 
   * 
   */
  void Clear()
  {
    fLayer1.Clear();
    fLayer2.Clear();
    Clear(fTracks);
    Clear(fTracklets);
  }
  /* @} */
  
  /** 
   * @{ 
   * @name Event trackleting 
   */
  /** 
   * Make a tracklet from clusters on the two layers 
   * 
   * @param c2 Cluster in second layer 
   * @param c1 Cluster in first layer 
   * 
   * @return Newly allocated tracklet 
   */
  Tracklet* MakeTracklet(Cluster* c2, Cluster* c1)
  {
    Double_t  y2 = fLayer2.fY;
    Double_t  y1 = fLayer1.fY;
    Double_t  x2 = c2->fX;
    Double_t  x1 = c1->fX;
    Double_t  a  = (y2-y1)/(x2-x1);
    Double_t  b  = y2-a*x2;
    Double_t  o  = -b/a;
    Double_t  an = TMath::ATan(a);
    Tracklet* t  = new Tracklet(*c1, *c2, an, o);
    return t;
  }
  /** 
   * Accept the given tracklet 
   * 
   * @param t Tracklet
   */
  void Accept(Tracklet* t)
  {
    t->Accept();
    Double_t ang = t->fAngle;
    if (ang < 0) ang += TMath::Pi();
    fRecord.Fill(fTracks.size(), ang, t->fOffset, t->Quality(), t->IsFake());
  }
  /** 
   * Perform trackleting.
   * 
   * There are tree modes of operation:
   *
   * - (@c global=false and @c noReuse=false ) First matching each
   *   cluster on outer (inner) layer with all clusters on the inner
   *   (outer) layer.  Then sort tracklets by distance to IP along the
   *   X direction, and take the tracklet which is closest to the IP.
   * 
   * - (@c global=false and @c noReuse=true ) First matching each
   *   cluster on outer (inner) layer with all non-used clusters on
   *   the inner (outer) layer.  Then sort tracklets by distance to IP
   *   along the X direction, and take the tracklet which is closest
   *   to the IP.  
   *
   * - (@c global=true ) First match all clusters on the outer layer
   *   with all clusters on the inner layer.  Then sort all possible
   *   tracklets by quality (distance to interaction point at (0,0)),
   *   and select any tracklet that does not share clusters with other
   *   tracklets.
   */
  void Trackleting()
  {
    // order of tracking 
    Layer* ls[] = { fParams.fOut2In ? &fLayer2 : &fLayer1,
		    fParams.fOut2In ? &fLayer1 : &fLayer2 };
    // Loop over first layer
    for (Layer::ClusterList::iterator i = ls[0]->fClusters.begin();
	 i != ls[0]->fClusters.end(); i++) { 
      // Declare temporary list of trackets 
      TrackletList tmp;
      // Loop over second layer 
      for (Layer::ClusterList::iterator j = ls[1]->fClusters.begin();
	   j != ls[1]->fClusters.end(); j++) { 
	// Create our tracklet
	if (fParams.fNoReuse && (*j)->fUsed) {
	  /// Info("Trackleting", "Cluster already used, skipping");	  
	  continue;
	}
	Tracklet* tkl = 0;
	if (fParams.fOut2In) tkl = MakeTracklet(*i, *j);
	else         tkl = MakeTracklet(*j, *i);
	if (!tkl) continue;
	// Push to temporary store 
	tmp.push_back(tkl);
	// Push to event store 
	fTracklets.push_back(tkl);
      }
      // Sort temporary store
      if (!fParams.fGlobal) {
	CompareTracklets c;
	tmp.sort(c);
	// Mark best tracklet
	if (tmp.front()) Accept(tmp.front());
      }
    }
    if (fParams.fGlobal) {
      // Sort _all_ tracklets by quality 
      CompareTracklets c;
      fTracklets.sort(c);
      // Accept tracks that do no share clusters 
      for (TrackletList::iterator i = fTracklets.begin();
	   i != fTracklets.end(); ++i) {
	Tracklet* t = *i;
	// If either cluster was already used, ignore this tracklet 
	if (t->fCluster1.fUsed || t->fCluster2.fUsed) continue;
	// Wide IPz cut 
	if (TMath::Abs(t->fOffset) > fParams.fOffsetCut) {
	  // Info("", "Discarding tracklet with offset=%f > 0.5", t->fOffset);
	  continue;
	}
	Accept(t);
      }      
    }
    // Figure out number of unused clusters
    fNFree       = 0;
    Int_t nFree2 = fLayer2.CountFree();
    Int_t nFree1 = fLayer1.CountFree();
    fNFree       = nFree1 + nFree2;
    
    // Figure out number of good and fake in this event 
    fNGood       = 0;
    fNFake       = 0;
    Int_t nTotal = 0;
    for (TrackletList::iterator i = fTracklets.begin();
	 i != fTracklets.end(); ++i) {
      if (!(*i)->IsAccepted()) continue;
      nTotal++;
      if ((*i)->IsFake()) fNFake++;
      else                fNGood++;
    }
#if 0
    Printf("From %4lu tracks got %4d tracklets of "
	   "which %4d are good, %4d fake (%4d+%4d=%4d free clusters) "
	   "[%s %sshare]",
	   fTracks.size(), nTotal, fNGood, fNFake, nFree1, nFree2, fNFree,
	   fParams.fGlobal ? "Global" : "Per-cluster",
	   fParams.fNoReuse ? "No-" : "");
#endif
    // Fill into statistics nTuple.
    fStat.Fill(fTracks.size(), nTotal, fNGood, fNFake, fNFree, nFree1, nFree2);
  }
  /* @} */
  /**
   * @{ 
   * @name Event tracks 
   */
  /** 
   * Create origin of track.  If we're creating good tracks, then
   * simply return 0.  Otherwise, choose a random number between -0.25
   * and +0.25.  If the random number is too close to 0, try again.
   * We can try up to 3 times.  If we do not manange to make a good
   * origin, return 1000.
   * 
   * @param secondary If true, create for emulated secondaries 
   * 
   * @return Generated origin, or 1000 in case of failure 
   */
  Double_t CreateOrigin(Bool_t secondary)
  {
    if (!secondary) return 0;
    Int_t nTry = 3;
    for (Int_t iTry = 0; iTry < nTry; iTry++) {
      Double_t off = gRandom->Uniform(-.25, .25);
      if (TMath::Abs(off) > 1e-2) return off;
    }
    return 1000;
  }
  /** 
   * Create tracks and clusters 
   * 
   * @param nTracks    Number of tracks to make 
   * @param maxAng     Maximum angle 
   * @param secondary  If true, emulate secondaries 
   */
  void CreateTracks(Int_t    nTracks,
		    Double_t maxAng,
		    Bool_t   secondary=false)
  {
    for (Int_t i = 0; i < nTracks; i++) {
      Double_t ang = gRandom->Uniform(maxAng, maxAng+TMath::Pi()/2);
      Double_t off = CreateOrigin(secondary);
      if (off > 999) continue; 
      Track*   trk = new Track(ang, off);
      fTracks.push_back(trk);
      fGenerated.Fill(trk->fAngle, trk->fOffset);
		      
      Double_t sigma1 = fParams.fSigma;
      Double_t sigma2 = fParams.fSigma;

      if (fParams.fVary) {
	sigma1 *= gRandom->Uniform(0.5,2);
	sigma2 *= gRandom->Uniform(0.5,2);
      }
      fLayer1.AddCluster(*trk, sigma1);
      fLayer2.AddCluster(*trk, sigma2);
    }
  }
  /** 
   * Post processing of clusters and the layers 
   * 
   * @param nTracks  Number of tracks 
   */
  void ClusterPost(Int_t nTracks)
  {
    if (!fParams.fNoise || !fParams.fMerge) return;
    
    for (Int_t iLayer = 0; iLayer < 2; iLayer++) {
      Layer& layer  = (iLayer == 0 ? fLayer1 : fLayer2);
      if (fParams.fNoise) {
	Int_t  nNoise = nTracks / 10;
	Int_t  nTries = 3;
	Int_t  nAdded = 0;
	for (Int_t iNoise = 0; iNoise < nNoise; iNoise++) {
	  for (Int_t iTry = 0; iTry < nTries; iTry) {
	    Double_t x = gRandom->Uniform(-1,+1);
	    if (layer.AddNoise(x, fParams.fSigma)) {
	      nAdded++;
	      break;
	    }
	  } // iTry
	} // iNoise
	// Printf("Added %d/%d noise clusters", nAdded, nNoise);
      } // iLayer 
      if (fParams.fMerge) layer.Merge();
    }
  }
  /* @} */

  /** 
   * @{ 
   * @name Event processing 
   */
  /** 
   * Create some number of tracks, and for each track, create a
   * cluster on each layer.  The cluster is smeared by the sigma
   * parameter.  The find the best tracklets of the event, and do some
   * statistics.
   * 
   * @param nTracks   Number of tracks to generate 
   * @param varTracks Variance of number of tracks to generate
   * @param dump      Should we dump to an image file?
   */
  void Event(Int_t    nTracks,
	     Double_t varTracks,
	     Bool_t   dump=false)
  {
    Clear();

    // Largest angle - fixed by geometry 
    const Double_t maxAng = TMath::Pi()/4;

    Int_t nTrk = nTracks;
    if (varTracks > 1e-3) nTrk = Int_t(gRandom->Gaus(nTracks,
						     varTracks*nTracks)+.5);
    // Create "primary" tracks 
    CreateTracks(nTrk, maxAng);
    // Possibly create "secondary" tracks 
    if (fParams.fSecondary) CreateTracks(nTrk/10, maxAng, true);

    // Possibly clean up clusters, and/or add noise 
    ClusterPost(nTrk);

    // Find tracklets
    Trackleting();

    if (dump) Draw();
  }
  /* @} */
  /** 
   * @{
   * @name Visualisation 
   */
  /** 
   * Create the canvas 
   * 
   */
  void Canvas()
  {
    if (!fCanvas) {
      fCanvas = new TCanvas("c","c", 900, 900);
      fCanvas->SetTopMargin(0.01);
      fCanvas->SetRightMargin(0.01);
      fCanvas->SetLeftMargin(0.12);
      fCanvas->SetTicks();
      fCanvas->SetGridx();
      fCanvas->SetGridy();
    }
    fCanvas->Clear();
  }
  /** 
   * Create the frame 
   *  
   * @param xmin Least X 
   * @param xmax Largest X
   * @param ymin Least Y
   * @param ymax Largest Y
   */
  void Frame(Double_t xmin=-1.2, Double_t xmax=1.2,
	     Double_t ymin=-0.2, Double_t ymax=1.2)
  {
    if (!fFrame) {
      fFrame = new TH2D("frame","",100,xmin,xmax,100,ymin,ymax);
      fFrame->SetDirectory(0);
      fFrame->SetStats(0);
      fFrame->SetXTitle("X");
      fFrame->SetYTitle("Y");
      fFrame->GetYaxis()->SetTitleOffset(1.2);
    }
    fFrame->Draw("axis");
  }
  /** 
   * Draw the event
   * 
   */
  void Draw()
  {
    Canvas();
    Frame();
    fLayer1.Draw();
    fLayer2.Draw();
    Draw(fTracks);
    Draw(fTracklets);

    TLatex* ltx =
      new TLatex(0, 1.1,
		 Form("%lu tracks, %d good, %d fake, %d free clusters",
		      fTracks.size(), fNGood, fNFake, fNFake));
    ltx->SetTextAlign(22);
    ltx->SetTextFont(42);
    ltx->SetTextSize(0.03);
    ltx->Draw();
				  
    TLegend* l = new TLegend(.7, .10, .99, .35);
    TLegendEntry* e = 0;
    e = l->AddEntry("dummy", "Track", "l");
    e->SetLineColor(kMagenta+2);
    e->SetLineStyle(3);
    e = l->AddEntry("dummy", "Used cluster", "p");
    e->SetMarkerColor(kBlue+2);
    e->SetMarkerStyle(25);
    e = l->AddEntry("dummy", "Free cluster", "p");
    e->SetMarkerColor(kRed+2);
    e->SetMarkerStyle(25);
    e = l->AddEntry("dummy", "Good tracklet", "l");
    e->SetLineColor(kGreen+2);
    e->SetLineStyle(1);
    e->SetLineWidth(2);
    e = l->AddEntry("dummy", "Fake tracklet", "l");
    e->SetLineColor(kRed+2);
    e->SetLineStyle(1);
    e->SetLineWidth(2);
    l->Draw();

    SuppressGuard g;
    fCanvas->SaveAs(Form("event%04lu.png", fTracks.size()));
  }
  /** 
   * Draw a list of tracks
   * 
   * @param tracks List of tracks to draw
   */
  void Draw(TrackList& tracks)
  {
    for (TrackList::iterator i = tracks.begin(); i != tracks.end(); ++i)
      (*i)->Draw();
  }
  /** 
   * Draw list of tracklets. Only accepted tracklets are drawn 
   * 
   * @param tracklets List to draw.  
   */
  void Draw(TrackletList& tracklets)
  {
    for (TrackletList::iterator i = tracklets.begin();
	 i != tracklets.end(); ++i) {
      // if ((*i)->IsFake()) continue;
      if (!(*i)->IsAccepted()) continue;
      (*i)->Draw();
    }
  }
  /* @} */
  /** 
   * @{ 
   * @name Trend analysis 
   */
  /** 
   * Do a trend analysis based on accumulated statistcs 
   * 
   */
  void Trends(Int_t nIter, const char* title="", TDirectory* out=0)
  {
    Double_t      maxTracks = 0;
    Int_t         nEvents   = fStat.GetEntries();
    Int_t         nStep     = nEvents / nIter;
    Int_t         iEvent    = 0;
    TGraphErrors* trendGood = new TGraphErrors(nStep);
    TGraphErrors* trendFake = new TGraphErrors(nStep);
    trendGood->SetLineColor(kGreen+2);
    trendFake->SetLineColor(kRed+2);
    trendGood->SetLineWidth(2);
    trendFake->SetLineWidth(2);
    trendGood->SetMarkerColor(kGreen+2);
    trendFake->SetMarkerColor(kRed+2);
    trendGood->SetMarkerStyle(20);
    trendFake->SetMarkerStyle(21);
    trendGood->SetMarkerSize(1.2);
    trendFake->SetMarkerSize(1.2);
    trendGood->SetFillStyle(0);
    trendFake->SetFillStyle(0);
    trendGood->SetTitle("N_{good tracklet}");
    trendFake->SetTitle("N_{fake tracklet}");
    for (Int_t iStep = 0; iStep < nStep; iStep++) {
      fStat.GetEntry(iEvent);
      TArrayD  cGood(nIter);
      TArrayD  cFake(nIter);
      Double_t nTrack = fStat.GetArgs()[0];
      maxTracks      = TMath::Max(maxTracks,nTrack);
      Printf("Entry # %2d nTracks=%5d", iEvent, Int_t(nTrack));
      for (Int_t iIter = 0; iIter < nIter; iIter++) {
	fStat.GetEntry(iEvent++); // First iter, same entry
	cGood[iIter] = fStat.GetArgs()[2];
	cFake[iIter] = fStat.GetArgs()[3];
      }
      Double_t mGood = TMath::Mean(cGood.fN, cGood.fArray);
      Double_t rGood = TMath::RMS (cGood.fN, cGood.fArray);
      Double_t mFake = TMath::Mean(cFake.fN, cFake.fArray);
      Double_t rFake = TMath::RMS (cFake.fN, cFake.fArray);
      trendGood->SetPoint     (iStep, nTrack, mGood);
      trendGood->SetPointError(iStep, 0,      rGood);
      trendFake->SetPoint     (iStep, nTrack, mFake);
      trendFake->SetPointError(iStep, 0,      rFake);
    }


    // Make canvas as prepare frame to draw in 
    Canvas();
    if (fFrame) { delete fFrame; fFrame = 0; }
    Double_t x1 = -1;
    Double_t x2 = 1.1*maxTracks;
    Double_t y1 = -1;
    Double_t y2 = 1.1*maxTracks;
    Frame(x1,x2,y1,y2);
    fFrame->SetXTitle("N_{tracks}");
    fFrame->SetYTitle("N_{tracklets}");
    fFrame->GetYaxis()->SetTitleOffset(1.4);
    
    // Draw trends 
    trendGood->Draw("p");
    trendFake->Draw("p");

    // Fit number of good and bad tracks 
    TF1* fitGood = new TF1("fitGood", "pol2", x1, x2);
    TF1* fitFake = new TF1("fitFake", "pol2", x1, x2);
    fitGood->SetLineColor(trendGood->GetLineColor());
    fitFake->SetLineColor(trendFake->GetLineColor());
    fitGood->SetLineStyle(1);
    fitFake->SetLineStyle(1);
    fitGood->FixParameter(0,0);
    fitFake->FixParameter(0,0);
    trendGood->Fit(fitGood,"Q", "");
    trendFake->Fit(fitFake,"Q", "");
    fitGood->Draw("same");
    fitFake->Draw("same");
    Printf("--- Result of fits: ---");
    Printf(" Ngood: (%5.3f +/- %5.3f)*Ntrack + (%8.5f +/- %8.5f)*Ntrack^2",
	   fitGood->GetParameter(1), fitGood->GetParError(1), 
	   fitGood->GetParameter(2), fitGood->GetParError(2));
    Printf(" Nfake: (%5.3f +/- %5.3f)*Ntrack + (%8.5f +/- %8.5f)*Ntrack^2",
	   fitFake->GetParameter(1), fitFake->GetParError(1), 
	   fitFake->GetParameter(2), fitFake->GetParError(2));

    // Make sum of both fits and draw
    TF1* fitTotal = new TF1("fitTotal","pol2(0)+pol2(3)",x1,x2);
    fitTotal->SetParameters(fitGood->GetParameter(0),
			    fitGood->GetParameter(1),
			    fitGood->GetParameter(2),
			    fitFake->GetParameter(0),
			    fitFake->GetParameter(1),
			    fitFake->GetParameter(2));
    fitTotal->SetLineColor(kBlack);
    fitTotal->SetLineStyle(1);
    fitTotal->Draw("same");

    // Now calculate expected number of tracklets of each kind given a
    // fix point (default nTracklets=100).  Also calculate what we'd
    // get by reweighing all tracklets/clusters with a constant
    // weight.
    Int_t    fix      = 100;
    Int_t    next     = 200;
    Double_t weight   = Double_t(next)/fix;
    Double_t gFix     = fitGood->Eval(fix);
    Double_t fFix     = fitFake->Eval(fix);
    Double_t gNext    = fitGood->Eval(next);
    Double_t fNext    = fitFake->Eval(next);
    Double_t gWeighed = weight*gFix;
    Double_t fWeighed = weight*weight*fFix;
    Printf("--- Projections ---");
    Printf(" @%3d tracks:        %6.2f good, %6.2f fake, %6.2f total",
	   fix, gFix, fFix, gFix+fFix);
    Printf(" @%3d tracks:        %6.2f good, %6.2f fake, %6.2f total",
	   next, gNext, fNext, gNext+fNext);
    Printf(" @%3d -> %3d tracks: %6.2f good, %6.2f fake, %6.2f total",
	   fix, next, gWeighed, fWeighed, gWeighed+fWeighed);
    Printf(" Difference:         %6.2f good, %6.2f fake, %6.2f total",
	   gWeighed-gNext, fWeighed-fNext, (gWeighed+fWeighed)-(gNext+fNext));

    // Make function that represents constant weighing of number
    // of good tracklets from a given fix point 
    TF1* weiGood = new TF1("weiGood", "x/[0]*[1]", x1, x2);
    weiGood->SetParameters(100, gFix);
    weiGood->SetLineColor(kBlue+2);
    weiGood->SetLineStyle(2);
    weiGood->Draw("same");
    
    // Make function that represents constant weighing of number
    // of fake tracklets from a given fix point 
    TF1* weiFake = new TF1("weiFake", "x*x/[0]/[0]*[1]", x1, x2);
    weiFake->SetParameters(100, fFix);
    weiFake->SetLineColor(kMagenta+2);
    weiFake->SetLineStyle(2);
    weiFake->Draw("same");

    // Make a function that represents a better scaling of number of
    // good tracklets given a fix point.
    TF1* modGood = new TF1("modGood", "x/[0]*([1]-(x/[0]-1)*[2])", x1, x2);
    modGood->SetParameters(100, gFix, fFix);
    modGood->SetLineColor(kPink+2);
    modGood->SetLineStyle(4);
    modGood->Draw("same");

    // Some other attempts at fits
    TF1* myFake = new TF1("myFake", "[0]*TMath::Power(x,[1])", x1, x2);
    myFake->SetLineColor(kPink+2);
    myFake->SetLineStyle(3);
    myFake->SetParameters(1,1.5);
    trendFake->Fit(myFake, "Q", "");
    myFake->Draw("same");
    TF1* myGood = new TF1("myGood", "x-[0]*TMath::Power(x,[1])", x1, x2);
    myGood->SetLineColor(kMagenta+2);
    myGood->SetLineStyle(3);
    myGood->SetParameters(1,1.5);
    trendGood->Fit(myGood, "Q", "");
    myGood->Draw("same");
    Printf("--- Result of other fits: ---");
    Printf(" Ngood: Ntrack-(%6.4f +/- %6.4f)*Ntrack^(%4.2f +/- %4.2f)",
	   myGood->GetParameter(0), myGood->GetParError(0), 
	   myGood->GetParameter(1), myGood->GetParError(1));
    Printf(" Nfake:        (%6.4f +/- %6.4f)*Ntrack^(%4.2f +/- %4.2f)",
	   myFake->GetParameter(0), myFake->GetParError(0), 
	   myFake->GetParameter(1), myFake->GetParError(1));
    

    // Make legend and modify it 
    TLegend* l = fCanvas->BuildLegend(0.12,0.7,.65,0.99, title);
    l->GetListOfPrimitives()->RemoveAt(1);
    TIter nextE(l->GetListOfPrimitives());
    TLegendEntry* e = 0;
    while ((e = static_cast<TLegendEntry*>(nextE()))) {
      TObject* o = e->GetObject();
      if (o == trendFake || o == trendGood) 
	e->SetOption("p");
      else
	e->SetOption("l");
      
      if (o == fitGood)
	e->SetLabel("f_{good}: 2^{nd} Pol fit to #it{N}_{good}");
      else if (o == fitFake) 
	e->SetLabel("f_{fake} 2^{nd} Pol fit to #it{N}_{fake}");
      else if (o == fitTotal) 
	e->SetLabel("f_{good}+f_{fake}");
      else if (o == weiGood) 
	e->SetLabel(Form("#it{w}#times#it{N}_{good} [fix=%3d]", fix));
      else if (o == weiFake)
	e->SetLabel(Form("#it{w}^{2}#times#it{N}_{fake} [fix=%3d]", fix));
      else if (o == modGood)
	e->SetLabel(Form("#it{w}[#it{N}_{good}-(#it{w}-1)#it{N}_{fake}] "
			 "[fix=%3d]", fix));
      else if (o == myFake)
	e->SetLabel("a#it{N}_{tracks}^{p}");
      else if (o == myGood)
	e->SetLabel("#it{N}_{tracks}-a#it{N}_{tracks}^{p}");
    }
    e = static_cast<TLegendEntry*>(l->GetListOfPrimitives()->At(0));
    e->SetOption("h");

    // Possibly save to disk
    if (out) {
      trendGood->Write();
      trendFake->Write();
      fitGood  ->Write();
      fitFake  ->Write();
      fitTotal ->Write();
      weiGood  ->Write();
      weiFake  ->Write();
      modGood  ->Write();
    }
      
    // Suppress message from ROOT 
    SuppressGuard g;
    
    // Save canvas to an image file 
    fCanvas->SaveAs("trends.png");
  }    
  /* @} */
  /** 
   * @{ 
   * @name Steering 
   */
  /** 
   * Make output file and dump some stuff there 
   * 
   * @param filename Output file name 
   * 
   * @return Pointer to output file 
   */
  TFile* Output(const char* filename)
  {
    TFile*      out = TFile::Open(filename,"RECREATE");
    TDirectory* ret = Output(out);

    return out;
  }  
  TDirectory* Output(TDirectory* dir)
  {
    dir->cd();
    fStat     .Write();
    fRecord   .Write();
    fGenerated.Write();
    fParams   .Store();

    return dir;
  }  
  /** 
   * Make a single event 
   * 
   * @param n Number of tracks to generate 
   */
  void RunOne(Int_t    n=500)
  {
    Event(n,0,true);
  }
  /** 
   * Run a scan over number of tracks, each time doing 10 events.  We
   * accumulate statistics on the number of fake and good tracklets.
   * 
   * @param n         Number of steps to do 
   */
  void RunScan(Int_t    n=20)
  {
    Int_t    nStep  = n;
    Double_t dPower = 1.7; // 2.33; // 1.7;
    Int_t    nIter  = 10;

    for (Int_t i = 0; i <= nStep; i++) {
      Int_t m = Int_t(TMath::Power(10,1+dPower/nStep*i));
      std::cout << "nTracks=" << std::setw(4)
		<< int(m *(fParams.fSecondary ? 1.1 : 1))
		<< " " << std::flush;
      for (Int_t j = 0; j < nIter; j++) {
	std::cout << "." << std::flush;
	Event(m,0,j==0);
      }
      std::cout << " done" <<std::endl;
    }
    TString tit;
    if (fParams.fOut2In) tit.Append("Inward ");
    else                 tit.Append("Outward ");
    if (fParams.fGlobal) tit.Append("All ");
    else {
      tit.Append("Per-cluster ");
      if (fParams.fNoReuse) tit.Append("no-shared");
    }
    if (fParams.fNoise)     tit.Append(" Noise");
    if (fParams.fVary)      tit.Append(" Vary");
    if (fParams.fMerge)     tit.Append(" Merge");
    if (fParams.fSecondary) tit.Append(" Secondary");

    TFile* out = Output("scan.root");
    Trends(nIter, tit, out);

    out->Write();
  }
  /** 
   * Make @a n events with 500 tracks in each, and form the @f$
   * dN/d\theta@f$ distribution for fake and good tracklets
   * 
   * @param n  Number of events to generate
   * @param m  Number of tracks to make for each event
   * @param v  Variance of number of tracks 
   */
  void RunDist(Int_t n=100, Int_t m=500, Double_t v=0)
  {
    TStopwatch w; w.Start();
    for (Int_t iEvent = 0; iEvent < n; iEvent++) {
      std::cout << "\rEvent # " << std::setw(4) << iEvent
		<< "/" << std::setw(4) << n << std::flush;
      Event(m,v);
      w.Stop();
      Double_t passed = w.RealTime();
      Double_t perEv  = passed / (iEvent+1);
      Double_t total  = n*perEv;
      Double_t remain = total-passed;
      std::cout << std::setw(8) << int(passed) << " seconds passed "
		<< std::setw(8) << int(remain+.5) << " seconds remaining"
		<< std::flush;
      w.Continue();
    }
    printf("\n");
    
    TH1* fakes = new TH1D("fakes","Fake",90,45,135);
    // TH1* fakes = new TH1D("fakes","Fakes",100, -1, 1);
    // fakes->SetDirectory(0);
    fakes->SetFillStyle(3001);
    fakes->SetFillColor(kRed+1);
    fakes->SetLineColor(kRed+1);
    fakes->SetXTitle("Angle [Degrees]");
    fakes->SetYTitle("#it{N}_{tracklet}");
    TH1* goods = static_cast<TH1*>(fakes->Clone("goods"));
    // goods->SetDirectory(0);
    goods->SetTitle("Good");
    goods->SetLineColor(kGreen+1);
    goods->SetFillColor(kGreen+1);

    TH1* tracks = static_cast<TH1*>(fakes->Clone("tracks"));
    // tracks->SetDirectory(0);
    tracks->SetTitle("Tracks");
    tracks->SetLineColor(kBlue+1);
    tracks->SetFillColor(kBlue+1);
    
    TString expr("angle*TMath::RadToDeg()");
    // TString expr("-TMath::Log(TMath::Tan(angle/2))");
    fRecord   .Draw(Form("%s>>fakes",  expr.Data()), "fake!=0");
    fRecord   .Draw(Form("%s>>goods",  expr.Data()), "fake==0");
    fGenerated.Draw(Form("%s>>tracks", expr.Data()));
    fakes ->Scale(1./n, "width");
    goods ->Scale(1./n, "width");
    tracks->Scale(1./n, "width");
    fakes ->SetDirectory(0);
    goods ->SetDirectory(0);
    tracks->SetDirectory(0);
    fakes ->SetStats(0);
    goods ->SetStats(0);
    tracks->SetStats(0);
    
    THStack* stack = new THStack("stack","");
    stack->Add(tracks);
    stack->Add(goods);
    stack->Add(fakes);

    Canvas();
    stack->Draw("nostack");
    stack->GetHistogram()->SetXTitle(fakes->GetXaxis()->GetTitle());
    stack->GetHistogram()->SetYTitle(fakes->GetYaxis()->GetTitle());
    stack->GetHistogram()->SetStats(0);
    TLegend* l = fCanvas->BuildLegend(.7,.12,.99,.3);    

    TFile* out = Output("dist.root");
    stack ->Write();
    fakes ->Write();
    goods ->Write();
    tracks->Write();
    out   ->Write();
  }
  /** 
   * Main stering function 
   * 
   * @param mode      Execution mode 
   * @param out2in    If true, track inward, otherwise outward 
   * @param global    If true, select amoung all combinations 
   * @param noReuse   If true, do not allow reuse of clusters
   * @param n         Parameter
   * @param sigma     Cluster smear 
   * @param noise     Whether to add noise 
   * @param vary      Whether to make random sigma 
   * @param merge     Wheter to merge overlapping clusters
   * @param secondary Whether to make 10% secondaries 
   * @param y1        Coordinate of inner layer 
   * 
   * @return 
   */
  static ToyModel* Run(Int_t    mode,
		       Bool_t   out2in=false,
		       Bool_t   global=false,
		       Bool_t   noReuse=false,
		       Int_t    n=20,
		       Double_t sigma=0.0008,
		       Bool_t   noise=false,
		       Bool_t   vary=false,
		       Bool_t   merge=false,
		       Bool_t   secondary=false,
		       Double_t y1=0.75)
  {
    ToyModel* model = new ToyModel(y1);
    model->SetOut2In(out2in);
    model->SetGlobal(global);
    model->SetNoReuse(noReuse);
    model->SetSigma(sigma);
    model->SetNoise(noise);
    model->SetVary(vary);
    model->SetMerge(merge);
    model->SetSecondary(secondary);

    Printf("Mode:               %s",
	   (mode == 1 ? "scan" : mode == 2 ? "dist" : "event"));
    Printf("Direction:          %sward", (out2in ? "in" : "out"));
    Printf("Selection:          %s",
	   (global ? "globally" : (out2in ? "by inner" : "by outer")));
    Printf("Reuse of clusters:  %s", noReuse   ? "no" : "yes");
    Printf("Vary cluster sizes: %s", vary      ? "yes" : "no");
    Printf("Merge clusters:     %s", merge     ? "yes" : "no");
    Printf("Make secondaries:   %s", secondary ? "yes" : "no");
    Printf("Cluster base size:  %5.3f", sigma);
    Printf("IP cut along z:     %5.3f", model->fParams.fOffsetCut);
    Printf("Layer 2 distance:   %5.3f", y1);
    Printf("%-20s %d",
	   (mode == 1 ? "Number of steps:" :
	    mode == 2 ? "Number of events: " : "Number of tracks"), n);
	    
    switch (mode) {
    case 1:  model->RunScan(n); break;
    case 2:  model->RunDist(n); break;
    default: model->RunOne(n); break;
    }
    return model;
  }
  /** 
   * Run the toy model 
   * 
   * @param what    What to do 
   * @param n       Parameter of what to do 
   * @param sigma   Width of clusters 
   * @param y1      Location of 1st layer 
   * 
   * @return Pointer to the model object 
   */
  static ToyModel* Run(const char* what,
		       Int_t       n,
		       Double_t    sigma=0.0008,
		       Double_t    y1=0.75)
  {
    TString  sm (what); sm.ToUpper();
    Int_t    mode    = -1;
    if      (sm.Contains("EVENT")) mode = 0;
    else if (sm.Contains("SCAN"))  mode = 1;
    else if (sm.Contains("DIST"))  mode = 2;
    else if (sm.Contains("HELP"))  mode = -1;
    if (mode < 0) {
      Printf("Usage: ToyModel::Run(OPTIONS,N,[SIGMA],[Y1])\n"
	     "\n"
	     "Options (first 3 letters enough):\n"
	     " Mode:\n"
	     "  EVENT     run single event\n"
	     "  SCAN      run scan over nTrack\n"
	     "  DIST      run several events, build dN/dtheta\n"
	     " Direction of trackleting:\n"
	     "  OUT       track outward\n"
	     "  IN        track inward\n"
	     " Tracklet selection:\n"
	     "  GLOBAL    select tracklets globally\n"
	     "  CLUSTER   select tracklets per outer cluster\n"
	     "  SINGLE    do not reuse clusters\n"
	     "  MULTI     do allow reuse of clusters\n"
	     " Cluster and track generation:\n"
	     "  NOISE     add noise clusters\n"
	     "  VARY      random cluster size\n"
	     "  MERGE     merge overlapping clusters\n"
	     "  SECONDARY create secondaries\n"
	     "\n"
	     "N - for EVENT, make this many tracklets\n"
	     "  - for SCAN, do this many steps\n"
	     "  - for DIST, do this many events\n"
	     "SIGMA Base size of clusters\n"
	     "Y1    Y coordinate of innner most layer");
      return 0;
    }
    Bool_t   out2in    = true; 
    Bool_t   global    = true;
    Bool_t   noReuse   = false;
    Bool_t   noise     = sm.Contains("NOI");
    Bool_t   vary      = sm.Contains("VAR");
    Bool_t   merge     = sm.Contains("MER");
    Bool_t   secondary = sm.Contains("SEC");
    if      (sm.Contains("GLO"))  global  = true;
    else if (sm.Contains("CLU"))  global  = false;
    if      (sm.Contains("OUT"))  out2in  = false;
    else if (sm.Contains("IN"))   out2in  = true;
    if      (sm.Contains("SIN"))  noReuse = true;
    else if (sm.Contains("MUL"))  noReuse = false;

    return Run(mode,
	       out2in,
	       global,
	       noReuse,
	       n,
	       sigma,
	       noise,
	       vary,
	       merge,
	       secondary,
	       y1);

  }
};


//
// EOF
//

